var cc = cc || {};
cc._tmp = cc._tmp || {};
cc._tmp.WebGLColor = function () {
    cc.color = function (a, c, b, d, e, f) {
        return void 0 === a ? new cc.Color(0, 0, 0, 255, e, f) : "string" === typeof a ? (a = cc.hexToColor(a), new cc.Color(a.r, a.g, a.b, a.a)) : "object" === typeof a ? new cc.Color(a.r, a.g, a.b, a.a, a.arrayBuffer, a.offset) : new cc.Color(a, c, b, d, e, f)
    };
    cc.Color = function (a, c, b, d, e, f) {
        this._arrayBuffer = e || new ArrayBuffer(cc.Color.BYTES_PER_ELEMENT);
        this._offset = f || 0;
        e = this._arrayBuffer;
        f = this._offset;
        var k = Uint8Array.BYTES_PER_ELEMENT;
        this._rU8 = new Uint8Array(e, f, 1);
        this._gU8 =
            new Uint8Array(e, f + k, 1);
        this._bU8 = new Uint8Array(e, f + 2 * k, 1);
        this._aU8 = new Uint8Array(e, f + 3 * k, 1);
        this._rU8[0] = a || 0;
        this._gU8[0] = c || 0;
        this._bU8[0] = b || 0;
        this._aU8[0] = d || 255;
        void 0 === d && (this.a_undefined = !0)
    };
    cc.Color.BYTES_PER_ELEMENT = 4;
    var b = cc.Color.prototype;
    b._getR = function () {
        return this._rU8[0]
    };
    b._setR = function (a) {
        this._rU8[0] = 0 > a ? 0 : a
    };
    b._getG = function () {
        return this._gU8[0]
    };
    b._setG = function (a) {
        this._gU8[0] = 0 > a ? 0 : a
    };
    b._getB = function () {
        return this._bU8[0]
    };
    b._setB = function (a) {
        this._bU8[0] = 0 > a ? 0 :
            a
    };
    b._getA = function () {
        return this._aU8[0]
    };
    b._setA = function (a) {
        this._aU8[0] = 0 > a ? 0 : a
    };
    cc.defineGetterSetter(b, "r", b._getR, b._setR);
    cc.defineGetterSetter(b, "g", b._getG, b._setG);
    cc.defineGetterSetter(b, "b", b._getB, b._setB);
    cc.defineGetterSetter(b, "a", b._getA, b._setA);
    cc.Vertex2F = function (a, c, b, d) {
        this._arrayBuffer = b || new ArrayBuffer(cc.Vertex2F.BYTES_PER_ELEMENT);
        this._offset = d || 0;
        this._xF32 = new Float32Array(this._arrayBuffer, this._offset, 1);
        this._yF32 = new Float32Array(this._arrayBuffer, this._offset +
            4, 1);
        this._xF32[0] = a || 0;
        this._yF32[0] = c || 0
    };
    cc.Vertex2F.BYTES_PER_ELEMENT = 8;
    Object.defineProperties(cc.Vertex2F.prototype, {x: {get: function () {
        return this._xF32[0]
    }, set: function (a) {
        this._xF32[0] = a
    }, enumerable: !0}, y: {get: function () {
        return this._yF32[0]
    }, set: function (a) {
        this._yF32[0] = a
    }, enumerable: !0}});
    cc.Vertex3F = function (a, c, b, d, e) {
        this._arrayBuffer = d || new ArrayBuffer(cc.Vertex3F.BYTES_PER_ELEMENT);
        this._offset = e || 0;
        d = this._arrayBuffer;
        e = this._offset;
        this._xF32 = new Float32Array(d, e, 1);
        this._xF32[0] =
            a || 0;
        this._yF32 = new Float32Array(d, e + Float32Array.BYTES_PER_ELEMENT, 1);
        this._yF32[0] = c || 0;
        this._zF32 = new Float32Array(d, e + 2 * Float32Array.BYTES_PER_ELEMENT, 1);
        this._zF32[0] = b || 0
    };
    cc.Vertex3F.BYTES_PER_ELEMENT = 12;
    Object.defineProperties(cc.Vertex3F.prototype, {x: {get: function () {
        return this._xF32[0]
    }, set: function (a) {
        this._xF32[0] = a
    }, enumerable: !0}, y: {get: function () {
        return this._yF32[0]
    }, set: function (a) {
        this._yF32[0] = a
    }, enumerable: !0}, z: {get: function () {
        return this._zF32[0]
    }, set: function (a) {
        this._zF32[0] =
            a
    }, enumerable: !0}});
    cc.Tex2F = function (a, c, b, d) {
        this._arrayBuffer = b || new ArrayBuffer(cc.Tex2F.BYTES_PER_ELEMENT);
        this._offset = d || 0;
        this._uF32 = new Float32Array(this._arrayBuffer, this._offset, 1);
        this._vF32 = new Float32Array(this._arrayBuffer, this._offset + 4, 1);
        this._uF32[0] = a || 0;
        this._vF32[0] = c || 0
    };
    cc.Tex2F.BYTES_PER_ELEMENT = 8;
    Object.defineProperties(cc.Tex2F.prototype, {u: {get: function () {
        return this._uF32[0]
    }, set: function (a) {
        this._uF32[0] = a
    }, enumerable: !0}, v: {get: function () {
        return this._vF32[0]
    }, set: function (a) {
        this._vF32[0] =
            a
    }, enumerable: !0}});
    cc.Quad2 = function (a, c, b, d, e, f) {
        this._arrayBuffer = e || new ArrayBuffer(cc.Quad2.BYTES_PER_ELEMENT);
        this._offset = f || 0;
        e = this._arrayBuffer;
        f = cc.Vertex2F.BYTES_PER_ELEMENT;
        this._tl = a ? new cc.Vertex2F(a.x, a.y, e, 0) : new cc.Vertex2F(0, 0, e, 0);
        this._tr = c ? new cc.Vertex2F(c.x, c.y, e, f) : new cc.Vertex2F(0, 0, e, f);
        this._bl = b ? new cc.Vertex2F(b.x, b.y, e, 2 * f) : new cc.Vertex2F(0, 0, e, 2 * f);
        this._br = d ? new cc.Vertex2F(d.x, d.y, e, 3 * f) : new cc.Vertex2F(0, 0, e, 3 * f)
    };
    cc.Quad2.BYTES_PER_ELEMENT = 32;
    cc.Quad3 = function (a, c, b, d) {
        this.bl = a || new cc.Vertex3F(0, 0, 0);
        this.br = c || new cc.Vertex3F(0, 0, 0);
        this.tl = b || new cc.Vertex3F(0, 0, 0);
        this.tr = d || new cc.Vertex3F(0, 0, 0)
    };
    Object.defineProperties(cc.Quad2.prototype, {tl: {get: function () {
        return this._tl
    }, set: function (a) {
        this._tl.x = a.x;
        this._tl.y = a.y
    }, enumerable: !0}, tr: {get: function () {
        return this._tr
    }, set: function (a) {
        this._tr.x = a.x;
        this._tr.y = a.y
    }, enumerable: !0}, bl: {get: function () {
        return this._bl
    }, set: function (a) {
        this._bl.x = a.x;
        this._bl.y = a.y
    }, enumerable: !0}, br: {get: function () {
        return this._br
    },
        set: function (a) {
            this._br.x = a.x;
            this._br.y = a.y
        }, enumerable: !0}});
    cc.V3F_C4B_T2F = function (a, c, b, d, e) {
        this._arrayBuffer = d || new ArrayBuffer(cc.V3F_C4B_T2F.BYTES_PER_ELEMENT);
        this._offset = e || 0;
        d = this._arrayBuffer;
        e = this._offset;
        var f = cc.Vertex3F.BYTES_PER_ELEMENT;
        this._vertices = a ? new cc.Vertex3F(a.x, a.y, a.z, d, e) : new cc.Vertex3F(0, 0, 0, d, e);
        this._colors = c ? cc.color(c.r, c.g, c.b, c.a, d, e + f) : cc.color(0, 0, 0, 0, d, e + f);
        this._texCoords = b ? new cc.Tex2F(b.u, b.v, d, e + f + cc.Color.BYTES_PER_ELEMENT) : new cc.Tex2F(0, 0, d, e +
            f + cc.Color.BYTES_PER_ELEMENT)
    };
    cc.V3F_C4B_T2F.BYTES_PER_ELEMENT = 24;
    Object.defineProperties(cc.V3F_C4B_T2F.prototype, {vertices: {get: function () {
        return this._vertices
    }, set: function (a) {
        var c = this._vertices;
        c.x = a.x;
        c.y = a.y;
        c.z = a.z
    }, enumerable: !0}, colors: {get: function () {
        return this._colors
    }, set: function (a) {
        var c = this._colors;
        c.r = a.r;
        c.g = a.g;
        c.b = a.b;
        c.a = a.a
    }, enumerable: !0}, texCoords: {get: function () {
        return this._texCoords
    }, set: function (a) {
        this._texCoords.u = a.u;
        this._texCoords.v = a.v
    }, enumerable: !0}});
    cc.V3F_C4B_T2F_Quad =
        function (a, c, b, d, e, f) {
            this._arrayBuffer = e || new ArrayBuffer(cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT);
            this._offset = f || 0;
            e = this._arrayBuffer;
            f = this._offset;
            var k = cc.V3F_C4B_T2F.BYTES_PER_ELEMENT;
            this._tl = a ? new cc.V3F_C4B_T2F(a.vertices, a.colors, a.texCoords, e, f) : new cc.V3F_C4B_T2F(null, null, null, e, f);
            this._bl = c ? new cc.V3F_C4B_T2F(c.vertices, c.colors, c.texCoords, e, f + k) : new cc.V3F_C4B_T2F(null, null, null, e, f + k);
            this._tr = b ? new cc.V3F_C4B_T2F(b.vertices, b.colors, b.texCoords, e, f + 2 * k) : new cc.V3F_C4B_T2F(null,
                null, null, e, f + 2 * k);
            this._br = d ? new cc.V3F_C4B_T2F(d.vertices, d.colors, d.texCoords, e, f + 3 * k) : new cc.V3F_C4B_T2F(null, null, null, e, f + 3 * k)
        };
    cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT = 96;
    Object.defineProperties(cc.V3F_C4B_T2F_Quad.prototype, {tl: {get: function () {
        return this._tl
    }, set: function (a) {
        var c = this._tl;
        c.vertices = a.vertices;
        c.colors = a.colors;
        c.texCoords = a.texCoords
    }, enumerable: !0}, bl: {get: function () {
        return this._bl
    }, set: function (a) {
        var c = this._bl;
        c.vertices = a.vertices;
        c.colors = a.colors;
        c.texCoords = a.texCoords
    },
        enumerable: !0}, tr: {get: function () {
        return this._tr
    }, set: function (a) {
        var c = this._tr;
        c.vertices = a.vertices;
        c.colors = a.colors;
        c.texCoords = a.texCoords
    }, enumerable: !0}, br: {get: function () {
        return this._br
    }, set: function (a) {
        var c = this._br;
        c.vertices = a.vertices;
        c.colors = a.colors;
        c.texCoords = a.texCoords
    }, enumerable: !0}, arrayBuffer: {get: function () {
        return this._arrayBuffer
    }, enumerable: !0}});
    cc.V3F_C4B_T2F_QuadZero = function () {
        return new cc.V3F_C4B_T2F_Quad
    };
    cc.V3F_C4B_T2F_QuadCopy = function (a) {
        if (!a)return cc.V3F_C4B_T2F_QuadZero();
        var c = a.tl, b = a.bl, d = a.tr;
        a = a.br;
        return{tl: {vertices: {x: c.vertices.x, y: c.vertices.y, z: c.vertices.z}, colors: {r: c.colors.r, g: c.colors.g, b: c.colors.b, a: c.colors.a}, texCoords: {u: c.texCoords.u, v: c.texCoords.v}}, bl: {vertices: {x: b.vertices.x, y: b.vertices.y, z: b.vertices.z}, colors: {r: b.colors.r, g: b.colors.g, b: b.colors.b, a: b.colors.a}, texCoords: {u: b.texCoords.u, v: b.texCoords.v}}, tr: {vertices: {x: d.vertices.x, y: d.vertices.y, z: d.vertices.z}, colors: {r: d.colors.r, g: d.colors.g, b: d.colors.b, a: d.colors.a}, texCoords: {u: d.texCoords.u,
            v: d.texCoords.v}}, br: {vertices: {x: a.vertices.x, y: a.vertices.y, z: a.vertices.z}, colors: {r: a.colors.r, g: a.colors.g, b: a.colors.b, a: a.colors.a}, texCoords: {u: a.texCoords.u, v: a.texCoords.v}}}
    };
    cc.V3F_C4B_T2F_QuadsCopy = function (a) {
        if (!a)return[];
        for (var c = [], b = 0; b < a.length; b++)c.push(cc.V3F_C4B_T2F_QuadCopy(a[b]));
        return c
    };
    cc.V2F_C4B_T2F = function (a, c, b, d, e) {
        this._arrayBuffer = d || new ArrayBuffer(cc.V2F_C4B_T2F.BYTES_PER_ELEMENT);
        this._offset = e || 0;
        d = this._arrayBuffer;
        e = this._offset;
        var f = cc.Vertex2F.BYTES_PER_ELEMENT;
        this._vertices = a ? new cc.Vertex2F(a.x, a.y, d, e) : new cc.Vertex2F(0, 0, d, e);
        this._colors = c ? cc.color(c.r, c.g, c.b, c.a, d, e + f) : cc.color(0, 0, 0, 0, d, e + f);
        this._texCoords = b ? new cc.Tex2F(b.u, b.v, d, e + f + cc.Color.BYTES_PER_ELEMENT) : new cc.Tex2F(0, 0, d, e + f + cc.Color.BYTES_PER_ELEMENT)
    };
    cc.V2F_C4B_T2F.BYTES_PER_ELEMENT = 20;
    Object.defineProperties(cc.V2F_C4B_T2F.prototype, {vertices: {get: function () {
        return this._vertices
    }, set: function (a) {
        this._vertices.x = a.x;
        this._vertices.y = a.y
    }, enumerable: !0}, colors: {get: function () {
        return this._colors
    },
        set: function (a) {
            var c = this._colors;
            c.r = a.r;
            c.g = a.g;
            c.b = a.b;
            c.a = a.a
        }, enumerable: !0}, texCoords: {get: function () {
        return this._texCoords
    }, set: function (a) {
        this._texCoords.u = a.u;
        this._texCoords.v = a.v
    }, enumerable: !0}});
    cc.V2F_C4B_T2F_Triangle = function (a, c, b, d, e) {
        this._arrayBuffer = d || new ArrayBuffer(cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT);
        this._offset = e || 0;
        d = this._arrayBuffer;
        e = this._offset;
        var f = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
        this._a = a ? new cc.V2F_C4B_T2F(a.vertices, a.colors, a.texCoords, d, e) : new cc.V2F_C4B_T2F(null,
            null, null, d, e);
        this._b = c ? new cc.V2F_C4B_T2F(c.vertices, c.colors, c.texCoords, d, e + f) : new cc.V2F_C4B_T2F(null, null, null, d, e + f);
        this._c = b ? new cc.V2F_C4B_T2F(b.vertices, b.colors, b.texCoords, d, e + 2 * f) : new cc.V2F_C4B_T2F(null, null, null, d, e + 2 * f)
    };
    cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT = 60;
    Object.defineProperties(cc.V2F_C4B_T2F_Triangle.prototype, {a: {get: function () {
        return this._a
    }, set: function (a) {
        var c = this._a;
        c.vertices = a.vertices;
        c.colors = a.colors;
        c.texCoords = a.texCoords
    }, enumerable: !0}, b: {get: function () {
        return this._b
    },
        set: function (a) {
            var c = this._b;
            c.vertices = a.vertices;
            c.colors = a.colors;
            c.texCoords = a.texCoords
        }, enumerable: !0}, c: {get: function () {
        return this._c
    }, set: function (a) {
        var c = this._c;
        c.vertices = a.vertices;
        c.colors = a.colors;
        c.texCoords = a.texCoords
    }, enumerable: !0}})
};
cc._tmp.WebGLCCNode = function () {
    var b = cc.Node.prototype;
    b._transform4x4 = null;
    b._stackMatrix = null;
    b._glServerState = null;
    b._camera = null;
    b.ctor = function () {
        this._initNode();
        var a = new cc.kmMat4;
        a.mat[2] = a.mat[3] = a.mat[6] = a.mat[7] = a.mat[8] = a.mat[9] = a.mat[11] = a.mat[14] = 0;
        a.mat[10] = a.mat[15] = 1;
        this._transform4x4 = a;
        this._glServerState = 0;
        this._stackMatrix = new cc.kmMat4
    };
    b.setNodeDirty = function () {
        !1 === this._transformDirty && (this._transformDirty = this._inverseDirty = !0)
    };
    b.visit = function () {
        if (this._visible) {
            var a =
                cc._renderContext, c, b = cc.current_stack;
            b.stack.push(b.top);
            cc.kmMat4Assign(this._stackMatrix, b.top);
            b.top = this._stackMatrix;
            var d = this.grid;
            d && d._active && d.beforeDraw();
            this.transform();
            var e = this._children;
            if (e && 0 < e.length) {
                var f = e.length;
                this.sortAllChildren();
                for (c = 0; c < f; c++)if (e[c] && 0 > e[c]._localZOrder)e[c].visit(); else break;
                for (this.draw(a); c < f; c++)e[c] && e[c].visit()
            } else this.draw(a);
            this.arrivalOrder = 0;
            d && d._active && d.afterDraw(this);
            b.top = b.stack.pop()
        }
    };
    b.transform = function () {
        var a = this._transform4x4,
            c = cc.current_stack.top, b = this.nodeToParentTransform(), d = a.mat;
        d[0] = b.a;
        d[4] = b.c;
        d[12] = b.tx;
        d[1] = b.b;
        d[5] = b.d;
        d[13] = b.ty;
        d[14] = this._vertexZ;
        cc.kmMat4Multiply(c, c, a);
        null != this._camera && !(null != this.grid && this.grid.isActive()) && (a = this._anchorPointInPoints.x, c = this._anchorPointInPoints.y, 0 !== a || 0 !== c ? (cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (a |= 0, c |= 0), cc.kmGLTranslatef(a, c, 0), this._camera.locate(), cc.kmGLTranslatef(-a, -c, 0)) : this._camera.locate())
    };
    b.nodeToParentTransform = b._nodeToParentTransformForWebGL
};
cc._tmp.WebGLTexture2D = function () {
    cc.Texture2D = cc.Class.extend({_pVRHaveAlphaPremultiplied: !0, _pixelFormat: null, _pixelsWide: 0, _pixelsHigh: 0, _name: "", _contentSize: null, maxS: 0, maxT: 0, _hasPremultipliedAlpha: !1, _hasMipmaps: !1, shaderProgram: null, _isLoaded: !1, _htmlElementObj: null, _webTextureObj: null, url: null, _loadedEventListeners: null, ctor: function () {
        this._contentSize = cc.size(0, 0);
        this._pixelFormat = cc.Texture2D.defaultPixelFormat
    }, releaseTexture: function () {
        this._webTextureObj && cc._renderContext.deleteTexture(this._webTextureObj);
        cc.loader.release(this.url)
    }, getPixelFormat: function () {
        return this._pixelFormat
    }, getPixelsWide: function () {
        return this._pixelsWide
    }, getPixelsHigh: function () {
        return this._pixelsHigh
    }, getName: function () {
        return this._webTextureObj
    }, getContentSize: function () {
        return cc.size(this._contentSize.width / cc.contentScaleFactor(), this._contentSize.height / cc.contentScaleFactor())
    }, _getWidth: function () {
        return this._contentSize.width / cc.contentScaleFactor()
    }, _getHeight: function () {
        return this._contentSize.height / cc.contentScaleFactor()
    },
        getContentSizeInPixels: function () {
            return this._contentSize
        }, getMaxS: function () {
            return this.maxS
        }, setMaxS: function (b) {
            this.maxS = b
        }, getMaxT: function () {
            return this.maxT
        }, setMaxT: function (b) {
            this.maxT = b
        }, getShaderProgram: function () {
            return this.shaderProgram
        }, setShaderProgram: function (b) {
            this.shaderProgram = b
        }, hasPremultipliedAlpha: function () {
            return this._hasPremultipliedAlpha
        }, hasMipmaps: function () {
            return this._hasMipmaps
        }, description: function () {
            return"\x3ccc.Texture2D | Name \x3d " + this._name + " | Dimensions \x3d " +
                this._pixelsWide + " x " + this._pixelsHigh + " | Coordinates \x3d (" + this.maxS + ", " + this.maxT + ")\x3e"
        }, releaseData: function (b) {
        }, keepData: function (b, a) {
            return b
        }, initWithData: function (b, a, c, g, d) {
            var e = cc.Texture2D, f = cc._renderContext, k = f.RGBA, l = f.UNSIGNED_BYTE, h = c * cc.Texture2D._B[a] / 8;
            0 === h % 8 ? f.pixelStorei(f.UNPACK_ALIGNMENT, 8) : 0 === h % 4 ? f.pixelStorei(f.UNPACK_ALIGNMENT, 4) : 0 === h % 2 ? f.pixelStorei(f.UNPACK_ALIGNMENT, 2) : f.pixelStorei(f.UNPACK_ALIGNMENT, 1);
            this._webTextureObj = f.createTexture();
            cc.glBindTexture2D(this);
            f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MIN_FILTER, f.LINEAR);
            f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MAG_FILTER, f.LINEAR);
            f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_S, f.CLAMP_TO_EDGE);
            f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_T, f.CLAMP_TO_EDGE);
            switch (a) {
                case e.PIXEL_FORMAT_RGBA8888:
                    k = f.RGBA;
                    break;
                case e.PIXEL_FORMAT_RGB888:
                    k = f.RGB;
                    break;
                case e.PIXEL_FORMAT_RGBA4444:
                    l = f.UNSIGNED_SHORT_4_4_4_4;
                    break;
                case e.PIXEL_FORMAT_RGB5A1:
                    l = f.UNSIGNED_SHORT_5_5_5_1;
                    break;
                case e.PIXEL_FORMAT_RGB565:
                    l = f.UNSIGNED_SHORT_5_6_5;
                    break;
                case e.PIXEL_FORMAT_AI88:
                    k = f.LUMINANCE_ALPHA;
                    break;
                case e.PIXEL_FORMAT_A8:
                    k = f.ALPHA;
                    break;
                case e.PIXEL_FORMAT_I8:
                    k = f.LUMINANCE;
                    break;
                default:
                    cc.assert(0, cc._LogInfos.Texture2D_initWithData)
            }
            f.texImage2D(f.TEXTURE_2D, 0, k, c, g, 0, k, l, b);
            this._contentSize.width = d.width;
            this._contentSize.height = d.height;
            this._pixelsWide = c;
            this._pixelsHigh = g;
            this._pixelFormat = a;
            this.maxS = d.width / c;
            this.maxT = d.height / g;
            this._hasMipmaps = this._hasPremultipliedAlpha = !1;
            this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE);
            return this._isLoaded = !0
        }, drawAtPoint: function (b) {
            var a = [0, this.maxT, this.maxS, this.maxT, 0, 0, this.maxS, 0], c = this._pixelsWide * this.maxS, g = this._pixelsHigh * this.maxT;
            b = [b.x, b.y, 0, c + b.x, b.y, 0, b.x, g + b.y, 0, c + b.x, g + b.y, 0];
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS);
            this._shaderProgram.use();
            this._shaderProgram.setUniformsForBuiltins();
            cc.glBindTexture2D(this);
            c = cc._renderContext;
            c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, c.FLOAT, !1, 0, b);
            c.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS,
                2, c.FLOAT, !1, 0, a);
            c.drawArrays(c.TRIANGLE_STRIP, 0, 4)
        }, drawInRect: function (b) {
            var a = [0, this.maxT, this.maxS, this.maxT, 0, 0, this.maxS, 0];
            b = [b.x, b.y, b.x + b.width, b.y, b.x, b.y + b.height, b.x + b.width, b.y + b.height];
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS);
            this._shaderProgram.use();
            this._shaderProgram.setUniformsForBuiltins();
            cc.glBindTexture2D(this);
            var c = cc._renderContext;
            c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, c.FLOAT, !1, 0, b);
            c.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS,
                2, c.FLOAT, !1, 0, a);
            c.drawArrays(c.TRIANGLE_STRIP, 0, 4)
        }, initWithImage: function (b) {
            if (null == b)return cc.log(cc._LogInfos.Texture2D_initWithImage), !1;
            var a = b.getWidth(), c = b.getHeight(), g = cc.configuration.getMaxTextureSize();
            if (a > g || c > g)return cc.log(cc._LogInfos.Texture2D_initWithImage_2, a, c, g, g), !1;
            this._isLoaded = !0;
            return this._initPremultipliedATextureWithImage(b, a, c)
        }, initWithElement: function (b) {
            b && (this._webTextureObj = cc._renderContext.createTexture(), this._htmlElementObj = b)
        }, getHtmlElementObj: function () {
            return this._htmlElementObj
        },
        isLoaded: function () {
            return this._isLoaded
        }, handleLoadedTexture: function () {
            if (cc._rendererInitialized) {
                if (!this._htmlElementObj) {
                    var b = cc.loader.getRes(this.url);
                    if (!b)return;
                    this.initWithElement(b)
                }
                this._htmlElementObj.width && this._htmlElementObj.height && (this._isLoaded = !0, b = cc._renderContext, cc.glBindTexture2D(this), b.pixelStorei(b.UNPACK_ALIGNMENT, 4), b.texImage2D(b.TEXTURE_2D, 0, b.RGBA, b.RGBA, b.UNSIGNED_BYTE, this._htmlElementObj), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.LINEAR), b.texParameteri(b.TEXTURE_2D,
                    b.TEXTURE_MAG_FILTER, b.LINEAR), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE), this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE), cc.glBindTexture2D(null), b = this._htmlElementObj.height, this._pixelsWide = this._contentSize.width = this._htmlElementObj.width, this._pixelsHigh = this._contentSize.height = b, this._pixelFormat = cc.Texture2D.PIXEL_FORMAT_RGBA8888, this.maxT = this.maxS = 1, this._hasMipmaps = this._hasPremultipliedAlpha = !1, this._callLoadedEventCallbacks())
            }
        }, initWithString: function (b, a, c, g, d, e) {
            cc.log(cc._LogInfos.Texture2D_initWithString);
            return null
        }, initWithETCFile: function (b) {
            cc.log(cc._LogInfos.Texture2D_initWithETCFile_2);
            return!1
        }, initWithPVRFile: function (b) {
            cc.log(cc._LogInfos.Texture2D_initWithPVRFile_2);
            return!1
        }, initWithPVRTCData: function (b, a, c, g, d, e) {
            cc.log(cc._LogInfos.Texture2D_initWithPVRTCData_2);
            return!1
        }, setTexParameters: function (b) {
            var a = cc._renderContext;
            cc.assert(this._pixelsWide == cc.NextPOT(this._pixelsWide) &&
                this._pixelsHigh == cc.NextPOT(this._pixelsHigh) || b.wrapS == a.CLAMP_TO_EDGE && b.wrapT == a.CLAMP_TO_EDGE, "WebGLRenderingContext.CLAMP_TO_EDGE should be used in NPOT textures");
            cc.glBindTexture2D(this);
            a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, b.minFilter);
            a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, b.magFilter);
            a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, b.wrapS);
            a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, b.wrapT)
        }, setAntiAliasTexParameters: function () {
            var b = cc._renderContext;
            cc.glBindTexture2D(this);
            this._hasMipmaps ? b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.LINEAR_MIPMAP_NEAREST) : b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.LINEAR);
            b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.NEAREST)
        }, setAliasTexParameters: function () {
            var b = cc._renderContext;
            cc.glBindTexture2D(this);
            this._hasMipmaps ? b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.NEAREST_MIPMAP_NEAREST) : b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.NEAREST);
            b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.NEAREST)
        },
        generateMipmap: function () {
            cc.assert(this._pixelsWide == cc.NextPOT(this._pixelsWide) && this._pixelsHigh == cc.NextPOT(this._pixelsHigh), "Mimpap texture only works in POT textures");
            cc.glBindTexture2D(this);
            cc._renderContext.generateMipmap(cc._renderContext.TEXTURE_2D);
            this._hasMipmaps = !0
        }, stringForFormat: function () {
            return cc.Texture2D._M[this._pixelFormat]
        }, bitsPerPixelForFormat: function (b) {
            b = b || this._pixelFormat;
            var a = cc.Texture2D._B[b];
            if (null != a)return a;
            cc.log(cc._LogInfos.Texture2D_bitsPerPixelForFormat,
                b);
            return-1
        }, _initPremultipliedATextureWithImage: function (b, a, c) {
            var g = cc.Texture2D, d = b.getData(), e = null, e = null, f = b.hasAlpha(), k = cc.size(b.getWidth(), b.getHeight()), l = g.defaultPixelFormat, h = b.getBitsPerComponent();
            f || (8 <= h ? l = g.PIXEL_FORMAT_RGB888 : (cc.log(cc._LogInfos.Texture2D__initPremultipliedATextureWithImage), l = g.PIXEL_FORMAT_RGB565));
            var m = a * c;
            if (l == g.PIXEL_FORMAT_RGB565)if (f) {
                d = new Uint16Array(a * c);
                e = b.getData();
                for (h = 0; h < m; ++h)d[h] = (e[h] >> 0 & 255) >> 3 << 11 | (e[h] >> 8 & 255) >> 2 << 5 | (e[h] >> 16 & 255) >> 3 <<
                    0
            } else {
                d = new Uint16Array(a * c);
                e = b.getData();
                for (h = 0; h < m; ++h)d[h] = (e[h] & 255) >> 3 << 11 | (e[h] & 255) >> 2 << 5 | (e[h] & 255) >> 3 << 0
            } else if (l == g.PIXEL_FORMAT_RGBA4444) {
                d = new Uint16Array(a * c);
                e = b.getData();
                for (h = 0; h < m; ++h)d[h] = (e[h] >> 0 & 255) >> 4 << 12 | (e[h] >> 8 & 255) >> 4 << 8 | (e[h] >> 16 & 255) >> 4 << 4 | (e[h] >> 24 & 255) >> 4 << 0
            } else if (l == g.PIXEL_FORMAT_RGB5A1) {
                d = new Uint16Array(a * c);
                e = b.getData();
                for (h = 0; h < m; ++h)d[h] = (e[h] >> 0 & 255) >> 3 << 11 | (e[h] >> 8 & 255) >> 3 << 6 | (e[h] >> 16 & 255) >> 3 << 1 | (e[h] >> 24 & 255) >> 7 << 0
            } else if (l == g.PIXEL_FORMAT_A8) {
                d =
                    new Uint8Array(a * c);
                e = b.getData();
                for (h = 0; h < m; ++h)d[h] = e >> 24 & 255
            }
            if (f && l == g.PIXEL_FORMAT_RGB888) {
                e = b.getData();
                d = new Uint8Array(3 * a * c);
                for (h = 0; h < m; ++h)d[3 * h] = e >> 0 & 255, d[3 * h + 1] = e >> 8 & 255, d[3 * h + 2] = e >> 16 & 255
            }
            this.initWithData(d, l, a, c, k);
            b.getData();
            this._hasPremultipliedAlpha = b.isPremultipliedAlpha();
            return!0
        }, addLoadedEventListener: function (b, a) {
            this._loadedEventListeners || (this._loadedEventListeners = []);
            this._loadedEventListeners.push({eventCallback: b, eventTarget: a})
        }, removeLoadedEventListener: function (b) {
            if (this._loadedEventListeners)for (var a =
                this._loadedEventListeners, c = 0; c < a.length; c++)a[c].eventTarget == b && a.splice(c, 1)
        }, _callLoadedEventCallbacks: function () {
            if (this._loadedEventListeners) {
                for (var b = this._loadedEventListeners, a = 0, c = b.length; a < c; a++) {
                    var g = b[a];
                    g.eventCallback.call(g.eventTarget, this)
                }
                b.length = 0
            }
        }})
};
cc._tmp.WebGLTextureAtlas = function () {
    var b = cc.TextureAtlas.prototype;
    b._setupVBO = function () {
        var a = cc._renderContext;
        this._buffersVBO[0] = a.createBuffer();
        this._buffersVBO[1] = a.createBuffer();
        this._quadsWebBuffer = a.createBuffer();
        this._mapBuffers()
    };
    b._mapBuffers = function () {
        var a = cc._renderContext;
        a.bindBuffer(a.ARRAY_BUFFER, this._quadsWebBuffer);
        a.bufferData(a.ARRAY_BUFFER, this._quadsArrayBuffer, a.DYNAMIC_DRAW);
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
        a.bufferData(a.ELEMENT_ARRAY_BUFFER,
            this._indices, a.STATIC_DRAW)
    };
    b.drawNumberOfQuads = function (a, c) {
        c = c || 0;
        if (!(0 === a || !this.texture || !this.texture.isLoaded())) {
            var b = cc._renderContext;
            cc.glBindTexture2D(this.texture);
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
            b.bindBuffer(b.ARRAY_BUFFER, this._quadsWebBuffer);
            this.dirty && b.bufferData(b.ARRAY_BUFFER, this._quadsArrayBuffer, b.DYNAMIC_DRAW);
            b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, b.FLOAT, !1, 24, 0);
            b.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, b.UNSIGNED_BYTE,
                !0, 24, 12);
            b.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, b.FLOAT, !1, 24, 16);
            this.dirty && (this.dirty = !1);
            b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
            cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP ? b.drawElements(b.TRIANGLE_STRIP, 6 * a, b.UNSIGNED_SHORT, 6 * c * this._indices.BYTES_PER_ELEMENT) : b.drawElements(b.TRIANGLES, 6 * a, b.UNSIGNED_SHORT, 6 * c * this._indices.BYTES_PER_ELEMENT);
            cc.g_NumberOfDraws++
        }
    }
};
cc._tmp.WebGLTextureCache = function () {
    var b = cc.textureCache;
    b.handleLoadedTexture = function (a) {
        var c = this._textures;
        cc._rendererInitialized || (c = this._loadedTexturesBefore);
        var b = c[a];
        b || (b = c[a] = new cc.Texture2D, b.url = a);
        b.handleLoadedTexture()
    };
    b.addImage = function (a, c, b) {
        cc.assert(a, cc._LogInfos.Texture2D_addImage_2);
        var d = this._textures;
        cc._rendererInitialized || (d = this._loadedTexturesBefore);
        var e = d[a] || d[cc.loader._aliases[a]];
        if (e)return c && c.call(b), e;
        cc.loader.getRes(a) || (cc.loader._checkIsImageURL(a) ?
            cc.loader.load(a, function (a) {
                c && c.call(b)
            }) : cc.loader.cache[a] = cc.loader.loadImg(a, function (b, d) {
            if (b)return c ? c(b) : b;
            cc.textureCache.handleLoadedTexture(a);
            c && c(null, d)
        }));
        e = d[a] = new cc.Texture2D;
        e.url = a;
        return e
    };
    delete b
};
cc._tmp.LayerDefineForWebGL = function () {
    var b = cc.Layer.prototype;
    b.bake = function () {
    };
    b.unbake = function () {
    };
    b.visit = cc.Node.prototype.visit
};
cc._tmp.WebGLLayerColor = function () {
    var b = cc.LayerColor.prototype;
    b._squareVertices = null;
    b._squareColors = null;
    b._verticesFloat32Buffer = null;
    b._colorsUint8Buffer = null;
    b._squareVerticesAB = null;
    b._squareColorsAB = null;
    b.ctor = function (a, c, b) {
        this._squareVerticesAB = new ArrayBuffer(32);
        this._squareColorsAB = new ArrayBuffer(16);
        var d = this._squareVerticesAB, e = this._squareColorsAB, f = cc.Vertex2F.BYTES_PER_ELEMENT, k = cc.Color.BYTES_PER_ELEMENT;
        this._squareVertices = [new cc.Vertex2F(0, 0, d, 0), new cc.Vertex2F(0, 0, d,
            f), new cc.Vertex2F(0, 0, d, 2 * f), new cc.Vertex2F(0, 0, d, 3 * f)];
        this._squareColors = [cc.color(0, 0, 0, 255, e, 0), cc.color(0, 0, 0, 255, e, k), cc.color(0, 0, 0, 255, e, 2 * k), cc.color(0, 0, 0, 255, e, 3 * k)];
        this._verticesFloat32Buffer = cc._renderContext.createBuffer();
        this._colorsUint8Buffer = cc._renderContext.createBuffer();
        cc.LayerRGBA.prototype.ctor.call(this);
        this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
        cc.LayerColor.prototype.init.call(this, a, c, b)
    };
    b.setContentSize = function (a, c) {
        var b = this._squareVertices;
        void 0 === c ? (b[1].x = a.width, b[2].y = a.height, b[3].x = a.width, b[3].y = a.height) : (b[1].x = a, b[2].y = c, b[3].x = a, b[3].y = c);
        this._bindLayerVerticesBufferData();
        cc.Layer.prototype.setContentSize.call(this, a, c)
    };
    b._setWidth = function (a) {
        var c = this._squareVertices;
        c[1].x = a;
        c[3].x = a;
        this._bindLayerVerticesBufferData();
        cc.Layer.prototype._setWidth.call(this, a)
    };
    b._setHeight = function (a) {
        var c = this._squareVertices;
        c[2].y = a;
        c[3].y = a;
        this._bindLayerVerticesBufferData();
        cc.Layer.prototype._setHeight.call(this, a)
    };
    b._updateColor =
        function () {
            for (var a = this._displayedColor, c = this._displayedOpacity, b = this._squareColors, d = 0; 4 > d; d++)b[d].r = a.r, b[d].g = a.g, b[d].b = a.b, b[d].a = c;
            this._bindLayerColorsBufferData()
        };
    b.draw = function (a) {
        a = a || cc._renderContext;
        cc.nodeDrawSetup(this);
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR);
        a.bindBuffer(a.ARRAY_BUFFER, this._verticesFloat32Buffer);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
        a.bindBuffer(a.ARRAY_BUFFER, this._colorsUint8Buffer);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 0, 0);
        cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst);
        a.drawArrays(a.TRIANGLE_STRIP, 0, 4)
    };
    b._bindLayerVerticesBufferData = function () {
        var a = cc._renderContext;
        a.bindBuffer(a.ARRAY_BUFFER, this._verticesFloat32Buffer);
        a.bufferData(a.ARRAY_BUFFER, this._squareVerticesAB, a.STATIC_DRAW)
    };
    b._bindLayerColorsBufferData = function () {
        var a = cc._renderContext;
        a.bindBuffer(a.ARRAY_BUFFER, this._colorsUint8Buffer);
        a.bufferData(a.ARRAY_BUFFER, this._squareColorsAB,
            a.STATIC_DRAW)
    }
};
cc._tmp.WebGLLayerGradient = function () {
    var b = cc.LayerGradient.prototype;
    b.draw = cc.LayerColor.prototype.draw;
    b._updateColor = function () {
        var a = this._alongVector, c = cc.pLength(a);
        if (0 !== c) {
            var b = Math.sqrt(2), a = cc.p(a.x / c, a.y / c);
            this._compressedInterpolation && (c = 1 / (Math.abs(a.x) + Math.abs(a.y)), a = cc.pMult(a, c * b));
            var d = this._displayedOpacity / 255, c = this._displayedColor, e = this._endColor, c = {r: c.r, g: c.g, b: c.b, a: this._startOpacity * d}, d = {r: e.r, g: e.g, b: e.b, a: this._endOpacity * d}, f = this._squareColors, e = f[0], k = f[1],
                l = f[2], f = f[3];
            e.r = d.r + (c.r - d.r) * ((b + a.x + a.y) / (2 * b));
            e.g = d.g + (c.g - d.g) * ((b + a.x + a.y) / (2 * b));
            e.b = d.b + (c.b - d.b) * ((b + a.x + a.y) / (2 * b));
            e.a = d.a + (c.a - d.a) * ((b + a.x + a.y) / (2 * b));
            k.r = d.r + (c.r - d.r) * ((b - a.x + a.y) / (2 * b));
            k.g = d.g + (c.g - d.g) * ((b - a.x + a.y) / (2 * b));
            k.b = d.b + (c.b - d.b) * ((b - a.x + a.y) / (2 * b));
            k.a = d.a + (c.a - d.a) * ((b - a.x + a.y) / (2 * b));
            l.r = d.r + (c.r - d.r) * ((b + a.x - a.y) / (2 * b));
            l.g = d.g + (c.g - d.g) * ((b + a.x - a.y) / (2 * b));
            l.b = d.b + (c.b - d.b) * ((b + a.x - a.y) / (2 * b));
            l.a = d.a + (c.a - d.a) * ((b + a.x - a.y) / (2 * b));
            f.r = d.r + (c.r - d.r) * ((b - a.x - a.y) /
                (2 * b));
            f.g = d.g + (c.g - d.g) * ((b - a.x - a.y) / (2 * b));
            f.b = d.b + (c.b - d.b) * ((b - a.x - a.y) / (2 * b));
            f.a = d.a + (c.a - d.a) * ((b - a.x - a.y) / (2 * b));
            this._bindLayerColorsBufferData()
        }
    }
};
cc._tmp.WebGLSprite = function () {
    var b = cc.Sprite.prototype;
    b._spriteFrameLoadedCallback = function (a) {
        this.setNodeDirty(!0);
        this.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize());
        this._callLoadedEventCallbacks()
    };
    b.setOpacityModifyRGB = function (a) {
        this._opacityModifyRGB !== a && (this._opacityModifyRGB = a, this.updateColor())
    };
    b.updateDisplayedOpacity = function (a) {
        cc.NodeRGBA.prototype.updateDisplayedOpacity.call(this, a);
        this.updateColor()
    };
    b.ctor = function (a, b, g) {
        cc.NodeRGBA.prototype.ctor.call(this);
        this._shouldBeHidden = !1;
        this._offsetPosition = cc.p(0, 0);
        this._unflippedOffsetPositionFromCenter = cc.p(0, 0);
        this._blendFunc = {src: cc.BLEND_SRC, dst: cc.BLEND_DST};
        this._rect = cc.rect(0, 0, 0, 0);
        this._quad = new cc.V3F_C4B_T2F_Quad;
        this._quadWebBuffer = cc._renderContext.createBuffer();
        this._textureLoaded = this._quadDirty = !0;
        this._softInit(a, b, g)
    };
    b.setBlendFunc = function (a, b) {
        var g = this._blendFunc;
        void 0 === b ? (g.src = a.src, g.dst = a.dst) : (g.src = a, g.dst = b)
    };
    b.init = function () {
        if (0 < arguments.length)return this.initWithFile(arguments[0],
            arguments[1]);
        cc.NodeRGBA.prototype.init.call(this);
        this.dirty = this._recursiveDirty = !1;
        this._opacityModifyRGB = !0;
        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;
        this.texture = null;
        this._textureLoaded = !0;
        this._flippedX = this._flippedY = !1;
        this.anchorY = this.anchorX = 0.5;
        this._offsetPosition.x = 0;
        this._offsetPosition.y = 0;
        this._hasChildren = !1;
        var a = {r: 255, g: 255, b: 255, a: 255};
        this._quad.bl.colors = a;
        this._quad.br.colors = a;
        this._quad.tl.colors = a;
        this._quad.tr.colors = a;
        this._quadDirty = !0;
        this.setTextureRect(cc.rect(0,
            0, 0, 0), !1, cc.size(0, 0));
        return!0
    };
    b.initWithTexture = function (a, b, g) {
        cc.assert(0 != arguments.length, cc._LogInfos.Sprite_initWithTexture);
        g = g || !1;
        if (!cc.NodeRGBA.prototype.init.call(this))return!1;
        this._batchNode = null;
        this.dirty = this._recursiveDirty = !1;
        this._opacityModifyRGB = !0;
        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;
        this._flippedX = this._flippedY = !1;
        this.anchorY = this.anchorX = 0.5;
        this._offsetPosition.x = 0;
        this._offsetPosition.y = 0;
        this._hasChildren = !1;
        var d = cc.color(255, 255, 255,
            255), e = this._quad;
        e.bl.colors = d;
        e.br.colors = d;
        e.tl.colors = d;
        e.tr.colors = d;
        this._textureLoaded = d = a.isLoaded();
        if (!d)return this._rectRotated = g || !1, b && (d = this._rect, d.x = b.x, d.y = b.y, d.width = b.width, d.height = b.height), a.addLoadedEventListener(this._textureLoadedCallback, this), !0;
        b || (b = cc.rect(0, 0, a.width, a.height));
        a && (g ? (d = b.x + b.height, e = b.y + b.width) : (d = b.x + b.width, e = b.y + b.height), d > a.width && cc.error(cc._LogInfos.RectWidth, a.url), e > a.height && cc.error(cc._LogInfos.RectHeight, a.url));
        this.texture = a;
        this.setTextureRect(b,
            g);
        this.batchNode = null;
        return this._quadDirty = !0
    };
    b._textureLoadedCallback = function (a) {
        if (!this._textureLoaded) {
            this._textureLoaded = !0;
            var b = this._rect;
            b ? cc._rectEqualToZero(b) && (b.width = a.width, b.height = a.height) : b = cc.rect(0, 0, a.width, a.height);
            this.texture = a;
            this.setTextureRect(b, this._rectRotated);
            this.batchNode = this._batchNode;
            this._quadDirty = !0;
            this._callLoadedEventCallbacks()
        }
    };
    b.setTextureRect = function (a, b, g) {
        this._rectRotated = b || !1;
        this.setContentSize(g || a);
        this.setVertexRect(a);
        this._setTextureCoords(a);
        a = this._unflippedOffsetPositionFromCenter;
        this._flippedX && (a.x = -a.x);
        this._flippedY && (a.y = -a.y);
        var d = this._rect;
        this._offsetPosition.x = a.x + (this._contentSize.width - d.width) / 2;
        this._offsetPosition.y = a.y + (this._contentSize.height - d.height) / 2;
        if (this._batchNode)this.dirty = !0; else {
            a = 0 + this._offsetPosition.x;
            b = 0 + this._offsetPosition.y;
            g = a + d.width;
            var d = b + d.height, e = this._quad;
            e.bl.vertices = {x: a, y: b, z: 0};
            e.br.vertices = {x: g, y: b, z: 0};
            e.tl.vertices = {x: a, y: d, z: 0};
            e.tr.vertices = {x: g, y: d, z: 0};
            this._quadDirty = !0
        }
    };
    b.updateTransform = function () {
        if (this.dirty) {
            var a = this._quad, b = this._parent;
            if (!this._visible || b && b != this._batchNode && b._shouldBeHidden)a.br.vertices = {x: 0, y: 0, z: 0}, a.tl.vertices = {x: 0, y: 0, z: 0}, a.tr.vertices = {x: 0, y: 0, z: 0}, a.bl.vertices = {x: 0, y: 0, z: 0}, this._shouldBeHidden = !0; else {
                this._shouldBeHidden = !1;
                var g = this._transformToBatch = !b || b == this._batchNode ? this.nodeToParentTransform() : cc.AffineTransformConcat(this.nodeToParentTransform(), b._transformToBatch), d = this._rect, b = this._offsetPosition.x, e =
                    this._offsetPosition.y, f = b + d.width, k = e + d.height, l = g.tx, h = g.ty, m = g.a, n = g.b, p = g.d, q = -g.c, g = b * m - e * q + l, d = b * n + e * p + h, r = f * m - e * q + l, e = f * n + e * p + h, s = f * m - k * q + l, f = f * n + k * p + h, l = b * m - k * q + l, b = b * n + k * p + h, k = this._vertexZ;
                cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (g |= 0, d |= 0, r |= 0, e |= 0, s |= 0, f |= 0, l |= 0, b |= 0);
                a.bl.vertices = {x: g, y: d, z: k};
                a.br.vertices = {x: r, y: e, z: k};
                a.tl.vertices = {x: l, y: b, z: k};
                a.tr.vertices = {x: s, y: f, z: k}
            }
            this.textureAtlas.updateQuad(a, this.atlasIndex);
            this.dirty = this._recursiveDirty = !1
        }
        this._hasChildren && this._arrayMakeObjectsPerformSelector(this._children,
            cc.Node.StateCallbackType.updateTransform);
        cc.SPRITE_DEBUG_DRAW && (a = [cc.p(this._quad.bl.vertices.x, this._quad.bl.vertices.y), cc.p(this._quad.br.vertices.x, this._quad.br.vertices.y), cc.p(this._quad.tr.vertices.x, this._quad.tr.vertices.y), cc.p(this._quad.tl.vertices.x, this._quad.tl.vertices.y)], cc._drawingUtil.drawPoly(a, 4, !0))
    };
    b.addChild = function (a, b, g) {
        cc.assert(a, cc._LogInfos.Sprite_addChild_3);
        null == b && (b = a._localZOrder);
        null == g && (g = a.tag);
        if (this._batchNode) {
            if (!(a instanceof cc.Sprite)) {
                cc.log(cc._LogInfos.Sprite_addChild);
                return
            }
            a.texture._webTextureObj !== this.textureAtlas.texture._webTextureObj && cc.log(cc._LogInfos.Sprite_addChild_2);
            this._batchNode.appendChild(a);
            this._reorderChildDirty || this._setReorderChildDirtyRecursively()
        }
        cc.NodeRGBA.prototype.addChild.call(this, a, b, g);
        this._hasChildren = !0
    };
    b.setOpacity = function (a) {
        cc.NodeRGBA.prototype.setOpacity.call(this, a);
        this.updateColor()
    };
    b.setColor = function (a) {
        cc.NodeRGBA.prototype.setColor.call(this, a);
        this.updateColor()
    };
    b.updateDisplayedColor = function (a) {
        cc.NodeRGBA.prototype.updateDisplayedColor.call(this,
            a);
        this.updateColor()
    };
    b.setSpriteFrame = function (a) {
        var b = this;
        "string" == typeof a && (a = cc.spriteFrameCache.getSpriteFrame(a), cc.assert(a, cc._LogInfos.Sprite_setSpriteFrame));
        b.setNodeDirty(!0);
        var g = a.getOffset();
        b._unflippedOffsetPositionFromCenter.x = g.x;
        b._unflippedOffsetPositionFromCenter.y = g.y;
        g = a.getTexture();
        a.textureLoaded() || (b._textureLoaded = !1, a.addLoadedEventListener(function (a) {
            b._textureLoaded = !0;
            var e = a.getTexture();
            e != b._texture && (b.texture = e);
            b.setTextureRect(a.getRect(), a.isRotated(),
                a.getOriginalSize());
            b._callLoadedEventCallbacks()
        }, b));
        g != b._texture && (b.texture = g);
        b._rectRotated = a.isRotated();
        b.setTextureRect(a.getRect(), b._rectRotated, a.getOriginalSize())
    };
    b.isFrameDisplayed = function (a) {
        return cc.rectEqualToRect(a.getRect(), this._rect) && a.getTexture().getName() == this._texture.getName() && cc.pointEqualToPoint(a.getOffset(), this._unflippedOffsetPositionFromCenter)
    };
    b.setBatchNode = function (a) {
        if (this._batchNode = a)this._transformToBatch = cc.AffineTransformIdentity(), this.textureAtlas =
            this._batchNode.textureAtlas; else {
            this.atlasIndex = cc.Sprite.INDEX_NOT_INITIALIZED;
            this.textureAtlas = null;
            this.dirty = this._recursiveDirty = !1;
            a = this._offsetPosition.x;
            var b = this._offsetPosition.y, g = a + this._rect.width, d = b + this._rect.height, e = this._quad;
            e.bl.vertices = {x: a, y: b, z: 0};
            e.br.vertices = {x: g, y: b, z: 0};
            e.tl.vertices = {x: a, y: d, z: 0};
            e.tr.vertices = {x: g, y: d, z: 0};
            this._quadDirty = !0
        }
    };
    b.setTexture = function (a) {
        a && "string" === typeof a ? (a = cc.textureCache.addImage(a), this.setTexture(a), a = a.getContentSize(),
            this.setTextureRect(cc.rect(0, 0, a.width, a.height))) : (cc.assert(!a || a instanceof cc.Texture2D, cc._LogInfos.Sprite_setTexture_2), this._batchNode && this._batchNode.texture != a ? cc.log(cc._LogInfos.Sprite_setTexture) : (this.shaderProgram = a ? cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR) : cc.shaderCache.programForKey(cc.SHADER_POSITION_COLOR), !this._batchNode && this._texture != a && (this._texture = a, this._updateBlendFunc())))
    };
    b.draw = function () {
        if (this._textureLoaded) {
            var a = cc._renderContext, b = this._texture;
            b ? b._isLoaded && (this._shaderProgram.use(), this._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst), cc.glBindTexture2DN(0, b), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), a.bindBuffer(a.ARRAY_BUFFER, this._quadWebBuffer), this._quadDirty && (a.bufferData(a.ARRAY_BUFFER, this._quad.arrayBuffer, a.DYNAMIC_DRAW), this._quadDirty = !1), a.vertexAttribPointer(0, 3, a.FLOAT, !1, 24, 0), a.vertexAttribPointer(1, 4, a.UNSIGNED_BYTE, !0, 24,
                12), a.vertexAttribPointer(2, 2, a.FLOAT, !1, 24, 16), a.drawArrays(a.TRIANGLE_STRIP, 0, 4)) : (this._shaderProgram.use(), this._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst), cc.glBindTexture2D(null), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR), a.bindBuffer(a.ARRAY_BUFFER, this._quadWebBuffer), this._quadDirty && (cc._renderContext.bufferData(cc._renderContext.ARRAY_BUFFER, this._quad.arrayBuffer, cc._renderContext.STATIC_DRAW),
                this._quadDirty = !1), a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, a.FLOAT, !1, 24, 0), a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 24, 12), a.drawArrays(a.TRIANGLE_STRIP, 0, 4));
            cc.g_NumberOfDraws++;
            if (0 !== cc.SPRITE_DEBUG_DRAW || this._showNode)1 === cc.SPRITE_DEBUG_DRAW || this._showNode ? (a = this._quad, a = [cc.p(a.tl.vertices.x, a.tl.vertices.y), cc.p(a.bl.vertices.x, a.bl.vertices.y), cc.p(a.br.vertices.x, a.br.vertices.y), cc.p(a.tr.vertices.x, a.tr.vertices.y)], cc._drawingUtil.drawPoly(a, 4,
                !0)) : 2 === cc.SPRITE_DEBUG_DRAW && (a = this.getTextureRect(), b = this.getOffsetPosition(), a = [cc.p(b.x, b.y), cc.p(b.x + a.width, b.y), cc.p(b.x + a.width, b.y + a.height), cc.p(b.x, b.y + a.height)], cc._drawingUtil.drawPoly(a, 4, !0))
        }
    };
    delete b
};
cc._tmp.WebGLLabelTTF = function () {
    var b = cc.LabelTTF.prototype;
    b.setColor = cc.Sprite.prototype.setColor;
    b._setColorsString = function () {
        this._needUpdateTexture = !0;
        var a = this._strokeColor, b = this._textFillColor;
        this._shadowColorStr = "rgba(128,128,128," + this._shadowOpacity + ")";
        this._fillColorStr = "rgba(" + (0 | b.r) + "," + (0 | b.g) + "," + (0 | b.b) + ", 1)";
        this._strokeColorStr = "rgba(" + (0 | a.r) + "," + (0 | a.g) + "," + (0 | a.b) + ", 1)"
    };
    b.updateDisplayedColor = cc.Sprite.prototype.updateDisplayedColor;
    b.setOpacity = cc.Sprite.prototype.setOpacity;
    b.updateDisplayedOpacity = cc.Sprite.prototype.updateDisplayedOpacity;
    b.initWithStringAndTextDefinition = function (a, b) {
        if (!cc.Sprite.prototype.init.call(this))return!1;
        this.shaderProgram = cc.shaderCache.programForKey(cc.LabelTTF._SHADER_PROGRAM);
        this._updateWithTextDefinition(b, !1);
        this.string = a;
        return!0
    };
    b.setFontFillColor = function (a) {
        var b = this._textFillColor;
        if (b.r != a.r || b.g != a.g || b.b != a.b)b.r = a.r, b.g = a.g, b.b = a.b, this._setColorsString(), this._needUpdateTexture = !0
    };
    b.draw = function (a) {
        if (this._string &&
            "" != this._string) {
            a = a || cc._renderContext;
            var b = this._texture;
            b && b._isLoaded && (this._shaderProgram.use(), this._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst), cc.glBindTexture2D(b), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), a.bindBuffer(a.ARRAY_BUFFER, this._quadWebBuffer), this._quadDirty && (a.bufferData(a.ARRAY_BUFFER, this._quad.arrayBuffer, a.STATIC_DRAW), this._quadDirty = !1), a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION,
                3, a.FLOAT, !1, 24, 0), a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, 24, 16), a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 24, 12), a.drawArrays(a.TRIANGLE_STRIP, 0, 4));
            if (1 === cc.SPRITE_DEBUG_DRAW)a = this._quad, a = [cc.p(a.tl.vertices.x, a.tl.vertices.y), cc.p(a.bl.vertices.x, a.bl.vertices.y), cc.p(a.br.vertices.x, a.br.vertices.y), cc.p(a.tr.vertices.x, a.tr.vertices.y)], cc._drawingUtil.drawPoly(a, 4, !0); else if (2 === cc.SPRITE_DEBUG_DRAW) {
                a = this.getTextureRect()._size;
                var b = this.offsetX,
                    g = this.offsetY;
                a = [cc.p(b, g), cc.p(b + a.width, g), cc.p(b + a.width, g + a.height), cc.p(b, g + a.height)];
                cc._drawingUtil.drawPoly(a, 4, !0)
            }
            cc.g_NumberOfDraws++
        }
    };
    b.setTextureRect = cc.Sprite.prototype.setTextureRect
};
cc._tmp.DirectorWebGL = function () {
    cc.DirectorDelegate = cc.Class.extend({updateProjection: function () {
    }});
    var b = cc.Director.prototype;
    b.setProjection = function (a) {
        var b = this._winSizeInPoints;
        this.setViewport();
        switch (a) {
            case cc.Director.PROJECTION_2D:
                cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
                cc.kmGLLoadIdentity();
                var g = new cc.kmMat4;
                cc.kmMat4OrthographicProjection(g, 0, b.width, 0, b.height, -1024, 1024);
                cc.kmGLMultMatrix(g);
                cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
                cc.kmGLLoadIdentity();
                break;
            case cc.Director.PROJECTION_3D:
                var d =
                    this.getZEye(), e = new cc.kmMat4, g = new cc.kmMat4;
                cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
                cc.kmGLLoadIdentity();
                cc.kmMat4PerspectiveProjection(e, 60, b.width / b.height, 0.1, 2 * d);
                cc.kmGLMultMatrix(e);
                cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
                cc.kmGLLoadIdentity();
                d = cc.kmVec3Fill(null, b.width / 2, b.height / 2, d);
                b = cc.kmVec3Fill(null, b.width / 2, b.height / 2, 0);
                e = cc.kmVec3Fill(null, 0, 1, 0);
                cc.kmMat4LookAt(g, d, b, e);
                cc.kmGLMultMatrix(g);
                break;
            case cc.Director.PROJECTION_CUSTOM:
                this._projectionDelegate && this._projectionDelegate.updateProjection();
                break;
            default:
                cc.log(cc._LogInfos.Director_setProjection)
        }
        this._projection = a;
        cc.eventManager.dispatchEvent(this._eventProjectionChanged);
        cc.setProjectionMatrixDirty()
    };
    b.setDepthTest = function (a) {
        var b = cc._renderContext;
        a ? (b.clearDepth(1), b.enable(b.DEPTH_TEST), b.depthFunc(b.LEQUAL)) : b.disable(b.DEPTH_TEST)
    };
    b.setOpenGLView = function (a) {
        this._winSizeInPoints.width = cc._canvas.width;
        this._winSizeInPoints.height = cc._canvas.height;
        this._openGLView = a || cc.view;
        a = cc.configuration;
        a.gatherGPUInfo();
        a.dumpInfo();
        this._createStatsLabel();
        this.setGLDefaultValues();
        cc.eventManager && cc.eventManager.setEnabled(!0)
    };
    b._clear = function () {
        var a = cc._renderContext;
        a.clear(a.COLOR_BUFFER_BIT | a.DEPTH_BUFFER_BIT)
    };
    b._beforeVisitScene = function () {
        cc.kmGLPushMatrix()
    };
    b._afterVisitScene = function () {
        cc.kmGLPopMatrix()
    };
    b._createStatsLabel = function () {
        if (cc.LabelAtlas) {
            if (!(null == cc.Director._fpsImageLoaded || !1 == cc.Director._fpsImageLoaded)) {
                var a = new cc.Texture2D;
                a.initWithElement(cc.Director._fpsImage);
                a.handleLoadedTexture();
                var b = cc.view.getDesignResolutionSize().height / 320;
                0 === b && (b = this._winSizeInPoints.height / 320);
                var g = new cc.LabelAtlas;
                g._setIgnoreContentScaleFactor(!0);
                g.initWithString("00.0", a, 12, 32, ".");
                g.scale = b;
                this._FPSLabel = g;
                g = new cc.LabelAtlas;
                g._setIgnoreContentScaleFactor(!0);
                g.initWithString("0.000", a, 12, 32, ".");
                g.scale = b;
                this._SPFLabel = g;
                g = new cc.LabelAtlas;
                g._setIgnoreContentScaleFactor(!0);
                g.initWithString("000", a, 12, 32, ".");
                g.scale = b;
                this._drawsLabel = g;
                a = cc.DIRECTOR_STATS_POSITION;
                this._drawsLabel.setPosition(a.x,
                        34 * b + a.y);
                this._SPFLabel.setPosition(a.x, 17 * b + a.y);
                this._FPSLabel.setPosition(a)
            }
        } else this._createStatsLabelForCanvas()
    };
    b._createStatsLabelForCanvas = function () {
        var a = 0, a = this._winSizeInPoints.width > this._winSizeInPoints.height ? 0 | 24 * (this._winSizeInPoints.height / 320) : 0 | 24 * (this._winSizeInPoints.width / 320);
        this._FPSLabel = cc.LabelTTF.create("000.0", "Arial", a);
        this._SPFLabel = cc.LabelTTF.create("0.000", "Arial", a);
        this._drawsLabel = cc.LabelTTF.create("0000", "Arial", a);
        a = cc.DIRECTOR_STATS_POSITION;
        this._drawsLabel.setPosition(this._drawsLabel.width /
            2 + a.x, 5 * this._drawsLabel.height / 2 + a.y);
        this._SPFLabel.setPosition(this._SPFLabel.width / 2 + a.x, 3 * this._SPFLabel.height / 2 + a.y);
        this._FPSLabel.setPosition(this._FPSLabel.width / 2 + a.x, this._FPSLabel.height / 2 + a.y)
    };
    b.convertToGL = function (a) {
        var b = new cc.kmMat4;
        cc.GLToClipTransform(b);
        var g = new cc.kmMat4;
        cc.kmMat4Inverse(g, b);
        var b = b.mat[14] / b.mat[15], d = this._openGLView.getDesignResolutionSize();
        a = new cc.kmVec3(2 * a.x / d.width - 1, 1 - 2 * a.y / d.height, b);
        b = new cc.kmVec3;
        cc.kmVec3TransformCoord(b, a, g);
        return cc.p(b.x,
            b.y)
    };
    b.convertToUI = function (a) {
        var b = new cc.kmMat4;
        cc.GLToClipTransform(b);
        var g = new cc.kmVec3;
        a = new cc.kmVec3(a.x, a.y, 0);
        cc.kmVec3TransformCoord(g, a, b);
        b = this._openGLView.getDesignResolutionSize();
        return cc.p(b.width * (0.5 * g.x + 0.5), b.height * (0.5 * -g.y + 0.5))
    };
    b.getVisibleSize = function () {
        return this._openGLView.getVisibleSize()
    };
    b.getVisibleOrigin = function () {
        return this._openGLView.getVisibleOrigin()
    };
    b.getZEye = function () {
        return this._winSizeInPoints.height / 1.1566
    };
    b.setViewport = function () {
        if (this._openGLView) {
            var a =
                this._winSizeInPoints;
            this._openGLView.setViewPortInPoints(0, 0, a.width, a.height)
        }
    };
    b.getOpenGLView = function () {
        return this._openGLView
    };
    b.getProjection = function () {
        return this._projection
    };
    b.setAlphaBlending = function (a) {
        a ? cc.glBlendFunc(cc.BLEND_SRC, cc.BLEND_DST) : cc.glBlendFunc(cc._renderContext.ONE, cc._renderContext.ZERO)
    };
    b.setGLDefaultValues = function () {
        this.setAlphaBlending(!0);
        this.setDepthTest(!1);
        this.setProjection(this._projection);
        cc._renderContext.clearColor(0, 0, 0, 1)
    }
};var cc = cc || {};
cc._tmp = cc._tmp || {};
cc._LogInfos = {};
_p = window;
_p = Object.prototype;
delete window._p;
cc.newElement = function (a) {
    return document.createElement(a)
};
cc._addEventListener = function (a, b, c, d) {
    a.addEventListener(b, c, d)
};
cc._isNodeJs = "undefined" !== typeof require && require("fs");
cc.each = function (a, b, c) {
    if (a)if (a instanceof Array)for (var d = 0, e = a.length; d < e && !1 !== b.call(c, a[d], d); d++); else for (d in a)if (!1 === b.call(c, a[d], d))break
};
cc.isCrossOrigin = function (a) {
    if (!a)return cc.log("invalid URL"), !1;
    var b = a.indexOf("://");
    if (-1 == b)return!1;
    b = a.indexOf("/", b + 3);
    return(-1 == b ? a : a.substring(0, b)) != location.origin
};
cc.async = {_counterFunc: function (a) {
    var b = this.counter;
    if (!b.err) {
        var c = b.length, d = b.results, e = b.option, f = e.cb, g = e.cbTarget, h = e.trigger, e = e.triggerTarget;
        if (a) {
            if (b.err = a, f)return f.call(g, a)
        } else {
            var k = Array.apply(null, arguments).slice(1), l = k.length;
            0 == l ? k = null : 1 == l && (k = k[0]);
            d[this.index] = k;
            b.count--;
            h && h.call(e, k, c - b.count, c);
            0 == b.count && f && f.apply(g, [null, d])
        }
    }
}, _emptyFunc: function () {
}, parallel: function (a, b, c) {
    var d = cc.async;
    if (void 0 !== c)"function" == typeof b && (b = {trigger: b}), b.cb = c || b.cb; else if (void 0 !==
        b)"function" == typeof b && (b = {cb: b}); else if (void 0 !== a)b = {}; else throw"arguments error!";
    var e = (c = a instanceof Array) ? a.length : Object.keys(a).length;
    if (0 == e)b.cb && b.cb.call(b.cbTarget, null); else {
        var f = {length: e, count: e, option: b, results: c ? [] : {}};
        cc.each(a, function (a, c) {
            if (f.err)return!1;
            var e = !b.cb && !b.trigger ? d._emptyFunc : d._counterFunc.bind({counter: f, index: c});
            a(e, c)
        })
    }
}, map: function (a, b, c) {
    var d = this, e = arguments.length;
    "function" == typeof b && (b = {iterator: b});
    if (3 === e)b.cb = c || b.cb; else if (2 > e)throw"arguments error!";
    "function" == typeof b && (b = {iterator: b});
    if (void 0 !== c)b.cb = c || b.cb; else if (void 0 === a)throw"arguments error!";
    var f = (e = a instanceof Array) ? a.length : Object.keys(a).length;
    if (0 === f)b.cb && b.cb.call(b.cbTarget, null); else {
        var g = {length: f, count: f, option: b, results: e ? [] : {}};
        cc.each(a, function (a, c) {
            if (g.err)return!1;
            var e = !b.cb ? d._emptyFunc : d._counterFunc.bind({counter: g, index: c});
            b.iterator.call(b.iteratorTarget, a, c, e)
        })
    }
}};
cc.path = {join: function () {
    for (var a = arguments.length, b = "", c = 0; c < a; c++)b = (b + ("" == b ? "" : "/") + arguments[c]).replace(/(\/|\\\\)$/, "");
    return b
}, extname: function (a) {
    return(a = /(\.[^\.\/\?\\]*)(\?.*)?$/.exec(a)) ? a[1] : null
}, mainFileName: function (a) {
    if (a) {
        var b = a.lastIndexOf(".");
        if (-1 !== b)return a.substring(0, b)
    }
    return a
}, basename: function (a, b) {
    var c = a.indexOf("?");
    0 < c && (a = a.substring(0, c));
    c = /(\/|\\\\)([^(\/|\\\\)]+)$/g.exec(a.replace(/(\/|\\\\)$/, ""));
    if (!c)return null;
    c = c[2];
    return b && a.substring(a.length -
        b.length).toLowerCase() == b.toLowerCase() ? c.substring(0, c.length - b.length) : c
}, dirname: function (a) {
    return a.replace(/((.*)(\/|\\|\\\\))?(.*?\..*$)?/, "$2")
}, changeExtname: function (a, b) {
    b = b || "";
    var c = a.indexOf("?"), d = "";
    0 < c && (d = a.substring(c), a = a.substring(0, c));
    c = a.lastIndexOf(".");
    return 0 > c ? a + b + d : a.substring(0, c) + b + d
}, changeBasename: function (a, b, c) {
    if (0 == b.indexOf("."))return this.changeExtname(a, b);
    var d = a.indexOf("?"), e = "";
    c = c ? this.extname(a) : "";
    0 < d && (e = a.substring(d), a = a.substring(0, d));
    d = a.lastIndexOf("/");
    return a.substring(0, 0 >= d ? 0 : d + 1) + b + c + e
}};
cc.loader = {_jsCache: {}, _register: {}, _langPathCache: {}, _aliases: {}, resPath: "", audioPath: "", cache: {}, getXMLHttpRequest: function () {
    return window.XMLHttpRequest ? new window.XMLHttpRequest : new ActiveXObject("MSXML2.XMLHTTP")
}, _getArgs4Js: function (a) {
    var b = a[0], c = a[1], d = a[2], e = ["", null, null];
    if (1 === a.length)e[1] = b instanceof Array ? b : [b]; else if (2 === a.length)"function" == typeof c ? (e[1] = b instanceof Array ? b : [b], e[2] = c) : (e[0] = b || "", e[1] = c instanceof Array ? c : [c]); else if (3 === a.length)e[0] = b || "", e[1] = c instanceof
        Array ? c : [c], e[2] = d; else throw"arguments error to load js!";
    return e
}, loadJs: function (a, b, c) {
    var d = this, e = d._jsCache, f = d._getArgs4Js(arguments);
    -1 < navigator.userAgent.indexOf("Trident/5") ? d._loadJs4Dependency(f[0], f[1], 0, f[2]) : cc.async.map(f[1], function (a, b, c) {
        a = cc.path.join(f[0], a);
        if (e[a])return c(null);
        d._createScript(a, !1, c)
    }, f[2])
}, loadJsWithImg: function (a, b, c) {
    var d = this._loadJsImg(), e = this._getArgs4Js(arguments);
    this.loadJs(e[0], e[1], function (a) {
        if (a)throw a;
        d.parentNode.removeChild(d);
        if (e[2])e[2]()
    })
},
    _createScript: function (a, b, c) {
        var d = document, e = cc.newElement("script");
        e.async = b;
        e.src = a;
        this._jsCache[a] = !0;
        cc._addEventListener(e, "load", function () {
            this.removeEventListener("load", arguments.callee, !1);
            c()
        }, !1);
        cc._addEventListener(e, "error", function () {
            c("Load " + a + " failed!")
        }, !1);
        d.body.appendChild(e)
    }, _loadJs4Dependency: function (a, b, c, d) {
        if (c >= b.length)d && d(); else {
            var e = this;
            e._createScript(cc.path.join(a, b[c]), !1, function (f) {
                if (f)return d(f);
                e._loadJs4Dependency(a, b, c + 1, d)
            })
        }
    }, _loadJsImg: function () {
        var a =
            document, b = a.getElementById("cocos2d_loadJsImg");
        if (!b) {
            b = cc.newElement("img");
            cc._loadingImage && (b.src = cc._loadingImage);
            a = a.getElementById(cc.game.config.id);
            a.style.backgroundColor = "black";
            a.parentNode.appendChild(b);
            var c = getComputedStyle ? getComputedStyle(a) : a.currentStyle;
            c || (c = {width: a.width, height: a.height});
            b.style.left = a.offsetLeft + (parseFloat(c.width) - b.width) / 2 + "px";
            b.style.top = a.offsetTop + (parseFloat(c.height) - b.height) / 2 + "px";
            b.style.position = "absolute"
        }
        return b
    }, loadTxt: function (a, b) {
        if (cc._isNodeJs)require("fs").readFile(a,
            function (a, c) {
                a ? b(a) : b(null, c.toString())
            }); else {
            var c = this.getXMLHttpRequest(), d = "load " + a + " failed!";
            c.open("GET", a, !0);
            /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? (c.setRequestHeader("Accept-Charset", "utf-8"), c.onreadystatechange = function () {
                4 == c.readyState && 200 == c.status ? b(null, c.responseText) : b(d)
            }) : (c.overrideMimeType && c.overrideMimeType("text/plain; charset\x3dutf-8"), c.onload = function () {
                4 == c.readyState && 200 == c.status ? b(null, c.responseText) : b(d)
            });
            c.send(null)
        }
    }, _loadTxtSync: function (a) {
        if (cc._isNodeJs)return require("fs").readFileSync(a).toString();
        var b = this.getXMLHttpRequest();
        b.open("GET", a, !1);
        /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? b.setRequestHeader("Accept-Charset", "utf-8") : b.overrideMimeType && b.overrideMimeType("text/plain; charset\x3dutf-8");
        b.send(null);
        return 4 == !b.readyState || 200 != b.status ? null : b.responseText
    }, loadJson: function (a, b) {
        this.loadTxt(a, function (c, d) {
            try {
                c ? b(c) : b(null, JSON.parse(d))
            } catch (e) {
                throw"load json [" + a + "] failed : " + e;
            }
        })
    }, _checkIsImageURL: function (a) {
        return null != /(\.png)|(\.jpg)|(\.bmp)|(\.jpeg)|(\.gif)/.exec(a)
    },
    loadImg: function (a, b, c) {
        var d = !0;
        void 0 !== c ? d = null == b.isCrossOrigin ? d : b.isCrossOrigin : void 0 !== b && (c = b);
        var e = new Image;
        d && "file://" != location.origin && (e.crossOrigin = "Anonymous");
        cc._addEventListener(e, "load", function () {
            this.removeEventListener("load", arguments.callee, !1);
            this.removeEventListener("error", arguments.callee, !1);
            c && c(null, e)
        });
        cc._addEventListener(e, "error", function () {
            this.removeEventListener("error", arguments.callee, !1);
            c && c("load image failed")
        });
        e.src = a;
        return e
    }, _loadResIterator: function (a, b, c) {
        var d = this, e = null, f = a.type;
        f ? (f = "." + f.toLowerCase(), e = a.src ? a.src : a.name + f) : (e = a, f = cc.path.extname(e));
        if (b = d.cache[e])return c(null, b);
        b = d._register[f.toLowerCase()];
        if (!b)return cc.error("loader for [" + f + "] not exists!"), c();
        f = b.getBasePath ? b.getBasePath() : d.resPath;
        f = d.getUrl(f, e);
        b.load(f, e, a, function (a, b) {
            a ? (cc.log(a), d.cache[e] = null, delete d.cache[e], c()) : (d.cache[e] = b, c(null, b))
        })
    }, getUrl: function (a, b) {
        var c = this._langPathCache, d = cc.path;
        if (void 0 !== a && void 0 === b) {
            b = a;
            var e = d.extname(b),
                e = e ? e.toLowerCase() : "";
            a = (e = this._register[e]) ? e.getBasePath ? e.getBasePath() : this.resPath : this.resPath
        }
        b = cc.path.join(a || "", b);
        if (b.match(/[\/(\\\\)]lang[\/(\\\\)]/i)) {
            if (c[b])return c[b];
            d = d.extname(b) || "";
            b = c[b] = b.substring(0, b.length - d.length) + "_" + cc.sys.language + d
        }
        return b
    }, load: function (a, b, c) {
        if (void 0 !== c)"function" == typeof b && (b = {trigger: b}); else if (void 0 !== b)"function" == typeof b && (c = b, b = {}); else if (void 0 !== a)b = {}; else throw"arguments error!";
        b.cb = function (a, b) {
            a && cc.log(a);
            c && c(b)
        };
        a instanceof
        Array || (a = [a]);
        b.iterator = this._loadResIterator;
        b.iteratorTarget = this;
        cc.async.map(a, b)
    }, _handleAliases: function (a, b) {
        var c = this._aliases, d = [], e;
        for (e in a) {
            var f = a[e];
            c[e] = f;
            d.push(f)
        }
        this.load(d, b)
    }, loadAliases: function (a, b) {
        var c = this, d = c.getRes(a);
        d ? c._handleAliases(d.filenames, b) : c.load(a, function (a) {
            c._handleAliases(a[0].filenames, b)
        })
    }, register: function (a, b) {
        if (a && b) {
            if ("string" == typeof a)return this._register[a.trim().toLowerCase()] = b;
            for (var c = 0, d = a.length; c < d; c++)this._register["." + a[c].trim().toLowerCase()] =
                b
        }
    }, getRes: function (a) {
        return this.cache[a] || this.cache[this._aliases[a]]
    }, release: function (a) {
        var b = this.cache, c = this._aliases;
        delete b[a];
        delete b[c[a]];
        delete c[a]
    }, releaseAll: function () {
        var a = this.cache, b = this._aliases, c;
        for (c in a)delete a[c];
        for (c in b)delete b[c]
    }};
(function () {
    var a = window, b, c;
    "undefined" !== typeof document.hidden ? (b = "hidden", c = "visibilitychange") : "undefined" !== typeof document.mozHidden ? (b = "mozHidden", c = "mozvisibilitychange") : "undefined" !== typeof document.msHidden ? (b = "msHidden", c = "msvisibilitychange") : "undefined" !== typeof document.webkitHidden && (b = "webkitHidden", c = "webkitvisibilitychange");
    var d = function () {
        cc.eventManager && cc.game._eventHide && cc.eventManager.dispatchEvent(cc.game._eventHide)
    }, e = function () {
        cc.eventManager && cc.game._eventShow &&
        cc.eventManager.dispatchEvent(cc.game._eventShow)
    };
    b ? cc._addEventListener(document, c, function () {
        document[b] ? d() : e()
    }, !1) : (cc._addEventListener(a, "blur", d, !1), cc._addEventListener(a, "focus", e, !1));
    "onpageshow"in window && "onpagehide"in window && (cc._addEventListener(a, "pagehide", d, !1), cc._addEventListener(a, "pageshow", e, !1));
    c = a = null
})();
cc.log = cc.warn = cc.error = cc.assert = function () {
};
cc.create3DContext = function (a, b) {
    for (var c = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"], d = null, e = 0; e < c.length; ++e) {
        try {
            d = a.getContext(c[e], b)
        } catch (f) {
        }
        if (d)break
    }
    return d
};
cc._initSys = function (a, b) {
    cc._RENDER_TYPE_CANVAS = 0;
    cc._RENDER_TYPE_WEBGL = 1;
    var c = cc.sys = {};
    c.LANGUAGE_ENGLISH = "en";
    c.LANGUAGE_CHINESE = "zh";
    c.LANGUAGE_FRENCH = "fr";
    c.LANGUAGE_ITALIAN = "it";
    c.LANGUAGE_GERMAN = "de";
    c.LANGUAGE_SPANISH = "es";
    c.LANGUAGE_RUSSIAN = "ru";
    c.LANGUAGE_KOREAN = "ko";
    c.LANGUAGE_JAPANESE = "ja";
    c.LANGUAGE_HUNGARIAN = "hu";
    c.LANGUAGE_PORTUGUESE = "pt";
    c.LANGUAGE_ARABIC = "ar";
    c.LANGUAGE_NORWEGIAN = "no";
    c.LANGUAGE_POLISH = "pl";
    c.OS_WINDOWS = "Windows";
    c.OS_IOS = "iOS";
    c.OS_OSX = "OS X";
    c.OS_UNIX = "UNIX";
    c.OS_LINUX = "Linux";
    c.OS_ANDROID = "Android";
    c.OS_UNKNOWN = "Unknown";
    c.BROWSER_TYPE_WECHAT = "wechat";
    c.BROWSER_TYPE_ANDROID = "androidbrowser";
    c.BROWSER_TYPE_IE = "ie";
    c.BROWSER_TYPE_QQ = "qqbrowser";
    c.BROWSER_TYPE_MOBILE_QQ = "mqqbrowser";
    c.BROWSER_TYPE_UC = "ucbrowser";
    c.BROWSER_TYPE_360 = "360browser";
    c.BROWSER_TYPE_BAIDU_APP = "baiduboxapp";
    c.BROWSER_TYPE_BAIDU = "baidubrowser";
    c.BROWSER_TYPE_MAXTHON = "maxthon";
    c.BROWSER_TYPE_OPERA = "opera";
    c.BROWSER_TYPE_MIUI = "miuibrowser";
    c.BROWSER_TYPE_FIREFOX = "firefox";
    c.BROWSER_TYPE_SAFARI =
        "safari";
    c.BROWSER_TYPE_CHROME = "chrome";
    c.BROWSER_TYPE_UNKNOWN = "unknown";
    c.isNative = !1;
    var d = [c.BROWSER_TYPE_BAIDU, c.BROWSER_TYPE_OPERA, c.BROWSER_TYPE_FIREFOX, c.BROWSER_TYPE_CHROME, c.BROWSER_TYPE_SAFARI], e = [c.BROWSER_TYPE_BAIDU, c.BROWSER_TYPE_OPERA, c.BROWSER_TYPE_FIREFOX, c.BROWSER_TYPE_CHROME, c.BROWSER_TYPE_SAFARI, c.BROWSER_TYPE_UC, c.BROWSER_TYPE_QQ, c.BROWSER_TYPE_MOBILE_QQ, c.BROWSER_TYPE_IE], f = window, g = f.navigator, h = document.documentElement, k = g.userAgent.toLowerCase();
    c.isMobile = -1 != k.indexOf("mobile") ||
        -1 != k.indexOf("android");
    var l = g.language, l = (l = l ? l : g.browserLanguage) ? l.split("-")[0] : c.LANGUAGE_ENGLISH;
    c.language = l;
    var l = c.BROWSER_TYPE_UNKNOWN, m = k.match(/micromessenger|qqbrowser|mqqbrowser|ucbrowser|360browser|baiduboxapp|baidubrowser|maxthon|trident|opera|miuibrowser|firefox/i) || k.match(/chrome|safari/i);
    m && 0 < m.length && (l = m[0].toLowerCase(), "micromessenger" == l ? l = c.BROWSER_TYPE_WECHAT : "safari" === l && k.match(/android.*applewebkit/) ? l = c.BROWSER_TYPE_ANDROID : "trident" == l && (l = c.BROWSER_TYPE_IE));
    c.browserType = l;
    c._supportMultipleAudio = -1 < e.indexOf(c.browserType);
    e = parseInt(a[b.renderMode]);
    l = cc._RENDER_TYPE_WEBGL;
    m = cc.newElement("Canvas");
    cc._supportRender = !0;
    d = -1 == d.indexOf(c.browserType);
    if (1 === e || 0 === e && (c.isMobile || d))l = cc._RENDER_TYPE_CANVAS;
    if (l == cc._RENDER_TYPE_WEBGL && (!f.WebGLRenderingContext || !cc.create3DContext(m, {stencil: !0, preserveDrawingBuffer: !0})))0 == e ? l = cc._RENDER_TYPE_CANVAS : cc._supportRender = !1;
    if (l == cc._RENDER_TYPE_CANVAS)try {
        m.getContext("2d")
    } catch (n) {
        cc._supportRender = !1
    }
    cc._renderType = l;
    try {
        c._supportWebAudio = !!new (f.AudioContext || f.webkitAudioContext || f.mozAudioContext)
    } catch (q) {
        c._supportWebAudio = !1
    }
    try {
        var r = c.localStorage = f.localStorage;
        r.setItem("storage", "");
        r.removeItem("storage");
        r = null
    } catch (t) {
        ("SECURITY_ERR" === t.name || "QuotaExceededError" === t.name) && cc.warn("Warning: localStorage isn't enabled. Please confirm browser cookie or privacy option"), c.localStorage = function () {
        }
    }
    r = c.capabilities = {canvas: !0};
    cc._renderType == cc._RENDER_TYPE_WEBGL && (r.opengl = !0);
    void 0 !== h.ontouchstart || g.msPointerEnabled ? r.touches = !0 : void 0 !== h.onmouseup && (r.mouse = !0);
    void 0 !== h.onkeyup && (r.keyboard = !0);
    if (f.DeviceMotionEvent || f.DeviceOrientationEvent)r.accelerometer = !0;
    f = k.match(/(iPad|iPhone|iPod)/i) ? !0 : !1;
    k = k.match(/android/i) || g.platform.match(/android/i) ? !0 : !1;
    h = c.OS_UNKNOWN;
    -1 != g.appVersion.indexOf("Win") ? h = c.OS_WINDOWS : f ? h = c.OS_IOS : -1 != g.appVersion.indexOf("Mac") ? h = c.OS_OSX : -1 != g.appVersion.indexOf("X11") ? h = c.OS_UNIX : -1 != g.appVersion.indexOf("Linux") ? h = c.OS_LINUX :
        k && (h = c.OS_ANDROID);
    c.os = h;
    c.garbageCollect = function () {
    };
    c.dumpRoot = function () {
    };
    c.restartVM = function () {
    };
    c.dump = function () {
        var a;
        a = "" + ("isMobile : " + this.isMobile + "\r\n");
        a += "language : " + this.language + "\r\n";
        a += "browserType : " + this.browserType + "\r\n";
        a += "capabilities : " + JSON.stringify(this.capabilities) + "\r\n";
        a += "os : " + this.os + "\r\n";
        cc.log(a)
    }
};
cc.ORIENTATION_PORTRAIT = 0;
cc.ORIENTATION_PORTRAIT_UPSIDE_DOWN = 1;
cc.ORIENTATION_LANDSCAPE_LEFT = 2;
cc.ORIENTATION_LANDSCAPE_RIGHT = 3;
cc._drawingUtil = null;
cc._renderContext = null;
cc._canvas = null;
cc._gameDiv = null;
cc._rendererInitialized = !1;
cc._setupCalled = !1;
cc._setup = function (a, b, c) {
    if (!cc._setupCalled) {
        cc._setupCalled = !0;
        var d = window;
        d.requestAnimFrame = d.requestAnimationFrame || d.webkitRequestAnimationFrame || d.mozRequestAnimationFrame || d.oRequestAnimationFrame || d.msRequestAnimationFrame;
        var e = cc.$(a) || cc.$("#" + a), f;
        "CANVAS" == e.tagName ? (b = b || e.width, c = c || e.height, f = cc.container = cc.newElement("DIV"), a = cc._canvas = e, a.parentNode.insertBefore(f, a), a.appendTo(f), f.setAttribute("id", "Cocos2dGameContainer")) : ("DIV" != e.tagName && cc.log("Warning: target element is not a DIV or CANVAS"),
            b = b || e.clientWidth, c = c || e.clientHeight, f = cc.container = e, a = cc._canvas = cc.$(cc.newElement("CANVAS")), e.appendChild(a));
        a.addClass("gameCanvas");
        a.setAttribute("width", b || 480);
        a.setAttribute("height", c || 320);
        a.setAttribute("tabindex", 99);
        a.style.outline = "none";
        e = f.style;
        e.width = (b || 480) + "px";
        e.height = (c || 320) + "px";
        e.margin = "0 auto";
        e.position = "relative";
        e.overflow = "hidden";
        f.top = "100%";
        cc._renderType == cc._RENDER_TYPE_WEBGL && (cc._renderContext = cc.webglContext = cc.create3DContext(a, {stencil: !0, preserveDrawingBuffer: !0,
            antialias: !cc.sys.isMobile, alpha: !1}));
        cc._renderContext ? (d.gl = cc._renderContext, cc._drawingUtil = new cc.DrawingPrimitiveWebGL(cc._renderContext), cc._rendererInitialized = !0, cc.textureCache._initializingRenderer(), cc.shaderCache._init()) : (cc._renderContext = a.getContext("2d"), cc._mainRenderContextBackup = cc._renderContext, cc._renderContext.translate(0, a.height), cc._drawingUtil = cc.DrawingPrimitiveCanvas ? new cc.DrawingPrimitiveCanvas(cc._renderContext) : null);
        cc._gameDiv = f;
        cc.log(cc.ENGINE_VERSION);
        cc._setContextMenuEnable(!1);
        cc.sys.isMobile && (b = cc.newElement("style"), b.type = "text/css", document.body.appendChild(b), b.textContent = "body,canvas,div{ -moz-user-select: none;-webkit-user-select: none;-ms-user-select: none;-khtml-user-select: none;-webkit-tap-highlight-color:rgba(0,0,0,0);}");
        cc.view = cc.EGLView._getInstance();
        cc.inputManager.registerSystemEvent(cc._canvas);
        cc.director = cc.Director._getInstance();
        cc.director.setOpenGLView && cc.director.setOpenGLView(cc.view);
        cc.winSize = cc.director.getWinSize();
        cc.saxParser = new cc.SAXParser;
        cc.plistParser = new cc.PlistParser
    }
};
cc._checkWebGLRenderMode = function () {
    if (cc._renderType !== cc._RENDER_TYPE_WEBGL)throw"This feature supports WebGL render mode only.";
};
cc._isContextMenuEnable = !1;
cc._setContextMenuEnable = function (a) {
    cc._isContextMenuEnable = a;
    cc._canvas.oncontextmenu = function () {
        if (!cc._isContextMenuEnable)return!1
    }
};
cc.game = {DEBUG_MODE_NONE: 0, DEBUG_MODE_INFO: 1, DEBUG_MODE_WARN: 2, DEBUG_MODE_ERROR: 3, DEBUG_MODE_INFO_FOR_WEB_PAGE: 4, DEBUG_MODE_WARN_FOR_WEB_PAGE: 5, DEBUG_MODE_ERROR_FOR_WEB_PAGE: 6, EVENT_HIDE: "game_on_hide", EVENT_SHOW: "game_on_show", _eventHide: null, _eventShow: null, _onBeforeStartArr: [], CONFIG_KEY: {engineDir: "engineDir", dependencies: "dependencies", debugMode: "debugMode", showFPS: "showFPS", frameRate: "frameRate", id: "id", renderMode: "renderMode", jsList: "jsList", classReleaseMode: "classReleaseMode"}, _prepareCalled: !1,
    _prepared: !1, _paused: !0, _intervalId: null, config: null, onStart: null, onStop: null, setFrameRate: function (a) {
        this.config[this.CONFIG_KEY.frameRate] = a;
        this._intervalId && clearInterval(this._intervalId);
        this._paused = !0;
        this._runMainLoop()
    }, _runMainLoop: function () {
        var a = this, b, c = a.config, d = a.CONFIG_KEY, e = window, f = c[d.frameRate], g = cc.director;
        g.setDisplayStats(c[d.showFPS]);
        e.requestAnimFrame && 60 == f ? (b = function () {
            a._paused || (g.mainLoop(), e.requestAnimFrame(b))
        }, e.requestAnimFrame(b)) : (b = function () {
            g.mainLoop()
        },
            a._intervalId = setInterval(b, 1E3 / f));
        a._paused = !1
    }, run: function (a) {
        var b = this, c = function () {
            a && (b.config[b.CONFIG_KEY.id] = a);
            b._prepareCalled ? cc._supportRender && (b._checkPrepare = setInterval(function () {
                b._prepared && (cc._setup(b.config[b.CONFIG_KEY.id]), b._runMainLoop(), b._eventHide = b._eventHide || new cc.EventCustom(b.EVENT_HIDE), b._eventHide.setUserData(b), b._eventShow = b._eventShow || new cc.EventCustom(b.EVENT_SHOW), b._eventShow.setUserData(b), b.onStart(), clearInterval(b._checkPrepare))
            }, 10)) : b.prepare(function () {
                cc._supportRender &&
                (cc._setup(b.config[b.CONFIG_KEY.id]), b._runMainLoop(), b._eventHide = b._eventHide || new cc.EventCustom(b.EVENT_HIDE), b._eventHide.setUserData(b), b._eventShow = b._eventShow || new cc.EventCustom(b.EVENT_SHOW), b._eventShow.setUserData(b), b.onStart())
            })
        };
        document.body ? c() : cc._addEventListener(window, "load", function () {
            this.removeEventListener("load", arguments.callee, !1);
            c()
        }, !1)
    }, _initConfig: function () {
        var a = this.CONFIG_KEY, b = function (b) {
            b[a.engineDir] = b[a.engineDir] || "frameworks/cocos2d-html5";
            null == b[a.debugMode] &&
            (b[a.debugMode] = 0);
            b[a.frameRate] = b[a.frameRate] || 60;
            null == b[a.renderMode] && (b[a.renderMode] = 1);
            return b
        };
        if (document.ccConfig)this.config = b(document.ccConfig); else try {
            for (var c = document.getElementsByTagName("script"), d = 0; d < c.length; d++) {
                var e = c[d].getAttribute("cocos");
                if ("" == e || e)break
            }
            var f, g, h;
            if (d < c.length) {
                if (f = c[d].src)h = /(.*)\//.exec(f)[0], cc.loader.resPath = h, f = cc.path.join(h, "project.json");
                g = cc.loader._loadTxtSync(f)
            }
            g || (g = cc.loader._loadTxtSync("project.json"));
            var k = JSON.parse(g);
            this.config =
                b(k || {})
        } catch (l) {
            cc.log("Failed to read or parse project.json"), this.config = b({})
        }
        cc._initSys(this.config, a)
    }, _jsAddedCache: {}, _getJsListOfModule: function (a, b, c) {
        var d = this._jsAddedCache;
        if (d[b])return null;
        c = c || "";
        var e = [], f = a[b];
        if (!f)throw"can not find module [" + b + "]";
        b = cc.path;
        for (var g = 0, h = f.length; g < h; g++) {
            var k = f[g];
            if (!d[k]) {
                var l = b.extname(k);
                l ? ".js" == l.toLowerCase() && e.push(b.join(c, k)) : (l = this._getJsListOfModule(a, k, c)) && (e = e.concat(l));
                d[k] = 1
            }
        }
        return e
    }, prepare: function (a) {
        var b = this,
            c = b.config, d = b.CONFIG_KEY, e = c[d.engineDir], f = cc.loader;
        if (cc._supportRender) {
            b._prepareCalled = !0;
            var g = c[d.jsList] || [];
            cc.Class ? f.loadJsWithImg("", g, function (c) {
                if (c)throw c;
                b._prepared = !0;
                a && a()
            }) : (d = cc.path.join(e, "moduleConfig.json"), f.loadJson(d, function (d, f) {
                if (d)throw d;
                var l = c.modules || [], m = f.module, n = [];
                cc._renderType == cc._RENDER_TYPE_WEBGL ? l.splice(0, 0, "shaders") : 0 > l.indexOf("core") && l.splice(0, 0, "core");
                for (var q = 0, r = l.length; q < r; q++) {
                    var t = b._getJsListOfModule(m, l[q], e);
                    t && (n = n.concat(t))
                }
                n =
                    n.concat(g);
                cc.loader.loadJsWithImg(n, function (c) {
                    if (c)throw c;
                    b._prepared = !0;
                    a && a()
                })
            }))
        } else cc.error("Can not support render!")
    }};
cc.game._initConfig();
cc.loader.loadBinary = function (a, b) {
    var c = this, d = this.getXMLHttpRequest(), e = "load " + a + " failed!";
    d.open("GET", a, !0);
    /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? (d.setRequestHeader("Accept-Charset", "x-user-defined"), d.onreadystatechange = function () {
        if (4 == d.readyState && 200 == d.status) {
            var a = cc._convertResponseBodyToText(d.responseBody);
            b(null, c._str2Uint8Array(a))
        } else b(e)
    }) : (d.overrideMimeType && d.overrideMimeType("text/plain; charset\x3dx-user-defined"), d.onload = function () {
        4 ==
        d.readyState && 200 == d.status ? b(null, c._str2Uint8Array(d.responseText)) : b(e)
    });
    d.send(null)
};
cc.loader._str2Uint8Array = function (a) {
    if (!a)return null;
    for (var b = new Uint8Array(a.length), c = 0; c < a.length; c++)b[c] = a.charCodeAt(c) & 255;
    return b
};
cc.loader.loadBinarySync = function (a) {
    var b = this.getXMLHttpRequest(), c = "load " + a + " failed!";
    b.open("GET", a, !1);
    a = null;
    if (/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
        b.setRequestHeader("Accept-Charset", "x-user-defined");
        b.send(null);
        if (200 != b.status)return cc.log(c), null;
        (b = cc._convertResponseBodyToText(b.responseBody)) && (a = this._str2Uint8Array(b))
    } else {
        b.overrideMimeType && b.overrideMimeType("text/plain; charset\x3dx-user-defined");
        b.send(null);
        if (200 != b.status)return cc.log(c),
            null;
        a = this._str2Uint8Array(b.responseText)
    }
    return a
};
var Uint8Array = Uint8Array || Array;
if (/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
    var IEBinaryToArray_ByteStr_Script = '\x3c!-- IEBinaryToArray_ByteStr --\x3e\r\nFunction IEBinaryToArray_ByteStr(Binary)\r\n   IEBinaryToArray_ByteStr \x3d CStr(Binary)\r\nEnd Function\r\nFunction IEBinaryToArray_ByteStr_Last(Binary)\r\n   Dim lastIndex\r\n   lastIndex \x3d LenB(Binary)\r\n   if lastIndex mod 2 Then\r\n       IEBinaryToArray_ByteStr_Last \x3d Chr( AscB( MidB( Binary, lastIndex, 1 ) ) )\r\n   Else\r\n       IEBinaryToArray_ByteStr_Last \x3d ""\r\n   End If\r\nEnd Function\r\n', myVBScript =
        cc.newElement("script");
    myVBScript.type = "text/vbscript";
    myVBScript.textContent = IEBinaryToArray_ByteStr_Script;
    document.body.appendChild(myVBScript);
    cc._convertResponseBodyToText = function (a) {
        for (var b = {}, c = 0; 256 > c; c++)for (var d = 0; 256 > d; d++)b[String.fromCharCode(c + 256 * d)] = String.fromCharCode(c) + String.fromCharCode(d);
        c = IEBinaryToArray_ByteStr(a);
        a = IEBinaryToArray_ByteStr_Last(a);
        return c.replace(/[\s\S]/g, function (a) {
            return b[a]
        }) + a
    }
}
;
cc = cc || {};
cc._loadingImage = "data:image/gif;base64,R0lGODlhEAAQALMNAD8/P7+/vyoqKlVVVX9/fxUVFUBAQGBgYMDAwC8vL5CQkP///wAAAP///wAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFAAANACwAAAAAEAAQAAAEO5DJSau9OOvNex0IMnDIsiCkiW6g6BmKYlBFkhSUEgQKlQCARG6nEBwOgl+QApMdCIRD7YZ5RjlGpCUCACH5BAUAAA0ALAAAAgAOAA4AAAQ6kLGB0JA4M7QW0hrngRllkYyhKAYqKUGguAws0ypLS8JxCLQDgXAIDg+FRKIA6v0SAECCBpXSkstMBAAh+QQFAAANACwAAAAACgAQAAAEOJDJORAac6K1kDSKYmydpASBUl0mqmRfaGTCcQgwcxDEke+9XO2WkxQSiUIuAQAkls0n7JgsWq8RACH5BAUAAA0ALAAAAAAOAA4AAAQ6kMlplDIzTxWC0oxwHALnDQgySAdBHNWFLAvCukc215JIZihVIZEogDIJACBxnCSXTcmwGK1ar1hrBAAh+QQFAAANACwAAAAAEAAKAAAEN5DJKc4RM+tDyNFTkSQF5xmKYmQJACTVpQSBwrpJNteZSGYoFWjIGCAQA2IGsVgglBOmEyoxIiMAIfkEBQAADQAsAgAAAA4ADgAABDmQSVZSKjPPBEDSGucJxyGA1XUQxAFma/tOpDlnhqIYN6MEAUXvF+zldrMBAjHoIRYLhBMqvSmZkggAIfkEBQAADQAsBgAAAAoAEAAABDeQyUmrnSWlYhMASfeFVbZdjHAcgnUQxOHCcqWylKEohqUEAYVkgEAMfkEJYrFA6HhKJsJCNFoiACH5BAUAAA0ALAIAAgAOAA4AAAQ3kMlJq704611SKloCAEk4lln3DQgyUMJxCBKyLAh1EMRR3wiDQmHY9SQslyIQUMRmlmVTIyRaIgA7";
cc._fpsImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAAgCAYAAAD9qabkAAAKQ2lDQ1BJQ0MgcHJvZmlsZQAAeNqdU3dYk/cWPt/3ZQ9WQtjwsZdsgQAiI6wIyBBZohCSAGGEEBJAxYWIClYUFRGcSFXEgtUKSJ2I4qAouGdBiohai1VcOO4f3Ke1fXrv7e371/u855zn/M55zw+AERImkeaiagA5UoU8Otgfj09IxMm9gAIVSOAEIBDmy8JnBcUAAPADeXh+dLA//AGvbwACAHDVLiQSx+H/g7pQJlcAIJEA4CIS5wsBkFIAyC5UyBQAyBgAsFOzZAoAlAAAbHl8QiIAqg0A7PRJPgUA2KmT3BcA2KIcqQgAjQEAmShHJAJAuwBgVYFSLALAwgCgrEAiLgTArgGAWbYyRwKAvQUAdo5YkA9AYACAmUIszAAgOAIAQx4TzQMgTAOgMNK/4KlfcIW4SAEAwMuVzZdL0jMUuJXQGnfy8ODiIeLCbLFCYRcpEGYJ5CKcl5sjE0jnA0zODAAAGvnRwf44P5Dn5uTh5mbnbO/0xaL+a/BvIj4h8d/+vIwCBAAQTs/v2l/l5dYDcMcBsHW/a6lbANpWAGjf+V0z2wmgWgrQevmLeTj8QB6eoVDIPB0cCgsL7SViob0w44s+/zPhb+CLfvb8QB7+23rwAHGaQJmtwKOD/XFhbnauUo7nywRCMW735yP+x4V//Y4p0eI0sVwsFYrxWIm4UCJNx3m5UpFEIcmV4hLpfzLxH5b9CZN3DQCshk/ATrYHtctswH7uAQKLDljSdgBAfvMtjBoLkQAQZzQyefcAAJO/+Y9AKwEAzZek4wAAvOgYXKiUF0zGCAAARKCBKrBBBwzBFKzADpzBHbzAFwJhBkRADCTAPBBCBuSAHAqhGJZBGVTAOtgEtbADGqARmuEQtMExOA3n4BJcgetwFwZgGJ7CGLyGCQRByAgTYSE6iBFijtgizggXmY4EImFINJKApCDpiBRRIsXIcqQCqUJqkV1II/ItchQ5jVxA+pDbyCAyivyKvEcxlIGyUQPUAnVAuagfGorGoHPRdDQPXYCWomvRGrQePYC2oqfRS+h1dAB9io5jgNExDmaM2WFcjIdFYIlYGibHFmPlWDVWjzVjHVg3dhUbwJ5h7wgkAouAE+wIXoQQwmyCkJBHWExYQ6gl7CO0EroIVwmDhDHCJyKTqE+0JXoS+cR4YjqxkFhGrCbuIR4hniVeJw4TX5NIJA7JkuROCiElkDJJC0lrSNtILaRTpD7SEGmcTCbrkG3J3uQIsoCsIJeRt5APkE+S+8nD5LcUOsWI4kwJoiRSpJQSSjVlP+UEpZ8yQpmgqlHNqZ7UCKqIOp9aSW2gdlAvU4epEzR1miXNmxZDy6Qto9XQmmlnafdoL+l0ugndgx5Fl9CX0mvoB+nn6YP0dwwNhg2Dx0hiKBlrGXsZpxi3GS+ZTKYF05eZyFQw1zIbmWeYD5hvVVgq9ip8FZHKEpU6lVaVfpXnqlRVc1U/1XmqC1SrVQ+rXlZ9pkZVs1DjqQnUFqvVqR1Vu6k2rs5Sd1KPUM9RX6O+X/2C+mMNsoaFRqCGSKNUY7fGGY0hFsYyZfFYQtZyVgPrLGuYTWJbsvnsTHYF+xt2L3tMU0NzqmasZpFmneZxzQEOxrHg8DnZnErOIc4NznstAy0/LbHWaq1mrX6tN9p62r7aYu1y7Rbt69rvdXCdQJ0snfU6bTr3dQm6NrpRuoW623XP6j7TY+t56Qn1yvUO6d3RR/Vt9KP1F+rv1u/RHzcwNAg2kBlsMThj8MyQY+hrmGm40fCE4agRy2i6kcRoo9FJoye4Ju6HZ+M1eBc+ZqxvHGKsNN5l3Gs8YWJpMtukxKTF5L4pzZRrmma60bTTdMzMyCzcrNisyeyOOdWca55hvtm82/yNhaVFnMVKizaLx5balnzLBZZNlvesmFY+VnlW9VbXrEnWXOss623WV2xQG1ebDJs6m8u2qK2brcR2m23fFOIUjynSKfVTbtox7PzsCuya7AbtOfZh9iX2bfbPHcwcEh3WO3Q7fHJ0dcx2bHC866ThNMOpxKnD6VdnG2ehc53zNRemS5DLEpd2lxdTbaeKp26fesuV5RruutK10/Wjm7ub3K3ZbdTdzD3Ffav7TS6bG8ldwz3vQfTw91jicczjnaebp8LzkOcvXnZeWV77vR5Ps5wmntYwbcjbxFvgvct7YDo+PWX6zukDPsY+Ap96n4e+pr4i3z2+I37Wfpl+B/ye+zv6y/2P+L/hefIW8U4FYAHBAeUBvYEagbMDawMfBJkEpQc1BY0FuwYvDD4VQgwJDVkfcpNvwBfyG/ljM9xnLJrRFcoInRVaG/owzCZMHtYRjobPCN8Qfm+m+UzpzLYIiOBHbIi4H2kZmRf5fRQpKjKqLupRtFN0cXT3LNas5Fn7Z72O8Y+pjLk722q2cnZnrGpsUmxj7Ju4gLiquIF4h/hF8ZcSdBMkCe2J5MTYxD2J43MC52yaM5zkmlSWdGOu5dyiuRfm6c7Lnnc8WTVZkHw4hZgSl7I/5YMgQlAvGE/lp25NHRPyhJuFT0W+oo2iUbG3uEo8kuadVpX2ON07fUP6aIZPRnXGMwlPUit5kRmSuSPzTVZE1t6sz9lx2S05lJyUnKNSDWmWtCvXMLcot09mKyuTDeR55m3KG5OHyvfkI/lz89sVbIVM0aO0Uq5QDhZML6greFsYW3i4SL1IWtQz32b+6vkjC4IWfL2QsFC4sLPYuHhZ8eAiv0W7FiOLUxd3LjFdUrpkeGnw0n3LaMuylv1Q4lhSVfJqedzyjlKD0qWlQyuCVzSVqZTJy26u9Fq5YxVhlWRV72qX1VtWfyoXlV+scKyorviwRrjm4ldOX9V89Xlt2treSrfK7etI66Trbqz3Wb+vSr1qQdXQhvANrRvxjeUbX21K3nShemr1js20zcrNAzVhNe1bzLas2/KhNqP2ep1/XctW/a2rt77ZJtrWv913e/MOgx0VO97vlOy8tSt4V2u9RX31btLugt2PGmIbur/mft24R3dPxZ6Pe6V7B/ZF7+tqdG9s3K+/v7IJbVI2jR5IOnDlm4Bv2pvtmne1cFoqDsJB5cEn36Z8e+NQ6KHOw9zDzd+Zf7f1COtIeSvSOr91rC2jbaA9ob3v6IyjnR1eHUe+t/9+7zHjY3XHNY9XnqCdKD3x+eSCk+OnZKeenU4/PdSZ3Hn3TPyZa11RXb1nQ8+ePxd07ky3X/fJ897nj13wvHD0Ivdi2yW3S609rj1HfnD94UivW2/rZffL7Vc8rnT0Tes70e/Tf/pqwNVz1/jXLl2feb3vxuwbt24m3Ry4Jbr1+Hb27Rd3Cu5M3F16j3iv/L7a/eoH+g/qf7T+sWXAbeD4YMBgz8NZD+8OCYee/pT/04fh0kfMR9UjRiONj50fHxsNGr3yZM6T4aeypxPPyn5W/3nrc6vn3/3i+0vPWPzY8Av5i8+/rnmp83Lvq6mvOscjxx+8znk98ab8rc7bfe+477rfx70fmSj8QP5Q89H6Y8en0E/3Pud8/vwv94Tz+4A5JREAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfcAgcQLxxUBNp/AAAQZ0lEQVR42u2be3QVVZbGv1N17829eRLyIKAEOiISEtPhJTJAYuyBDmhWjAEx4iAGBhxA4wABbVAMWUAeykMCM+HRTcBRWkNH2l5moS0LCCrQTkYeQWBQSCAIgYRXEpKbW/XNH5zS4noR7faPEeu31l0h4dSpvc+t/Z199jkFWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhY/H9D/MR9qfKnLj/00U71aqfJn9+HCkCR/Wk36ddsgyJ/1wF4fkDfqqm9/gPsUeTnVr6a2xlQfnxdI7zs0W7irzD17Ytb2WT7EeNv/r4ox1O3Quf2QP2pgt9utwfout4FQE8AVBSlnaRmfvAURQkg2RlAbwB9AThlW5L0GaiKojhJhgOIBqDa7XaPrusdPtr5kQwF0BVAAoBIABRCKDd5aFUhRDAAw57eAOwAhKIoupft3zoqhB1AqLwuHIBut9uFt02qqvqRDJR2dAEQJj/BAOjn56dqmma+xiaECAEQAWAggLsB6A6HQ2iaZggBhBAqgEAAnQB0kzaEmT4hAITT6VQ8Ho/HJAKKECJQtr8LwD1y/A1/vcdfEUIEyfZ9AcQbYvZ942Px88L2UwlJR0dH0EMPPbRj5syZPUeNGrXR7Xb/641xIwJ1XY9NSUlZm52dfW+XLl1w8uRJzJ8//+OGhoYJqqqe1TSt1Wsm9NN1PSIqKmr12rVrR5WUlHy1bdu2AQCumWc3IYRD1/UwVVXnFRQUTIuNjUVzczN2797dWFJSkq8oymZd15sAGAEnFEUJ1nX9nzIzM1dnZmZGh4SE4OTJk5g5c+Zf29vbp9pstrMej6fVOyhIhgAYU1hY+B+hoaGoqKg4XVlZea+XTULTNFdCQsLGiRMnPuR2u3UhBOV9eeDAAWXTpk095DUe6WsoyRE5OTlr0tLSAux2O/bs2cO5c+e+pijKUpIXSHaQVAGkvPLKK++6XK4OksJLCFlXV2cvKSlJBFAjhU+x2WwhHo9nUHp6+urMzMy7wsLCUF9fjxdffPHjxsbGiTab7WuPx9NiEutOuq4PyMjI+M+srKyYqKgoHD58GDNmzNjq8XhyVFU9b/q+LH7hBAEYu3PnTlZVVRFAGgCX6f/tAHoOHDjwa0p27txp/JO9e/f+QM7cipw9nfL3kQBKt2zZQpJ87rnn6mQmoHilw2EACs+cOUOSrK+vZ1NTE0nyo48+IoBpxswoBcMJ4Ndjx471kOTFixe5d+9ekqTH42H//v13A4jyzpAURfEH0H/OnDnthu1z5sw558MmFUCPWbNmnaMP3nrrLZoyDmP8Hl68eDFJ8siRI9/Yc+zYMQKYKdtAztrTrl27xptRXV1NAKMAOAyBBBA/Y8aMdpLs6Ojgxx9//E37+++//29yvFXppwvAwMcee8xjtDHsuXLlCqOjo//ia3wsfpkoALqFhoZuIckJEyackimm3dQmEMDUmpoakmRISMhhAHOHDx/eQJIbN24kgKEyMAHAFRMTs2XXrl1saWkhSZ0kp0+ffhrAr3wEW/S8efOukORLL72kA1gKYMPWrVtJkk899dRJAHeYrgsEsIQkjx8/TgDvAPjd448/3kaSb7zxBmUa7vC6z53BwcFbSHL9+vU6Sc6aNes8gF5ewWAH0PfVV18lSQL4DMBGIcQ6AKtcLleBFC2jXtFt8ODBe0iyoqKCAJYByC8qKmJDQwOzsrK+MAmqo1OnTveHhoa+GRkZ+XZkZOSWiIiIvzgcjk9mzpypkWRmZuZpmbYbGV4AgPnNzc1sa2sjgN0A5iQmJtaSZHl5OQHcb/K3s81mW0uSTU1NBFAFYFbfvn1Pk+Tbb79NAA8IIVzW42/hByA+Pz/fLR/2ZXIda05NI/z9/TeR5J49ewhgqlxTrtI0jY2NjQQw3zTLuWJiYjaUlJToS5Ys6fjkk080kwDEeAmADcA9GzZsIElGRUW9CyAWwLApU6Y0kOSKFSsog9QICGdERMTGsrIyZmVlEcC9AB4IDw/fTpLbtm0jgN94CUAnAJmVlZVcs2aNZ/LkyRdJcvbs2b4EwAkgZfPmzTxw4AABFAN4BkC6vFeUSewcAO5duXIlSTIhIaEawGMAxgKYAmAGgCS73e5vrKVk/yGythANYEhCQsIhkly+fDkBpKqqGmL6DgIALDKN/3yZpVWQZGVlJQE8aPI3KiMjo5okV61aRQAjAPQBMPfIkSN0u90EUCBtsPiFEwpgbn19PdetW2fM5N4zQ9ekpKQqkty0aRMBpMjiWM6JEydIkoqirJUFJ6iq6pAPVy8A6cZMehMBUACEuVyuFwG8HBwcPEIWx367ZMkSjSQXLVrUJouTRorrkAHdA8BdQogsAOsKCwtJkmPGjDkvMw2bDDo/ADEjRoz4XylyFbm5uY0mAbjLyyZ/AOOrq6tZVlbWsWDBgo69e/eyoqKCgwcPPg4gSQaoIRbp27dvN7KF+tLSUr28vJwFBQXtMpvpYRIM7+wrAkDeqVOnePbsWQIoNKfzpiXPg8uXLydJJicnNwF4f+nSpW6STEtLq5fjYwhk1wkTJtSQ5Ouvv04AqTKj+N2xY8dIkgEBAW/Ie1v8wncRegwZMmQvSfbr12+3Ua33WqPfOWbMmP0kWVpaSgCDZAqcfejQIWNZsEGKgvnh9gfQb9myZd8nAEJVVZtMkUNk8CcNHTq0liR1XWdYWNhmH1mJIme80OnTp18x1rp5eXkEsNJms92Fb7e/IgEsvHz5Mp999tkmAI/l5uZeMC0B7vEqqAYAyL106RJJsra2lpWVld+sucePH38ZQG+5NncBeOrgwYMkqbe3t/Po0aOsra011wAWyl0H7x0JJ4DE+fPnu0kyPT29DsDdUrBuyNKEEAkAdpw/f/6GeoEM8GUmfwEgPCIiopwkGxsbabPZPgOw6L777vvm4p49e26VGYjFLxUhhD+ApLKyMp44ccIoVnXybgbgzkcfffRzklyzZg0BDJYCMMmoCwQFBXkLgLGWvvcWAgBToSsKwNPTp09vMR7UuLi4rwH0lgU8c/Db5ezbeeTIkRWzZ8++aMxu+fn5BPCADBwHgP4LFy701NXVEUAJgAnPP/98kyxMNgHo53A4zH77BQQETMvPz7+Um5vbBuAlAFMSExPPmdbVL0qh8Acw8fDhw5SCchVAEYAVb775JknyhRdeaJYztHfxMwLAaqNwCGC2FArv8x0hAHKNLGPKlCme5OTk/Zs3bzb7O0wKiiG8KXl5ed8IxenTp0mSR48e1UmyW7duWywBuD2xyQcgFECgoih+8H1gyJgZV5Lkyy+/3CbTRIePtl2HDBmyw1QBHyGDdXZdXR1JUghRKkXBjOMHCoBdpr0L3nvvPZLkF198wejo6O0A4lVVDTb74HQ6AwD8Wq7Jh8rgGgDgQ13XjVR8qaxJuADMbmlpYXl5uV5UVNRWUFDgfv/993Vj/ZydnU1c37eHXML4S3viAcQqitJD2l104cIFY8lTKsXSBWBMVVWVcd9yed2A1NTUQ6Zl00CvLMMOoHdubm6zFIlWOf5+PsY/Kj09vdrU11QAwwGsv3jxIk21m2DZr10I0RXAuAcffPBgaWkpV69eTYfDcdiwUxY0w6xw+flX8L1xApjevXv3lREREaW6rofB93aPDUDQpEmTMgHgtddeqwBwEd/utZvpqK6uPgEAcXFxkA94NwB9unfvjrNnz4LklwDcf08iIqv66Zs2bXrl4YcfxooVKxAbG7uqrq5uAYA2TdOEqqpGYIi2tjbl6aeffu/YsWPv5uTk7JaC1wHg4Pnz542MwoVvTx+21dbWYvjw4WLixIl+2dnZ9lGjRgmSTE1NRUpKCkwFTGiaxtTU1OXTpk3707Bhw/6g67pDipnT4biuj7qut+Lbk3Vf1tTUXI9qu91Pjq1QFEUBgJaWFgBo8yGOQ8eNGxcAAOvXr/8QwBUfYygAKL169eoCABcuXACAWtn2hOGv0+kMNO1KiPDw8F4A4rZv3/7R1KlTR0+bNu1ht9u9r1+/fqitrQXJgwDarRC6/QjPzs4+QJIffPCB9/aQmSAA43ft2mW0e1QGoi8CAPyLsZccExNTC2BlRkbGRdOyYJCP2csBIN6UAZzCd7cBbQCijYp/dXU1ExMTz6SmptaMHj36f9LS0vYlJCRsl6mxIWSdu3fv/g5J7t+/nwC2AShMTk6+SJKff/45AWRLYbD7+fndAeDf5BJnLoCCyZMnt5JkdnZ2C4B/F0KEm1Pu+Pj4rST55ZdfEsBWAK+mpaVdMo3raDn7KwDuSEpK+m+S3LBhAwG8DuCtHTt2UBbpjgC408vvcFVV15HkuXPnjMp+p5uMf0RcXNyHJNnQ0EBVVfcCWBQXF3fG+Jv0yxABPwB5LS0tRmFxN4BlTzzxxGWSXLx4sS5F3GGFy+1Hp5SUlJq6ujoWFxdTpsZ2H+0iIyMj/0iSWVlZX5mr5jfJFroPGzasxlhTnjp1iiTZ3NxMl8tlrCd9pfa9SkpKSJI5OTmnZOageLUZZqxvfVFWVkZcPwdgNwnSCKPqb17jkmR8fPzfZMDZ5CRsFBmNI7h95s2b1yhT7/MAYmStwCx4vy0uLqa3v5qmEcCfvSr1QQAeXb16NY3Cm3HQ55133iGAp+SxZTNhKSkpfzUddkrFjYevzAQCeGjp0qXfsYckY2NjTwD4leGDLCL2HTdunNtoY+zWSHFcIHdsFCtcfuZ1vO9Eqs3m7/F47sb1k2qX/f3997W2tl7BjWfpBYDOzzzzzIVJkyZh0KBBCwEsB3AJvl9AETabLcDj8dwRFRW1ctasWb8JCgpSzp07d62wsPC/Wltb8xRFadR1/ZqPXYbgAQMGbI2Pjw/+6quv9ldVVT0r01ezuPRJSUn5Y9euXXVd11WzDaqq6kePHm3+7LPPRgO4KlNuxWazhXo8nuTk5OSXMjIyEl0uFxoaGtqKior+dPXq1VdUVT0jj7r68ieoT58+vx8yZMjdx48fP1JVVTVF9m20VW02WyfZf97YsWPjXS4X6urqWvPy8jYCWCyEuEDS8FdVFKWzruv//OSTTy5OTk7uqWkaPv3007qysrJ8RVH+LI8ym8/rB3Tu3HnRI488knLo0KG2ffv2ZQI4C98vP6mqqoZqmpaclpa2cOTIkX39/f3R0NDQUVxc/G5TU9PLqqrWa5rWLH1QVFUN0TStX1JSUvH48eP7BwYG4uDBg1cKCgpeBbBe2u+2Qug2EwD5N5sMPuNtMe8XP4TT6Qxoa2sbIGeXvUKIK7d4IISiKC5d1wPljOfA9bPwzYqiXNV13dd6Uqiq6qdpml2mpe02m63d4/G4vcTF5fF47LJf71nJA6BZVVW3pmntuPHlmAD5wk6Q9NnbHp9vHaqq6tA0zU/64PZhk1FfCZB9G/23ALiqKEqzD39tpvbGUqoFwFUhRLP3yzpCCDtJpxyXDulfG27+pqRR3DXsUWVd4Yq0x/taVQjhIhksC8L+ABpM9ljBf5sKwI8pIBr75L5E4vvu+UNeG/a+hv+AL7yFH8qPtOfHjtOP6V/Bja8D6z/B2Nys/1u9Xv33tLf4GfF/LC4GCJwByWIAAAAASUVORK5CYII\x3d";
cc._loaderImage = "data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAAAlAAD/4QMpaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjAtYzA2MCA2MS4xMzQ3NzcsIDIwMTAvMDIvMTItMTc6MzI6MDAgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjM4MDBEMDY2QTU1MjExRTFBQTAzQjEzMUNFNzMxRkQwIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjM4MDBEMDY1QTU1MjExRTFBQTAzQjEzMUNFNzMxRkQwIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDUzUgV2luZG93cyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkU2RTk0OEM4OERCNDExRTE5NEUyRkE3M0M3QkE1NTlEIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkU2RTk0OEM5OERCNDExRTE5NEUyRkE3M0M3QkE1NTlEIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+/+4ADkFkb2JlAGTAAAAAAf/bAIQADQkJCQoJDQoKDRMMCwwTFhENDREWGhUVFhUVGhkUFhUVFhQZGR0fIB8dGScnKionJzk4ODg5QEBAQEBAQEBAQAEODAwOEA4RDw8RFA4RDhQVERISERUfFRUXFRUfKB0ZGRkZHSgjJiAgICYjLCwoKCwsNzc1NzdAQEBAQEBAQEBA/8AAEQgAyACgAwEiAAIRAQMRAf/EALAAAAEFAQEAAAAAAAAAAAAAAAQAAgMFBgcBAQEAAwEBAAAAAAAAAAAAAAAAAQMEAgUQAAIBAgIEBwoLBgQGAwAAAAECAwAEEQUhMRIGQVFxsTITFGGBwdEiQlKSMzWRoeFicqKyI1NzFYJjJDQWB9KjVCbxwkNkJWXik3QRAAIBAgMFBQcDBQEAAAAAAAABAhEDIRIEMUFRcTJhwVIUBZGhsSJyEzOB0ULhYpIjUxX/2gAMAwEAAhEDEQA/AMJSpUqAVKlXuFAeUq9wpUB5XuFe4V6ooDzZHDox0CnGMinzwl7Z8NajaHeoO3vmTBZBtp9YUIqTEV5ROxHKnWRnaU8VRMhFBUjpV7hSoSeUq9pUB5Sr2lhQHlKvcK8oBV7hSFSRrtaKAZs07YNPM1pG2xJIAw1jSeandry/8X4m8VCKkWwaWwam7Xl/4v1W8VLtmX/i/VbxUoKkWwakSM407tmX/i/VbxUmzGwjQsjdY41IARie/U0IbZO0kNtCXnOCkEBeFu4KI3Bs7DNb27ya+jDx3kJeEnpJJEcQVbWDsk17u5urd591ucZkWhym2Vnd9RkCDEpFxDRpbw0bunu5mlp2De2FMLYXOD2wB2xbOeraUcYGJ72mlSUiqzzdzMd3Z3mixltA2yzcK/NlHM1DQyRXce1HocdNOEfJXZ88y9ZojOqhiBszIRiHQ8Y4cK5TvHuzLljHNMqxNoDjLFraHHnjPxcNCGVbxEUzYNTx5jZSxhpW6qTzlwJ+DCvO2Zf+L9VvFSgqyHYNLYNTdssPxfibxUu15f8Ai/VPiqCakOwa82DU/a8v/F+JvFTDdWPBL8R8VKCvYRYV5UzoMAy6QdIIqI0B4KJtxiRQwou16QoGUkntH5Tz0RbZbmF2hktraSVBo2lUkY8tDye0flPPXTslVUyiyVRsjqUOA4yMT8dW2ram2m6UVTNq9S7EIyUVJydMTn/6DnP+im9Wl+g5z/opvVrpteEhQWY4AaSTwAVf5WPiZh/9S5/zj7zltzlmYWkfWXNvJDGTgGcYDHirR7i7mSbwXParsFMrgb7w6jKw/wCmnc9I14kF3vpvCljbMyWMOJL4aEiB8qU/ObUK7HYWVrl1pFZWiCOCBQqKOLjPGTrNZZqKbUXVHq2nNwTuJRk1VpbgXN8s7Rk5ym0UQQzhIG2NAjhxHWbI+gCBVjBBFbwxwQqEiiUJGg1BVGAFe7dV28WYLYZFmF2Th1UD7JGjymGyn1iK5OyzIBGB1HgrLZhamzumQAGJwSqnSCh1q3GOCodxt4cxurdcpzuN4cyhiWaF5Bg09udUmnWw1H/jV9nFuJ7Quo+8h8peThFA+047vduyMtk7fYqTl07YFdfUufMPzT5p71UdtlmYXaGS2t3mQHAsgxANdadYJopLe4QS2867EsZ4QfCNYrCFbjdDPmgkYyWFxgVf04ifJf6ScNdRUW1XBb6FU5TjF5EpSSrGu/s5lN+g5z/opvVpfoOc/wCim9WtdHnatvObJXDW7xLGhB8nrPaY9/HCr+tEdPCVaSeDoYLnqF63lzW4/PFSW3ecxbI84VSzWUwUaSdg0DXXK5nvAipnd6qgKvWnQO7pri9ZUEmm3Vl2j1kr8pRlFRyquBNZjGxQ/S56Y1S2fu9OVueon11Szahoou06QoQUXadIVCD2FJJ7R+U89dMydv8Axdn+TH9muZye0flPPXQstlK5Tbka1gUjlC1q0vVLkeb6r+O3Tx9xcY1nt8c0NrZCyiOE1108NYjGv1joo7Js1jzKyScYLIvkzL6LDwHXVJksH9Sb49dKNq0tj1jA6uriOCL+02FWX7iVtZX1/AzaHTyeoauKn2MX9W79zebiZCuR5MjSrhfXuEtwTrUeZH+yNfdrRNcxI6IzhXlJEak6WIGJ2Rw4ChWnChndtlVBLMdQA0k1gbXNMzzDfDLs6mjaPKppJbWwJ1bOwwxw43OnHh71YT3DpfWUJmFlb5jHHDdeXBHIsrRea5TSqvxqG04cNN62vetoCS4tre5mgnkGE9q+3DKOkuI2WX6LDQRRHWDh1UCtwj7QRg2wdl8Djgw1qe7XvW0BQ3kfZ7mSLgU+T9E6RVbnuVrnWVSWqj+Lt8ZbRuHEdKPkYVcZ2MJY5fSGyeVar45+rkWQHAqccalPE5km1htWK5nK4Wnt5FuUBUwOMG4nGkA/BXUrW4S6torlOjMgcd/xVn7rLo7zKs0uEjCNeSvdwoBhgsZxX1l2j36k3Lu+uyprdj5Vs5A+i/lD48a0aaVJOPi7jB6lbzWozpjB48pf1NDXNN4vfl7+Z4BXS65pvF78vfzPAK71XTHmZ/S/yT+jvJ7L3fHytz1E+upbL+Qj5W56jfXWRnsIYKLtekKEFGWvSFQgyjk9o/Keet3YthlMP/5x9msJJ7R+U89biyb/AMXEv7gD6tadL1T+kwepRrC39ZkLDMbiwMvUHRPG0bjlGg8ore/23sxBldxfMPLupNhT8yL/AORNZbdzJ484scytxgLqJY5LZj6Q2sV5G1Vud1mjjyG0ij0NEGSZToKyhjtqw4waztuiXA3qKTbSxltfGhbZlE95ZtZqxVbgiOZhrER9ph3Svk9+pJILZ4Y4DGBFCUMKjRsGPobPFhUfW0NJmljE2xJcIrcI2vFUEln1lRXd6lrazXT9GCNpD+yNqoI7mOVduNw6nzlOIoPOUa6yye1XXcbMR5GdQ3xY0BSbj31/FcTQZirJ+q431q7anbHCTZ72Bw7lbPrKBMcBWNNgbMBBh+bsjBdni0VJ1lARZs6yWiupxCuMDy6KpS2IwOo6DTr3Mre3e5tZZVUM4ZBjqOOJoWO4jkXajcOOMHGgDISvWIrdAkKR80+TzVl908bPPL3LzxOuHdifxVfiTAg92qI/w+/8gGgSyN/mR7XPVlp0lF/3L3mbVKtu5Hjbk/8AHE2Fc03i9+Xv5ngFdKNc13i9+Xv5ngFaNV0x5nn+l/kn9HeEWXu+PlbnqJ9dS2Xu9OVueon11kZ7CGCjLXpCgxRlr0hUIPYUcntH5Tz1s8vb+Bt1/dqPirGSe0flPPWusG/g4Py15q06XqlyMWvVYQ+ruI9xJOqzO9hOto/sP8tbGOFIrmWeM7IuMDMnAXXQJOUjQeOsJk0nY96ip0CYunrjaHx1t+srPJUbXBm2LrFPikwTOb+T+VhbZxGMrDXp83x1QSy2tucJpUjPETp+Cn5/ftaRvKvtp3Kx48HG3erHMzOxZiWZtLMdJNQSbbL71Vk6yynViOkqnEEfOWtPbXi3EQkGg6mXiNckjeSJxJGxR10qw0GtxuxmvbImD4CZMFlA4fRfv0BqesqqzTMZNMEDbIHtHH2QeCiZJSqMQdOGiue53mz3czQwsRbIcNHnkec3c4qAMuriz68gTIToxwOOnlp0MjxMJYW741Gs3RVldtbygE/dMcHX/moDaxTiWNZB53B3arb8/wC+4SOF4sf/AKxU9kcBsfOGHfoUHtG/RbzY5Die5HHhXdvavqiZ9Q8Jdlq4/gbKua7xe/L38zwCuhpf2Uk/Zo50kmwJKIdogDjw1VzzeL35e/meAVp1LTgqY4nn+mRauzqmqwrjzCLL3fHytz1E+upLL+Qj5W56jfXWRnroYKLtekKEFF2vSFQg9hSSe0flPPWosm/hIfoLzVl5PaPynnrRWb/w0X0F5q06XqlyM2sVYx5gmbFre/t71NY2T+0h8VbSO5SWNJUOKSAMp7jDGspmMPaLRlXS6eWve1/FRO7WYdbZm1Y/eW/R7qHxHRXGojlm3ulid6aVbaW+OALvgCLq2Hm9WxHKWqjhj6xsK1e8dm15l4niG1LZkswGsxtrPeOmsvayBJA1VItlWjptLuTdPMo7LtjRDq9naK4+WF9IrUW7BaHOljGqVHB7w2hzVoZt87d8vaNYSLl02CcRsDEbJbj71Uu7UBkvJ7/D7q2QoDxySaAO8MTXdxRVMpRp5XZOWdF/ms7R5XdyKfKWJsO/5PhrG5XlNxmEywW6bTnTxAAcJNbGSMXkM1pjgbiNo1PziPJ+Os7u7m/6ReM00ZOgxSpqYYHT3wRXMKN4ll9zUG4bQfNshu8sZVuEA2hirA4qe/VOwwrVbzbww5mI44UKRRYkbWG0S3JWctbd7u5WFfOOLHiUdJqmaipfLsIsObhWe001lMkMVvJNjhghIALMcBxCs7fxXQmkupx1bXDswGPlaTidVaEyKNXkoo4eBV+Sq7L7Vs9zcBgeyQ4GQ/MB1crmoim2orezqcowTuSeEY48jQ7oZX2PLzdyLhNd6RjrEY6I7+uspvH78vfzPAK6UAAAFGAGgAcArmu8Xvy9/M8ArTfio24RW5nnaG67uou3H/KPuqT2X8hHytz1G+upLL3enK3PUb66ys9RDBRdr0hQgou06QqEGUkntH5Tz1e238vF9BeaqKT2j8p56vbb+Xi+gvNWjTdUuRn1XTHmTh8KrJTJlt8t1CPIY44cGnpJVjTJYkmjaN9Ib4u7V923njTethRauZJV3PaW1rfLIiXEDYg6R4VYc9CXW7thfOZbKdbGZtLW8uPVY/u3GrkNUkM9zlcxUjbhfWOA90cRq4gv4LhdqN+VToNYWmnRm9NNVWNTyHc6VWBv8wt4YeHqm6xyPmroq1Z7WGFLSxTq7WLSuPSdjrkfumq5yHXDUeA92oO2SKpVumNAaoJLMXH3myp0rpJ4uKhc3tbDM5BMri1zAj79j7KTiY8TcdBpcsith0286o+sPCagEX9Pzg4zXUCp6QYse8oouCG3tk6m1BYv05W6T+IdyolxbHDAAa2OgDlNCz3ryN2WxBd5PJMg1t81eId2ukqnLlTBbfcuY+9uJLiRcvtPvHdsHK+cfRHcHDWsyawjyy0WBcDI3lTP6TeIcFV+S5OmXx9bJg1048o8Cj0V8Jq2DVu09nL80up7OxHi+oal3P8AXB/IsZS8T/YOV65zvCcc7vfzPAK3ivWCz445zeH954BXOr6I8yfSfyz+jvCLP3fHytz1G+upLP3fHytz1E+usbPaQ0UXadIUIKLtekKhB7Ckk9o/Keer22/l4/oLzVRSe0flPPV7b/y8X0F5q0abqlyM+q6Y8yQsBTDMor1o8aiaE1pbluMqS3sbLLHIhSRQyngqukhaJ9uBjo+H5aOa3ao2t34qouRlLajTalGP8v0IY8ylXQ+PKPFU/bYXOLPge6CKia0LaxTOxHu1Q7cuBd9yPEJ7TbjXKO8CajbMIF6CNIeNvJHjqIWJ7tSpYkalqVblwIdyG+RGXur0hXYJFxal+Dhq5y3slkv3Y2pD0pTr+QUClpJRUdo9XW4OLrTHtM16cZLLWkeC7y4jvlNEpcRtw1Ux27Ci448NZrTFy3nn3IQWxlgGrDZ3pza7/M8ArZo+ArF5171uvp+CqdV0R5l/psUrs2vB3hdl7vTlbnqJ9dS2Xu+PlbnqJ9dY2eshooq16QoQUXa9IVCD2FLJ7RuU89WNtmUSQqkgYMgw0accKrpPaPynnrZWG4Vi+VWmY5tnMWXG+XrIYnA0rhj0mdcTgdNdwnKDqjmduM1SRR/qlr8/4KX6pa8T/BVzDuLZXudRZblmbxXcPUNPc3KqCIwrbOzgrHEnHjoyD+3eSXkht7DeKG4umDGOJVUklfouThXfmbnZ7Cvy1vt9pmv1W1+d8FL9VteJvgq5yrcOGfLmzHN80iyyETPbptAEFo2ZG8pmUa1OFNn3Ky6W/sbDKM5hv5bx2WTZA+7RF2y52WOPJTzE+z2Dy1vt9pT/AKpacTerS/U7Tib1a04/t7kDXPY03jhN0W6sQ7K7W3q2dnrMccaDy/8At80kuZfqWYxWNtlcvUPPhiGYhWDeUy7IwYU8xPs9g8tb7faUn6pacTerTxm9oOBvVq3v9z927aynuId44LiWKNnjhAXF2UYhRg516qpsryjLr21665zFLSTaK9U2GOA87SwqY37knRU+BzOzags0s1Oyr+BKM6sxwP6tSDPLMen6vy0rvdm3Sxlu7K/S7WDDrFUDUTxgnTU826eXW7KlxmqQuwDBXUKcD+1Xee/wXuKX5XDGWLapSVcOyhEM/seJ/V+WnjeGx4pPV+Wkm6kKZlFay3Jlt7iFpYZY8ASVK6DjtDDA0f8A0Tl340/1f8Ndx8xJVWXB0KbktFFpNzdVXAC/qOwA0CQni2flrO3Vwbm5lnI2TKxbDirX/wBE5d+NcfV/wVR7xZPa5U9utvI8nWhmbbw0YEAYYAVxfhfy5rlKR4Fulu6X7mW1mzT8S4Yis/5CPlbnqJ9dSWfu9OVueon11mZvQ2i7XpChKKtekKhBlNJ7R+U89bDfGTb3a3ZX0Lcj6kdY+T2j8p560288m1kWQr6MJ+ylSAr+2cnV5renjs3H1loX+3j9XvbbtxLN9lqW4UnV5jdnjtXHxihtyZNjeSBu5J9k1BJe7xy7W5CJ/wCzuD/mTVTf2+fq97LJuLrPsNRueS7W6aJ/38x+vLVXuY+xvHaNxbf2GoCezf8A36j/APsSf8w1sLnqczTefJluYoLm5uo5F61sBshItP1cNFYe1f8A3ir/APfE/wCZUe9bB94r5jwuPsrQFhmG4l/Z2M17HdW90tuu3IkTHaCjWdIw0VVZdks9/C06yJFEp2dp+E1bbqybGTZ8vpQD7L1XRv8A7blT96Oda7tpNuuNE37Cq9KSisjyuUoxrStKllHbLlWTXsMs8chuSuwEPDqwoLe5y+YRE/gLzmqRekvKKtd4327yM/ulHxmrHJStySWVRyrjxKI2XC/CTlnlPPKTpTdFbP0L1bgrf5Lp0G3dPhQHwV0S1lzBsns3sESR8Crh9WAJGjSOKuU3E+zdZQ3oJh8IArdZXFDmOTpHa3i2+YrI2KtKy4ricBsBuHHgFXSo440+Wa2qqxjvM9uMoy+WvzWpLCWWWE28HxL6e43ojgkeSCBY1Ri5BGIUDT51cl3vm276BBqSEH4WbxV0tlkyXJcxTMb+OW6uY9mGHrCzDQwwAbTp2uKuTZ9N1uYsfRRR8WPhrm419mSSjRyiqxVK7y23B/ftuTm2oSdJyzNVw3BFn7vTlbnqF9dS2fu9OVueon11lZuQ2iLdsGFD05H2dNQGV0ntG5Tz1dWm9N1b2kVq8EVwsI2UaQaQOKhmitZGLOmk68DhSFvY+gfWNSAg7z3Qvo7yKCKIohiaNR5LKxx8qpxvjcqS0VpbxvwOAcRQPZ7D0G9Y0uz2HoH1jUCpLY7zXlpbm3eKO5QuzjrBqZji3x17PvNcyT288VvDBJbMWUovS2hslW7mFQ9nsPQPrGl2ew9A+saCod/WNxtbYsrfb17WBxx5ddD2281xC88klvDcSXEnWuzrqOGGC9zRUPZ7D0G9Y0uzWHoH1jQVCLreq6ntZbaO3it1mGy7RjTs1X2mYy20ZiCq8ZOODcdEdmsPQb1jS7PYegfWNdJuLqnQiSUlRqpFLmryxtH1Ma7Qw2gNNPOdSt0oI27p007s9h6B9Y0uz2HoH1jXX3Z+I4+1b8IJdX89xLHKQFMXQUahpxoiPN5P+onfU+A0/s9h6DesaXZ7D0D6xpG7OLbUtu0StW5JJx2bBsmbtiSiEk+cxoCWWSaVpZOk2vDVo0VYdnsPQb1jSNvZcCH1jSd2c+p1XAmFqEOmOPEfaH+BQd1ueo211IzrgFUYKNAAqI1WztCpUqVCRUqVKgFSpUqAVKlSoBUqVKgFSpUqAVKlSoBUqVKgFSpUqAVKlSoD/9k\x3d";
var cc = cc || {}, ClassManager = {id: 0 | 998 * Math.random(), instanceId: 0 | 998 * Math.random(), compileSuper: function (a, b, c) {
    a = a.toString();
    var d = a.indexOf("("), e = a.indexOf(")"), d = a.substring(d + 1, e), d = d.trim(), e = a.indexOf("{"), f = a.lastIndexOf("}");
    for (a = a.substring(e + 1, f); -1 != a.indexOf("this._super");) {
        var e = a.indexOf("this._super"), f = a.indexOf("(", e), g = a.indexOf(")", f), g = a.substring(f + 1, g), g = (g = g.trim()) ? "," : "";
        a = a.substring(0, e) + "ClassManager[" + c + "]." + b + ".call(this" + g + a.substring(f + 1)
    }
    return Function(d, a)
}, getNewID: function () {
    return this.id++
},
    getNewInstanceId: function () {
        return this.instanceId++
    }};
ClassManager.compileSuper.ClassManager = ClassManager;
(function () {
    var a = /\b_super\b/, b = cc.game.config[cc.game.CONFIG_KEY.classReleaseMode];
    b && console.log("release Mode");
    cc.Class = function () {
    };
    cc.Class.extend = function (c) {
        function d() {
            this.__instanceId = ClassManager.getNewInstanceId();
            this.ctor && this.ctor.apply(this, arguments)
        }

        var e = this.prototype, f = Object.create(e), g = ClassManager.getNewID();
        ClassManager[g] = e;
        var h = {writable: !0, enumerable: !1, configurable: !0};
        f.__instanceId = null;
        d.id = g;
        h.value = g;
        Object.defineProperty(f, "__pid", h);
        d.prototype = f;
        h.value = d;
        Object.defineProperty(d.prototype, "constructor", h);
        this.__getters__ && (d.__getters__ = cc.clone(this.__getters__));
        this.__setters__ && (d.__setters__ = cc.clone(this.__setters__));
        for (var k = 0, l = arguments.length; k < l; ++k) {
            var m = arguments[k], n;
            for (n in m) {
                var q = "function" === typeof m[n], r = "function" === typeof e[n], t = a.test(m[n]);
                b && q && r && t ? (h.value = ClassManager.compileSuper(m[n], n, g), Object.defineProperty(f, n, h)) : q && r && t ? (h.value = function (a, b) {
                    return function () {
                        var c = this._super;
                        this._super = e[a];
                        var d = b.apply(this,
                            arguments);
                        this._super = c;
                        return d
                    }
                }(n, m[n]), Object.defineProperty(f, n, h)) : q ? (h.value = m[n], Object.defineProperty(f, n, h)) : f[n] = m[n];
                if (q) {
                    var s, v;
                    if (this.__getters__ && this.__getters__[n]) {
                        var q = this.__getters__[n], u;
                        for (u in this.__setters__)if (this.__setters__[u] == q) {
                            v = u;
                            break
                        }
                        cc.defineGetterSetter(f, q, m[n], m[v] ? m[v] : f[v], n, v)
                    }
                    if (this.__setters__ && this.__setters__[n]) {
                        q = this.__setters__[n];
                        for (u in this.__getters__)if (this.__getters__[u] == q) {
                            s = u;
                            break
                        }
                        cc.defineGetterSetter(f, q, m[s] ? m[s] : f[s], m[n],
                            s, n)
                    }
                }
            }
        }
        d.extend = cc.Class.extend;
        d.implement = function (a) {
            for (var b in a)f[b] = a[b]
        };
        return d
    };
    Function.prototype.bind = Function.prototype.bind || function (a) {
        var b = this;
        return function () {
            var e = Array.prototype.slice.call(arguments);
            return b.apply(a || null, e)
        }
    }
})();
cc.defineGetterSetter = function (a, b, c, d, e, f) {
    if (a.__defineGetter__)c && a.__defineGetter__(b, c), d && a.__defineSetter__(b, d); else if (Object.defineProperty) {
        var g = {enumerable: !1, configurable: !0};
        c && (g.get = c);
        d && (g.set = d);
        Object.defineProperty(a, b, g)
    } else throw Error("browser does not support getters");
    if (!e && !f)for (var g = null != c, h = void 0 != d, k = Object.getOwnPropertyNames(a), l = 0; l < k.length; l++) {
        var m = k[l];
        if (!((a.__lookupGetter__ ? a.__lookupGetter__(m) : Object.getOwnPropertyDescriptor(a, m)) || "function" !== typeof a[m])) {
            var n =
                a[m];
            if (g && n === c && (e = m, !h || f))break;
            if (h && n === d && (f = m, !g || e))break
        }
    }
    a = a.constructor;
    e && (a.__getters__ || (a.__getters__ = {}), a.__getters__[e] = b);
    f && (a.__setters__ || (a.__setters__ = {}), a.__setters__[f] = b)
};
cc.clone = function (a) {
    var b = a.constructor ? new a.constructor : {}, c;
    for (c in a) {
        var d = a[c];
        b[c] = "object" == typeof d && d && !(d instanceof cc.Node) && !(d instanceof HTMLElement) ? cc.clone(d) : d
    }
    return b
};
cc.Point = function (a, b) {
    this.x = a || 0;
    this.y = b || 0
};
cc.p = function (a, b) {
    return void 0 == a ? {x: 0, y: 0} : void 0 == b ? {x: a.x, y: a.y} : {x: a, y: b}
};
cc.pointEqualToPoint = function (a, b) {
    return a && b && a.x === b.x && a.y === b.y
};
cc.Size = function (a, b) {
    this.width = a || 0;
    this.height = b || 0
};
cc.size = function (a, b) {
    return void 0 === a ? {width: 0, height: 0} : void 0 === b ? {width: a.width, height: a.height} : {width: a, height: b}
};
cc.sizeEqualToSize = function (a, b) {
    return a && b && a.width == b.width && a.height == b.height
};
cc.Rect = function (a, b, c, d) {
    this.x = a || 0;
    this.y = b || 0;
    this.width = c || 0;
    this.height = d || 0
};
cc.rect = function (a, b, c, d) {
    return void 0 === a ? {x: 0, y: 0, width: 0, height: 0} : void 0 === b ? {x: a.x, y: a.y, width: a.width, height: a.height} : {x: a, y: b, width: c, height: d}
};
cc.rectEqualToRect = function (a, b) {
    return a && b && a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height
};
cc._rectEqualToZero = function (a) {
    return a && 0 === a.x && 0 === a.y && 0 === a.width && 0 === a.height
};
cc.rectContainsRect = function (a, b) {
    return!a || !b ? !1 : !(a.x >= b.x || a.y >= b.y || a.x + a.width <= b.x + b.width || a.y + a.height <= b.y + b.height)
};
cc.rectGetMaxX = function (a) {
    return a.x + a.width
};
cc.rectGetMidX = function (a) {
    return a.x + a.width / 2
};
cc.rectGetMinX = function (a) {
    return a.x
};
cc.rectGetMaxY = function (a) {
    return a.y + a.height
};
cc.rectGetMidY = function (a) {
    return a.y + a.height / 2
};
cc.rectGetMinY = function (a) {
    return a.y
};
cc.rectContainsPoint = function (a, b) {
    return b.x >= cc.rectGetMinX(a) && b.x <= cc.rectGetMaxX(a) && b.y >= cc.rectGetMinY(a) && b.y <= cc.rectGetMaxY(a)
};
cc.rectIntersectsRect = function (a, b) {
    var c = a.y + a.height, d = b.x + b.width, e = b.y + b.height;
    return!(a.x + a.width < b.x || d < a.x || c < b.y || e < a.y)
};
cc.rectOverlapsRect = function (a, b) {
    return!(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y)
};
cc.rectUnion = function (a, b) {
    var c = cc.rect(0, 0, 0, 0);
    c.x = Math.min(a.x, b.x);
    c.y = Math.min(a.y, b.y);
    c.width = Math.max(a.x + a.width, b.x + b.width) - c.x;
    c.height = Math.max(a.y + a.height, b.y + b.height) - c.y;
    return c
};
cc.rectIntersection = function (a, b) {
    var c = cc.rect(Math.max(cc.rectGetMinX(a), cc.rectGetMinX(b)), Math.max(cc.rectGetMinY(a), cc.rectGetMinY(b)), 0, 0);
    c.width = Math.min(cc.rectGetMaxX(a), cc.rectGetMaxX(b)) - cc.rectGetMinX(c);
    c.height = Math.min(cc.rectGetMaxY(a), cc.rectGetMaxY(b)) - cc.rectGetMinY(c);
    return c
};
cc.visibleRect = {topLeft: cc.p(0, 0), topRight: cc.p(0, 0), top: cc.p(0, 0), bottomLeft: cc.p(0, 0), bottomRight: cc.p(0, 0), bottom: cc.p(0, 0), center: cc.p(0, 0), left: cc.p(0, 0), right: cc.p(0, 0), width: 0, height: 0, init: function (a) {
    var b = this.width = a.width, c = this.height = a.height, d = a.x;
    a = a.y;
    var e = a + c, f = d + b;
    this.topLeft.x = d;
    this.topLeft.y = e;
    this.topRight.x = f;
    this.topRight.y = e;
    this.top.x = d + b / 2;
    this.top.y = e;
    this.bottomLeft.x = d;
    this.bottomLeft.y = a;
    this.bottomRight.x = f;
    this.bottomRight.y = a;
    this.bottom.x = d + b / 2;
    this.bottom.y =
        a;
    this.center.x = d + b / 2;
    this.center.y = a + c / 2;
    this.left.x = d;
    this.left.y = a + c / 2;
    this.right.x = f;
    this.right.y = a + c / 2
}};
cc.SAXParser = cc.Class.extend({_parser: null, _isSupportDOMParser: null, ctor: function () {
    window.DOMParser ? (this._isSupportDOMParser = !0, this._parser = new DOMParser) : this._isSupportDOMParser = !1
}, parse: function (a) {
    return this._parseXML(a)
}, _parseXML: function (a) {
    var b;
    this._isSupportDOMParser ? b = this._parser.parseFromString(a, "text/xml") : (b = new ActiveXObject("Microsoft.XMLDOM"), b.async = "false", b.loadXML(a));
    return b
}});
cc.PlistParser = cc.SAXParser.extend({parse: function (a) {
    a = this._parseXML(a).documentElement;
    if ("plist" != a.tagName)throw"Not a plist file!";
    for (var b = null, c = 0, d = a.childNodes.length; c < d && !(b = a.childNodes[c], 1 == b.nodeType); c++);
    return this._parseNode(b)
}, _parseNode: function (a) {
    var b = null, c = a.tagName;
    if ("dict" == c)b = this._parseDict(a); else if ("array" == c)b = this._parseArray(a); else if ("string" == c)if (1 == a.childNodes.length)b = a.firstChild.nodeValue; else {
        b = "";
        for (c = 0; c < a.childNodes.length; c++)b += a.childNodes[c].nodeValue
    } else"false" ==
    c ? b = !1 : "true" == c ? b = !0 : "real" == c ? b = parseFloat(a.firstChild.nodeValue) : "integer" == c && (b = parseInt(a.firstChild.nodeValue, 10));
    return b
}, _parseArray: function (a) {
    for (var b = [], c = 0, d = a.childNodes.length; c < d; c++) {
        var e = a.childNodes[c];
        1 == e.nodeType && b.push(this._parseNode(e))
    }
    return b
}, _parseDict: function (a) {
    for (var b = {}, c = null, d = 0, e = a.childNodes.length; d < e; d++) {
        var f = a.childNodes[d];
        1 == f.nodeType && ("key" == f.tagName ? c = f.firstChild.nodeValue : b[c] = this._parseNode(f))
    }
    return b
}});
cc._txtLoader = {load: function (a, b, c, d) {
    cc.loader.loadTxt(a, d)
}};
cc.loader.register(["txt", "xml", "vsh", "fsh", "atlas"], cc._txtLoader);
cc._jsonLoader = {load: function (a, b, c, d) {
    cc.loader.loadJson(a, d)
}};
cc.loader.register(["json", "ExportJson"], cc._jsonLoader);
cc._imgLoader = {load: function (a, b, c, d) {
    cc.loader.cache[b] = cc.loader.loadImg(a, function (a, c) {
        if (a)return d(a);
        cc.textureCache.handleLoadedTexture(b);
        d(null, c)
    })
}};
cc.loader.register("png jpg bmp jpeg gif ico".split(" "), cc._imgLoader);
cc._serverImgLoader = {load: function (a, b, c, d) {
    cc.loader.cache[b] = cc.loader.loadImg(c.src, function (a, c) {
        if (a)return d(a);
        cc.textureCache.handleLoadedTexture(b);
        d(null, c)
    })
}};
cc.loader.register(["serverImg"], cc._serverImgLoader);
cc._plistLoader = {load: function (a, b, c, d) {
    cc.loader.loadTxt(a, function (a, b) {
        if (a)return d(a);
        d(null, cc.plistParser.parse(b))
    })
}};
cc.loader.register(["plist"], cc._plistLoader);
cc._fontLoader = {TYPE: {".eot": "embedded-opentype", ".ttf": "truetype", ".woff": "woff", ".svg": "svg"}, _loadFont: function (a, b, c) {
    var d = document, e = cc.path, f = this.TYPE, g = cc.newElement("style");
    g.type = "text/css";
    d.body.appendChild(g);
    var h = "@font-face { font-family:" + a + "; src:";
    if (b instanceof Array)for (var k = 0, l = b.length; k < l; k++)c = e.extname(b[k]).toLowerCase(), h += "url('" + b[k] + "') format('" + f[c] + "')", h += k == l - 1 ? ";" : ","; else h += "url('" + b + "') format('" + f[c] + "');";
    g.textContent += h + "};";
    b = cc.newElement("div");
    c =
        b.style;
    c.fontFamily = a;
    b.innerHTML = ".";
    c.position = "absolute";
    c.left = "-100px";
    c.top = "-100px";
    d.body.appendChild(b)
}, load: function (a, b, c, d) {
    b = c.type;
    a = c.name;
    b = c.srcs;
    "string" == typeof c ? (b = cc.path.extname(c), a = cc.path.basename(c, b), this._loadFont(a, c, b)) : this._loadFont(a, b);
    d(null, !0)
}};
cc.loader.register(["font", "eot", "ttf", "woff", "svg"], cc._fontLoader);
cc._binaryLoader = {load: function (a, b, c, d) {
    cc.loader.loadBinary(a, d)
}};
window.CocosEngine = cc.ENGINE_VERSION = "Cocos2d-html5 v3.0 RC0";
cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL = 0;
cc.DIRECTOR_STATS_POSITION = cc.p(0, 0);
cc.DIRECTOR_FPS_INTERVAL = 0.5;
cc.COCOSNODE_RENDER_SUBPIXEL = 1;
cc.SPRITEBATCHNODE_RENDER_SUBPIXEL = 1;
cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA = 0;
cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP = 0;
cc.TEXTURE_ATLAS_USE_VAO = 0;
cc.TEXTURE_NPOT_SUPPORT = 0;
cc.RETINA_DISPLAY_SUPPORT = 1;
cc.RETINA_DISPLAY_FILENAME_SUFFIX = "-hd";
cc.USE_LA88_LABELS = 1;
cc.SPRITE_DEBUG_DRAW = 0;
cc.SPRITEBATCHNODE_DEBUG_DRAW = 0;
cc.LABELBMFONT_DEBUG_DRAW = 0;
cc.LABELATLAS_DEBUG_DRAW = 0;
cc.IS_RETINA_DISPLAY_SUPPORTED = 1;
cc.DEFAULT_ENGINE = cc.ENGINE_VERSION + "-canvas";
cc.ENABLE_STACKABLE_ACTIONS = 1;
cc.ENABLE_GL_STATE_CACHE = 1;
cc.$ = function (a) {
    var b = this == cc ? document : this;
    if (a = a instanceof HTMLElement ? a : b.querySelector(a))a.find = a.find || cc.$, a.hasClass = a.hasClass || function (a) {
        return this.className.match(RegExp("(\\s|^)" + a + "(\\s|$)"))
    }, a.addClass = a.addClass || function (a) {
        this.hasClass(a) || (this.className && (this.className += " "), this.className += a);
        return this
    }, a.removeClass = a.removeClass || function (a) {
        this.hasClass(a) && (this.className = this.className.replace(a, ""));
        return this
    }, a.remove = a.remove || function () {
        this.parentNode &&
        this.parentNode.removeChild(this);
        return this
    }, a.appendTo = a.appendTo || function (a) {
        a.appendChild(this);
        return this
    }, a.prependTo = a.prependTo || function (a) {
        a.childNodes[0] ? a.insertBefore(this, a.childNodes[0]) : a.appendChild(this);
        return this
    }, a.transforms = a.transforms || function () {
        this.style[cc.$.trans] = cc.$.translate(this.position) + cc.$.rotate(this.rotation) + cc.$.scale(this.scale) + cc.$.skew(this.skew);
        return this
    }, a.position = a.position || {x: 0, y: 0}, a.rotation = a.rotation || 0, a.scale = a.scale || {x: 1, y: 1}, a.skew =
        a.skew || {x: 0, y: 0}, a.translates = function (a, b) {
        this.position.x = a;
        this.position.y = b;
        this.transforms();
        return this
    }, a.rotate = function (a) {
        this.rotation = a;
        this.transforms();
        return this
    }, a.resize = function (a, b) {
        this.scale.x = a;
        this.scale.y = b;
        this.transforms();
        return this
    }, a.setSkew = function (a, b) {
        this.skew.x = a;
        this.skew.y = b;
        this.transforms();
        return this
    };
    return a
};
switch (cc.sys.browserType) {
    case cc.sys.BROWSER_TYPE_FIREFOX:
        cc.$.pfx = "Moz";
        cc.$.hd = !0;
        break;
    case cc.sys.BROWSER_TYPE_CHROME:
    case cc.sys.BROWSER_TYPE_SAFARI:
        cc.$.pfx = "webkit";
        cc.$.hd = !0;
        break;
    case cc.sys.BROWSER_TYPE_OPERA:
        cc.$.pfx = "O";
        cc.$.hd = !1;
        break;
    case cc.sys.BROWSER_TYPE_IE:
        cc.$.pfx = "ms";
        cc.$.hd = !1;
        break;
    default:
        cc.$.pfx = "webkit", cc.$.hd = !0
}
cc.$.trans = cc.$.pfx + "Transform";
cc.$.translate = cc.$.hd ? function (a) {
    return"translate3d(" + a.x + "px, " + a.y + "px, 0) "
} : function (a) {
    return"translate(" + a.x + "px, " + a.y + "px) "
};
cc.$.rotate = cc.$.hd ? function (a) {
    return"rotateZ(" + a + "deg) "
} : function (a) {
    return"rotate(" + a + "deg) "
};
cc.$.scale = function (a) {
    return"scale(" + a.x + ", " + a.y + ") "
};
cc.$.skew = function (a) {
    return"skewX(" + -a.x + "deg) skewY(" + a.y + "deg)"
};
cc.$new = function (a) {
    return cc.$(document.createElement(a))
};
cc.$.findpos = function (a) {
    var b = 0, c = 0;
    do b += a.offsetLeft, c += a.offsetTop; while (a = a.offsetParent);
    return{x: b, y: c}
};
cc.INVALID_INDEX = -1;
cc.PI = Math.PI;
cc.FLT_MAX = parseFloat("3.402823466e+38F");
cc.FLT_MIN = parseFloat("1.175494351e-38F");
cc.RAD = cc.PI / 180;
cc.DEG = 180 / cc.PI;
cc.UINT_MAX = 4294967295;
cc.swap = function (a, b, c) {
    if ("object" == typeof c && "undefined" != typeof c.x && "undefined" != typeof c.y) {
        var d = c[a];
        c[a] = c[b];
        c[b] = d
    } else cc.log(cc._LogInfos.swap)
};
cc.lerp = function (a, b, c) {
    return a + (b - a) * c
};
cc.rand = function () {
    return 16777215 * Math.random()
};
cc.randomMinus1To1 = function () {
    return 2 * (Math.random() - 0.5)
};
cc.random0To1 = Math.random;
cc.degreesToRadians = function (a) {
    return a * cc.RAD
};
cc.radiansToDegrees = function (a) {
    return a * cc.DEG
};
cc.radiansToDegress = function (a) {
    cc.log(cc._LogInfos.radiansToDegress);
    return a * cc.DEG
};
cc.REPEAT_FOREVER = Number.MAX_VALUE - 1;
cc.BLEND_SRC = cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA ? 1 : 770;
cc.BLEND_DST = 771;
cc.nodeDrawSetup = function (a) {
    a._shaderProgram && (a._shaderProgram.use(), a._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4())
};
cc.enableDefaultGLStates = function () {
};
cc.disableDefaultGLStates = function () {
};
cc.incrementGLDraws = function (a) {
    cc.g_NumberOfDraws += a
};
cc.FLT_EPSILON = 1.192092896E-7;
cc.contentScaleFactor = cc.IS_RETINA_DISPLAY_SUPPORTED ? function () {
    return cc.director.getContentScaleFactor()
} : function () {
    return 1
};
cc.pointPointsToPixels = function (a) {
    var b = cc.contentScaleFactor();
    return cc.p(a.x * b, a.y * b)
};
cc.pointPixelsToPoints = function (a) {
    var b = cc.contentScaleFactor();
    return cc.p(a.x / b, a.y / b)
};
cc._pointPixelsToPointsOut = function (a, b) {
    var c = cc.contentScaleFactor();
    b.x = a.x / c;
    b.y = a.y / c
};
cc.sizePointsToPixels = function (a) {
    var b = cc.contentScaleFactor();
    return cc.size(a.width * b, a.height * b)
};
cc.sizePixelsToPoints = function (a) {
    var b = cc.contentScaleFactor();
    return cc.size(a.width / b, a.height / b)
};
cc._sizePixelsToPointsOut = function (a, b) {
    var c = cc.contentScaleFactor();
    b.width = a.width / c;
    b.height = a.height / c
};
cc.rectPixelsToPoints = cc.IS_RETINA_DISPLAY_SUPPORTED ? function (a) {
    var b = cc.contentScaleFactor();
    return cc.rect(a.x / b, a.y / b, a.width / b, a.height / b)
} : function (a) {
    return a
};
cc.rectPointsToPixels = cc.IS_RETINA_DISPLAY_SUPPORTED ? function (a) {
    var b = cc.contentScaleFactor();
    return cc.rect(a.x * b, a.y * b, a.width * b, a.height * b)
} : function (a) {
    return a
};
cc.ONE = 1;
cc.ZERO = 0;
cc.SRC_ALPHA = 770;
cc.SRC_ALPHA_SATURATE = 776;
cc.SRC_COLOR = 768;
cc.DST_ALPHA = 772;
cc.DST_COLOR = 774;
cc.ONE_MINUS_SRC_ALPHA = 771;
cc.ONE_MINUS_SRC_COLOR = 769;
cc.ONE_MINUS_DST_ALPHA = 773;
cc.ONE_MINUS_DST_COLOR = 775;
cc.ONE_MINUS_CONSTANT_ALPHA = 32772;
cc.ONE_MINUS_CONSTANT_COLOR = 32770;
cc.checkGLErrorDebug = function () {
    if (cc.renderMode == cc._RENDER_TYPE_WEBGL) {
        var a = cc._renderContext.getError();
        a && cc.log(CC._localZOrder.checkGLErrorDebug, a)
    }
};
cc.DEVICE_ORIENTATION_PORTRAIT = 0;
cc.DEVICE_ORIENTATION_LANDSCAPE_LEFT = 1;
cc.DEVICE_ORIENTATION_PORTRAIT_UPSIDE_DOWN = 2;
cc.DEVICE_ORIENTATION_LANDSCAPE_RIGHT = 3;
cc.DEVICE_MAX_ORIENTATIONS = 2;
cc.VERTEX_ATTRIB_FLAG_NONE = 0;
cc.VERTEX_ATTRIB_FLAG_POSITION = 1;
cc.VERTEX_ATTRIB_FLAG_COLOR = 2;
cc.VERTEX_ATTRIB_FLAG_TEX_COORDS = 4;
cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX = cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS;
cc.GL_ALL = 0;
cc.VERTEX_ATTRIB_POSITION = 0;
cc.VERTEX_ATTRIB_COLOR = 1;
cc.VERTEX_ATTRIB_TEX_COORDS = 2;
cc.VERTEX_ATTRIB_MAX = 3;
cc.UNIFORM_PMATRIX = 0;
cc.UNIFORM_MVMATRIX = 1;
cc.UNIFORM_MVPMATRIX = 2;
cc.UNIFORM_TIME = 3;
cc.UNIFORM_SINTIME = 4;
cc.UNIFORM_COSTIME = 5;
cc.UNIFORM_RANDOM01 = 6;
cc.UNIFORM_SAMPLER = 7;
cc.UNIFORM_MAX = 8;
cc.SHADER_POSITION_TEXTURECOLOR = "ShaderPositionTextureColor";
cc.SHADER_POSITION_TEXTURECOLORALPHATEST = "ShaderPositionTextureColorAlphaTest";
cc.SHADER_POSITION_COLOR = "ShaderPositionColor";
cc.SHADER_POSITION_TEXTURE = "ShaderPositionTexture";
cc.SHADER_POSITION_TEXTURE_UCOLOR = "ShaderPositionTexture_uColor";
cc.SHADER_POSITION_TEXTUREA8COLOR = "ShaderPositionTextureA8Color";
cc.SHADER_POSITION_UCOLOR = "ShaderPosition_uColor";
cc.SHADER_POSITION_LENGTHTEXTURECOLOR = "ShaderPositionLengthTextureColor";
cc.UNIFORM_PMATRIX_S = "CC_PMatrix";
cc.UNIFORM_MVMATRIX_S = "CC_MVMatrix";
cc.UNIFORM_MVPMATRIX_S = "CC_MVPMatrix";
cc.UNIFORM_TIME_S = "CC_Time";
cc.UNIFORM_SINTIME_S = "CC_SinTime";
cc.UNIFORM_COSTIME_S = "CC_CosTime";
cc.UNIFORM_RANDOM01_S = "CC_Random01";
cc.UNIFORM_SAMPLER_S = "CC_Texture0";
cc.UNIFORM_ALPHA_TEST_VALUE_S = "CC_alpha_value";
cc.ATTRIBUTE_NAME_COLOR = "a_color";
cc.ATTRIBUTE_NAME_POSITION = "a_position";
cc.ATTRIBUTE_NAME_TEX_COORD = "a_texCoord";
cc.ITEM_SIZE = 32;
cc.CURRENT_ITEM = 3233828865;
cc.ZOOM_ACTION_TAG = 3233828866;
cc.NORMAL_TAG = 8801;
cc.SELECTED_TAG = 8802;
cc.DISABLE_TAG = 8803;
cc._tmp.PrototypeColor = function () {
    var a = cc.color;
    a._getWhite = function () {
        return a(255, 255, 255)
    };
    a._getYellow = function () {
        return a(255, 255, 0)
    };
    a._getBlue = function () {
        return a(0, 0, 255)
    };
    a._getGreen = function () {
        return a(0, 255, 0)
    };
    a._getRed = function () {
        return a(255, 0, 0)
    };
    a._getMagenta = function () {
        return a(255, 0, 255)
    };
    a._getBlack = function () {
        return a(0, 0, 0)
    };
    a._getOrange = function () {
        return a(255, 127, 0)
    };
    a._getGray = function () {
        return a(166, 166, 166)
    };
    cc.defineGetterSetter(a, "WHITE", a._getWhite);
    cc.defineGetterSetter(a,
        "YELLOW", a._getYellow);
    cc.defineGetterSetter(a, "BLUE", a._getBlue);
    cc.defineGetterSetter(a, "GREEN", a._getGreen);
    cc.defineGetterSetter(a, "RED", a._getRed);
    cc.defineGetterSetter(a, "MAGENTA", a._getMagenta);
    cc.defineGetterSetter(a, "BLACK", a._getBlack);
    cc.defineGetterSetter(a, "ORANGE", a._getOrange);
    cc.defineGetterSetter(a, "GRAY", a._getGray)
};
cc.Color = function (a, b, c, d) {
    this.r = a || 0;
    this.g = b || 0;
    this.b = c || 0;
    this.a = d || 255
};
cc.color = function (a, b, c, d) {
    return void 0 === a ? {r: 0, g: 0, b: 0, a: 255} : "string" === typeof a ? cc.hexToColor(a) : "object" === typeof a ? {r: a.r, g: a.g, b: a.b, a: a.a || 255} : {r: a, g: b, b: c, a: d || 255}
};
cc.colorEqual = function (a, b) {
    return a.r === b.r && a.g === b.g && a.b === b.b
};
cc.Acceleration = function (a, b, c, d) {
    this.x = a || 0;
    this.y = b || 0;
    this.z = c || 0;
    this.timestamp = d || 0
};
cc.Vertex2F = function (a, b) {
    this.x = a || 0;
    this.y = b || 0
};
cc.vertex2 = function (a, b) {
    return new cc.Vertex2F(a, b)
};
cc.Vertex3F = function (a, b, c) {
    this.x = a || 0;
    this.y = b || 0;
    this.z = c || 0
};
cc.vertex3 = function (a, b, c) {
    return new cc.Vertex3F(a, b, c)
};
cc.Tex2F = function (a, b) {
    this.u = a || 0;
    this.v = b || 0
};
cc.tex2 = function (a, b) {
    return new cc.Tex2F(a, b)
};
cc.BlendFunc = function (a, b) {
    this.src = a;
    this.dst = b
};
cc.blendFuncDisable = function () {
    return new cc.BlendFunc(cc.ONE, cc.ZERO)
};
cc.hexToColor = function (a) {
    a = a.replace(/^#?/, "0x");
    a = parseInt(a);
    return cc.color(a >> 16, (a >> 8) % 256, a % 256)
};
cc.colorToHex = function (a) {
    var b = a.r.toString(16), c = a.g.toString(16), d = a.b.toString(16);
    return"#" + (16 > a.r ? "0" + b : b) + (16 > a.g ? "0" + c : c) + (16 > a.b ? "0" + d : d)
};
cc.TEXT_ALIGNMENT_LEFT = 0;
cc.TEXT_ALIGNMENT_CENTER = 1;
cc.TEXT_ALIGNMENT_RIGHT = 2;
cc.VERTICAL_TEXT_ALIGNMENT_TOP = 0;
cc.VERTICAL_TEXT_ALIGNMENT_CENTER = 1;
cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM = 2;
cc._Dictionary = cc.Class.extend({_keyMapTb: null, _valueMapTb: null, __currId: 0, ctor: function () {
    this._keyMapTb = {};
    this._valueMapTb = {};
    this.__currId = 2 << (0 | 10 * Math.random())
}, __getKey: function () {
    this.__currId++;
    return"key_" + this.__currId
}, setObject: function (a, b) {
    if (null != b) {
        var c = this.__getKey();
        this._keyMapTb[c] = b;
        this._valueMapTb[c] = a
    }
}, objectForKey: function (a) {
    if (null == a)return null;
    var b = this._keyMapTb, c;
    for (c in b)if (b[c] === a)return this._valueMapTb[c];
    return null
}, valueForKey: function (a) {
    return this.objectForKey(a)
},
    removeObjectForKey: function (a) {
        if (null != a) {
            var b = this._keyMapTb, c;
            for (c in b)if (b[c] === a) {
                delete this._valueMapTb[c];
                delete b[c];
                break
            }
        }
    }, removeObjectsForKeys: function (a) {
        if (null != a)for (var b = 0; b < a.length; b++)this.removeObjectForKey(a[b])
    }, allKeys: function () {
        var a = [], b = this._keyMapTb, c;
        for (c in b)a.push(b[c]);
        return a
    }, removeAllObjects: function () {
        this._keyMapTb = {};
        this._valueMapTb = {}
    }, count: function () {
        return this.allKeys().length
    }});
cc.FontDefinition = function () {
    this.fontName = "Arial";
    this.fontSize = 12;
    this.textAlign = cc.TEXT_ALIGNMENT_CENTER;
    this.verticalAlign = cc.VERTICAL_TEXT_ALIGNMENT_TOP;
    this.fillStyle = cc.color(255, 255, 255, 255);
    this.boundingHeight = this.boundingWidth = 0;
    this.strokeEnabled = !1;
    this.strokeStyle = cc.color(255, 255, 255, 255);
    this.lineWidth = 1;
    this.shadowEnabled = !1;
    this.shadowBlur = this.shadowOffsetY = this.shadowOffsetX = 0;
    this.shadowOpacity = 1
};
cc._renderType === cc._RENDER_TYPE_WEBGL && (cc.assert("function" === typeof cc._tmp.WebGLColor, cc._LogInfos.MissingFile, "CCTypesWebGL.js"), cc._tmp.WebGLColor(), delete cc._tmp.WebGLColor);
cc.assert("function" === typeof cc._tmp.PrototypeColor, cc._LogInfos.MissingFile, "CCTypesPropertyDefine.js");
cc._tmp.PrototypeColor();
delete cc._tmp.PrototypeColor;
cc.Touches = [];
cc.TouchesIntergerDict = {};
cc.EGLView = cc.Class.extend({_delegate: null, _frameSize: null, _designResolutionSize: null, _originalDesignResolutionSize: null, _viewPortRect: null, _visibleRect: null, _retinaEnabled: !1, _autoFullScreen: !0, _devicePixelRatio: 1, _viewName: "", _resizeCallback: null, _scaleX: 1, _originalScaleX: 1, _scaleY: 1, _originalScaleY: 1, _indexBitsUsed: 0, _maxTouches: 5, _resolutionPolicy: null, _rpExactFit: null, _rpShowAll: null, _rpNoBorder: null, _rpFixedHeight: null, _rpFixedWidth: null, _initialized: !1, _captured: !1, _wnd: null, _hDC: null, _hRC: null,
    _supportTouch: !1, _contentTranslateLeftTop: null, _frame: null, _frameZoomFactor: 1, __resizeWithBrowserSize: !1, _isAdjustViewPort: !0, ctor: function () {
        var a = document, b = cc.ContainerStrategy, c = cc.ContentStrategy;
        this._frame = cc.container.parentNode === a.body ? a.documentElement : cc.container.parentNode;
        this._frameSize = cc.size(0, 0);
        this._initFrameSize();
        var a = cc._canvas.width, d = cc._canvas.height;
        this._designResolutionSize = cc.size(a, d);
        this._originalDesignResolutionSize = cc.size(a, d);
        this._viewPortRect = cc.rect(0, 0,
            a, d);
        this._visibleRect = cc.rect(0, 0, a, d);
        this._contentTranslateLeftTop = {left: 0, top: 0};
        this._viewName = "Cocos2dHTML5";
        a = cc.sys;
        this.enableRetina(a.os == a.OS_IOS || a.os == a.OS_OSX);
        cc.visibleRect && cc.visibleRect.init(this._visibleRect);
        this._rpExactFit = new cc.ResolutionPolicy(b.EQUAL_TO_FRAME, c.EXACT_FIT);
        this._rpShowAll = new cc.ResolutionPolicy(b.PROPORTION_TO_FRAME, c.SHOW_ALL);
        this._rpNoBorder = new cc.ResolutionPolicy(b.EQUAL_TO_FRAME, c.NO_BORDER);
        this._rpFixedHeight = new cc.ResolutionPolicy(b.EQUAL_TO_FRAME,
            c.FIXED_HEIGHT);
        this._rpFixedWidth = new cc.ResolutionPolicy(b.EQUAL_TO_FRAME, c.FIXED_WIDTH);
        this._hDC = cc._canvas;
        this._hRC = cc._renderContext
    }, _resizeEvent: function () {
        var a = this._originalDesignResolutionSize.width, b = this._originalDesignResolutionSize.height;
        this._resizeCallback && (this._initFrameSize(), this._resizeCallback.call());
        0 < a && this.setDesignResolutionSize(a, b, this._resolutionPolicy)
    }, resizeWithBrowserSize: function (a) {
        a ? this.__resizeWithBrowserSize || (this.__resizeWithBrowserSize = !0, a = this._resizeEvent.bind(this),
            cc._addEventListener(window, "resize", a, !1)) : this.__resizeWithBrowserSize && (this.__resizeWithBrowserSize = !0, a = this._resizeEvent.bind(this), window.removeEventListener("resize", a, !1))
    }, setResizeCallback: function (a) {
        if ("function" == typeof a || null == a)this._resizeCallback = a
    }, _initFrameSize: function () {
        var a = this._frameSize;
        a.width = this._frame.clientWidth;
        a.height = this._frame.clientHeight
    }, _adjustSizeKeepCanvasSize: function () {
        var a = this._originalDesignResolutionSize.width, b = this._originalDesignResolutionSize.height;
        0 < a && this.setDesignResolutionSize(a, b, this._resolutionPolicy)
    }, _setViewPortMeta: function (a, b) {
        if (this._isAdjustViewPort) {
            var c = {"user-scalable": "no", "maximum-scale": "1.0", "initial-scale": "1.0"}, d = document.getElementsByName("viewport"), e;
            0 == d.length ? (d = cc.newElement("meta"), d.name = "viewport", d.content = "", document.head.appendChild(d)) : d = d[0];
            if (cc.sys.isMobile && cc.sys.browserType == cc.sys.BROWSER_TYPE_FIREFOX)d.content = "initial-scale:1"; else {
                e = d.content;
                for (var f in c)RegExp(f).test(e) || (e += ("" == e ? "" :
                    ",") + f + "\x3d" + c[f]);
                d.content = e
            }
        }
    }, _setScaleXYForRenderTexture: function () {
        var a = cc.contentScaleFactor();
        this._scaleY = this._scaleX = a
    }, _resetScale: function () {
        this._scaleX = this._originalScaleX;
        this._scaleY = this._originalScaleY
    }, _adjustSizeToBrowser: function () {
    }, initialize: function () {
        this._initialized = !0
    }, adjustViewPort: function (a) {
        this._isAdjustViewPort = a
    }, enableRetina: function (a) {
        this._retinaEnabled = a ? !0 : !1
    }, isRetinaEnabled: function () {
        return this._retinaEnabled
    }, enableAutoFullScreen: function (a) {
        this._autoFullScreen =
            a ? !0 : !1
    }, isAutoFullScreenEnabled: function () {
        return this._autoFullScreen
    }, end: function () {
    }, isOpenGLReady: function () {
        return null != this._hDC && null != this._hRC
    }, setFrameZoomFactor: function (a) {
        this._frameZoomFactor = a;
        this.centerWindow();
        cc.director.setProjection(cc.director.getProjection())
    }, swapBuffers: function () {
    }, setIMEKeyboardState: function (a) {
    }, setContentTranslateLeftTop: function (a, b) {
        this._contentTranslateLeftTop = {left: a, top: b}
    }, getContentTranslateLeftTop: function () {
        return this._contentTranslateLeftTop
    },
    getFrameSize: function () {
        return cc.size(this._frameSize.width, this._frameSize.height)
    }, setFrameSize: function (a, b) {
        this._frameSize.width = a;
        this._frameSize.height = b;
        this._frame.style.width = a + "px";
        this._frame.style.height = b + "px";
        this._resizeEvent();
        cc.director.setProjection(cc.director.getProjection())
    }, centerWindow: function () {
    }, getVisibleSize: function () {
        return cc.size(this._visibleRect.width, this._visibleRect.height)
    }, getVisibleOrigin: function () {
        return cc.p(this._visibleRect.x, this._visibleRect.y)
    },
    canSetContentScaleFactor: function () {
        return!0
    }, getResolutionPolicy: function () {
        return this._resolutionPolicy
    }, setResolutionPolicy: function (a) {
        if (a instanceof cc.ResolutionPolicy)this._resolutionPolicy = a; else {
            var b = cc.ResolutionPolicy;
            a === b.EXACT_FIT && (this._resolutionPolicy = this._rpExactFit);
            a === b.SHOW_ALL && (this._resolutionPolicy = this._rpShowAll);
            a === b.NO_BORDER && (this._resolutionPolicy = this._rpNoBorder);
            a === b.FIXED_HEIGHT && (this._resolutionPolicy = this._rpFixedHeight);
            a === b.FIXED_WIDTH && (this._resolutionPolicy =
                this._rpFixedWidth)
        }
    }, setDesignResolutionSize: function (a, b, c) {
        if (isNaN(a) || 0 == a || isNaN(b) || 0 == b)cc.log(cc._LogInfos.EGLView_setDesignResolutionSize); else {
            this.setResolutionPolicy(c);
            var d = this._resolutionPolicy;
            if (d) {
                d.preApply(this);
                var e = this._frameSize.width, f = this._frameSize.height;
                cc.sys.isMobile && this._setViewPortMeta(this._frameSize.width, this._frameSize.height);
                this._initFrameSize();
                c == this._resolutionPolicy && a == this._originalDesignResolutionSize.width && b == this._originalDesignResolutionSize.height &&
                    e == this._frameSize.width && f == this._frameSize.height || (this._designResolutionSize = cc.size(a, b), this._originalDesignResolutionSize = cc.size(a, b), a = d.apply(this, this._designResolutionSize), a.scale && 2 == a.scale.length && (this._scaleX = a.scale[0], this._scaleY = a.scale[1]), a.viewport && (a = this._viewPortRect = a.viewport, b = this._visibleRect, b.width = cc._canvas.width / this._scaleX, b.height = cc._canvas.height / this._scaleY, b.x = -a.x / this._scaleX, b.y = -a.y / this._scaleY), a = cc.director, cc.winSize.width = a._winSizeInPoints.width =
                    this._visibleRect.width, cc.winSize.height = a._winSizeInPoints.height = this._visibleRect.height, d.postApply(this), cc._renderType == cc._RENDER_TYPE_WEBGL && (a._createStatsLabel(), a.setGLDefaultValues()), this._originalScaleX = this._scaleX, this._originalScaleY = this._scaleY, cc.DOM && cc.DOM._resetEGLViewDiv(), cc.visibleRect && cc.visibleRect.init(this._visibleRect))
            } else cc.log(cc._LogInfos.EGLView_setDesignResolutionSize_2)
        }
    }, getDesignResolutionSize: function () {
        return cc.size(this._designResolutionSize.width, this._designResolutionSize.height)
    },
    setViewPortInPoints: function (a, b, c, d) {
        var e = this._frameZoomFactor, f = this._scaleX, g = this._scaleY;
        cc._renderContext.viewport(a * f * e + this._viewPortRect.x * e, b * g * e + this._viewPortRect.y * e, c * f * e, d * g * e)
    }, setScissorInPoints: function (a, b, c, d) {
        var e = this._frameZoomFactor, f = this._scaleX, g = this._scaleY;
        cc._renderContext.scissor(a * f * e + this._viewPortRect.x * e, b * g * e + this._viewPortRect.y * e, c * f * e, d * g * e)
    }, isScissorEnabled: function () {
        var a = cc._renderContext;
        return a.isEnabled(a.SCISSOR_TEST)
    }, getScissorRect: function () {
        var a =
            cc._renderContext, b = this._scaleX, c = this._scaleY, a = a.getParameter(a.SCISSOR_BOX);
        return cc.rect((a[0] - this._viewPortRect.x) / b, (a[1] - this._viewPortRect.y) / c, a[2] / b, a[3] / c)
    }, setViewName: function (a) {
        null != a && 0 < a.length && (this._viewName = a)
    }, getViewName: function () {
        return this._viewName
    }, getViewPortRect: function () {
        return this._viewPortRect
    }, getScaleX: function () {
        return this._scaleX
    }, getScaleY: function () {
        return this._scaleY
    }, getDevicePixelRatio: function () {
        return this._devicePixelRatio
    }, convertToLocationInView: function (a, b, c) {
        return{x: this._devicePixelRatio * (a - c.left), y: this._devicePixelRatio * (c.top + c.height - b)}
    }, _convertMouseToLocationInView: function (a, b) {
        var c = this._viewPortRect;
        a.x = (this._devicePixelRatio * (a.x - b.left) - c.x) / this._scaleX;
        a.y = (this._devicePixelRatio * (b.top + b.height - a.y) - c.y) / this._scaleY
    }, _convertTouchesWithScale: function (a) {
        for (var b = this._viewPortRect, c = this._scaleX, d = this._scaleY, e, f, g, h = 0; h < a.length; h++)e = a[h], f = e._point, g = e._prevPoint, e._setPoint((f.x - b.x) / c, (f.y - b.y) / d), e._setPrevPoint((g.x -
            b.x) / c, (g.y - b.y) / d)
    }});
cc.EGLView._getInstance = function () {
    this._instance || (this._instance = this._instance || new cc.EGLView, this._instance.initialize());
    return this._instance
};
cc.ContainerStrategy = cc.Class.extend({preApply: function (a) {
}, apply: function (a, b) {
}, postApply: function (a) {
}, _setupContainer: function (a, b, c) {
    var d = a._frame;
    cc.view._autoFullScreen && (cc.sys.isMobile && d == document.documentElement) && cc.screen.autoFullScreen(d);
    var d = cc._canvas, e = cc.container;
    e.style.width = d.style.width = b + "px";
    e.style.height = d.style.height = c + "px";
    e = a._devicePixelRatio = 1;
    a.isRetinaEnabled() && (e = a._devicePixelRatio = window.devicePixelRatio || 1);
    d.width = b * e;
    d.height = c * e;
    a = document.body;
    var f;
    if (a && (f = a.style))f.paddingTop = f.paddingTop || "0px", f.paddingRight = f.paddingRight || "0px", f.paddingBottom = f.paddingBottom || "0px", f.paddingLeft = f.paddingLeft || "0px", f.borderTop = f.borderTop || "0px", f.borderRight = f.borderRight || "0px", f.borderBottom = f.borderBottom || "0px", f.borderLeft = f.borderLeft || "0px", f.marginTop = f.marginTop || "0px", f.marginRight = f.marginRight || "0px", f.marginBottom = f.marginBottom || "0px", f.marginLeft = f.marginLeft || "0px"
}, _fixContainer: function () {
    document.body.insertBefore(cc.container, document.body.firstChild);
    var a = document.body.style;
    a.width = window.innerWidth + "px";
    a.height = window.innerHeight + "px";
    a.overflow = "hidden";
    a = cc.container.style;
    a.position = "fixed";
    a.left = a.top = "0px";
    document.body.scrollTop = 0
}});
cc.ContentStrategy = cc.Class.extend({_result: {scale: [1, 1], viewport: null}, _buildResult: function (a, b, c, d, e, f) {
    2 > Math.abs(a - c) && (c = a);
    2 > Math.abs(b - d) && (d = b);
    a = cc.rect(Math.round((a - c) / 2), Math.round((b - d) / 2), c, d);
    cc._renderType == cc._RENDER_TYPE_CANVAS && cc._renderContext.translate(a.x, a.y + d);
    this._result.scale = [e, f];
    this._result.viewport = a;
    return this._result
}, preApply: function (a) {
}, apply: function (a, b) {
    return{scale: [1, 1]}
}, postApply: function (a) {
}});
(function () {
    var a = cc.ContainerStrategy.extend({apply: function (a) {
        this._setupContainer(a, a._frameSize.width, a._frameSize.height)
    }}), b = cc.ContainerStrategy.extend({apply: function (a, b) {
        var c = a._frameSize.width, d = a._frameSize.height, e = cc.container.style, m = b.width, n = b.height, q = c / m, r = d / n, t, s;
        q < r ? (t = c, s = n * q) : (t = m * r, s = d);
        m = Math.round((c - t) / 2);
        s = Math.round((d - s) / 2);
        this._setupContainer(a, c - 2 * m, d - 2 * s);
        e.marginLeft = m + "px";
        e.marginRight = m + "px";
        e.marginTop = s + "px";
        e.marginBottom = s + "px"
    }});
    a.extend({preApply: function (a) {
        this._super(a);
        a._frame = document.documentElement
    }, apply: function (a) {
        this._super(a);
        this._fixContainer()
    }});
    b.extend({preApply: function (a) {
        this._super(a);
        a._frame = document.documentElement
    }, apply: function (a, b) {
        this._super(a, b);
        this._fixContainer()
    }});
    var c = cc.ContainerStrategy.extend({apply: function (a) {
        this._setupContainer(a, cc._canvas.width, cc._canvas.height)
    }});
    cc.ContainerStrategy.EQUAL_TO_FRAME = new a;
    cc.ContainerStrategy.PROPORTION_TO_FRAME = new b;
    cc.ContainerStrategy.ORIGINAL_CONTAINER = new c;
    var a = cc.ContentStrategy.extend({apply: function (a, b) {
        var c = cc._canvas.width, d = cc._canvas.height;
        return this._buildResult(c, d, c, d, c / b.width, d / b.height)
    }}), b = cc.ContentStrategy.extend({apply: function (a, b) {
        var c = cc._canvas.width, d = cc._canvas.height, e = b.width, m = b.height, n = c / e, q = d / m, r = 0, t, s;
        n < q ? (r = n, t = c, s = m * r) : (r = q, t = e * r, s = d);
        return this._buildResult(c, d, t, s, r, r)
    }}), c = cc.ContentStrategy.extend({apply: function (a, b) {
        var c = cc._canvas.width, d = cc._canvas.height, e = b.width, m = b.height, n = c / e, q = d / m, r, t, s;
        n < q ? (r = q, t = e * r, s = d) : (r = n, t = c, s = m * r);
        return this._buildResult(c,
            d, t, s, r, r)
    }}), d = cc.ContentStrategy.extend({apply: function (a, b) {
        var c = cc._canvas.width, d = cc._canvas.height, e = d / b.height;
        return this._buildResult(c, d, c, d, e, e)
    }, postApply: function (a) {
        cc.director._winSizeInPoints = a.getVisibleSize()
    }}), e = cc.ContentStrategy.extend({apply: function (a, b) {
        var c = cc._canvas.width, d = cc._canvas.height, e = c / b.width;
        return this._buildResult(c, d, c, d, e, e)
    }, postApply: function (a) {
        cc.director._winSizeInPoints = a.getVisibleSize()
    }});
    cc.ContentStrategy.EXACT_FIT = new a;
    cc.ContentStrategy.SHOW_ALL =
        new b;
    cc.ContentStrategy.NO_BORDER = new c;
    cc.ContentStrategy.FIXED_HEIGHT = new d;
    cc.ContentStrategy.FIXED_WIDTH = new e
})();
cc.ResolutionPolicy = cc.Class.extend({_containerStrategy: null, _contentStrategy: null, ctor: function (a, b) {
    this.setContainerStrategy(a);
    this.setContentStrategy(b)
}, preApply: function (a) {
    this._containerStrategy.preApply(a);
    this._contentStrategy.preApply(a)
}, apply: function (a, b) {
    this._containerStrategy.apply(a, b);
    return this._contentStrategy.apply(a, b)
}, postApply: function (a) {
    this._containerStrategy.postApply(a);
    this._contentStrategy.postApply(a)
}, setContainerStrategy: function (a) {
    a instanceof cc.ContainerStrategy &&
    (this._containerStrategy = a)
}, setContentStrategy: function (a) {
    a instanceof cc.ContentStrategy && (this._contentStrategy = a)
}});
cc.ResolutionPolicy.EXACT_FIT = 0;
cc.ResolutionPolicy.NO_BORDER = 1;
cc.ResolutionPolicy.SHOW_ALL = 2;
cc.ResolutionPolicy.FIXED_HEIGHT = 3;
cc.ResolutionPolicy.FIXED_WIDTH = 4;
cc.ResolutionPolicy.UNKNOWN = 5;
cc.UIInterfaceOrientationLandscapeLeft = -90;
cc.UIInterfaceOrientationLandscapeRight = 90;
cc.UIInterfaceOrientationPortraitUpsideDown = 180;
cc.UIInterfaceOrientationPortrait = 0;
cc.inputManager = {_mousePressed: !1, _isRegisterEvent: !1, _preTouchPoint: cc.p(0, 0), _prevMousePoint: cc.p(0, 0), _preTouchPool: [], _preTouchPoolPointer: 0, _touches: [], _touchesIntegerDict: {}, _indexBitsUsed: 0, _maxTouches: 5, _accelEnabled: !1, _accelInterval: 1 / 30, _accelMinus: 1, _accelCurTime: 0, _acceleration: null, _accelDeviceEvent: null, _getUnUsedIndex: function () {
    for (var a = this._indexBitsUsed, b = 0; b < this._maxTouches; b++) {
        if (!(a & 1))return this._indexBitsUsed |= 1 << b, b;
        a >>= 1
    }
    return-1
}, _removeUsedIndexBit: function (a) {
    0 > a ||
        a >= this._maxTouches || (a = ~(1 << a), this._indexBitsUsed &= a)
}, _glView: null, handleTouchesBegin: function (a) {
    for (var b, c, d, e = [], f = this._touchesIntegerDict, g = 0, h = a.length; g < h; g++)b = a[g], d = b.getID(), c = f[d], null == c && (c = this._getUnUsedIndex(), -1 == c ? cc.log(cc._LogInfos.inputManager_handleTouchesBegin, c) : (b = this._touches[c] = b, f[d] = c, e.push(b)));
    0 < e.length && (this._glView._convertTouchesWithScale(e), a = new cc.EventTouch(e), a._eventCode = cc.EventTouch.EventCode.BEGAN, cc.eventManager.dispatchEvent(a))
}, handleTouchesMove: function (a) {
    for (var b,
             c, d = [], e = this._touches, f = 0, g = a.length; f < g; f++)b = a[f], c = b.getID(), c = this._touchesIntegerDict[c], null != c && e[c] && (e[c]._setPoint(b._point), e[c]._setPrevPoint(b._prevPoint), d.push(e[c]));
    0 < d.length && (this._glView._convertTouchesWithScale(d), a = new cc.EventTouch(d), a._eventCode = cc.EventTouch.EventCode.MOVED, cc.eventManager.dispatchEvent(a))
}, handleTouchesEnd: function (a) {
    a = this.getSetOfTouchesEndOrCancel(a);
    0 < a.length && (this._glView._convertTouchesWithScale(a), a = new cc.EventTouch(a), a._eventCode = cc.EventTouch.EventCode.ENDED,
        cc.eventManager.dispatchEvent(a))
}, handleTouchesCancel: function (a) {
    a = this.getSetOfTouchesEndOrCancel(a);
    0 < a.length && (this._glView._convertTouchesWithScale(a), a = new cc.EventTouch(a), a._eventCode = cc.EventTouch.EventCode.CANCELLED, cc.eventManager.dispatchEvent(a))
}, getSetOfTouchesEndOrCancel: function (a) {
    for (var b, c, d, e = [], f = this._touches, g = this._touchesIntegerDict, h = 0, k = a.length; h < k; h++)b = a[h], d = b.getID(), c = g[d], null != c && f[c] && (f[c]._setPoint(b._point), f[c]._setPrevPoint(b._prevPoint), e.push(f[c]), this._removeUsedIndexBit(c),
        delete g[d]);
    return e
}, getHTMLElementPosition: function (a) {
    var b = document.documentElement, c = window, d = null, d = "function" === typeof a.getBoundingClientRect ? a.getBoundingClientRect() : a instanceof HTMLCanvasElement ? {left: 0, top: 0, width: a.width, height: a.height} : {left: 0, top: 0, width: parseInt(a.style.width), height: parseInt(a.style.height)};
    return{left: d.left + c.pageXOffset - b.clientLeft, top: d.top + c.pageYOffset - b.clientTop, width: d.width, height: d.height}
}, getPreTouch: function (a) {
    for (var b = null, c = this._preTouchPool,
             d = a.getId(), e = c.length - 1; 0 <= e; e--)if (c[e].getId() == d) {
        b = c[e];
        break
    }
    b || (b = a);
    return b
}, setPreTouch: function (a) {
    for (var b = !1, c = this._preTouchPool, d = a.getId(), e = c.length - 1; 0 <= e; e--)if (c[e].getId() == d) {
        c[e] = a;
        b = !0;
        break
    }
    b || (50 >= c.length ? c.push(a) : (c[this._preTouchPoolPointer] = a, this._preTouchPoolPointer = (this._preTouchPoolPointer + 1) % 50))
}, getTouchByXY: function (a, b, c) {
    var d = this._preTouchPoint;
    a = this._glView.convertToLocationInView(a, b, c);
    b = new cc.Touch(a.x, a.y);
    b._setPrevPoint(d.x, d.y);
    d.x = a.x;
    d.y = a.y;
    return b
}, getMouseEvent: function (a, b, c) {
    var d = this._prevMousePoint;
    this._glView._convertMouseToLocationInView(a, b);
    b = new cc.EventMouse(c);
    b.setLocation(a.x, a.y);
    b._setPrevCursor(d.x, d.y);
    d.x = a.x;
    d.y = a.y;
    return b
}, getPointByEvent: function (a, b) {
    if (null != a.pageX)return{x: a.pageX, y: a.pageY};
    b.left -= document.body.scrollLeft;
    b.top -= document.body.scrollTop;
    return{x: a.clientX, y: a.clientY}
}, getTouchesByEvent: function (a, b) {
    for (var c = [], d = this._glView, e, f, g = this._preTouchPoint, h = a.changedTouches.length, k = 0; k <
        h; k++)if (e = a.changedTouches[k]) {
        var l;
        l = cc.sys.BROWSER_TYPE_FIREFOX === cc.sys.browserType ? d.convertToLocationInView(e.pageX, e.pageY, b) : d.convertToLocationInView(e.clientX, e.clientY, b);
        null != e.identifier ? (e = new cc.Touch(l.x, l.y, e.identifier), f = this.getPreTouch(e).getLocation(), e._setPrevPoint(f.x, f.y), this.setPreTouch(e)) : (e = new cc.Touch(l.x, l.y), e._setPrevPoint(g.x, g.y));
        g.x = l.x;
        g.y = l.y;
        c.push(e)
    }
    return c
}, registerSystemEvent: function (a) {
    if (!this._isRegisterEvent) {
        var b = this._glView = cc.view, c = this,
            d = "touches"in cc.sys.capabilities;
        "mouse"in cc.sys.capabilities && (cc._addEventListener(window, "mousedown", function () {
            c._mousePressed = !0
        }, !1), cc._addEventListener(window, "mouseup", function (b) {
                var e = c._mousePressed;
                c._mousePressed = !1;
                if (e) {
                    var e = c.getHTMLElementPosition(a), f = c.getPointByEvent(b, e);
                    cc.rectContainsPoint(new cc.Rect(e.left, e.top, e.width, e.height), f) || (d || c.handleTouchesEnd([c.getTouchByXY(f.x, f.y, e)]), e = c.getMouseEvent(f, e, cc.EventMouse.UP), e.setButton(b.button), cc.eventManager.dispatchEvent(e))
                }
            },
            !1), cc._addEventListener(a, "mousedown", function (b) {
            c._mousePressed = !0;
            var e = c.getHTMLElementPosition(a), f = c.getPointByEvent(b, e);
            d || c.handleTouchesBegin([c.getTouchByXY(f.x, f.y, e)]);
            e = c.getMouseEvent(f, e, cc.EventMouse.DOWN);
            e.setButton(b.button);
            cc.eventManager.dispatchEvent(e);
            b.stopPropagation();
            b.preventDefault();
            a.focus()
        }, !1), cc._addEventListener(a, "mouseup", function (b) {
            c._mousePressed = !1;
            var e = c.getHTMLElementPosition(a), f = c.getPointByEvent(b, e);
            d || c.handleTouchesEnd([c.getTouchByXY(f.x, f.y,
                e)]);
            e = c.getMouseEvent(f, e, cc.EventMouse.UP);
            e.setButton(b.button);
            cc.eventManager.dispatchEvent(e);
            b.stopPropagation();
            b.preventDefault()
        }, !1), cc._addEventListener(a, "mousemove", function (b) {
            var e = c.getHTMLElementPosition(a), f = c.getPointByEvent(b, e);
            d || c.handleTouchesMove([c.getTouchByXY(f.x, f.y, e)]);
            e = c.getMouseEvent(f, e, cc.EventMouse.MOVE);
            c._mousePressed ? e.setButton(b.button) : e.setButton(null);
            cc.eventManager.dispatchEvent(e);
            b.stopPropagation();
            b.preventDefault()
        }, !1), cc._addEventListener(a, "mousewheel",
            function (b) {
                var d = c.getHTMLElementPosition(a), e = c.getPointByEvent(b, d), d = c.getMouseEvent(e, d, cc.EventMouse.SCROLL);
                d.setButton(b.button);
                d.setScrollData(0, b.wheelDelta);
                cc.eventManager.dispatchEvent(d);
                b.stopPropagation();
                b.preventDefault()
            }, !1), cc._addEventListener(a, "DOMMouseScroll", function (b) {
            var d = c.getHTMLElementPosition(a), e = c.getPointByEvent(b, d), d = c.getMouseEvent(e, d, cc.EventMouse.SCROLL);
            d.setButton(b.button);
            d.setScrollData(0, -120 * b.detail);
            cc.eventManager.dispatchEvent(d);
            b.stopPropagation();
            b.preventDefault()
        }, !1));
        if (window.navigator.msPointerEnabled) {
            var e = {MSPointerDown: c.handleTouchesBegin, MSPointerMove: c.handleTouchesMove, MSPointerUp: c.handleTouchesEnd, MSPointerCancel: c.handleTouchesCancel}, f;
            for (f in e)(function (b, d) {
                cc._addEventListener(a, b, function (b) {
                    var e = c.getHTMLElementPosition(a);
                    e.left -= document.documentElement.scrollLeft;
                    e.top -= document.documentElement.scrollTop;
                    d.call(c, [c.getTouchByXY(b.clientX, b.clientY, e)]);
                    b.stopPropagation()
                }, !1)
            })(f, e[f])
        }
        d && (cc._addEventListener(a,
            "touchstart", function (b) {
                if (b.changedTouches) {
                    var d = c.getHTMLElementPosition(a);
                    d.left -= document.body.scrollLeft;
                    d.top -= document.body.scrollTop;
                    c.handleTouchesBegin(c.getTouchesByEvent(b, d));
                    b.stopPropagation();
                    b.preventDefault();
                    a.focus()
                }
            }, !1), cc._addEventListener(a, "touchmove", function (b) {
            if (b.changedTouches) {
                var d = c.getHTMLElementPosition(a);
                d.left -= document.body.scrollLeft;
                d.top -= document.body.scrollTop;
                c.handleTouchesMove(c.getTouchesByEvent(b, d));
                b.stopPropagation();
                b.preventDefault()
            }
        }, !1),
            cc._addEventListener(a, "touchend", function (b) {
                if (b.changedTouches) {
                    var d = c.getHTMLElementPosition(a);
                    d.left -= document.body.scrollLeft;
                    d.top -= document.body.scrollTop;
                    c.handleTouchesEnd(c.getTouchesByEvent(b, d));
                    b.stopPropagation();
                    b.preventDefault()
                }
            }, !1), cc._addEventListener(a, "touchcancel", function (d) {
                if (d.changedTouches) {
                    var e = c.getHTMLElementPosition(a);
                    e.left -= document.body.scrollLeft;
                    e.top -= document.body.scrollTop;
                    b.handleTouchesCancel(c.getTouchesByEvent(d, e));
                    d.stopPropagation();
                    d.preventDefault()
                }
            },
            !1));
        this._registerKeyboardEvent();
        this._registerAccelerometerEvent();
        this._isRegisterEvent = !0
    }
}, _registerKeyboardEvent: function () {
}, _registerAccelerometerEvent: function () {
}, update: function (a) {
    this._accelCurTime > this._accelInterval && (this._accelCurTime -= this._accelInterval, cc.eventManager.dispatchEvent(new cc.EventAcceleration(this._acceleration)));
    this._accelCurTime += a
}};
cc.AffineTransform = function (a, b, c, d, e, f) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.tx = e;
    this.ty = f
};
cc.AffineTransformMake = function (a, b, c, d, e, f) {
    return{a: a, b: b, c: c, d: d, tx: e, ty: f}
};
cc.PointApplyAffineTransform = function (a, b) {
    return{x: b.a * a.x + b.c * a.y + b.tx, y: b.b * a.x + b.d * a.y + b.ty}
};
cc._PointApplyAffineTransform = function (a, b, c) {
    return{x: c.a * a + c.c * b + c.tx, y: c.b * a + c.d * b + c.ty}
};
cc.SizeApplyAffineTransform = function (a, b) {
    return{width: b.a * a.width + b.c * a.height, height: b.b * a.width + b.d * a.height}
};
cc.AffineTransformMakeIdentity = function () {
    return{a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0}
};
cc.AffineTransformIdentity = function () {
    return{a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0}
};
cc.RectApplyAffineTransform = function (a, b) {
    var c = cc.rectGetMinY(a), d = cc.rectGetMinX(a), e = cc.rectGetMaxX(a), f = cc.rectGetMaxY(a), g = cc._PointApplyAffineTransform(d, c, b), c = cc._PointApplyAffineTransform(e, c, b), d = cc._PointApplyAffineTransform(d, f, b), h = cc._PointApplyAffineTransform(e, f, b), e = Math.min(g.x, c.x, d.x, h.x), f = Math.max(g.x, c.x, d.x, h.x), k = Math.min(g.y, c.y, d.y, h.y), g = Math.max(g.y, c.y, d.y, h.y);
    return cc.rect(e, k, f - e, g - k)
};
cc._RectApplyAffineTransformIn = function (a, b) {
    var c = cc.rectGetMinY(a), d = cc.rectGetMinX(a), e = cc.rectGetMaxX(a), f = cc.rectGetMaxY(a), g = cc._PointApplyAffineTransform(d, c, b), c = cc._PointApplyAffineTransform(e, c, b), d = cc._PointApplyAffineTransform(d, f, b), h = cc._PointApplyAffineTransform(e, f, b), e = Math.min(g.x, c.x, d.x, h.x), f = Math.max(g.x, c.x, d.x, h.x), k = Math.min(g.y, c.y, d.y, h.y), g = Math.max(g.y, c.y, d.y, h.y);
    a.x = e;
    a.y = k;
    a.width = f - e;
    a.height = g - k;
    return a
};
cc.AffineTransformTranslate = function (a, b, c) {
    return{a: a.a, b: a.b, c: a.c, d: a.d, tx: a.tx + a.a * b + a.c * c, ty: a.ty + a.b * b + a.d * c}
};
cc.AffineTransformScale = function (a, b, c) {
    return{a: a.a * b, b: a.b * b, c: a.c * c, d: a.d * c, tx: a.tx, ty: a.ty}
};
cc.AffineTransformRotate = function (a, b) {
    var c = Math.sin(b), d = Math.cos(b);
    return{a: a.a * d + a.c * c, b: a.b * d + a.d * c, c: a.c * d - a.a * c, d: a.d * d - a.b * c, tx: a.tx, ty: a.ty}
};
cc.AffineTransformConcat = function (a, b) {
    return{a: a.a * b.a + a.b * b.c, b: a.a * b.b + a.b * b.d, c: a.c * b.a + a.d * b.c, d: a.c * b.b + a.d * b.d, tx: a.tx * b.a + a.ty * b.c + b.tx, ty: a.tx * b.b + a.ty * b.d + b.ty}
};
cc.AffineTransformEqualToTransform = function (a, b) {
    return a.a === b.a && a.b === b.b && a.c === b.c && a.d === b.d && a.tx === b.tx && a.ty === b.ty
};
cc.AffineTransformInvert = function (a) {
    var b = 1 / (a.a * a.d - a.b * a.c);
    return{a: b * a.d, b: -b * a.b, c: -b * a.c, d: b * a.a, tx: b * (a.c * a.ty - a.d * a.tx), ty: b * (a.b * a.tx - a.a * a.ty)}
};
cc.POINT_EPSILON = parseFloat("1.192092896e-07F");
cc.pNeg = function (a) {
    return cc.p(-a.x, -a.y)
};
cc.pAdd = function (a, b) {
    return cc.p(a.x + b.x, a.y + b.y)
};
cc.pSub = function (a, b) {
    return cc.p(a.x - b.x, a.y - b.y)
};
cc.pMult = function (a, b) {
    return cc.p(a.x * b, a.y * b)
};
cc.pMidpoint = function (a, b) {
    return cc.pMult(cc.pAdd(a, b), 0.5)
};
cc.pDot = function (a, b) {
    return a.x * b.x + a.y * b.y
};
cc.pCross = function (a, b) {
    return a.x * b.y - a.y * b.x
};
cc.pPerp = function (a) {
    return cc.p(-a.y, a.x)
};
cc.pRPerp = function (a) {
    return cc.p(a.y, -a.x)
};
cc.pProject = function (a, b) {
    return cc.pMult(b, cc.pDot(a, b) / cc.pDot(b, b))
};
cc.pRotate = function (a, b) {
    return cc.p(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x)
};
cc.pUnrotate = function (a, b) {
    return cc.p(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y)
};
cc.pLengthSQ = function (a) {
    return cc.pDot(a, a)
};
cc.pDistanceSQ = function (a, b) {
    return cc.pLengthSQ(cc.pSub(a, b))
};
cc.pLength = function (a) {
    return Math.sqrt(cc.pLengthSQ(a))
};
cc.pDistance = function (a, b) {
    return cc.pLength(cc.pSub(a, b))
};
cc.pNormalize = function (a) {
    return cc.pMult(a, 1 / cc.pLength(a))
};
cc.pForAngle = function (a) {
    return cc.p(Math.cos(a), Math.sin(a))
};
cc.pToAngle = function (a) {
    return Math.atan2(a.y, a.x)
};
cc.clampf = function (a, b, c) {
    if (b > c) {
        var d = b;
        b = c;
        c = d
    }
    return a < b ? b : a < c ? a : c
};
cc.pClamp = function (a, b, c) {
    return cc.p(cc.clampf(a.x, b.x, c.x), cc.clampf(a.y, b.y, c.y))
};
cc.pFromSize = function (a) {
    return cc.p(a.width, a.height)
};
cc.pCompOp = function (a, b) {
    return cc.p(b(a.x), b(a.y))
};
cc.pLerp = function (a, b, c) {
    return cc.pAdd(cc.pMult(a, 1 - c), cc.pMult(b, c))
};
cc.pFuzzyEqual = function (a, b, c) {
    return a.x - c <= b.x && b.x <= a.x + c && a.y - c <= b.y && b.y <= a.y + c ? !0 : !1
};
cc.pCompMult = function (a, b) {
    return cc.p(a.x * b.x, a.y * b.y)
};
cc.pAngleSigned = function (a, b) {
    var c = cc.pNormalize(a), d = cc.pNormalize(b), c = Math.atan2(c.x * d.y - c.y * d.x, cc.pDot(c, d));
    return Math.abs(c) < cc.POINT_EPSILON ? 0 : c
};
cc.pAngle = function (a, b) {
    var c = Math.acos(cc.pDot(cc.pNormalize(a), cc.pNormalize(b)));
    return Math.abs(c) < cc.POINT_EPSILON ? 0 : c
};
cc.pRotateByAngle = function (a, b, c) {
    a = cc.pSub(a, b);
    var d = Math.cos(c);
    c = Math.sin(c);
    var e = a.x;
    a.x = e * d - a.y * c + b.x;
    a.y = e * c + a.y * d + b.y;
    return a
};
cc.pLineIntersect = function (a, b, c, d, e) {
    if (a.x == b.x && a.y == b.y || c.x == d.x && c.y == d.y)return!1;
    var f = b.x - a.x;
    b = b.y - a.y;
    var g = d.x - c.x;
    d = d.y - c.y;
    var h = a.x - c.x;
    a = a.y - c.y;
    c = d * f - g * b;
    e.x = g * a - d * h;
    e.y = f * a - b * h;
    if (0 == c)return 0 == e.x || 0 == e.y ? !0 : !1;
    e.x /= c;
    e.y /= c;
    return!0
};
cc.pSegmentIntersect = function (a, b, c, d) {
    var e = cc.p(0, 0);
    return cc.pLineIntersect(a, b, c, d, e) && 0 <= e.x && 1 >= e.x && 0 <= e.y && 1 >= e.y ? !0 : !1
};
cc.pIntersectPoint = function (a, b, c, d) {
    var e = cc.p(0, 0);
    return cc.pLineIntersect(a, b, c, d, e) ? (c = cc.p(0, 0), c.x = a.x + e.x * (b.x - a.x), c.y = a.y + e.x * (b.y - a.y), c) : cc.p(0, 0)
};
cc.pSameAs = function (a, b) {
    return null != a && null != b ? a.x == b.x && a.y == b.y : !1
};
cc.pZeroIn = function (a) {
    a.x = 0;
    a.y = 0
};
cc.pIn = function (a, b) {
    a.x = b.x;
    a.y = b.y
};
cc.pMultIn = function (a, b) {
    a.x *= b;
    a.y *= b
};
cc.pSubIn = function (a, b) {
    a.x -= b.x;
    a.y -= b.y
};
cc.pAddIn = function (a, b) {
    a.x += b.x;
    a.y += b.y
};
cc.pNormalizeIn = function (a) {
    cc.pMultIn(a, 1 / Math.sqrt(a.x * a.x + a.y * a.y))
};
cc.Touch = cc.Class.extend({_point: null, _prevPoint: null, _id: 0, _startPointCaptured: !1, _startPoint: null, ctor: function (a, b, c) {
    this._point = cc.p(a || 0, b || 0);
    this._id = c || 0
}, getLocation: function () {
    return{x: this._point.x, y: this._point.y}
}, getLocationX: function () {
    return this._point.x
}, getLocationY: function () {
    return this._point.y
}, getPreviousLocation: function () {
    return{x: this._prevPoint.x, y: this._prevPoint.y}
}, getStartLocation: function () {
    return{x: this._startPoint.x, y: this._startPoint.y}
}, getDelta: function () {
    return cc.pSub(this._point,
        this._prevPoint)
}, getLocationInView: function () {
    return{x: this._point.x, y: this._point.y}
}, getPreviousLocationInView: function () {
    return{x: this._prevPoint.x, y: this._prevPoint.y}
}, getStartLocationInView: function () {
    return{x: this._startPoint.x, y: this._startPoint.y}
}, getID: function () {
    return this._id
}, getId: function () {
    return this._id
}, setTouchInfo: function (a, b, c) {
    this._prevPoint = this._point;
    this._point = cc.p(b || 0, c || 0);
    this._id = a;
    this._startPointCaptured || (this._startPoint = cc.p(this._point), this._startPointCaptured = !0)
}, _setPoint: function (a, b) {
    void 0 === b ? (this._point.x = a.x, this._point.y = a.y) : (this._point.x = a, this._point.y = b)
}, _setPrevPoint: function (a, b) {
    this._prevPoint = void 0 === b ? cc.p(a.x, a.y) : cc.p(a || 0, b || 0)
}});
cc.Event = cc.Class.extend({_type: 0, _isStopped: !1, _currentTarget: null, _setCurrentTarget: function (a) {
    this._currentTarget = a
}, ctor: function (a) {
    this._type = a
}, getType: function () {
    return this._type
}, stopPropagation: function () {
    this._isStopped = !0
}, isStopped: function () {
    return this._isStopped
}, getCurrentTarget: function () {
    return this._currentTarget
}});
cc.Event.TOUCH = 0;
cc.Event.KEYBOARD = 1;
cc.Event.ACCELERATION = 2;
cc.Event.MOUSE = 3;
cc.Event.CUSTOM = 4;
cc.EventCustom = cc.Event.extend({_eventName: null, _userData: null, ctor: function (a) {
    cc.Event.prototype.ctor.call(this, cc.Event.CUSTOM);
    this._eventName = a
}, setUserData: function (a) {
    this._userData = a
}, getUserData: function () {
    return this._userData
}, getEventName: function () {
    return this._eventName
}});
cc.EventMouse = cc.Event.extend({_eventType: 0, _button: 0, _x: 0, _y: 0, _prevX: 0, _prevY: 0, _scrollX: 0, _scrollY: 0, ctor: function (a) {
    cc.Event.prototype.ctor.call(this, cc.Event.MOUSE);
    this._eventType = a
}, setScrollData: function (a, b) {
    this._scrollX = a;
    this._scrollY = b
}, getScrollX: function () {
    return this._scrollX
}, getScrollY: function () {
    return this._scrollY
}, setLocation: function (a, b) {
    this._x = a;
    this._y = b
}, getLocation: function () {
    return{x: this._x, y: this._y}
}, getLocationInView: function () {
    return{x: this._x, y: cc.view._designResolutionSize.height -
        this._y}
}, _setPrevCursor: function (a, b) {
    this._prevX = a;
    this._prevY = b
}, getDelta: function () {
    return{x: this._x - this._prevX, y: this._y - this._prevY}
}, getDeltaX: function () {
    return this._x - this._prevX
}, getDeltaY: function () {
    return this._y - this._prevY
}, setButton: function (a) {
    this._button = a
}, getButton: function () {
    return this._button
}, getLocationX: function () {
    return this._x
}, getLocationY: function () {
    return this._y
}});
cc.EventMouse.NONE = 0;
cc.EventMouse.DOWN = 1;
cc.EventMouse.UP = 2;
cc.EventMouse.MOVE = 3;
cc.EventMouse.SCROLL = 4;
cc.EventMouse.BUTTON_LEFT = 0;
cc.EventMouse.BUTTON_RIGHT = 2;
cc.EventMouse.BUTTON_MIDDLE = 1;
cc.EventMouse.BUTTON_4 = 3;
cc.EventMouse.BUTTON_5 = 4;
cc.EventMouse.BUTTON_6 = 5;
cc.EventMouse.BUTTON_7 = 6;
cc.EventMouse.BUTTON_8 = 7;
cc.EventTouch = cc.Event.extend({_eventCode: 0, _touches: null, ctor: function (a) {
    cc.Event.prototype.ctor.call(this, cc.Event.TOUCH);
    this._touches = a || []
}, getEventCode: function () {
    return this._eventCode
}, getTouches: function () {
    return this._touches
}, _setEventCode: function (a) {
    this._eventCode = a
}, _setTouches: function (a) {
    this._touches = a
}});
cc.EventTouch.MAX_TOUCHES = 5;
cc.EventTouch.EventCode = {BEGAN: 0, MOVED: 1, ENDED: 2, CANCELLED: 3};
cc.EventListener = cc.Class.extend({_onEvent: null, _type: 0, _listenerID: null, _registered: !1, _fixedPriority: 0, _node: null, _paused: !1, _isEnabled: !0, ctor: function (a, b, c) {
    this._onEvent = c;
    this._type = a || 0;
    this._listenerID = b || ""
}, _setPaused: function (a) {
    this._paused = a
}, _isPaused: function () {
    return this._paused
}, _setRegistered: function (a) {
    this._registered = a
}, _isRegistered: function () {
    return this._registered
}, _getType: function () {
    return this._type
}, _getListenerID: function () {
    return this._listenerID
}, _setFixedPriority: function (a) {
    this._fixedPriority =
        a
}, _getFixedPriority: function () {
    return this._fixedPriority
}, _setSceneGraphPriority: function (a) {
    this._node = a
}, _getSceneGraphPriority: function () {
    return this._node
}, checkAvailable: function () {
    return null != this._onEvent
}, clone: function () {
    return null
}, setEnabled: function (a) {
    this._isEnabled = a
}, isEnabled: function () {
    return this._isEnabled
}, retain: function () {
}, release: function () {
}});
cc.EventListener.UNKNOWN = 0;
cc.EventListener.TOUCH_ONE_BY_ONE = 1;
cc.EventListener.TOUCH_ALL_AT_ONCE = 2;
cc.EventListener.KEYBOARD = 3;
cc.EventListener.MOUSE = 4;
cc.EventListener.ACCELERATION = 5;
cc.EventListener.CUSTOM = 6;
cc._EventListenerCustom = cc.EventListener.extend({_onCustomEvent: null, ctor: function (a, b) {
    this._onCustomEvent = b;
    var c = this;
    cc.EventListener.prototype.ctor.call(this, cc.EventListener.CUSTOM, a, function (a) {
        null != c._onCustomEvent && c._onCustomEvent(a)
    })
}, checkAvailable: function () {
    return cc.EventListener.prototype.checkAvailable.call(this) && null != this._onCustomEvent
}, clone: function () {
    return new cc._EventListenerCustom(this._listenerID, this._onCustomEvent)
}});
cc._EventListenerCustom.create = function (a, b) {
    return new cc._EventListenerCustom(a, b)
};
cc._EventListenerMouse = cc.EventListener.extend({onMouseDown: null, onMouseUp: null, onMouseMove: null, onMouseScroll: null, ctor: function () {
    var a = this;
    cc.EventListener.prototype.ctor.call(this, cc.EventListener.MOUSE, cc._EventListenerMouse.LISTENER_ID, function (b) {
        var c = cc.EventMouse;
        switch (b._eventType) {
            case c.DOWN:
                if (a.onMouseDown)a.onMouseDown(b);
                break;
            case c.UP:
                if (a.onMouseUp)a.onMouseUp(b);
                break;
            case c.MOVE:
                if (a.onMouseMove)a.onMouseMove(b);
                break;
            case c.SCROLL:
                if (a.onMouseScroll)a.onMouseScroll(b)
        }
    })
},
    clone: function () {
        var a = new cc._EventListenerMouse;
        a.onMouseDown = this.onMouseDown;
        a.onMouseUp = this.onMouseUp;
        a.onMouseMove = this.onMouseMove;
        a.onMouseScroll = this.onMouseScroll;
        return a
    }, checkAvailable: function () {
        return!0
    }});
cc._EventListenerMouse.LISTENER_ID = "__cc_mouse";
cc._EventListenerMouse.create = function () {
    return new cc._EventListenerMouse
};
cc._EventListenerTouchOneByOne = cc.EventListener.extend({_claimedTouches: null, swallowTouches: !1, onTouchBegan: null, onTouchMoved: null, onTouchEnded: null, onTouchCancelled: null, ctor: function () {
    cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ONE_BY_ONE, cc._EventListenerTouchOneByOne.LISTENER_ID, null);
    this._claimedTouches = []
}, setSwallowTouches: function (a) {
    this.swallowTouches = a
}, clone: function () {
    var a = new cc._EventListenerTouchOneByOne;
    a.onTouchBegan = this.onTouchBegan;
    a.onTouchMoved = this.onTouchMoved;
    a.onTouchEnded = this.onTouchEnded;
    a.onTouchCancelled = this.onTouchCancelled;
    a.swallowTouches = this.swallowTouches;
    return a
}, checkAvailable: function () {
    return!this.onTouchBegan ? (cc.log(cc._LogInfos._EventListenerTouchOneByOne_checkAvailable), !1) : !0
}});
cc._EventListenerTouchOneByOne.LISTENER_ID = "__cc_touch_one_by_one";
cc._EventListenerTouchOneByOne.create = function () {
    return new cc._EventListenerTouchOneByOne
};
cc._EventListenerTouchAllAtOnce = cc.EventListener.extend({onTouchesBegan: null, onTouchesMoved: null, onTouchesEnded: null, onTouchesCancelled: null, ctor: function () {
    cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ALL_AT_ONCE, cc._EventListenerTouchAllAtOnce.LISTENER_ID, null)
}, clone: function () {
    var a = new cc._EventListenerTouchAllAtOnce;
    a.onTouchesBegan = this.onTouchesBegan;
    a.onTouchesMoved = this.onTouchesMoved;
    a.onTouchesEnded = this.onTouchesEnded;
    a.onTouchesCancelled = this.onTouchesCancelled;
    return a
},
    checkAvailable: function () {
        return null == this.onTouchesBegan && null == this.onTouchesMoved && null == this.onTouchesEnded && null == this.onTouchesCancelled ? (cc.log(cc._LogInfos._EventListenerTouchAllAtOnce_checkAvailable), !1) : !0
    }});
cc._EventListenerTouchAllAtOnce.LISTENER_ID = "__cc_touch_all_at_once";
cc._EventListenerTouchAllAtOnce.create = function () {
    return new cc._EventListenerTouchAllAtOnce
};
cc.EventListener.create = function (a) {
    cc.assert(a && a.event, cc._LogInfos.EventListener_create);
    var b = a.event;
    delete a.event;
    var c = null;
    b === cc.EventListener.TOUCH_ONE_BY_ONE ? c = new cc._EventListenerTouchOneByOne : b === cc.EventListener.TOUCH_ALL_AT_ONCE ? c = new cc._EventListenerTouchAllAtOnce : b === cc.EventListener.MOUSE ? c = new cc._EventListenerMouse : b === cc.EventListener.CUSTOM ? (c = new cc._EventListenerCustom(a.eventName, a.callback), delete a.eventName, delete a.callback) : b === cc.EventListener.KEYBOARD ? c = new cc._EventListenerKeyboard :
        b === cc.EventListener.ACCELERATION && (c = new cc._EventListenerAcceleration(a.callback), delete a.callback);
    for (var d in a)c[d] = a[d];
    return c
};
cc.copyArray = function (a) {
    var b, c = a.length, d = Array(c);
    for (b = 0; b < c; b += 1)d[b] = a[b];
    return d
};
cc._EventListenerVector = cc.Class.extend({_fixedListeners: null, _sceneGraphListeners: null, gt0Index: 0, ctor: function () {
    this._fixedListeners = [];
    this._sceneGraphListeners = []
}, size: function () {
    return this._fixedListeners.length + this._sceneGraphListeners.length
}, empty: function () {
    return 0 === this._fixedListeners.length && 0 === this._sceneGraphListeners.length
}, push: function (a) {
    0 == a._getFixedPriority() ? this._sceneGraphListeners.push(a) : this._fixedListeners.push(a)
}, clearSceneGraphListeners: function () {
    this._sceneGraphListeners.length =
        0
}, clearFixedListeners: function () {
    this._fixedListeners.length = 0
}, clear: function () {
    this._sceneGraphListeners.length = 0;
    this._fixedListeners.length = 0
}, getFixedPriorityListeners: function () {
    return this._fixedListeners
}, getSceneGraphPriorityListeners: function () {
    return this._sceneGraphListeners
}});
cc.__getListenerID = function (a) {
    var b = cc.Event, c = a.getType();
    if (c === b.ACCELERATION)return cc._EventListenerAcceleration.LISTENER_ID;
    if (c === b.CUSTOM)return a.getEventName();
    if (c === b.KEYBOARD)return cc._EventListenerKeyboard.LISTENER_ID;
    if (c === b.MOUSE)return cc._EventListenerMouse.LISTENER_ID;
    c === b.TOUCH && cc.log(cc._LogInfos.__getListenerID);
    return""
};
cc.eventManager = {DIRTY_NONE: 0, DIRTY_FIXED_PRIORITY: 1, DIRTY_SCENE_GRAPH_PRIORITY: 2, DIRTY_ALL: 3, _listenersMap: {}, _priorityDirtyFlagMap: {}, _nodeListenersMap: {}, _nodePriorityMap: {}, _globalZOrderNodeMap: {}, _toAddedListeners: [], _dirtyNodes: [], _inDispatch: 0, _isEnabled: !1, _nodePriorityIndex: 0, _internalCustomListenerIDs: [cc.game.EVENT_HIDE, cc.game.EVENT_SHOW], _setDirtyForNode: function (a) {
    null != this._nodeListenersMap[a.__instanceId] && this._dirtyNodes.push(a);
    a = a.getChildren();
    for (var b = 0, c = a.length; b < c; b++)this._setDirtyForNode(a[b])
},
    pauseTarget: function (a, b) {
        var c = this._nodeListenersMap[a.__instanceId], d, e;
        if (c) {
            d = 0;
            for (e = c.length; d < e; d++)c[d]._setPaused(!0)
        }
        if (!0 === b) {
            c = a.getChildren();
            d = 0;
            for (e = c.length; d < e; d++)this.pauseTarget(c[d], !0)
        }
    }, resumeTarget: function (a, b) {
        var c = this._nodeListenersMap[a.__instanceId], d, e;
        if (c) {
            d = 0;
            for (e = c.length; d < e; d++)c[d]._setPaused(!1)
        }
        this._setDirtyForNode(a);
        if (!0 === b) {
            c = a.getChildren();
            d = 0;
            for (e = c.length; d < e; d++)this.resumeTarget(c[d], !0)
        }
    }, _addListener: function (a) {
        0 === this._inDispatch ? this._forceAddEventListener(a) :
            this._toAddedListeners.push(a)
    }, _forceAddEventListener: function (a) {
        var b = a._getListenerID(), c = this._listenersMap[b];
        c || (c = new cc._EventListenerVector, this._listenersMap[b] = c);
        c.push(a);
        0 == a._getFixedPriority() ? (this._setDirty(b, this.DIRTY_SCENE_GRAPH_PRIORITY), b = a._getSceneGraphPriority(), null == b && cc.log(cc._LogInfos.eventManager__forceAddEventListener), this._associateNodeAndEventListener(b, a), b.isRunning() && this.resumeTarget(b)) : this._setDirty(b, this.DIRTY_FIXED_PRIORITY)
    }, _getListeners: function (a) {
        return this._listenersMap[a]
    },
    _updateDirtyFlagForSceneGraph: function () {
        if (0 != this._dirtyNodes.length) {
            for (var a = this._dirtyNodes, b, c, d = this._nodeListenersMap, e = 0, f = a.length; e < f; e++)if (b = d[a[e].__instanceId])for (var g = 0, h = b.length; g < h; g++)(c = b[g]) && this._setDirty(c._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY);
            this._dirtyNodes.length = 0
        }
    }, _removeAllListenersInVector: function (a) {
        if (a)for (var b, c = 0; c < a.length;)b = a[c], b._setRegistered(!1), null != b._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(b._getSceneGraphPriority(),
            b), b._setSceneGraphPriority(null)), 0 === this._inDispatch ? cc.arrayRemoveObject(a, b) : ++c
    }, _removeListenersForListenerID: function (a) {
        var b = this._listenersMap[a];
        if (b) {
            var c = b.getFixedPriorityListeners(), d = b.getSceneGraphPriorityListeners();
            this._removeAllListenersInVector(d);
            this._removeAllListenersInVector(c);
            delete this._priorityDirtyFlagMap[a];
            this._inDispatch || (b.clear(), delete this._listenersMap[a])
        }
        c = this._toAddedListeners;
        for (b = 0; b < c.length;)(d = c[b]) && d._getListenerID() == a ? cc.arrayRemoveObject(c,
            d) : ++b
    }, _sortEventListeners: function (a) {
        var b = this.DIRTY_NONE, c = this._priorityDirtyFlagMap;
        c[a] && (b = c[a]);
        b != this.DIRTY_NONE && (c[a] = this.DIRTY_NONE, b & this.DIRTY_FIXED_PRIORITY && this._sortListenersOfFixedPriority(a), b & this.DIRTY_SCENE_GRAPH_PRIORITY && ((b = cc.director.getRunningScene()) ? this._sortListenersOfSceneGraphPriority(a, b) : c[a] = this.DIRTY_SCENE_GRAPH_PRIORITY))
    }, _sortListenersOfSceneGraphPriority: function (a, b) {
        var c = this._getListeners(a);
        if (c) {
            var d = c.getSceneGraphPriorityListeners();
            d && 0 !==
                d.length && (this._nodePriorityIndex = 0, this._nodePriorityMap = {}, this._visitTarget(b, !0), c.getSceneGraphPriorityListeners().sort(this._sortEventListenersOfSceneGraphPriorityDes))
        }
    }, _sortEventListenersOfSceneGraphPriorityDes: function (a, b) {
        var c = cc.eventManager._nodePriorityMap;
        return c[b._getSceneGraphPriority().__instanceId] - c[a._getSceneGraphPriority().__instanceId]
    }, _sortListenersOfFixedPriority: function (a) {
        if (a = this._listenersMap[a]) {
            var b = a.getFixedPriorityListeners();
            if (b && 0 !== b.length) {
                b.sort(this._sortListenersOfFixedPriorityAsc);
                for (var c = 0, d = b.length; c < d && !(0 <= b[c]._getFixedPriority());)++c;
                a.gt0Index = c
            }
        }
    }, _sortListenersOfFixedPriorityAsc: function (a, b) {
        return a._getFixedPriority() - b._getFixedPriority()
    }, _onUpdateListeners: function (a) {
        if (a = this._listenersMap[a]) {
            var b = a.getFixedPriorityListeners(), c = a.getSceneGraphPriorityListeners(), d, e;
            if (c)for (d = 0; d < c.length;)e = c[d], e._isRegistered() ? ++d : cc.arrayRemoveObject(c, e);
            if (b)for (d = 0; d < b.length;)e = b[d], e._isRegistered() ? ++d : cc.arrayRemoveObject(b, e);
            c && 0 === c.length && a.clearSceneGraphListeners();
            b && 0 === b.length && a.clearFixedListeners()
        }
    }, _updateListeners: function (a) {
        var b = this._inDispatch;
        cc.assert(0 < b, cc._LogInfos.EventManager__updateListeners);
        a.getType() == cc.Event.TOUCH ? (this._onUpdateListeners(cc._EventListenerTouchOneByOne.LISTENER_ID), this._onUpdateListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID)) : this._onUpdateListeners(cc.__getListenerID(a));
        if (!(1 < b)) {
            cc.assert(1 == b, cc._LogInfos.EventManager__updateListeners_2);
            a = this._listenersMap;
            var b = this._priorityDirtyFlagMap, c;
            for (c in a)a[c].empty() &&
            (delete b[c], delete a[c]);
            c = this._toAddedListeners;
            if (0 !== c.length) {
                a = 0;
                for (b = c.length; a < b; a++)this._forceAddEventListener(c[a]);
                this._toAddedListeners.length = 0
            }
        }
    }, _onTouchEventCallback: function (a, b) {
        if (!a._isRegistered)return!1;
        var c = b.event, d = b.selTouch;
        c._setCurrentTarget(a._node);
        var e = !1, f, g = c.getEventCode(), h = cc.EventTouch.EventCode;
        if (g == h.BEGAN)a.onTouchBegan && (e = a.onTouchBegan(d, c)) && a._registered && a._claimedTouches.push(d); else if (0 < a._claimedTouches.length && -1 != (f = a._claimedTouches.indexOf(d)))if (e = !0, g === h.MOVED && a.onTouchMoved)a.onTouchMoved(d, c); else if (g === h.ENDED) {
            if (a.onTouchEnded)a.onTouchEnded(d, c);
            a._registered && a._claimedTouches.splice(f, 1)
        } else if (g === h.CANCELLED) {
            if (a.onTouchCancelled)a.onTouchCancelled(d, c);
            a._registered && a._claimedTouches.splice(f, 1)
        }
        return c.isStopped() ? (cc.eventManager._updateListeners(c), !0) : e && a._registered && a.swallowTouches ? (b.needsMutableSet && b.touches.splice(d, 1), !0) : !1
    }, _dispatchTouchEvent: function (a) {
        this._sortEventListeners(cc._EventListenerTouchOneByOne.LISTENER_ID);
        this._sortEventListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
        var b = this._getListeners(cc._EventListenerTouchOneByOne.LISTENER_ID), c = this._getListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
        if (!(null == b && null == c)) {
            var d = a.getTouches(), e = cc.copyArray(d), f = {event: a, needsMutableSet: b && c, touches: e, selTouch: null};
            if (b)for (var g = 0; g < d.length; g++)if (f.selTouch = d[g], this._dispatchEventToListeners(b, this._onTouchEventCallback, f), a.isStopped())return;
            if (c && 0 < e.length && (this._dispatchEventToListeners(c,
                this._onTouchesEventCallback, {event: a, touches: e}), a.isStopped()))return;
            this._updateListeners(a)
        }
    }, _onTouchesEventCallback: function (a, b) {
        if (!a._registered)return!1;
        var c = cc.EventTouch.EventCode, d = b.event, e = b.touches, f = d.getEventCode();
        d._setCurrentTarget(a._node);
        if (f == c.BEGAN && a.onTouchesBegan)a.onTouchesBegan(e, d); else if (f == c.MOVED && a.onTouchesMoved)a.onTouchesMoved(e, d); else if (f == c.ENDED && a.onTouchesEnded)a.onTouchesEnded(e, d); else if (f == c.CANCELLED && a.onTouchesCancelled)a.onTouchesCancelled(e,
            d);
        return d.isStopped() ? (cc.eventManager._updateListeners(d), !0) : !1
    }, _associateNodeAndEventListener: function (a, b) {
        var c = this._nodeListenersMap[a.__instanceId];
        c || (c = [], this._nodeListenersMap[a.__instanceId] = c);
        c.push(b)
    }, _dissociateNodeAndEventListener: function (a, b) {
        var c = this._nodeListenersMap[a.__instanceId];
        c && (cc.arrayRemoveObject(c, b), 0 === c.length && delete this._nodeListenersMap[a.__instanceId])
    }, _dispatchEventToListeners: function (a, b, c) {
        var d = !1, e = a.getFixedPriorityListeners(), f = a.getSceneGraphPriorityListeners(),
            g = 0, h;
        if (e && 0 !== e.length)for (; g < a.gt0Index; ++g)if (h = e[g], h.isEnabled() && !h._isPaused() && h._isRegistered() && b(h, c)) {
            d = !0;
            break
        }
        if (f && !d)for (a = 0; a < f.length; a++)if (h = f[a], h.isEnabled() && !h._isPaused() && h._isRegistered() && b(h, c)) {
            d = !0;
            break
        }
        if (e && !d)for (; g < e.length && !(h = e[g], h.isEnabled() && !h._isPaused() && h._isRegistered() && b(h, c)); ++g);
    }, _setDirty: function (a, b) {
        var c = this._priorityDirtyFlagMap;
        c[a] = null == c[a] ? b : b | c[a]
    }, _visitTarget: function (a, b) {
        var c = a.getChildren(), d = 0, e = c.length, f = this._globalZOrderNodeMap,
            g = this._nodeListenersMap;
        if (0 < e) {
            for (var h; d < e; d++)if ((h = c[d]) && 0 > h.getLocalZOrder())this._visitTarget(h, !1); else break;
            null != g[a.__instanceId] && (f[a.getGlobalZOrder()] || (f[a.getGlobalZOrder()] = []), f[a.getGlobalZOrder()].push(a.__instanceId));
            for (; d < e; d++)(h = c[d]) && this._visitTarget(h, !1)
        } else null != g[a.__instanceId] && (f[a.getGlobalZOrder()] || (f[a.getGlobalZOrder()] = []), f[a.getGlobalZOrder()].push(a.__instanceId));
        if (b) {
            var c = [], k;
            for (k in f)c.push(k);
            c.sort(this._sortNumberAsc);
            k = c.length;
            h = this._nodePriorityMap;
            for (d = 0; d < k; d++) {
                e = f[c[d]];
                for (g = 0; g < e.length; g++)h[e[g]] = ++this._nodePriorityIndex
            }
            this._globalZOrderNodeMap = {}
        }
    }, _sortNumberAsc: function (a, b) {
        return a - b
    }, addListener: function (a, b) {
        cc.assert(a && b, cc._LogInfos.eventManager_addListener_2);
        if (a instanceof cc.EventListener) {
            if (a._isRegistered()) {
                cc.log(cc._LogInfos.eventManager_addListener_4);
                return
            }
        } else cc.assert("number" !== typeof b, cc._LogInfos.eventManager_addListener_3), a = cc.EventListener.create(a);
        a.checkAvailable() && ("number" == typeof b ? 0 == b ? cc.log(cc._LogInfos.eventManager_addListener) :
            (a._setSceneGraphPriority(null), a._setFixedPriority(b), a._setRegistered(!0), a._setPaused(!1), this._addListener(a)) : (a._setSceneGraphPriority(b), a._setFixedPriority(0), a._setRegistered(!0), this._addListener(a)))
    }, addCustomListener: function (a, b) {
        var c = cc._EventListenerCustom.create(a, b);
        this.addListener(c, 1);
        return c
    }, removeListener: function (a) {
        if (null != a) {
            var b, c = this._listenersMap, d;
            for (d in c) {
                var e = c[d], f = e.getFixedPriorityListeners();
                b = e.getSceneGraphPriorityListeners();
                (b = this._removeListenerInVector(b,
                    a)) ? this._setDirty(a._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY) : (b = this._removeListenerInVector(f, a)) && this._setDirty(a._getListenerID(), this.DIRTY_FIXED_PRIORITY);
                e.empty() && (delete this._priorityDirtyFlagMap[a._getListenerID()], delete c[d]);
                if (b)break
            }
            if (!b) {
                c = this._toAddedListeners;
                d = 0;
                for (e = c.length; d < e; d++)if (f = c[d], f == a) {
                    cc.arrayRemoveObject(c, f);
                    break
                }
            }
        }
    }, _removeListenerInVector: function (a, b) {
        if (null == a)return!1;
        for (var c = 0, d = a.length; c < d; c++) {
            var e = a[c];
            if (e == b)return e._setRegistered(!1),
                null != e._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(e._getSceneGraphPriority(), e), e._setSceneGraphPriority(null)), 0 == this._inDispatch && cc.arrayRemoveObject(a, e), !0
        }
        return!1
    }, removeListeners: function (a, b) {
        if (a instanceof cc.Node) {
            delete this._nodePriorityMap[a.__instanceId];
            cc.arrayRemoveObject(this._dirtyNodes, a);
            var c = this._nodeListenersMap[a.__instanceId];
            if (c) {
                for (var d = cc.copyArray(c), c = 0; c < d.length; c++)this.removeListener(d[c]);
                d.length = 0;
                d = this._toAddedListeners;
                for (c = 0; c <
                    d.length;) {
                    var e = d[c];
                    e._getSceneGraphPriority() == a ? (e._setSceneGraphPriority(null), e._setRegistered(!1), d.splice(c, 1)) : ++c
                }
                if (!0 === b) {
                    d = a.getChildren();
                    c = 0;
                    for (e = d.length; c < e; c++)this.removeListeners(d[c], !0)
                }
            }
        } else a == cc.EventListener.TOUCH_ONE_BY_ONE ? this._removeListenersForListenerID(cc._EventListenerTouchOneByOne.LISTENER_ID) : a == cc.EventListener.TOUCH_ALL_AT_ONCE ? this._removeListenersForListenerID(cc._EventListenerTouchAllAtOnce.LISTENER_ID) : a == cc.EventListener.MOUSE ? this._removeListenersForListenerID(cc._EventListenerMouse.LISTENER_ID) :
                a == cc.EventListener.ACCELERATION ? this._removeListenersForListenerID(cc._EventListenerAcceleration.LISTENER_ID) : a == cc.EventListener.KEYBOARD ? this._removeListenersForListenerID(cc._EventListenerKeyboard.LISTENER_ID) : cc.log(cc._LogInfos.eventManager_removeListeners)
    }, removeCustomListeners: function (a) {
        this._removeListenersForListenerID(a)
    }, removeAllListeners: function () {
        var a = this._listenersMap, b = this._internalCustomListenerIDs, c;
        for (c in a)-1 === b.indexOf(c) && this._removeListenersForListenerID(c)
    }, setPriority: function (a, b) {
        if (null != a) {
            var c = this._listenersMap, d;
            for (d in c) {
                var e = c[d].getFixedPriorityListeners();
                if (e && -1 != e.indexOf(a)) {
                    null != a._getSceneGraphPriority() && cc.log(cc._LogInfos.eventManager_setPriority);
                    a._getFixedPriority() !== b && (a._setFixedPriority(b), this._setDirty(a._getListenerID(), this.DIRTY_FIXED_PRIORITY));
                    break
                }
            }
        }
    }, setEnabled: function (a) {
        this._isEnabled = a
    }, isEnabled: function () {
        return this._isEnabled
    }, dispatchEvent: function (a) {
        if (this._isEnabled) {
            this._updateDirtyFlagForSceneGraph();
            this._inDispatch++;
            if (!a || !a.getType)throw"event is undefined";
            if (a.getType() == cc.Event.TOUCH)this._dispatchTouchEvent(a); else {
                var b = cc.__getListenerID(a);
                this._sortEventListeners(b);
                b = this._listenersMap[b];
                null != b && this._dispatchEventToListeners(b, this._onListenerCallback, a);
                this._updateListeners(a)
            }
            this._inDispatch--
        }
    }, _onListenerCallback: function (a, b) {
        b._setCurrentTarget(a._getSceneGraphPriority());
        a._onEvent(b);
        return b.isStopped()
    }, dispatchCustomEvent: function (a, b) {
        var c = new cc.EventCustom(a);
        c.setUserData(b);
        this.dispatchEvent(c)
    }};
cc._tmp.PrototypeCCNode = function () {
    var a = cc.Node.prototype;
    cc.defineGetterSetter(a, "x", a.getPositionX, a.setPositionX);
    cc.defineGetterSetter(a, "y", a.getPositionY, a.setPositionY);
    cc.defineGetterSetter(a, "width", a._getWidth, a._setWidth);
    cc.defineGetterSetter(a, "height", a._getHeight, a._setHeight);
    cc.defineGetterSetter(a, "anchorX", a._getAnchorX, a._setAnchorX);
    cc.defineGetterSetter(a, "anchorY", a._getAnchorY, a._setAnchorY);
    cc.defineGetterSetter(a, "skewX", a.getSkewX, a.setSkewX);
    cc.defineGetterSetter(a, "skewY",
        a.getSkewY, a.setSkewY);
    cc.defineGetterSetter(a, "zIndex", a.getLocalZOrder, a.setLocalZOrder);
    cc.defineGetterSetter(a, "vertexZ", a.getVertexZ, a.setVertexZ);
    cc.defineGetterSetter(a, "rotation", a.getRotation, a.setRotation);
    cc.defineGetterSetter(a, "rotationX", a.getRotationX, a.setRotationX);
    cc.defineGetterSetter(a, "rotationY", a.getRotationY, a.setRotationY);
    cc.defineGetterSetter(a, "scale", a.getScale, a.setScale);
    cc.defineGetterSetter(a, "scaleX", a.getScaleX, a.setScaleX);
    cc.defineGetterSetter(a, "scaleY", a.getScaleY,
        a.setScaleY);
    cc.defineGetterSetter(a, "children", a.getChildren);
    cc.defineGetterSetter(a, "childrenCount", a.getChildrenCount);
    cc.defineGetterSetter(a, "parent", a.getParent, a.setParent);
    cc.defineGetterSetter(a, "visible", a.isVisible, a.setVisible);
    cc.defineGetterSetter(a, "running", a.isRunning);
    cc.defineGetterSetter(a, "ignoreAnchor", a.isIgnoreAnchorPointForPosition, a.ignoreAnchorPointForPosition);
    cc.defineGetterSetter(a, "actionManager", a.getActionManager, a.setActionManager);
    cc.defineGetterSetter(a, "scheduler",
        a.getScheduler, a.setScheduler);
    cc.defineGetterSetter(a, "shaderProgram", a.getShaderProgram, a.setShaderProgram);
    cc.defineGetterSetter(a, "glServerState", a.getGLServerState, a.setGLServerState)
};
cc._tmp.PrototypeCCNodeRGBA = function () {
    var a = cc.NodeRGBA.prototype;
    cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity);
    cc.defineGetterSetter(a, "opacityModifyRGB", a.isOpacityModifyRGB, a.setOpacityModifyRGB);
    cc.defineGetterSetter(a, "cascadeOpacity", a.isCascadeOpacityEnabled, a.setCascadeOpacityEnabled);
    cc.defineGetterSetter(a, "color", a.getColor, a.setColor);
    cc.defineGetterSetter(a, "cascadeColor", a.isCascadeColorEnabled, a.setCascadeColorEnabled)
};
cc.NODE_TAG_INVALID = -1;
cc.s_globalOrderOfArrival = 1;
cc.Node = cc.Class.extend({_localZOrder: 0, _globalZOrder: 0, _vertexZ: 0, _rotationX: 0, _rotationY: 0, _scaleX: 1, _scaleY: 1, _position: null, _skewX: 0, _skewY: 0, _children: null, _visible: !0, _anchorPoint: null, _anchorPointInPoints: null, _contentSize: null, _running: !1, _parent: null, _ignoreAnchorPointForPosition: !1, tag: cc.NODE_TAG_INVALID, userData: null, userObject: null, _transformDirty: !0, _inverseDirty: !0, _cacheDirty: !0, _cachedParent: null, _transformGLDirty: null, _transform: null, _inverse: null, _reorderChildDirty: !1, _shaderProgram: null,
    arrivalOrder: 0, _actionManager: null, _scheduler: null, _eventDispatcher: null, _initializedNode: !1, _additionalTransformDirty: !1, _additionalTransform: null, _componentContainer: null, _isTransitionFinished: !1, _rotationRadiansX: 0, _rotationRadiansY: 0, _className: "Node", _showNode: !1, _name: "", _initNode: function () {
        this._anchorPoint = cc.p(0, 0);
        this._anchorPointInPoints = cc.p(0, 0);
        this._contentSize = cc.size(0, 0);
        this._position = cc.p(0, 0);
        this._children = [];
        this._transform = {a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0};
        var a = cc.director;
        this._actionManager =
            a.getActionManager();
        this._scheduler = a.getScheduler();
        this._initializedNode = !0;
        this._additionalTransform = cc.AffineTransformMakeIdentity();
        cc.ComponentContainer && (this._componentContainer = new cc.ComponentContainer(this))
    }, init: function () {
        !1 === this._initializedNode && this._initNode();
        return!0
    }, _arrayMakeObjectsPerformSelector: function (a, b) {
        if (a && 0 !== a.length) {
            var c, d = a.length, e;
            c = cc.Node.StateCallbackType;
            switch (b) {
                case c.onEnter:
                    for (c = 0; c < d; c++)if (e = a[c])e.onEnter();
                    break;
                case c.onExit:
                    for (c = 0; c < d; c++)if (e =
                        a[c])e.onExit();
                    break;
                case c.onEnterTransitionDidFinish:
                    for (c = 0; c < d; c++)if (e = a[c])e.onEnterTransitionDidFinish();
                    break;
                case c.cleanup:
                    for (c = 0; c < d; c++)(e = a[c]) && e.cleanup();
                    break;
                case c.updateTransform:
                    for (c = 0; c < d; c++)(e = a[c]) && e.updateTransform();
                    break;
                case c.onExitTransitionDidStart:
                    for (c = 0; c < d; c++)if (e = a[c])e.onExitTransitionDidStart();
                    break;
                case c.sortAllChildren:
                    for (c = 0; c < d; c++)(e = a[c]) && e.sortAllChildren();
                    break;
                default:
                    cc.assert(0, cc._LogInfos.Node__arrayMakeObjectsPerformSelector)
            }
        }
    }, setNodeDirty: null,
    attr: function (a) {
        for (var b in a)this[b] = a[b]
    }, getSkewX: function () {
        return this._skewX
    }, setSkewX: function (a) {
        this._skewX = a;
        this.setNodeDirty()
    }, getSkewY: function () {
        return this._skewY
    }, setSkewY: function (a) {
        this._skewY = a;
        this.setNodeDirty()
    }, setLocalZOrder: function (a) {
        this._localZOrder = a;
        this._parent && this._parent.reorderChild(this, a);
        cc.eventManager._setDirtyForNode(this)
    }, _setLocalZOrder: function (a) {
        this._localZOrder = a
    }, getLocalZOrder: function () {
        return this._localZOrder
    }, getZOrder: function () {
        cc.log(cc._LogInfos.Node_getZOrder);
        return this.getLocalZOrder()
    }, setZOrder: function (a) {
        cc.log(cc._LogInfos.Node_setZOrder);
        this.setLocalZOrder(a)
    }, setGlobalZOrder: function (a) {
        this._globalZOrder != a && (this._globalZOrder = a, cc.eventManager._setDirtyForNode(this))
    }, getGlobalZOrder: function () {
        return this._globalZOrder
    }, getVertexZ: function () {
        return this._vertexZ
    }, setVertexZ: function (a) {
        this._vertexZ = a
    }, getRotation: function () {
        this._rotationX !== this._rotationY && cc.log(cc._LogInfos.Node_getRotation);
        return this._rotationX
    }, setRotation: function (a) {
        this._rotationX =
            this._rotationY = a;
        this._rotationRadiansX = 0.017453292519943295 * this._rotationX;
        this._rotationRadiansY = 0.017453292519943295 * this._rotationY;
        this.setNodeDirty()
    }, getRotationX: function () {
        return this._rotationX
    }, setRotationX: function (a) {
        this._rotationX = a;
        this._rotationRadiansX = 0.017453292519943295 * this._rotationX;
        this.setNodeDirty()
    }, getRotationY: function () {
        return this._rotationY
    }, setRotationY: function (a) {
        this._rotationY = a;
        this._rotationRadiansY = 0.017453292519943295 * this._rotationY;
        this.setNodeDirty()
    },
    getScale: function () {
        this._scaleX !== this._scaleY && cc.log(cc._LogInfos.Node_getScale);
        return this._scaleX
    }, setScale: function (a, b) {
        this._scaleX = a;
        this._scaleY = b || 0 === b ? b : a;
        this.setNodeDirty()
    }, getScaleX: function () {
        return this._scaleX
    }, setScaleX: function (a) {
        this._scaleX = a;
        this.setNodeDirty()
    }, getScaleY: function () {
        return this._scaleY
    }, setScaleY: function (a) {
        this._scaleY = a;
        this.setNodeDirty()
    }, setPosition: function (a, b) {
        var c = this._position;
        void 0 === b ? (c.x = a.x, c.y = a.y) : (c.x = a, c.y = b);
        this.setNodeDirty()
    },
    getPosition: function () {
        return cc.p(this._position)
    }, getPositionX: function () {
        return this._position.x
    }, setPositionX: function (a) {
        this._position.x = a;
        this.setNodeDirty()
    }, getPositionY: function () {
        return this._position.y
    }, setPositionY: function (a) {
        this._position.y = a;
        this.setNodeDirty()
    }, getChildrenCount: function () {
        return this._children.length
    }, getChildren: function () {
        return this._children
    }, isVisible: function () {
        return this._visible
    }, setVisible: function (a) {
        this._visible = a;
        this.setNodeDirty()
    }, getAnchorPoint: function () {
        return this._anchorPoint
    },
    setAnchorPoint: function (a, b) {
        var c = this._anchorPoint;
        if (void 0 === b) {
            if (a.x === c.x && a.y === c.y)return;
            c.x = a.x;
            c.y = a.y
        } else {
            if (a === c.x && b === c.y)return;
            c.x = a;
            c.y = b
        }
        var d = this._anchorPointInPoints, e = this._contentSize;
        d.x = e.width * c.x;
        d.y = e.height * c.y;
        this.setNodeDirty()
    }, _getAnchor: function () {
        return this._anchorPoint
    }, _setAnchor: function (a) {
        var b = a.x;
        a = a.y;
        this._anchorPoint.x !== b && (this._anchorPoint.x = b, this._anchorPointInPoints.x = this._contentSize.width * b);
        this._anchorPoint.y !== a && (this._anchorPoint.y =
            a, this._anchorPointInPoints.y = this._contentSize.height * a);
        this.setNodeDirty()
    }, _getAnchorX: function () {
        return this._anchorPoint.x
    }, _setAnchorX: function (a) {
        this._anchorPoint.x !== a && (this._anchorPoint.x = a, this._anchorPointInPoints.x = this._contentSize.width * a, this.setNodeDirty())
    }, _getAnchorY: function () {
        return this._anchorPoint.y
    }, _setAnchorY: function (a) {
        this._anchorPoint.y !== a && (this._anchorPoint.y = a, this._anchorPointInPoints.y = this._contentSize.height * a, this.setNodeDirty())
    }, getAnchorPointInPoints: function () {
        return this._anchorPointInPoints
    },
    _getWidth: function () {
        return this._contentSize.width
    }, _setWidth: function (a) {
        this._contentSize.width = a;
        this._anchorPointInPoints.x = a * this._anchorPoint.x;
        this.setNodeDirty()
    }, _getHeight: function () {
        return this._contentSize.height
    }, _setHeight: function (a) {
        this._contentSize.height = a;
        this._anchorPointInPoints.y = a * this._anchorPoint.y;
        this.setNodeDirty()
    }, getContentSize: function () {
        return this._contentSize
    }, setContentSize: function (a, b) {
        var c = this._contentSize;
        if (void 0 === b) {
            if (a.width === c.width && a.height ===
                c.height)return;
            c.width = a.width;
            c.height = a.height
        } else {
            if (a === c.width && b === c.height)return;
            c.width = a;
            c.height = b
        }
        var d = this._anchorPointInPoints, e = this._anchorPoint;
        d.x = c.width * e.x;
        d.y = c.height * e.y;
        this.setNodeDirty()
    }, isRunning: function () {
        return this._running
    }, getParent: function () {
        return this._parent
    }, setParent: function (a) {
        this._parent = a
    }, isIgnoreAnchorPointForPosition: function () {
        return this._ignoreAnchorPointForPosition
    }, ignoreAnchorPointForPosition: function (a) {
        a != this._ignoreAnchorPointForPosition &&
        (this._ignoreAnchorPointForPosition = a, this.setNodeDirty())
    }, getTag: function () {
        return this.tag
    }, setTag: function (a) {
        this.tag = a
    }, setName: function (a) {
        this._name
    }, getName: function () {
        return this._name
    }, getUserData: function () {
        return this.userData
    }, setUserData: function (a) {
        this.userData = a
    }, getUserObject: function () {
        return this.userObject
    }, setUserObject: function (a) {
        this.userObject != a && (this.userObject = a)
    }, getOrderOfArrival: function () {
        return this.arrivalOrder
    }, setOrderOfArrival: function (a) {
        this.arrivalOrder =
            a
    }, getActionManager: function () {
        this._actionManager || (this._actionManager = cc.director.getActionManager());
        return this._actionManager
    }, setActionManager: function (a) {
        this._actionManager != a && (this.stopAllActions(), this._actionManager = a)
    }, getScheduler: function () {
        this._scheduler || (this._scheduler = cc.director.getScheduler());
        return this._scheduler
    }, setScheduler: function (a) {
        this._scheduler != a && (this.unscheduleAllCallbacks(), this._scheduler = a)
    }, getBoundingBox: function () {
        var a = cc.rect(0, 0, this._contentSize.width,
            this._contentSize.height);
        return cc._RectApplyAffineTransformIn(a, this.nodeToParentTransform())
    }, cleanup: function () {
        this.stopAllActions();
        this.unscheduleAllCallbacks();
        cc.eventManager.removeListeners(this);
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.cleanup)
    }, getChildByTag: function (a) {
        var b = this._children;
        if (null != b)for (var c = 0; c < b.length; c++) {
            var d = b[c];
            if (d && d.tag == a)return d
        }
        return null
    }, getChildByName: function (a) {
        if (!a)return cc.log("Invalid name"), null;
        for (var b =
            this._children, c = 0, d = b.length; c < d; c++)if (b[c]._name == a)return b[c];
        return null
    }, addChild: function (a, b, c) {
        cc.assert(a, cc._LogInfos.Node_addChild_3);
        if (a === this)cc.log(cc._LogInfos.Node_addChild); else if (null !== a._parent)cc.log(cc._LogInfos.Node_addChild_2); else if (b = null != b ? b : a._localZOrder, a.tag = null != c ? c : a.tag, this._insertChild(a, b), a._parent = this, this._cachedParent && (a._cachedParent = this._cachedParent), this._running && (a.onEnter(), this._isTransitionFinished))a.onEnterTransitionDidFinish()
    }, removeFromParent: function (a) {
        this._parent &&
        (null == a && (a = !0), this._parent.removeChild(this, a))
    }, removeFromParentAndCleanup: function (a) {
        cc.log(cc._LogInfos.Node_removeFromParentAndCleanup);
        this.removeFromParent(a)
    }, removeChild: function (a, b) {
        0 !== this._children.length && (null == b && (b = !0), -1 < this._children.indexOf(a) && this._detachChild(a, b), this.setNodeDirty())
    }, removeChildByTag: function (a, b) {
        a === cc.NODE_TAG_INVALID && cc.log(cc._LogInfos.Node_removeChildByTag);
        var c = this.getChildByTag(a);
        null == c ? cc.log(cc._LogInfos.Node_removeChildByTag_2, a) : this.removeChild(c,
            b)
    }, removeAllChildrenWithCleanup: function (a) {
        cc.log(cc._LogInfos.Node_removeAllChildrenWithCleanup);
        this.removeAllChildren(a)
    }, removeAllChildren: function (a) {
        var b = this._children;
        if (null != b) {
            null == a && (a = !0);
            for (var c = 0; c < b.length; c++) {
                var d = b[c];
                d && (this._running && (d.onExitTransitionDidStart(), d.onExit()), a && d.cleanup(), d.parent = null)
            }
            this._children.length = 0
        }
    }, _detachChild: function (a, b) {
        this._running && (a.onExitTransitionDidStart(), a.onExit());
        b && a.cleanup();
        a.parent = null;
        cc.arrayRemoveObject(this._children,
            a)
    }, _insertChild: function (a, b) {
        this._reorderChildDirty = !0;
        this._children.push(a);
        a._setLocalZOrder(b)
    }, reorderChild: function (a, b) {
        cc.assert(a, cc._LogInfos.Node_reorderChild);
        this._reorderChildDirty = !0;
        a.arrivalOrder = cc.s_globalOrderOfArrival;
        cc.s_globalOrderOfArrival++;
        a._setLocalZOrder(b);
        this.setNodeDirty()
    }, sortAllChildren: function () {
        if (this._reorderChildDirty) {
            var a = this._children, b = a.length, c, d, e;
            for (c = 1; c < b; c++) {
                e = a[c];
                for (d = c - 1; 0 <= d;) {
                    if (e._localZOrder < a[d]._localZOrder)a[d + 1] = a[d]; else if (e._localZOrder ===
                        a[d]._localZOrder && e.arrivalOrder < a[d].arrivalOrder)a[d + 1] = a[d]; else break;
                    d--
                }
                a[d + 1] = e
            }
            this._reorderChildDirty = !1
        }
    }, draw: function (a) {
    }, transformAncestors: function () {
        null != this._parent && (this._parent.transformAncestors(), this._parent.transform())
    }, onEnter: function () {
        this._isTransitionFinished = !1;
        this._running = !0;
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.onEnter);
        this.resume()
    }, onEnterTransitionDidFinish: function () {
        this._isTransitionFinished = !0;
        this._arrayMakeObjectsPerformSelector(this._children,
            cc.Node.StateCallbackType.onEnterTransitionDidFinish)
    }, onExitTransitionDidStart: function () {
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.onExitTransitionDidStart)
    }, onExit: function () {
        this._running = !1;
        this.pause();
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.onExit);
        this._componentContainer && this._componentContainer.removeAll()
    }, runAction: function (a) {
        cc.assert(a, cc._LogInfos.Node_runAction);
        this.actionManager.addAction(a, this, !this._running);
        return a
    }, stopAllActions: function () {
        this.actionManager && this.actionManager.removeAllActionsFromTarget(this)
    }, stopAction: function (a) {
        this.actionManager.removeAction(a)
    }, stopActionByTag: function (a) {
        a === cc.ACTION_TAG_INVALID ? cc.log(cc._LogInfos.Node_stopActionByTag) : this.actionManager.removeActionByTag(a, this)
    }, getActionByTag: function (a) {
        return a === cc.ACTION_TAG_INVALID ? (cc.log(cc._LogInfos.Node_getActionByTag), null) : this.actionManager.getActionByTag(a, this)
    }, getNumberOfRunningActions: function () {
        return this.actionManager.numberOfRunningActionsInTarget(this)
    },
    scheduleUpdate: function () {
        this.scheduleUpdateWithPriority(0)
    }, scheduleUpdateWithPriority: function (a) {
        this.scheduler.scheduleUpdateForTarget(this, a, !this._running)
    }, unscheduleUpdate: function () {
        this.scheduler.unscheduleUpdateForTarget(this)
    }, schedule: function (a, b, c, d) {
        b = b || 0;
        cc.assert(a, cc._LogInfos.Node_schedule);
        cc.assert(0 <= b, cc._LogInfos.Node_schedule_2);
        c = null == c ? cc.REPEAT_FOREVER : c;
        this.scheduler.scheduleCallbackForTarget(this, a, b, c, d || 0, !this._running)
    }, scheduleOnce: function (a, b) {
        this.schedule(a,
            0, 0, b)
    }, unschedule: function (a) {
        a && this.scheduler.unscheduleCallbackForTarget(this, a)
    }, unscheduleAllCallbacks: function () {
        this.scheduler.unscheduleAllCallbacksForTarget(this)
    }, resumeSchedulerAndActions: function () {
        cc.log(cc._LogInfos.Node_resumeSchedulerAndActions);
        this.resume()
    }, resume: function () {
        this.scheduler.resumeTarget(this);
        this.actionManager && this.actionManager.resumeTarget(this);
        cc.eventManager.resumeTarget(this)
    }, pauseSchedulerAndActions: function () {
        cc.log(cc._LogInfos.Node_pauseSchedulerAndActions);
        this.pause()
    }, pause: function () {
        this.scheduler.pauseTarget(this);
        this.actionManager && this.actionManager.pauseTarget(this);
        cc.eventManager.pauseTarget(this)
    }, setAdditionalTransform: function (a) {
        this._additionalTransform = a;
        this._additionalTransformDirty = this._transformDirty = !0
    }, parentToNodeTransform: function () {
        this._inverseDirty && (this._inverse = cc.AffineTransformInvert(this.nodeToParentTransform()), this._inverseDirty = !1);
        return this._inverse
    }, nodeToWorldTransform: function () {
        for (var a = this.nodeToParentTransform(),
                 b = this._parent; null != b; b = b.parent)a = cc.AffineTransformConcat(a, b.nodeToParentTransform());
        return a
    }, worldToNodeTransform: function () {
        return cc.AffineTransformInvert(this.nodeToWorldTransform())
    }, convertToNodeSpace: function (a) {
        return cc.PointApplyAffineTransform(a, this.worldToNodeTransform())
    }, convertToWorldSpace: function (a) {
        a = a || cc.p(0, 0);
        return cc.PointApplyAffineTransform(a, this.nodeToWorldTransform())
    }, convertToNodeSpaceAR: function (a) {
        return cc.pSub(this.convertToNodeSpace(a), this._anchorPointInPoints)
    },
    convertToWorldSpaceAR: function (a) {
        a = a || cc.p(0, 0);
        a = cc.pAdd(a, this._anchorPointInPoints);
        return this.convertToWorldSpace(a)
    }, _convertToWindowSpace: function (a) {
        a = this.convertToWorldSpace(a);
        return cc.director.convertToUI(a)
    }, convertTouchToNodeSpace: function (a) {
        a = a.getLocation();
        return this.convertToNodeSpace(a)
    }, convertTouchToNodeSpaceAR: function (a) {
        a = a.getLocation();
        a = cc.director.convertToGL(a);
        return this.convertToNodeSpaceAR(a)
    }, update: function (a) {
        this._componentContainer && !this._componentContainer.isEmpty() &&
        this._componentContainer.visit(a)
    }, updateTransform: function () {
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.updateTransform)
    }, retain: function () {
    }, release: function () {
    }, getComponent: function (a) {
        return this._componentContainer.getComponent(a)
    }, addComponent: function (a) {
        this._componentContainer.add(a)
    }, removeComponent: function (a) {
        return this._componentContainer.remove(a)
    }, removeAllComponents: function () {
        this._componentContainer.removeAll()
    }, grid: null, ctor: null, visit: null,
    transform: null, nodeToParentTransform: null, _setNodeDirtyForCache: function () {
        if (!1 === this._cacheDirty) {
            this._cacheDirty = !0;
            var a = this._cachedParent;
            a && a != this && a._setNodeDirtyForCache()
        }
    }, _setCachedParent: function (a) {
        if (this._cachedParent != a) {
            this._cachedParent = a;
            for (var b = this._children, c = 0, d = b.length; c < d; c++)b[c]._setCachedParent(a)
        }
    }, getCamera: function () {
        this._camera || (this._camera = new cc.Camera);
        return this._camera
    }, getGrid: function () {
        return this.grid
    }, setGrid: function (a) {
        this.grid = a
    }, getShaderProgram: function () {
        return this._shaderProgram
    },
    setShaderProgram: function (a) {
        this._shaderProgram = a
    }, getGLServerState: function () {
        return this._glServerState
    }, setGLServerState: function (a) {
        this._glServerState = a
    }, getBoundingBoxToWorld: function () {
        var a = cc.rect(0, 0, this._contentSize.width, this._contentSize.height), b = this.nodeToWorldTransform(), a = cc.RectApplyAffineTransform(a, this.nodeToWorldTransform());
        if (!this._children)return a;
        for (var c = this._children, d = 0; d < c.length; d++) {
            var e = c[d];
            e && e._visible && (e = e._getBoundingBoxToCurrentNode(b)) && (a = cc.rectUnion(a,
                e))
        }
        return a
    }, _getBoundingBoxToCurrentNode: function (a) {
        var b = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        a = null == a ? this.nodeToParentTransform() : cc.AffineTransformConcat(this.nodeToParentTransform(), a);
        b = cc.RectApplyAffineTransform(b, a);
        if (!this._children)return b;
        for (var c = this._children, d = 0; d < c.length; d++) {
            var e = c[d];
            e && e._visible && (e = e._getBoundingBoxToCurrentNode(a)) && (b = cc.rectUnion(b, e))
        }
        return b
    }, _nodeToParentTransformForWebGL: function () {
        if (this._transformDirty) {
            var a = this._position.x,
                b = this._position.y, c = this._anchorPointInPoints.x, d = -c, e = this._anchorPointInPoints.y, f = -e, g = this._scaleX, h = this._scaleY;
            this._ignoreAnchorPointForPosition && (a += c, b += e);
            var k = 1, l = 0, m = 1, n = 0;
            if (0 !== this._rotationX || 0 !== this._rotationY)k = Math.cos(-this._rotationRadiansX), l = Math.sin(-this._rotationRadiansX), m = Math.cos(-this._rotationRadiansY), n = Math.sin(-this._rotationRadiansY);
            var q = this._skewX || this._skewY;
            if (!q && (0 !== c || 0 !== e))a += m * d * g + -l * f * h, b += n * d * g + k * f * h;
            var r = this._transform;
            r.a = m * g;
            r.b = n * g;
            r.c =
                -l * h;
            r.d = k * h;
            r.tx = a;
            r.ty = b;
            if (q && (r = cc.AffineTransformConcat({a: 1, b: Math.tan(cc.degreesToRadians(this._skewY)), c: Math.tan(cc.degreesToRadians(this._skewX)), d: 1, tx: 0, ty: 0}, r), 0 !== c || 0 !== e))r = cc.AffineTransformTranslate(r, d, f);
            this._additionalTransformDirty && (r = cc.AffineTransformConcat(r, this._additionalTransform), this._additionalTransformDirty = !1);
            this._transform = r;
            this._transformDirty = !1
        }
        return this._transform
    }});
cc.Node.create = function () {
    return new cc.Node
};
cc.Node.StateCallbackType = {onEnter: 1, onExit: 2, cleanup: 3, onEnterTransitionDidFinish: 4, updateTransform: 5, onExitTransitionDidStart: 6, sortAllChildren: 7};
if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
    var _p = cc.Node.prototype;
    _p.ctor = function () {
        this._initNode()
    };
    _p.setNodeDirty = function () {
        this._setNodeDirtyForCache();
        !1 === this._transformDirty && (this._transformDirty = this._inverseDirty = !0)
    };
    _p.visit = function (a) {
        if (this._visible) {
            a = a || cc._renderContext;
            var b, c = this._children, d;
            a.save();
            this.transform(a);
            var e = c.length;
            if (0 < e) {
                this.sortAllChildren();
                for (b = 0; b < e; b++)if (d = c[b], 0 > d._localZOrder)d.visit(a); else break;
                for (this.draw(a); b < e; b++)c[b].visit(a)
            } else this.draw(a);
            this._cacheDirty = !1;
            this.arrivalOrder = 0;
            a.restore()
        }
    };
    _p.transform = function (a) {
        a = a || cc._renderContext;
        var b = cc.view, c = this.nodeToParentTransform();
        a.transform(c.a, c.c, c.b, c.d, c.tx * b.getScaleX(), -c.ty * b.getScaleY())
    };
    _p.nodeToParentTransform = function () {
        if (this._transformDirty) {
            var a = this._transform;
            a.tx = this._position.x;
            a.ty = this._position.y;
            var b = 1, c = 0;
            this._rotationX && (b = Math.cos(this._rotationRadiansX), c = Math.sin(this._rotationRadiansX));
            a.a = a.d = b;
            a.b = -c;
            a.c = c;
            var d = this._scaleX, e = this._scaleY,
                f = this._anchorPointInPoints.x, g = this._anchorPointInPoints.y, h = 1E-6 > d && -1E-6 < d ? 1E-6 : d, k = 1E-6 > e && -1E-6 < e ? 1E-6 : e;
            if (this._skewX || this._skewY) {
                var l = Math.tan(-this._skewX * Math.PI / 180), m = Math.tan(-this._skewY * Math.PI / 180);
                Infinity === l && (l = 99999999);
                Infinity === m && (m = 99999999);
                var n = g * l * h, q = f * m * k;
                a.a = b + -c * m;
                a.b = b * l + -c;
                a.c = c + b * m;
                a.d = c * l + b;
                a.tx += b * n + -c * q;
                a.ty += c * n + b * q
            }
            if (1 !== d || 1 !== e)a.a *= h, a.c *= h, a.b *= k, a.d *= k;
            a.tx += b * -f * h + -c * g * k;
            a.ty -= c * -f * h + b * g * k;
            this._ignoreAnchorPointForPosition && (a.tx += f, a.ty += g);
            this._additionalTransformDirty &&
            (this._transform = cc.AffineTransformConcat(a, this._additionalTransform), this._additionalTransformDirty = !1);
            this._transformDirty = !1
        }
        return this._transform
    };
    _p = null
} else cc.assert("function" === typeof cc._tmp.WebGLCCNode, cc._LogInfos.MissingFile, "BaseNodesWebGL.js"), cc._tmp.WebGLCCNode(), delete cc._tmp.WebGLCCNode;
cc.assert("function" === typeof cc._tmp.PrototypeCCNode, cc._LogInfos.MissingFile, "BaseNodesPropertyDefine.js");
cc._tmp.PrototypeCCNode();
delete cc._tmp.PrototypeCCNode;
cc.NodeRGBA = cc.Node.extend({RGBAProtocol: !0, _displayedOpacity: 255, _realOpacity: 255, _displayedColor: null, _realColor: null, _cascadeColorEnabled: !1, _cascadeOpacityEnabled: !1, ctor: function () {
    cc.Node.prototype.ctor.call(this);
    this._realOpacity = this._displayedOpacity = 255;
    this._displayedColor = cc.color(255, 255, 255, 255);
    this._realColor = cc.color(255, 255, 255, 255);
    this._cascadeOpacityEnabled = this._cascadeColorEnabled = !1
}, _updateColor: function () {
}, getOpacity: function () {
    return this._realOpacity
}, getDisplayedOpacity: function () {
    return this._displayedOpacity
},
    setOpacity: function (a) {
        this._displayedOpacity = this._realOpacity = a;
        var b = 255, c = this._parent;
        c && (c.RGBAProtocol && c.cascadeOpacity) && (b = c.getDisplayedOpacity());
        this.updateDisplayedOpacity(b);
        this._displayedColor.a = this._realColor.a = a
    }, updateDisplayedOpacity: function (a) {
        this._displayedOpacity = this._realOpacity * a / 255;
        if (this._cascadeOpacityEnabled) {
            a = this._children;
            for (var b = 0; b < a.length; b++) {
                var c = a[b];
                c && c.RGBAProtocol && c.updateDisplayedOpacity(this._displayedOpacity)
            }
        }
    }, isCascadeOpacityEnabled: function () {
        return this._cascadeOpacityEnabled
    },
    setCascadeOpacityEnabled: function (a) {
        this._cascadeOpacityEnabled !== a && ((this._cascadeOpacityEnabled = a) ? this._enableCascadeOpacity() : this._disableCascadeOpacity())
    }, _enableCascadeOpacity: function () {
        var a = 255, b = this._parent;
        b && (b.RGBAProtocol && b.cascadeOpacity) && (a = b.getDisplayedOpacity());
        this.updateDisplayedOpacity(a)
    }, _disableCascadeOpacity: function () {
        this._displayedOpacity = this._realOpacity;
        for (var a = this._children, b = 0; b < a.length; b++) {
            var c = a[b];
            c && c.RGBAProtocol && c.updateDisplayedOpacity(255)
        }
    },
    getColor: function () {
        var a = this._realColor;
        return cc.color(a.r, a.g, a.b, a.a)
    }, getDisplayedColor: function () {
        var a = this._displayedColor;
        return cc.color(a.r, a.g, a.b, a.a)
    }, setColor: function (a) {
        var b = this._displayedColor, c = this._realColor;
        b.r = c.r = a.r;
        b.g = c.g = a.g;
        b.b = c.b = a.b;
        b = (b = this._parent) && b.RGBAProtocol && b.cascadeColor ? b.getDisplayedColor() : cc.color.WHITE;
        this.updateDisplayedColor(b);
        void 0 !== a.a && !a.a_undefined && this.setOpacity(a.a)
    }, updateDisplayedColor: function (a) {
        var b = this._displayedColor, c = this._realColor;
        b.r = 0 | c.r * a.r / 255;
        b.g = 0 | c.g * a.g / 255;
        b.b = 0 | c.b * a.b / 255;
        if (this._cascadeColorEnabled) {
            a = this._children;
            for (c = 0; c < a.length; c++) {
                var d = a[c];
                d && d.RGBAProtocol && d.updateDisplayedColor(b)
            }
        }
    }, isCascadeColorEnabled: function () {
        return this._cascadeColorEnabled
    }, setCascadeColorEnabled: function (a) {
        this._cascadeColorEnabled !== a && ((this._cascadeColorEnabled = a) ? this._enableCascadeColor() : this._disableCascadeColor())
    }, _enableCascadeColor: function () {
        var a;
        a = (a = this._parent) && a.RGBAProtocol && a.cascadeColor ? a.getDisplayedColor() :
            cc.color.WHITE;
        this.updateDisplayedColor(a)
    }, _disableCascadeColor: function () {
        var a = this._displayedColor, b = this._realColor;
        a.r = b.r;
        a.g = b.g;
        a.b = b.b;
        for (var a = this._children, b = cc.color.WHITE, c = 0; c < a.length; c++) {
            var d = a[c];
            d && d.RGBAProtocol && d.updateDisplayedColor(b)
        }
    }, addChild: function (a, b, c) {
        cc.Node.prototype.addChild.call(this, a, b, c);
        this._cascadeColorEnabled && this._enableCascadeColor();
        this._cascadeOpacityEnabled && this._enableCascadeOpacity()
    }, setOpacityModifyRGB: function (a) {
    }, isOpacityModifyRGB: function () {
        return!1
    }});
cc.NodeRGBA.create = function () {
    var a = new cc.NodeRGBA;
    a.init();
    return a
};
cc.assert("function" === typeof cc._tmp.PrototypeCCNodeRGBA, cc._LogInfos.MissingFile, "BaseNodesPropertyDefine.js");
cc._tmp.PrototypeCCNodeRGBA();
delete cc._tmp.PrototypeCCNodeRGBA;
cc.Node.ON_ENTER = 0;
cc.Node.ON_EXIT = 1;
cc.Node.ON_ENTER_TRANSITION_DID_FINISH = 2;
cc.Node.ON_EXIT_TRANSITOIN_DID_START = 3;
cc.Node.ON_CLEAN_UP = 4;
cc._tmp.PrototypeTexture2D = function () {
    var a = cc.Texture2D;
    a.PVRImagesHavePremultipliedAlpha = function (a) {
        cc.PVRHaveAlphaPremultiplied_ = a
    };
    a.PIXEL_FORMAT_RGBA8888 = 2;
    a.PIXEL_FORMAT_RGB888 = 3;
    a.PIXEL_FORMAT_RGB565 = 4;
    a.PIXEL_FORMAT_A8 = 5;
    a.PIXEL_FORMAT_I8 = 6;
    a.PIXEL_FORMAT_AI88 = 7;
    a.PIXEL_FORMAT_RGBA4444 = 8;
    a.PIXEL_FORMAT_RGB5A1 = 7;
    a.PIXEL_FORMAT_PVRTC4 = 9;
    a.PIXEL_FORMAT_PVRTC2 = 10;
    a.PIXEL_FORMAT_DEFAULT = a.PIXEL_FORMAT_RGBA8888;
    var b = cc.Texture2D._M = {};
    b[a.PIXEL_FORMAT_RGBA8888] = "RGBA8888";
    b[a.PIXEL_FORMAT_RGB888] =
        "RGB888";
    b[a.PIXEL_FORMAT_RGB565] = "RGB565";
    b[a.PIXEL_FORMAT_A8] = "A8";
    b[a.PIXEL_FORMAT_I8] = "I8";
    b[a.PIXEL_FORMAT_AI88] = "AI88";
    b[a.PIXEL_FORMAT_RGBA4444] = "RGBA4444";
    b[a.PIXEL_FORMAT_RGB5A1] = "RGB5A1";
    b[a.PIXEL_FORMAT_PVRTC4] = "PVRTC4";
    b[a.PIXEL_FORMAT_PVRTC2] = "PVRTC2";
    b = cc.Texture2D._B = {};
    b[a.PIXEL_FORMAT_RGBA8888] = 32;
    b[a.PIXEL_FORMAT_RGB888] = 24;
    b[a.PIXEL_FORMAT_RGB565] = 16;
    b[a.PIXEL_FORMAT_A8] = 8;
    b[a.PIXEL_FORMAT_I8] = 8;
    b[a.PIXEL_FORMAT_AI88] = 16;
    b[a.PIXEL_FORMAT_RGBA4444] = 16;
    b[a.PIXEL_FORMAT_RGB5A1] = 16;
    b[a.PIXEL_FORMAT_PVRTC4] = 4;
    b[a.PIXEL_FORMAT_PVRTC2] = 3;
    b = cc.Texture2D.prototype;
    cc.defineGetterSetter(b, "name", b.getName);
    cc.defineGetterSetter(b, "pixelFormat", b.getPixelFormat);
    cc.defineGetterSetter(b, "pixelsWidth", b.getPixelsWide);
    cc.defineGetterSetter(b, "pixelsHeight", b.getPixelsHigh);
    cc.defineGetterSetter(b, "width", b._getWidth);
    cc.defineGetterSetter(b, "height", b._getHeight);
    a.defaultPixelFormat = a.PIXEL_FORMAT_DEFAULT
};
cc._tmp.PrototypeTextureAtlas = function () {
    var a = cc.TextureAtlas.prototype;
    cc.defineGetterSetter(a, "totalQuads", a.getTotalQuads);
    cc.defineGetterSetter(a, "capacity", a.getCapacity);
    cc.defineGetterSetter(a, "quads", a.getQuads, a.setQuads)
};
cc.ALIGN_CENTER = 51;
cc.ALIGN_TOP = 19;
cc.ALIGN_TOP_RIGHT = 18;
cc.ALIGN_RIGHT = 50;
cc.ALIGN_BOTTOM_RIGHT = 34;
cc.ALIGN_BOTTOM = 35;
cc.ALIGN_BOTTOM_LEFT = 33;
cc.ALIGN_LEFT = 49;
cc.ALIGN_TOP_LEFT = 17;
cc.PVRHaveAlphaPremultiplied_ = !1;
cc._renderType === cc._RENDER_TYPE_CANVAS ? cc.Texture2D = cc.Class.extend({_contentSize: null, _isLoaded: !1, _htmlElementObj: null, _loadedEventListeners: null, url: null, ctor: function () {
    this._contentSize = cc.size(0, 0);
    this._isLoaded = !1;
    this._htmlElementObj = null
}, getPixelsWide: function () {
    return this._contentSize.width
}, getPixelsHigh: function () {
    return this._contentSize.height
}, getContentSize: function () {
    var a = cc.contentScaleFactor();
    return cc.size(this._contentSize.width / a, this._contentSize.height / a)
}, _getWidth: function () {
    return this._contentSize.width /
        cc.contentScaleFactor()
}, _getHeight: function () {
    return this._contentSize.height / cc.contentScaleFactor()
}, getContentSizeInPixels: function () {
    return this._contentSize
}, initWithElement: function (a) {
    a && (this._htmlElementObj = a)
}, getHtmlElementObj: function () {
    return this._htmlElementObj
}, isLoaded: function () {
    return this._isLoaded
}, handleLoadedTexture: function () {
    if (!this._isLoaded) {
        if (!this._htmlElementObj) {
            var a = cc.loader.getRes(this.url);
            if (!a)return;
            this.initWithElement(a)
        }
        this._isLoaded = !0;
        a = this._htmlElementObj;
        this._contentSize.width = a.width;
        this._contentSize.height = a.height;
        this._callLoadedEventCallbacks()
    }
}, description: function () {
    return"\x3ccc.Texture2D | width \x3d " + this._contentSize.width + " height " + this._contentSize.height + "\x3e"
}, initWithData: function (a, b, c, d, e) {
    return!1
}, initWithImage: function (a) {
    return!1
}, initWithString: function (a, b, c, d, e, f) {
    return!1
}, releaseTexture: function () {
}, getName: function () {
    return null
}, getMaxS: function () {
    return 1
}, setMaxS: function (a) {
}, getMaxT: function () {
    return 1
}, setMaxT: function (a) {
},
    getPixelFormat: function () {
        return null
    }, getShaderProgram: function () {
        return null
    }, setShaderProgram: function (a) {
    }, hasPremultipliedAlpha: function () {
        return!1
    }, hasMipmaps: function () {
        return!1
    }, releaseData: function (a) {
    }, keepData: function (a, b) {
        return a
    }, drawAtPoint: function (a) {
    }, drawInRect: function (a) {
    }, initWithETCFile: function (a) {
        cc.log(cc._LogInfos.Texture2D_initWithETCFile);
        return!1
    }, initWithPVRFile: function (a) {
        cc.log(cc._LogInfos.Texture2D_initWithPVRFile);
        return!1
    }, initWithPVRTCData: function (a, b, c, d, e, f) {
        cc.log(cc._LogInfos.Texture2D_initWithPVRTCData);
        return!1
    }, setTexParameters: function (a) {
    }, setAntiAliasTexParameters: function () {
    }, setAliasTexParameters: function () {
    }, generateMipmap: function () {
    }, stringForFormat: function () {
        return""
    }, bitsPerPixelForFormat: function (a) {
        return-1
    }, addLoadedEventListener: function (a, b) {
        this._loadedEventListeners || (this._loadedEventListeners = []);
        this._loadedEventListeners.push({eventCallback: a, eventTarget: b})
    }, removeLoadedEventListener: function (a) {
        if (this._loadedEventListeners)for (var b =
            this._loadedEventListeners, c = 0; c < b.length; c++)b[c].eventTarget == a && b.splice(c, 1)
    }, _callLoadedEventCallbacks: function () {
        if (this._loadedEventListeners) {
            for (var a = this._loadedEventListeners, b = 0, c = a.length; b < c; b++) {
                var d = a[b];
                d.eventCallback.call(d.eventTarget, this)
            }
            a.length = 0
        }
    }}) : (cc.assert("function" === typeof cc._tmp.WebGLTexture2D, cc._LogInfos.MissingFile, "TexturesWebGL.js"), cc._tmp.WebGLTexture2D(), delete cc._tmp.WebGLTexture2D);
cc.assert("function" === typeof cc._tmp.PrototypeTexture2D, cc._LogInfos.MissingFile, "TexturesPropertyDefine.js");
cc._tmp.PrototypeTexture2D();
delete cc._tmp.PrototypeTexture2D;
cc.textureCache = {_textures: {}, _textureColorsCache: {}, _textureKeySeq: 0 | 1E3 * Math.random(), _loadedTexturesBefore: {}, _initializingRenderer: function () {
    var a, b = this._loadedTexturesBefore, c = this._textures;
    for (a in b) {
        var d = b[a];
        d.handleLoadedTexture();
        c[a] = d
    }
    this._loadedTexturesBefore = {}
}, addPVRTCImage: function (a) {
    cc.log(cc._LogInfos.textureCache_addPVRTCImage)
}, addETCImage: function (a) {
    cc.log(cc._LogInfos.textureCache_addETCImage)
}, description: function () {
    return"\x3cTextureCache | Number of textures \x3d " +
        this._textures.length + "\x3e"
}, textureForKey: function (a) {
    return this._textures[a] || this._textures[cc.loader._aliases[a]]
}, getKeyByTexture: function (a) {
    for (var b in this._textures)if (this._textures[b] == a)return b;
    return null
}, _generalTextureKey: function () {
    this._textureKeySeq++;
    return"_textureKey_" + this._textureKeySeq
}, getTextureColors: function (a) {
    var b = this.getKeyByTexture(a);
    b || (b = a instanceof HTMLImageElement ? a.src : this._generalTextureKey());
    this._textureColorsCache[b] || (this._textureColorsCache[b] =
        cc.generateTextureCacheForColor(a));
    return this._textureColorsCache[b]
}, addPVRImage: function (a) {
    cc.log(cc._LogInfos.textureCache_addPVRImage)
}, removeAllTextures: function () {
    var a = this._textures, b;
    for (b in a)a[b] && a[b].releaseTexture();
    this._textures = {}
}, removeTexture: function (a) {
    if (a) {
        var b = this._textures, c;
        for (c in b)b[c] == a && (b[c].releaseTexture(), delete b[c])
    }
}, removeTextureForKey: function (a) {
    null != a && this._textures[a] && delete this._textures[a]
}, cacheImage: function (a, b) {
    if (b instanceof cc.Texture2D)this._textures[a] =
        b; else {
        var c = new cc.Texture2D;
        c.initWithElement(b);
        c.handleLoadedTexture();
        this._textures[a] = c
    }
}, addUIImage: function (a, b) {
    cc.assert(a, cc._LogInfos.textureCache_addUIImage_2);
    if (b && this._textures[b])return this._textures[b];
    var c = new cc.Texture2D;
    c.initWithImage(a);
    null != b && null != c ? this._textures[b] = c : cc.log(cc._LogInfos.textureCache_addUIImage);
    return c
}, dumpCachedTextureInfo: function () {
    var a = 0, b = 0, c = this._textures, d;
    for (d in c) {
        var e = c[d];
        a++;
        e.getHtmlElementObj()instanceof HTMLImageElement ? cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo,
            d, e.getHtmlElementObj().src, e.pixelsWidth, e.pixelsHeight) : cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_2, d, e.pixelsWidth, e.pixelsHeight);
        b += 4 * e.pixelsWidth * e.pixelsHeight
    }
    c = this._textureColorsCache;
    for (d in c) {
        var e = c[d], f;
        for (f in e) {
            var g = e[f];
            a++;
            cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_2, d, g.width, g.height);
            b += 4 * g.width * g.height
        }
    }
    cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_3, a, b / 1024, (b / 1048576).toFixed(2))
}, _clear: function () {
    this._textures = {};
    this._textureColorsCache =
    {};
    this._textureKeySeq = 0 | 1E3 * Math.random();
    this._loadedTexturesBefore = {}
}};
cc._renderType === cc._RENDER_TYPE_CANVAS ? (_p = cc.textureCache, _p.handleLoadedTexture = function (a) {
    var b = this._textures, c = b[a];
    c || (c = b[a] = new cc.Texture2D, c.url = a);
    c.handleLoadedTexture()
}, _p.addImage = function (a, b, c) {
    cc.assert(a, cc._LogInfos.Texture2D_addImage);
    var d = this._textures, e = d[a] || d[cc.loader._aliases[a]];
    if (e)return b && b.call(c), e;
    e = d[a] = new cc.Texture2D;
    e.url = a;
    cc.loader.getRes(a) ? e.handleLoadedTexture() : cc.loader._checkIsImageURL(a) ? cc.loader.load(a, function (a) {
        b && b.call(c)
    }) : cc.loader.cache[a] =
        cc.loader.loadImg(a, function (c, d) {
            if (c)return b ? b(c) : c;
            cc.textureCache.handleLoadedTexture(a);
            b && b(null, d)
        });
    return e
}, _p = null) : (cc.assert("function" === typeof cc._tmp.WebGLTextureCache, cc._LogInfos.MissingFile, "TexturesWebGL.js"), cc._tmp.WebGLTextureCache(), delete cc._tmp.WebGLTextureCache);
cc.Scene = cc.Node.extend({_className: "Scene", ctor: function () {
    cc.Node.prototype.ctor.call(this);
    this._ignoreAnchorPointForPosition = !0;
    this.setAnchorPoint(0.5, 0.5);
    this.setContentSize(cc.director.getWinSize())
}});
cc.Scene.create = function () {
    return new cc.Scene
};
cc.LoaderScene = cc.Scene.extend({_interval: null, _length: 0, _count: 0, _label: null, _className: "LoaderScene", init: function () {
    var a = this, b = 200, c = a._bgLayer = cc.LayerColor.create(cc.color(32, 32, 32, 255));
    c.setPosition(cc.visibleRect.bottomLeft);
    a.addChild(c, 0);
    var d = 24, e = -b / 2 + 100;
    cc._loaderImage && (cc.loader.loadImg(cc._loaderImage, {isCrossOrigin: !1}, function (c, d) {
        b = d.height;
        a._initStage(d, cc.visibleRect.center)
    }), d = 14, e = -b / 2 - 10);
    d = a._label = cc.LabelTTF.create("Loading... 0%", "Arial", d);
    d.setPosition(cc.pAdd(cc.visibleRect.center,
        cc.p(0, e)));
    d.setColor(cc.color(180, 180, 180));
    c.addChild(this._label, 10);
    return!0
}, _initStage: function (a, b) {
    var c = this._texture2d = new cc.Texture2D;
    c.initWithElement(a);
    c.handleLoadedTexture();
    c = this._logo = cc.Sprite.create(c);
    c.setScale(cc.contentScaleFactor());
    c.x = b.x;
    c.y = b.y;
    this._bgLayer.addChild(c, 10)
}, onEnter: function () {
    cc.Node.prototype.onEnter.call(this);
    this.schedule(this._startLoading, 0.3)
}, onExit: function () {
    cc.Node.prototype.onExit.call(this);
    this._label.setString("Loading... 0%")
}, initWithResources: function (a, b) {
    "string" == typeof a && (a = [a]);
    this.resources = a || [];
    this.cb = b
}, _startLoading: function () {
    var a = this;
    a.unschedule(a._startLoading);
    var b = a.resources;
    a._length = b.length;
    a._count = 0;
    cc.loader.load(b, function (b, d) {
        a._count = d
    }, function () {
        a.cb && a.cb()
    });
    a.schedule(a._updatePercent)
}, _updatePercent: function () {
    var a = this._count, b = this._length, c;
    c = Math.min(100 * (a / b) | 0, 100);
    this._label.setString("Loading... " + c + "%");
    a >= b && this.unschedule(this._updatePercent)
}});
cc.LoaderScene.preload = function (a, b) {
    var c = cc;
    c.loaderScene || (c.loaderScene = new cc.LoaderScene, c.loaderScene.init());
    c.loaderScene.initWithResources(a, b);
    cc.director.runScene(c.loaderScene);
    return c.loaderScene
};
cc._tmp.PrototypeLayerRGBA = function () {
    var a = cc.LayerRGBA.prototype;
    cc.defineGetterSetter(a, "opacityModifyRGB", a.isOpacityModifyRGB, a.setOpacityModifyRGB);
    cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity);
    cc.defineGetterSetter(a, "cascadeOpacity", a.isCascadeOpacityEnabled, a.setCascadeOpacityEnabled);
    cc.defineGetterSetter(a, "color", a.getColor, a.setColor);
    cc.defineGetterSetter(a, "cascadeColor", a.isCascadeColorEnabled, a.setCascadeColorEnabled)
};
cc._tmp.PrototypeLayerColor = function () {
    var a = cc.LayerColor.prototype;
    cc.defineGetterSetter(a, "width", a._getWidth, a._setWidth);
    cc.defineGetterSetter(a, "height", a._getHeight, a._setHeight)
};
cc._tmp.PrototypeLayerGradient = function () {
    var a = cc.LayerGradient.prototype;
    cc.defineGetterSetter(a, "startColor", a.getStartColor, a.setStartColor);
    cc.defineGetterSetter(a, "endColor", a.getEndColor, a.setEndColor);
    cc.defineGetterSetter(a, "startOpacity", a.getStartOpacity, a.setStartOpacity);
    cc.defineGetterSetter(a, "endOpacity", a.getEndOpacity, a.setEndOpacity);
    cc.defineGetterSetter(a, "vector", a.getVector, a.setVector)
};
cc.Layer = cc.Node.extend({_isBaked: !1, _bakeSprite: null, _className: "Layer", ctor: function () {
    var a = cc.Node.prototype;
    a.ctor.call(this);
    this._ignoreAnchorPointForPosition = !0;
    a.setAnchorPoint.call(this, 0.5, 0.5);
    a.setContentSize.call(this, cc.winSize)
}, bake: null, unbake: null, isBaked: function () {
    return this._isBaked
}, visit: null});
cc.Layer.create = function () {
    return new cc.Layer
};
if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
    var p = cc.Layer.prototype;
    p.bake = function () {
        if (!this._isBaked) {
            this._isBaked = this._cacheDirty = !0;
            this._cachedParent = this;
            for (var a = this._children, b = 0, c = a.length; b < c; b++)a[b]._setCachedParent(this);
            this._bakeSprite || (this._bakeSprite = new cc.BakeSprite)
        }
    };
    p.unbake = function () {
        if (this._isBaked) {
            this._isBaked = !1;
            this._cacheDirty = !0;
            this._cachedParent = null;
            for (var a = this._children, b = 0, c = a.length; b < c; b++)a[b]._setCachedParent(null)
        }
    };
    p.visit = function (a) {
        if (this._isBaked) {
            a =
                a || cc._renderContext;
            var b, c = this._children, d = c.length;
            if (this._visible && 0 !== d) {
                var e = this._bakeSprite;
                a.save();
                this.transform(a);
                if (this._cacheDirty) {
                    b = this._getBoundingBoxForBake();
                    b.width |= 0;
                    b.height |= 0;
                    var f = e.getCacheContext();
                    e.resetCanvasSize(b.width, b.height);
                    f.translate(0 - b.x, b.height + b.y);
                    var g = e.getAnchorPointInPoints();
                    e.setPosition(g.x + b.x, g.y + b.y);
                    this.sortAllChildren();
                    for (b = 0; b < d; b++)c[b].visit(f);
                    this._cacheDirty = !1
                }
                e.visit(a);
                this.arrivalOrder = 0;
                a.restore()
            }
        } else cc.Node.prototype.visit.call(this,
            a)
    };
    p._getBoundingBoxForBake = function () {
        var a = null;
        if (!this._children || 0 === this._children.length)return cc.rect(0, 0, 10, 10);
        for (var b = this._children, c = 0; c < b.length; c++) {
            var d = b[c];
            d && d._visible && (a ? (d = d._getBoundingBoxToCurrentNode()) && (a = cc.rectUnion(a, d)) : a = d._getBoundingBoxToCurrentNode())
        }
        return a
    };
    p = null
} else cc.assert("function" === typeof cc._tmp.LayerDefineForWebGL, cc._LogInfos.MissingFile, "CCLayerWebGL.js"), cc._tmp.LayerDefineForWebGL(), delete cc._tmp.LayerDefineForWebGL;
cc.LayerRGBA = cc.Layer.extend({RGBAProtocol: !0, _displayedOpacity: 255, _realOpacity: 255, _displayedColor: null, _realColor: null, _cascadeOpacityEnabled: !1, _cascadeColorEnabled: !1, _className: "LayerRGBA", ctor: function () {
    cc.Layer.prototype.ctor.call(this);
    this._displayedColor = cc.color(255, 255, 255, 255);
    this._realColor = cc.color(255, 255, 255, 255)
}, init: function () {
    var a = cc.Layer.prototype;
    this._ignoreAnchorPointForPosition = !0;
    a.setAnchorPoint.call(this, 0.5, 0.5);
    a.setContentSize.call(this, cc.winSize);
    this.cascadeColor =
        this.cascadeOpacity = !1;
    return!0
}, getOpacity: function () {
    return this._realOpacity
}, getDisplayedOpacity: function () {
    return this._displayedOpacity
}, setOpacity: function (a) {
    this._displayedOpacity = this._realOpacity = a;
    var b = 255, c = this._parent;
    c && (c.RGBAProtocol && c.cascadeOpacity) && (b = c.getDisplayedOpacity());
    this.updateDisplayedOpacity(b);
    this._displayedColor.a = this._realColor.a = a
}, updateDisplayedOpacity: function (a) {
    this._displayedOpacity = 0 | this._realOpacity * a / 255;
    if (this._cascadeOpacityEnabled) {
        a = this._children;
        for (var b, c = 0; c < a.length; c++)(b = a[c]) && b.RGBAProtocol && b.updateDisplayedOpacity(this._displayedOpacity)
    }
}, isCascadeOpacityEnabled: function () {
    return this._cascadeOpacityEnabled
}, setCascadeOpacityEnabled: function (a) {
    this._cascadeOpacityEnabled !== a && ((this._cascadeOpacityEnabled = a) ? this._enableCascadeOpacity() : this._disableCascadeOpacity())
}, _enableCascadeOpacity: function () {
    var a = 255, b = this._parent;
    b && (b.RGBAProtocol && b.cascadeOpacity) && (a = b.getDisplayedOpacity());
    this.updateDisplayedOpacity(a)
}, _disableCascadeOpacity: function () {
    this._displayedOpacity =
        this._realOpacity;
    for (var a = this._children, b, c = 0; c < a.length; c++)(b = a[c]) && b.RGBAProtocol && b.updateDisplayedOpacity(255)
}, getColor: function () {
    var a = this._realColor;
    return cc.color(a.r, a.g, a.b, a.a)
}, getDisplayedColor: function () {
    var a = this._displayedColor;
    return cc.color(a.r, a.g, a.b)
}, setColor: function (a) {
    var b = this._displayedColor, c = this._realColor;
    b.r = c.r = a.r;
    b.g = c.g = a.g;
    b.b = c.b = a.b;
    b = (b = this._parent) && b.RGBAProtocol && b.cascadeColor ? b.getDisplayedColor() : cc.color.WHITE;
    this.updateDisplayedColor(b);
    void 0 !== a.a && !a.a_undefined && this.setOpacity(a.a)
}, updateDisplayedColor: function (a) {
    var b = this._displayedColor, c = this._realColor;
    b.r = 0 | c.r * a.r / 255;
    b.g = 0 | c.g * a.g / 255;
    b.b = 0 | c.b * a.b / 255;
    if (this._cascadeColorEnabled) {
        a = this._children;
        for (var d = 0; d < a.length; d++)(c = a[d]) && c.RGBAProtocol && c.updateDisplayedColor(b)
    }
}, isCascadeColorEnabled: function () {
    return this._cascadeColorEnabled
}, setCascadeColorEnabled: function (a) {
    this._cascadeColorEnabled !== a && ((this._cascadeColorEnabled = a) ? this._enableCascadeColor() :
        this._disableCascadeColor())
}, _enableCascadeColor: function () {
    var a;
    a = (a = this._parent) && a.RGBAProtocol && a.cascadeColor ? a.getDisplayedColor() : cc.color.WHITE;
    this.updateDisplayedColor(a)
}, _disableCascadeColor: function () {
    var a = this._displayedColor, b = this._realColor;
    a.r = b.r;
    a.g = b.g;
    a.b = b.b;
    var a = this._children, b = cc.color.WHITE, c, d;
    for (d = 0; d < a.length; d++)(c = a[d]) && c.RGBAProtocol && c.updateDisplayedColor(b)
}, addChild: function (a, b, c) {
    cc.Node.prototype.addChild.call(this, a, b, c);
    this._cascadeColorEnabled && this._enableCascadeColor();
    this._cascadeOpacityEnabled && this._enableCascadeOpacity()
}, setOpacityModifyRGB: function (a) {
}, isOpacityModifyRGB: function () {
    return!1
}});
cc.assert("function" === typeof cc._tmp.PrototypeLayerRGBA, cc._LogInfos.MissingFile, "CCLayerPropertyDefine.js");
cc._tmp.PrototypeLayerRGBA();
delete cc._tmp.PrototypeLayerRGBA;
cc.LayerColor = cc.LayerRGBA.extend({_blendFunc: null, _className: "LayerColor", getBlendFunc: function () {
    return this._blendFunc
}, changeWidthAndHeight: function (a, b) {
    this.width = a;
    this.height = b
}, changeWidth: function (a) {
    this.width = a
}, changeHeight: function (a) {
    this.height = a
}, setOpacityModifyRGB: function (a) {
}, isOpacityModifyRGB: function () {
    return!1
}, setColor: function (a) {
    cc.LayerRGBA.prototype.setColor.call(this, a);
    this._updateColor()
}, setOpacity: function (a) {
    cc.LayerRGBA.prototype.setOpacity.call(this, a);
    this._updateColor()
},
    _isLighterMode: !1, ctor: null, init: function (a, b, c) {
        cc._renderType !== cc._RENDER_TYPE_CANVAS && (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_COLOR));
        var d = cc.director.getWinSize();
        a = a || cc.color(0, 0, 0, 255);
        b = void 0 === b ? d.width : b;
        c = void 0 === c ? d.height : c;
        d = this._displayedColor;
        d.r = a.r;
        d.g = a.g;
        d.b = a.b;
        d = this._realColor;
        d.r = a.r;
        d.g = a.g;
        d.b = a.b;
        this._realOpacity = this._displayedOpacity = a.a;
        a = cc.LayerColor.prototype;
        a.setContentSize.call(this, b, c);
        a._updateColor.call(this);
        return!0
    }, setBlendFunc: function (a, b) {
        this._blendFunc = void 0 === b ? a : {src: a, dst: b};
        cc._renderType === cc._RENDER_TYPE_CANVAS && (this._isLighterMode = this._blendFunc && 1 == this._blendFunc.src && 771 == this._blendFunc.dst)
    }, _setWidth: null, _setHeight: null, _updateColor: null, updateDisplayedColor: function (a) {
        cc.LayerRGBA.prototype.updateDisplayedColor.call(this, a);
        this._updateColor()
    }, updateDisplayedOpacity: function (a) {
        cc.LayerRGBA.prototype.updateDisplayedOpacity.call(this, a);
        this._updateColor()
    }, draw: null});
cc.LayerColor.create = function (a, b, c) {
    return new cc.LayerColor(a, b, c)
};
cc._renderType === cc._RENDER_TYPE_CANVAS ? (_p = cc.LayerColor.prototype, _p.ctor = function (a, b, c) {
    cc.LayerRGBA.prototype.ctor.call(this);
    this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
    cc.LayerColor.prototype.init.call(this, a, b, c)
}, _p._setWidth = cc.LayerRGBA.prototype._setWidth, _p._setHeight = cc.LayerRGBA.prototype._setHeight, _p._updateColor = function () {
}, _p.draw = function (a) {
    a = a || cc._renderContext;
    var b = cc.view, c = this._displayedColor;
    a.fillStyle = "rgba(" + (0 | c.r) + "," + (0 | c.g) + "," + (0 | c.b) + "," + this._displayedOpacity /
        255 + ")";
    a.fillRect(0, 0, this.width * b.getScaleX(), -this.height * b.getScaleY());
    cc.g_NumberOfDraws++
}, _p.visit = function (a) {
    if (this._isBaked) {
        a = a || cc._renderContext;
        var b, c = this._children, d = c.length;
        if (this._visible) {
            var e = this._bakeSprite;
            a.save();
            this.transform(a);
            if (this._cacheDirty) {
                b = this._getBoundingBoxForBake();
                b.width |= 0;
                b.height |= 0;
                var f = e.getCacheContext();
                e.resetCanvasSize(b.width, b.height);
                var g = e.getAnchorPointInPoints(), h = this._position;
                if (this._ignoreAnchorPointForPosition)f.translate(0 -
                    b.x + h.x, b.height + b.y - h.y), e.setPosition(g.x + b.x - h.x, g.y + b.y - h.y); else {
                    var k = this.getAnchorPointInPoints(), l = h.x - k.x, h = h.y - k.y;
                    f.translate(0 - b.x + l, b.height + b.y - h);
                    e.setPosition(g.x + b.x - l, g.y + b.y - h)
                }
                if (0 < d) {
                    this.sortAllChildren();
                    for (b = 0; b < d; b++)if (g = c[b], 0 > g._localZOrder)g.visit(f); else break;
                    for (this.draw(f); b < d; b++)c[b].visit(f)
                } else this.draw(f);
                this._cacheDirty = !1
            }
            e.visit(a);
            this.arrivalOrder = 0;
            a.restore()
        }
    } else cc.Node.prototype.visit.call(this, a)
}, _p._getBoundingBoxForBake = function () {
    var a = cc.rect(0,
        0, this._contentSize.width, this._contentSize.height), b = this.nodeToWorldTransform(), a = cc.RectApplyAffineTransform(a, this.nodeToWorldTransform());
    if (!this._children || 0 === this._children.length)return a;
    for (var c = this._children, d = 0; d < c.length; d++) {
        var e = c[d];
        e && e._visible && (e = e._getBoundingBoxToCurrentNode(b), a = cc.rectUnion(a, e))
    }
    return a
}, _p = null) : (cc.assert("function" === typeof cc._tmp.WebGLLayerColor, cc._LogInfos.MissingFile, "CCLayerWebGL.js"), cc._tmp.WebGLLayerColor(), delete cc._tmp.WebGLLayerColor);
cc.assert("function" === typeof cc._tmp.PrototypeLayerColor, cc._LogInfos.MissingFile, "CCLayerPropertyDefine.js");
cc._tmp.PrototypeLayerColor();
delete cc._tmp.PrototypeLayerColor;
cc.LayerGradient = cc.LayerColor.extend({_startColor: null, _endColor: null, _startOpacity: 255, _endOpacity: 255, _alongVector: null, _compressedInterpolation: !1, _gradientStartPoint: null, _gradientEndPoint: null, _className: "LayerGradient", ctor: function (a, b, c) {
    cc.LayerColor.prototype.ctor.call(this);
    this._startColor = cc.color(0, 0, 0, 255);
    this._endColor = cc.color(0, 0, 0, 255);
    this._alongVector = cc.p(0, -1);
    this._endOpacity = this._startOpacity = 255;
    this._gradientStartPoint = cc.p(0, 0);
    this._gradientEndPoint = cc.p(0, 0);
    cc.LayerGradient.prototype.init.call(this,
        a, b, c)
}, init: function (a, b, c) {
    a = a || cc.color(0, 0, 0, 255);
    b = b || cc.color(0, 0, 0, 255);
    c = c || cc.p(0, -1);
    var d = this._startColor, e = this._endColor;
    d.r = a.r;
    d.g = a.g;
    d.b = a.b;
    this._startOpacity = a.a;
    e.r = b.r;
    e.g = b.g;
    e.b = b.b;
    this._endOpacity = b.a;
    this._alongVector = c;
    this._compressedInterpolation = !0;
    this._gradientStartPoint = cc.p(0, 0);
    this._gradientEndPoint = cc.p(0, 0);
    cc.LayerColor.prototype.init.call(this, cc.color(a.r, a.g, a.b, 255));
    cc.LayerGradient.prototype._updateColor.call(this);
    return!0
}, setContentSize: function (a, b) {
    cc.LayerColor.prototype.setContentSize.call(this, a, b);
    this._updateColor()
}, _setWidth: function (a) {
    cc.LayerColor.prototype._setWidth.call(this, a);
    this._updateColor()
}, _setHeight: function (a) {
    cc.LayerColor.prototype._setHeight.call(this, a);
    this._updateColor()
}, getStartColor: function () {
    return this._realColor
}, setStartColor: function (a) {
    this.color = a
}, setEndColor: function (a) {
    this._endColor = a;
    this._updateColor()
}, getEndColor: function () {
    return this._endColor
}, setStartOpacity: function (a) {
    this._startOpacity =
        a;
    this._updateColor()
}, getStartOpacity: function () {
    return this._startOpacity
}, setEndOpacity: function (a) {
    this._endOpacity = a;
    this._updateColor()
}, getEndOpacity: function () {
    return this._endOpacity
}, setVector: function (a) {
    this._alongVector.x = a.x;
    this._alongVector.y = a.y;
    this._updateColor()
}, getVector: function () {
    return cc.p(this._alongVector.x, this._alongVector.y)
}, isCompressedInterpolation: function () {
    return this._compressedInterpolation
}, setCompressedInterpolation: function (a) {
    this._compressedInterpolation =
        a;
    this._updateColor()
}, _draw: null, _updateColor: null});
cc.LayerGradient.create = function (a, b, c) {
    return new cc.LayerGradient(a, b, c)
};
cc._renderType === cc._RENDER_TYPE_CANVAS ? (_p = cc.LayerGradient.prototype, _p.draw = function (a) {
    a = a || cc._renderContext;
    this._isLighterMode && (a.globalCompositeOperation = "lighter");
    a.save();
    var b = cc.view, c = this._displayedOpacity / 255, d = this.width * b.getScaleX(), b = this.height * b.getScaleY(), e = a.createLinearGradient(this._gradientStartPoint.x, this._gradientStartPoint.y, this._gradientEndPoint.x, this._gradientEndPoint.y), f = this._displayedColor, g = this._endColor;
    e.addColorStop(0, "rgba(" + Math.round(f.r) + "," + Math.round(f.g) +
        "," + Math.round(f.b) + "," + (c * (this._startOpacity / 255)).toFixed(4) + ")");
    e.addColorStop(1, "rgba(" + Math.round(g.r) + "," + Math.round(g.g) + "," + Math.round(g.b) + "," + (c * (this._endOpacity / 255)).toFixed(4) + ")");
    a.fillStyle = e;
    a.fillRect(0, 0, d, -b);
    0 != this._rotation && a.rotate(this._rotationRadians);
    a.restore()
}, _p._updateColor = function () {
    var a = this._alongVector, b = 0.5 * this.width, c = 0.5 * this.height;
    this._gradientStartPoint.x = b * -a.x + b;
    this._gradientStartPoint.y = c * a.y - c;
    this._gradientEndPoint.x = b * a.x + b;
    this._gradientEndPoint.y =
        c * -a.y - c
}, _p = null) : (cc.assert("function" === typeof cc._tmp.WebGLLayerGradient, cc._LogInfos.MissingFile, "CCLayerWebGL.js"), cc._tmp.WebGLLayerGradient(), delete cc._tmp.WebGLLayerGradient);
cc.assert("function" === typeof cc._tmp.PrototypeLayerGradient, cc._LogInfos.MissingFile, "CCLayerPropertyDefine.js");
cc._tmp.PrototypeLayerGradient();
delete cc._tmp.PrototypeLayerGradient;
cc.LayerMultiplex = cc.Layer.extend({_enabledLayer: 0, _layers: null, _className: "LayerMultiplex", ctor: function (a) {
    cc.Layer.prototype.ctor.call(this);
    a && cc.LayerMultiplex.prototype.initWithLayers.call(this, a)
}, initWithLayers: function (a) {
    0 < a.length && null == a[a.length - 1] && cc.log(cc._LogInfos.LayerMultiplex_initWithLayers);
    this._layers = a;
    this._enabledLayer = 0;
    this.addChild(this._layers[this._enabledLayer]);
    return!0
}, switchTo: function (a) {
    a >= this._layers.length ? cc.log(cc._LogInfos.LayerMultiplex_switchTo) : (this.removeChild(this._layers[this._enabledLayer],
        !0), this._enabledLayer = a, this.addChild(this._layers[a]))
}, switchToAndReleaseMe: function (a) {
    a >= this._layers.length ? cc.log(cc._LogInfos.LayerMultiplex_switchToAndReleaseMe) : (this.removeChild(this._layers[this._enabledLayer], !0), this._layers[this._enabledLayer] = null, this._enabledLayer = a, this.addChild(this._layers[a]))
}, addLayer: function (a) {
    a ? this._layers.push(a) : cc.log(cc._LogInfos.LayerMultiplex_addLayer)
}});
cc.LayerMultiplex.create = function () {
    return new cc.LayerMultiplex(arguments)
};
cc._tmp.PrototypeSprite = function () {
    var a = cc.Sprite.prototype;
    cc.defineGetterSetter(a, "opacityModifyRGB", a.isOpacityModifyRGB, a.setOpacityModifyRGB);
    cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity);
    cc.defineGetterSetter(a, "color", a.getColor, a.setColor);
    cc.defineGetterSetter(a, "flippedX", a.isFlippedX, a.setFlippedX);
    cc.defineGetterSetter(a, "flippedY", a.isFlippedY, a.setFlippedY);
    cc.defineGetterSetter(a, "offsetX", a._getOffsetX);
    cc.defineGetterSetter(a, "offsetY", a._getOffsetY);
    cc.defineGetterSetter(a,
        "texture", a.getTexture, a.setTexture);
    cc.defineGetterSetter(a, "textureRectRotated", a.isTextureRectRotated);
    cc.defineGetterSetter(a, "batchNode", a.getBatchNode, a.setBatchNode);
    cc.defineGetterSetter(a, "quad", a.getQuad)
};
cc.generateTextureCacheForColor = function (a) {
    function b() {
        var b = cc.generateTextureCacheForColor, d = a.width, g = a.height;
        c[0].width = d;
        c[0].height = g;
        c[1].width = d;
        c[1].height = g;
        c[2].width = d;
        c[2].height = g;
        c[3].width = d;
        c[3].height = g;
        b.canvas.width = d;
        b.canvas.height = g;
        var h = b.canvas.getContext("2d");
        h.drawImage(a, 0, 0);
        b.tempCanvas.width = d;
        b.tempCanvas.height = g;
        for (var h = h.getImageData(0, 0, d, g).data, k = 0; 4 > k; k++) {
            var l = c[k].getContext("2d");
            l.getImageData(0, 0, d, g).data;
            b.tempCtx.drawImage(a, 0, 0);
            for (var m = b.tempCtx.getImageData(0,
                0, d, g), n = m.data, q = 0; q < h.length; q += 4)n[q] = 0 === k ? h[q] : 0, n[q + 1] = 1 === k ? h[q + 1] : 0, n[q + 2] = 2 === k ? h[q + 2] : 0, n[q + 3] = h[q + 3];
            l.putImageData(m, 0, 0)
        }
        a.onload = null
    }

    if (a.channelCache)return a.channelCache;
    var c = [cc.newElement("canvas"), cc.newElement("canvas"), cc.newElement("canvas"), cc.newElement("canvas")];
    try {
        b()
    } catch (d) {
        a.onload = b
    }
    return a.channelCache = c
};
cc.generateTextureCacheForColor.canvas = cc.newElement("canvas");
cc.generateTextureCacheForColor.tempCanvas = cc.newElement("canvas");
cc.generateTextureCacheForColor.tempCtx = cc.generateTextureCacheForColor.tempCanvas.getContext("2d");
cc.generateTintImage2 = function (a, b, c) {
    c || (c = cc.rect(0, 0, a.width, a.height), c = cc.rectPixelsToPoints(c));
    var d = cc.newElement("canvas"), e = d.getContext("2d");
    d.width != c.width && (d.width = c.width);
    d.height != c.height && (d.height = c.height);
    e.save();
    e.drawImage(a, c.x, c.y, c.width, c.height, 0, 0, c.width, c.height);
    e.globalCompositeOperation = "source-in";
    e.globalAlpha = b.a / 255;
    e.fillStyle = "rgb(" + b.r + "," + b.g + "," + b.b + ")";
    e.fillRect(0, 0, c.width, c.height);
    e.restore();
    return d
};
cc.generateTintImage = function (a, b, c, d, e) {
    d || (d = cc.rect(0, 0, a.width, a.height));
    a = c.r / 255;
    var f = c.g / 255;
    c = c.b / 255;
    var g = Math.min(d.width, b[0].width), h = Math.min(d.height, b[0].height), k;
    e ? (k = e.getContext("2d"), k.clearRect(0, 0, g, h)) : (e = cc.newElement("canvas"), e.width = g, e.height = h, k = e.getContext("2d"));
    k.save();
    k.globalCompositeOperation = "lighter";
    var l = k.globalAlpha;
    0 < a && (k.globalAlpha = a * l, k.drawImage(b[0], d.x, d.y, g, h, 0, 0, g, h));
    0 < f && (k.globalAlpha = f * l, k.drawImage(b[1], d.x, d.y, g, h, 0, 0, g, h));
    0 < c && (k.globalAlpha =
        c * l, k.drawImage(b[2], d.x, d.y, g, h, 0, 0, g, h));
    1 > a + f + c && (k.globalAlpha = l, k.drawImage(b[3], d.x, d.y, g, h, 0, 0, g, h));
    k.restore();
    return e
};
cc.cutRotateImageToCanvas = function (a, b) {
    if (!a)return null;
    if (!b)return a;
    var c = cc.newElement("canvas");
    c.width = b.width;
    c.height = b.height;
    var d = c.getContext("2d");
    d.translate(c.width / 2, c.height / 2);
    d.rotate(-1.5707963267948966);
    d.drawImage(a, b.x, b.y, b.height, b.width, -b.height / 2, -b.width / 2, b.height, b.width);
    return c
};
cc.Sprite = cc.NodeRGBA.extend({RGBAProtocol: !0, dirty: !1, atlasIndex: 0, textureAtlas: null, _batchNode: null, _recursiveDirty: null, _hasChildren: null, _shouldBeHidden: !1, _transformToBatch: null, _blendFunc: null, _texture: null, _rect: null, _rectRotated: !1, _offsetPosition: null, _unflippedOffsetPositionFromCenter: null, _opacityModifyRGB: !1, _flippedX: !1, _flippedY: !1, _textureLoaded: !1, _loadedEventListeners: null, _newTextureWhenChangeColor: null, _className: "Sprite", textureLoaded: function () {
    return this._textureLoaded
}, addLoadedEventListener: function (a, b) {
    this._loadedEventListeners || (this._loadedEventListeners = []);
    this._loadedEventListeners.push({eventCallback: a, eventTarget: b})
}, _callLoadedEventCallbacks: function () {
    if (this._loadedEventListeners) {
        for (var a = this._loadedEventListeners, b = 0, c = a.length; b < c; b++) {
            var d = a[b];
            d.eventCallback.call(d.eventTarget, this)
        }
        a.length = 0
    }
}, isDirty: function () {
    return this.dirty
}, setDirty: function (a) {
    this.dirty = a
}, isTextureRectRotated: function () {
    return this._rectRotated
}, getAtlasIndex: function () {
    return this.atlasIndex
},
    setAtlasIndex: function (a) {
        this.atlasIndex = a
    }, getTextureRect: function () {
        return cc.rect(this._rect.x, this._rect.y, this._rect.width, this._rect.height)
    }, getTextureAtlas: function () {
        return this.textureAtlas
    }, setTextureAtlas: function (a) {
        this.textureAtlas = a
    }, getOffsetPosition: function () {
        return this._offsetPosition
    }, _getOffsetX: function () {
        return this._offsetPosition.x
    }, _getOffsetY: function () {
        return this._offsetPosition.y
    }, getBlendFunc: function () {
        return this._blendFunc
    }, initWithSpriteFrame: function (a) {
        cc.assert(a,
            cc._LogInfos.Sprite_initWithSpriteFrame);
        a.textureLoaded() || (this._textureLoaded = !1, a.addLoadedEventListener(this._spriteFrameLoadedCallback, this));
        var b = cc._renderType === cc._RENDER_TYPE_CANVAS ? !1 : a._rotated, b = this.initWithTexture(a.getTexture(), a.getRect(), b);
        this.setSpriteFrame(a);
        return b
    }, _spriteFrameLoadedCallback: null, initWithSpriteFrameName: function (a) {
        cc.assert(a, cc._LogInfos.Sprite_initWithSpriteFrameName);
        var b = cc.spriteFrameCache.getSpriteFrame(a);
        cc.assert(b, a + cc._LogInfos.Sprite_initWithSpriteFrameName1);
        return this.initWithSpriteFrame(b)
    }, useBatchNode: function (a) {
        this.textureAtlas = a.textureAtlas;
        this._batchNode = a
    }, setVertexRect: function (a) {
        this._rect.x = a.x;
        this._rect.y = a.y;
        this._rect.width = a.width;
        this._rect.height = a.height
    }, sortAllChildren: function () {
        if (this._reorderChildDirty) {
            var a = this._children, b = a.length, c, d, e;
            for (c = 1; c < b; c++) {
                e = a[c];
                for (d = c - 1; 0 <= d;) {
                    if (e._localZOrder < a[d]._localZOrder)a[d + 1] = a[d]; else if (e._localZOrder === a[d]._localZOrder && e.arrivalOrder < a[d].arrivalOrder)a[d + 1] = a[d]; else break;
                    d--
                }
                a[d + 1] = e
            }
            this._batchNode && this._arrayMakeObjectsPerformSelector(a, cc.Node.StateCallbackType.sortAllChildren);
            this._reorderChildDirty = !1
        }
    }, reorderChild: function (a, b) {
        cc.assert(a, cc._LogInfos.Sprite_reorderChild_2);
        -1 === this._children.indexOf(a) ? cc.log(cc._LogInfos.Sprite_reorderChild) : b !== a.zIndex && (this._batchNode && !this._reorderChildDirty && (this._setReorderChildDirtyRecursively(), this._batchNode.reorderBatch(!0)), cc.Node.prototype.reorderChild.call(this, a, b))
    }, removeChild: function (a, b) {
        this._batchNode &&
        this._batchNode.removeSpriteFromAtlas(a);
        cc.Node.prototype.removeChild.call(this, a, b)
    }, removeAllChildren: function (a) {
        var b = this._children, c = this._batchNode;
        if (c && null != b)for (var d = 0, e = b.length; d < e; d++)c.removeSpriteFromAtlas(b[d]);
        cc.Node.prototype.removeAllChildren.call(this, a);
        this._hasChildren = !1
    }, setDirtyRecursively: function (a) {
        this.dirty = this._recursiveDirty = a;
        a = this._children;
        for (var b, c = a ? a.length : 0, d = 0; d < c; d++)b = a[d], b instanceof cc.Sprite && b.setDirtyRecursively(!0)
    }, setNodeDirty: function (a) {
        cc.Node.prototype.setNodeDirty.call(this);
        !a && (this._batchNode && !this._recursiveDirty) && (this._hasChildren ? this.setDirtyRecursively(!0) : this.dirty = this._recursiveDirty = !0)
    }, ignoreAnchorPointForPosition: function (a) {
        this._batchNode ? cc.log(cc._LogInfos.Sprite_ignoreAnchorPointForPosition) : cc.Node.prototype.ignoreAnchorPointForPosition.call(this, a)
    }, setFlippedX: function (a) {
        this._flippedX != a && (this._flippedX = a, this.setTextureRect(this._rect, this._rectRotated, this._contentSize), this.setNodeDirty(!0))
    }, setFlippedY: function (a) {
        this._flippedY != a &&
        (this._flippedY = a, this.setTextureRect(this._rect, this._rectRotated, this._contentSize), this.setNodeDirty(!0))
    }, isFlippedX: function () {
        return this._flippedX
    }, isFlippedY: function () {
        return this._flippedY
    }, setOpacityModifyRGB: null, isOpacityModifyRGB: function () {
        return this._opacityModifyRGB
    }, updateDisplayedOpacity: null, setDisplayFrameWithAnimationName: function (a, b) {
        cc.assert(a, cc._LogInfos.Sprite_setDisplayFrameWithAnimationName_3);
        var c = cc.animationCache.getAnimation(a);
        c ? (c = c.getFrames()[b]) ? this.setSpriteFrame(c.getSpriteFrame()) :
            cc.log(cc._LogInfos.Sprite_setDisplayFrameWithAnimationName_2) : cc.log(cc._LogInfos.Sprite_setDisplayFrameWithAnimationName)
    }, getBatchNode: function () {
        return this._batchNode
    }, _setReorderChildDirtyRecursively: function () {
        if (!this._reorderChildDirty) {
            this._reorderChildDirty = !0;
            for (var a = this._parent; a && a != this._batchNode;)a._setReorderChildDirtyRecursively(), a = a.parent
        }
    }, getTexture: function () {
        return this._texture
    }, _quad: null, _quadWebBuffer: null, _quadDirty: !1, _colorized: !1, _isLighterMode: !1, _originalTexture: null,
    _textureRect_Canvas: null, _drawSize_Canvas: null, ctor: null, _softInit: function (a, b, c) {
        if (void 0 === a)cc.Sprite.prototype.init.call(this); else if ("string" === typeof a)"#" === a[0] ? (a = a.substr(1, a.length - 1), a = cc.spriteFrameCache.getSpriteFrame(a), this.initWithSpriteFrame(a)) : cc.Sprite.prototype.init.call(this, a, b); else if ("object" === typeof a)if (a instanceof cc.Texture2D)this.initWithTexture(a, b, c); else if (a instanceof cc.SpriteFrame)this.initWithSpriteFrame(a); else if (a instanceof HTMLImageElement || a instanceof
            HTMLCanvasElement)b = new cc.Texture2D, b.initWithElement(a), b.handleLoadedTexture(), this.initWithTexture(b)
    }, getQuad: function () {
        return this._quad
    }, setBlendFunc: null, init: null, initWithFile: function (a, b) {
        cc.assert(a, cc._LogInfos.Sprite_initWithFile);
        var c = cc.textureCache.textureForKey(a);
        if (c) {
            if (!b) {
                var d = c.getContentSize();
                b = cc.rect(0, 0, d.width, d.height)
            }
            return this.initWithTexture(c, b)
        }
        c = cc.textureCache.addImage(a);
        return this.initWithTexture(c, b || cc.rect(0, 0, c._contentSize.width, c._contentSize.height))
    },
    initWithTexture: null, _textureLoadedCallback: null, setTextureRect: null, updateTransform: null, addChild: null, updateColor: function () {
        var a = this._displayedColor, b = this._displayedOpacity, a = {r: a.r, g: a.g, b: a.b, a: b};
        this._opacityModifyRGB && (a.r *= b / 255, a.g *= b / 255, a.b *= b / 255);
        b = this._quad;
        b.bl.colors = a;
        b.br.colors = a;
        b.tl.colors = a;
        b.tr.colors = a;
        this._batchNode && (this.atlasIndex != cc.Sprite.INDEX_NOT_INITIALIZED ? this.textureAtlas.updateQuad(b, this.atlasIndex) : this.dirty = !0);
        this._quadDirty = !0
    }, setOpacity: null, setColor: null,
    updateDisplayedColor: null, setSpriteFrame: null, setDisplayFrame: function (a) {
        cc.log(cc._LogInfos.Sprite_setDisplayFrame);
        this.setSpriteFrame(a)
    }, isFrameDisplayed: null, displayFrame: function () {
        return cc.SpriteFrame.create(this._texture, cc.rectPointsToPixels(this._rect), this._rectRotated, cc.pointPointsToPixels(this._unflippedOffsetPositionFromCenter), cc.sizePointsToPixels(this._contentSize))
    }, setBatchNode: null, setTexture: null, _updateBlendFunc: function () {
        this._batchNode ? cc.log(cc._LogInfos.Sprite__updateBlendFunc) :
                !this._texture || !this._texture.hasPremultipliedAlpha() ? (this._blendFunc.src = cc.SRC_ALPHA, this._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA, this.opacityModifyRGB = !1) : (this._blendFunc.src = cc.BLEND_SRC, this._blendFunc.dst = cc.BLEND_DST, this.opacityModifyRGB = !0)
    }, _changeTextureColor: function () {
        var a, b = this._texture, c = this._textureRect_Canvas;
        if (b && (c.validRect && this._originalTexture) && (a = b.getHtmlElementObj()))if (b = cc.textureCache.getTextureColors(this._originalTexture.getHtmlElementObj()))this._colorized = !0,
                a instanceof HTMLCanvasElement && !this._rectRotated && !this._newTextureWhenChangeColor ? cc.generateTintImage(a, b, this._displayedColor, c, a) : (a = cc.generateTintImage(a, b, this._displayedColor, c), b = new cc.Texture2D, b.initWithElement(a), b.handleLoadedTexture(), this.texture = b)
    }, _setTextureCoords: function (a) {
        a = cc.rectPointsToPixels(a);
        var b = this._batchNode ? this.textureAtlas.texture : this._texture;
        if (b) {
            var c = b.pixelsWidth, d = b.pixelsHeight, e, f = this._quad;
            this._rectRotated ? (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ?
                (b = (2 * a.x + 1) / (2 * c), c = b + (2 * a.height - 2) / (2 * c), e = (2 * a.y + 1) / (2 * d), a = e + (2 * a.width - 2) / (2 * d)) : (b = a.x / c, c = (a.x + a.height) / c, e = a.y / d, a = (a.y + a.width) / d), this._flippedX && (d = e, e = a, a = d), this._flippedY && (d = b, b = c, c = d), f.bl.texCoords.u = b, f.bl.texCoords.v = e, f.br.texCoords.u = b, f.br.texCoords.v = a, f.tl.texCoords.u = c, f.tl.texCoords.v = e, f.tr.texCoords.u = c, f.tr.texCoords.v = a) : (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (b = (2 * a.x + 1) / (2 * c), c = b + (2 * a.width - 2) / (2 * c), e = (2 * a.y + 1) / (2 * d), a = e + (2 * a.height - 2) / (2 * d)) : (b = a.x / c, c = (a.x + a.width) /
                c, e = a.y / d, a = (a.y + a.height) / d), this._flippedX && (d = b, b = c, c = d), this._flippedY && (d = e, e = a, a = d), f.bl.texCoords.u = b, f.bl.texCoords.v = a, f.br.texCoords.u = c, f.br.texCoords.v = a, f.tl.texCoords.u = b, f.tl.texCoords.v = e, f.tr.texCoords.u = c, f.tr.texCoords.v = e);
            this._quadDirty = !0
        }
    }, draw: null});
cc.Sprite.create = function (a, b, c) {
    return new cc.Sprite(a, b, c)
};
cc.Sprite.INDEX_NOT_INITIALIZED = -1;
cc._renderType === cc._RENDER_TYPE_CANVAS ? (_p = cc.Sprite.prototype, _p._spriteFrameLoadedCallback = function (a) {
    this.setNodeDirty(!0);
    this.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize());
    a = this.color;
    (255 !== a.r || 255 !== a.g || 255 !== a.b) && this._changeTextureColor();
    this._callLoadedEventCallbacks()
}, _p.setOpacityModifyRGB = function (a) {
    this._opacityModifyRGB !== a && (this._opacityModifyRGB = a, this.setNodeDirty(!0))
}, _p.updateDisplayedOpacity = function (a) {
    cc.NodeRGBA.prototype.updateDisplayedOpacity.call(this,
        a);
    this._setNodeDirtyForCache()
}, _p.ctor = function (a, b, c) {
    cc.NodeRGBA.prototype.ctor.call(this);
    this._shouldBeHidden = !1;
    this._offsetPosition = cc.p(0, 0);
    this._unflippedOffsetPositionFromCenter = cc.p(0, 0);
    this._blendFunc = {src: cc.BLEND_SRC, dst: cc.BLEND_DST};
    this._rect = cc.rect(0, 0, 0, 0);
    this._newTextureWhenChangeColor = !1;
    this._textureLoaded = !0;
    this._textureRect_Canvas = {x: 0, y: 0, width: 0, height: 0, validRect: !1};
    this._drawSize_Canvas = cc.size(0, 0);
    this._softInit(a, b, c)
}, _p.setBlendFunc = function (a, b) {
    var c = this._blendFunc;
    void 0 === b ? (c.src = a.src, c.dst = a.dst) : (c.src = a, c.dst = b);
    this._isLighterMode = c && (c.src == cc.SRC_ALPHA && c.dst == cc.ONE || c.src == cc.ONE && c.dst == cc.ONE)
}, _p.init = function () {
    if (0 < arguments.length)return this.initWithFile(arguments[0], arguments[1]);
    cc.NodeRGBA.prototype.init.call(this);
    this.dirty = this._recursiveDirty = !1;
    this._opacityModifyRGB = !0;
    this._blendFunc.src = cc.BLEND_SRC;
    this._blendFunc.dst = cc.BLEND_DST;
    this.texture = null;
    this._textureLoaded = !0;
    this._flippedX = this._flippedY = !1;
    this.anchorY = this.anchorX =
        0.5;
    this._offsetPosition.x = 0;
    this._offsetPosition.y = 0;
    this._hasChildren = !1;
    this.setTextureRect(cc.rect(0, 0, 0, 0), !1, cc.size(0, 0));
    return!0
}, _p.initWithTexture = function (a, b, c) {
    cc.assert(0 != arguments.length, cc._LogInfos.CCSpriteBatchNode_initWithTexture);
    if ((c = c || !1) && a.isLoaded()) {
        var d = a.getHtmlElementObj(), d = cc.cutRotateImageToCanvas(d, b), e = new cc.Texture2D;
        e.initWithElement(d);
        e.handleLoadedTexture();
        a = e;
        this._rect = cc.rect(0, 0, b.width, b.height)
    }
    if (!cc.NodeRGBA.prototype.init.call(this))return!1;
    this._batchNode = null;
    this.dirty = this._recursiveDirty = !1;
    this._opacityModifyRGB = !0;
    this._blendFunc.src = cc.BLEND_SRC;
    this._blendFunc.dst = cc.BLEND_DST;
    this._flippedX = this._flippedY = !1;
    this.anchorY = this.anchorX = 0.5;
    this._offsetPosition.x = 0;
    this._offsetPosition.y = 0;
    this._hasChildren = !1;
    this._textureLoaded = d = a.isLoaded();
    if (!d)return this._rectRotated = c, b && (this._rect.x = b.x, this._rect.y = b.y, this._rect.width = b.width, this._rect.height = b.height), a.addLoadedEventListener(this._textureLoadedCallback, this), !0;
    b || (b = cc.rect(0, 0, a.width, a.height));
    a && (d = b.y + b.height, b.x + b.width > a.width && cc.error(cc._LogInfos.RectWidth, a.url), d > a.height && cc.error(cc._LogInfos.RectHeight, a.url));
    this.texture = this._originalTexture = a;
    this.setTextureRect(b, c);
    this.batchNode = null;
    return!0
}, _p._textureLoadedCallback = function (a) {
    if (!this._textureLoaded) {
        this._textureLoaded = !0;
        var b = this._rect;
        b ? cc._rectEqualToZero(b) && (b.width = a.width, b.height = a.height) : b = cc.rect(0, 0, a.width, a.height);
        this.texture = this._originalTexture = a;
        this.setTextureRect(b,
            this._rectRotated);
        this.batchNode = this._batchNode;
        this._callLoadedEventCallbacks()
    }
}, _p.setTextureRect = function (a, b, c) {
    this._rectRotated = b || !1;
    this.setContentSize(c || a);
    this.setVertexRect(a);
    b = this._textureRect_Canvas;
    c = cc.contentScaleFactor();
    b.x = 0 | a.x * c;
    b.y = 0 | a.y * c;
    b.width = 0 | a.width * c;
    b.height = 0 | a.height * c;
    b.validRect = !(0 === b.width || 0 === b.height || 0 > b.x || 0 > b.y);
    a = this._unflippedOffsetPositionFromCenter;
    this._flippedX && (a.x = -a.x);
    this._flippedY && (a.y = -a.y);
    this._offsetPosition.x = a.x + (this._contentSize.width -
        this._rect.width) / 2;
    this._offsetPosition.y = a.y + (this._contentSize.height - this._rect.height) / 2;
    this._batchNode && (this.dirty = !0)
}, _p.updateTransform = function () {
    if (this.dirty) {
        var a = this._parent;
        !this._visible || a && a != this._batchNode && a._shouldBeHidden ? this._shouldBeHidden = !0 : (this._shouldBeHidden = !1, this._transformToBatch = !a || a == this._batchNode ? this.nodeToParentTransform() : cc.AffineTransformConcat(this.nodeToParentTransform(), a._transformToBatch));
        this.dirty = this._recursiveDirty = !1
    }
    this._hasChildren &&
    this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.updateTransform)
}, _p.addChild = function (a, b, c) {
    cc.assert(a, cc._LogInfos.CCSpriteBatchNode_addChild_2);
    null == b && (b = a._localZOrder);
    null == c && (c = a.tag);
    cc.NodeRGBA.prototype.addChild.call(this, a, b, c);
    this._hasChildren = !0
}, _p.setOpacity = function (a) {
    cc.NodeRGBA.prototype.setOpacity.call(this, a);
    this._setNodeDirtyForCache()
}, _p.setColor = function (a) {
    var b = this.color;
    b.r === a.r && b.g === a.g && b.b === a.b || (cc.NodeRGBA.prototype.setColor.call(this,
        a), this._changeTextureColor(), this._setNodeDirtyForCache())
}, _p.updateDisplayedColor = function (a) {
    var b = this.color;
    cc.NodeRGBA.prototype.updateDisplayedColor.call(this, a);
    a = this._displayedColor;
    b.r === a.r && b.g === a.g && b.b === a.b || (this._changeTextureColor(), this._setNodeDirtyForCache())
}, _p.setSpriteFrame = function (a) {
    var b = this;
    "string" == typeof a && (a = cc.spriteFrameCache.getSpriteFrame(a), cc.assert(a, cc._LogInfos.CCSpriteBatchNode_setSpriteFrame));
    b.setNodeDirty(!0);
    var c = a.getOffset();
    b._unflippedOffsetPositionFromCenter.x =
        c.x;
    b._unflippedOffsetPositionFromCenter.y = c.y;
    b._rectRotated = a.isRotated();
    var c = a.getTexture(), d = a.textureLoaded();
    d || (b._textureLoaded = !1, a.addLoadedEventListener(function (a) {
        b._textureLoaded = !0;
        var c = a.getTexture();
        c != b._texture && (b.texture = c);
        b.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize());
        b._callLoadedEventCallbacks()
    }, b));
    c != b._texture && (b.texture = c);
    b._rectRotated && (b._originalTexture = c);
    b.setTextureRect(a.getRect(), b._rectRotated, a.getOriginalSize());
    b._colorized = !1;
    d && (a =
        b.color, (255 !== a.r || 255 !== a.g || 255 !== a.b) && b._changeTextureColor())
}, _p.isFrameDisplayed = function (a) {
    return a.getTexture() != this._texture ? !1 : cc.rectEqualToRect(a.getRect(), this._rect)
}, _p.setBatchNode = function (a) {
    (this._batchNode = a) ? (this._transformToBatch = cc.AffineTransformIdentity(), this.textureAtlas = this._batchNode.textureAtlas) : (this.atlasIndex = cc.Sprite.INDEX_NOT_INITIALIZED, this.textureAtlas = null, this.dirty = this._recursiveDirty = !1)
}, _p.setTexture = function (a) {
    a && "string" === typeof a ? (a = cc.textureCache.addImage(a),
        this.setTexture(a), a = a.getContentSize(), this.setTextureRect(cc.rect(0, 0, a.width, a.height))) : (cc.assert(!a || a instanceof cc.Texture2D, cc._LogInfos.CCSpriteBatchNode_setTexture), this._texture != a && (a && a.getHtmlElementObj()instanceof HTMLImageElement && (this._originalTexture = a), this._texture = a))
}, _p.draw = function (a) {
    if (this._textureLoaded) {
        a = a || cc._renderContext;
        this._isLighterMode && (a.globalCompositeOperation = "lighter");
        var b = cc.view.getScaleX(), c = cc.view.getScaleY();
        a.globalAlpha = this._displayedOpacity /
            255;
        var d = this._rect, e = this._contentSize, f = this._offsetPosition, g = this._drawSize_Canvas, h = 0 | f.x, k = -f.y - d.height, l = this._textureRect_Canvas;
        g.width = d.width * b;
        g.height = d.height * c;
        if (this._flippedX || this._flippedY)a.save(), this._flippedX && (h = -f.x - d.width, a.scale(-1, 1)), this._flippedY && (k = f.y, a.scale(1, -1));
        h *= b;
        k *= c;
        this._texture && l.validRect ? (e = this._texture.getHtmlElementObj(), this._colorized ? a.drawImage(e, 0, 0, l.width, l.height, h, k, g.width, g.height) : a.drawImage(e, l.x, l.y, l.width, l.height, h, k, g.width,
            g.height)) : !this._texture && l.validRect && (g = this.color, a.fillStyle = "rgba(" + g.r + "," + g.g + "," + g.b + ",1)", a.fillRect(h, k, e.width * b, e.height * c));
        1 === cc.SPRITE_DEBUG_DRAW || this._showNode ? (a.strokeStyle = "rgba(0,255,0,1)", h /= b, k = -(k / c), h = [cc.p(h, k), cc.p(h + d.width, k), cc.p(h + d.width, k - d.height), cc.p(h, k - d.height)], cc._drawingUtil.drawPoly(h, 4, !0)) : 2 === cc.SPRITE_DEBUG_DRAW && (a.strokeStyle = "rgba(0,255,0,1)", b = this._rect, k = -k, h = [cc.p(h, k), cc.p(h + b.width, k), cc.p(h + b.width, k - b.height), cc.p(h, k - b.height)], cc._drawingUtil.drawPoly(h,
            4, !0));
        (this._flippedX || this._flippedY) && a.restore();
        cc.g_NumberOfDraws++
    }
}, delete _p) : (cc.assert("function" === typeof cc._tmp.WebGLSprite, cc._LogInfos.MissingFile, "SpritesWebGL.js"), cc._tmp.WebGLSprite(), delete cc._tmp.WebGLSprite);
cc.assert("function" === typeof cc._tmp.PrototypeSprite, cc._LogInfos.MissingFile, "SpritesPropertyDefine.js");
cc._tmp.PrototypeSprite();
delete cc._tmp.PrototypeSprite;
cc.AnimationFrame = cc.Class.extend({_spriteFrame: null, _delayPerUnit: 0, _userInfo: null, ctor: function (a, b, c) {
    this._spriteFrame = a || null;
    this._delayPerUnit = b || 0;
    this._userInfo = c || null
}, clone: function () {
    var a = new cc.AnimationFrame;
    a.initWithSpriteFrame(this._spriteFrame.clone(), this._delayPerUnit, this._userInfo);
    return a
}, copyWithZone: function (a) {
    return cc.clone(this)
}, copy: function (a) {
    a = new cc.AnimationFrame;
    a.initWithSpriteFrame(this._spriteFrame.clone(), this._delayPerUnit, this._userInfo);
    return a
}, initWithSpriteFrame: function (a, b, c) {
    this._spriteFrame = a;
    this._delayPerUnit = b;
    this._userInfo = c;
    return!0
}, getSpriteFrame: function () {
    return this._spriteFrame
}, setSpriteFrame: function (a) {
    this._spriteFrame = a
}, getDelayUnits: function () {
    return this._delayPerUnit
}, setDelayUnits: function (a) {
    this._delayPerUnit = a
}, getUserInfo: function () {
    return this._userInfo
}, setUserInfo: function (a) {
    this._userInfo = a
}});
cc.AnimationFrame.create = function (a, b, c) {
    return new cc.AnimationFrame(a, b, c)
};
cc.Animation = cc.Class.extend({_frames: null, _loops: 0, _restoreOriginalFrame: !1, _duration: 0, _delayPerUnit: 0, _totalDelayUnits: 0, ctor: function (a, b, c) {
    this._frames = [];
    if (void 0 === a)this.initWithSpriteFrames(null, 0); else {
        var d = a[0];
        d && (d instanceof cc.SpriteFrame ? this.initWithSpriteFrames(a, b, c) : d instanceof cc.AnimationFrame && this.initWithAnimationFrames(a, b, c))
    }
}, getFrames: function () {
    return this._frames
}, setFrames: function (a) {
    this._frames = a
}, addSpriteFrame: function (a) {
    var b = new cc.AnimationFrame;
    b.initWithSpriteFrame(a,
        1, null);
    this._frames.push(b);
    this._totalDelayUnits++
}, addSpriteFrameWithFile: function (a) {
    a = cc.textureCache.addImage(a);
    var b = cc.rect(0, 0, 0, 0);
    b.width = a.width;
    b.height = a.height;
    a = cc.SpriteFrame.create(a, b);
    this.addSpriteFrame(a)
}, addSpriteFrameWithTexture: function (a, b) {
    var c = cc.SpriteFrame.create(a, b);
    this.addSpriteFrame(c)
}, initWithAnimationFrames: function (a, b, c) {
    cc.arrayVerifyType(a, cc.AnimationFrame);
    this._delayPerUnit = b;
    this._loops = void 0 === c ? 1 : c;
    this._totalDelayUnits = 0;
    b = this._frames;
    for (c = b.length =
        0; c < a.length; c++) {
        var d = a[c];
        b.push(d);
        this._totalDelayUnits += d.getDelayUnits()
    }
    return!0
}, clone: function () {
    var a = new cc.Animation;
    a.initWithAnimationFrames(this._copyFrames(), this._delayPerUnit, this._loops);
    a.setRestoreOriginalFrame(this._restoreOriginalFrame);
    return a
}, copyWithZone: function (a) {
    a = new cc.Animation;
    a.initWithAnimationFrames(this._copyFrames(), this._delayPerUnit, this._loops);
    a.setRestoreOriginalFrame(this._restoreOriginalFrame);
    return a
}, _copyFrames: function () {
    for (var a = [], b = 0; b < this._frames.length; b++)a.push(this._frames[b].clone());
    return a
}, copy: function (a) {
    return this.copyWithZone(null)
}, getLoops: function () {
    return this._loops
}, setLoops: function (a) {
    this._loops = a
}, setRestoreOriginalFrame: function (a) {
    this._restoreOriginalFrame = a
}, getRestoreOriginalFrame: function () {
    return this._restoreOriginalFrame
}, getDuration: function () {
    return this._totalDelayUnits * this._delayPerUnit
}, getDelayPerUnit: function () {
    return this._delayPerUnit
}, setDelayPerUnit: function (a) {
    this._delayPerUnit = a
}, getTotalDelayUnits: function () {
    return this._totalDelayUnits
},
    initWithSpriteFrames: function (a, b, c) {
        cc.arrayVerifyType(a, cc.SpriteFrame);
        this._loops = void 0 === c ? 1 : c;
        this._delayPerUnit = b || 0;
        this._totalDelayUnits = 0;
        b = this._frames;
        b.length = 0;
        if (a) {
            for (c = 0; c < a.length; c++) {
                var d = a[c], e = new cc.AnimationFrame;
                e.initWithSpriteFrame(d, 1, null);
                b.push(e)
            }
            this._totalDelayUnits += a.length
        }
        return!0
    }, retain: function () {
    }, release: function () {
    }});
cc.Animation.create = function (a, b, c) {
    return new cc.Animation(a, b, c)
};
cc.animationCache = {_animations: {}, addAnimation: function (a, b) {
    this._animations[b] = a
}, removeAnimation: function (a) {
    a && this._animations[a] && delete this._animations[a]
}, getAnimation: function (a) {
    return this._animations[a] ? this._animations[a] : null
}, _addAnimationsWithDictionary: function (a, b) {
    var c = a.animations;
    if (c) {
        var d = 1, e = a.properties;
        if (e)for (var d = null != e.format ? parseInt(e.format) : d, e = e.spritesheets, f = cc.spriteFrameCache, g = cc.path, h = 0; h < e.length; h++)f.addSpriteFrames(g.changeBasename(b, e[h]));
        switch (d) {
            case 1:
                this._parseVersion1(c);
                break;
            case 2:
                this._parseVersion2(c);
                break;
            default:
                cc.log(cc._LogInfos.animationCache__addAnimationsWithDictionary_2)
        }
    } else cc.log(cc._LogInfos.animationCache__addAnimationsWithDictionary)
}, addAnimations: function (a) {
    cc.assert(a, cc._LogInfos.animationCache_addAnimations_2);
    var b = cc.loader.getRes(a);
    b ? this._addAnimationsWithDictionary(b, a) : cc.log(cc._LogInfos.animationCache_addAnimations)
}, _parseVersion1: function (a) {
    var b = cc.spriteFrameCache, c;
    for (c in a) {
        var d = a[c], e = d.frames, d = parseFloat(d.delay) ||
            0, f = null;
        if (e) {
            for (var f = [], g = 0; g < e.length; g++) {
                var h = b.getSpriteFrame(e[g]);
                if (h) {
                    var k = new cc.AnimationFrame;
                    k.initWithSpriteFrame(h, 1, null);
                    f.push(k)
                } else cc.log(cc._LogInfos.animationCache__parseVersion1_2, c, e[g])
            }
            0 === f.length ? cc.log(cc._LogInfos.animationCache__parseVersion1_3, c) : (f.length != e.length && cc.log(cc._LogInfos.animationCache__parseVersion1_4, c), f = cc.Animation.create(f, d, 1), cc.animationCache.addAnimation(f, c))
        } else cc.log(cc._LogInfos.animationCache__parseVersion1, c)
    }
}, _parseVersion2: function (a) {
    var b =
        cc.spriteFrameCache, c;
    for (c in a) {
        var d = a[c], e = d.loop, f = parseInt(d.loops), e = e ? cc.REPEAT_FOREVER : isNaN(f) ? 1 : f, f = d.restoreOriginalFrame && !0 == d.restoreOriginalFrame ? !0 : !1, g = d.frames;
        if (g) {
            for (var h = [], k = 0; k < g.length; k++) {
                var l = g[k], m = l.spriteframe, n = b.getSpriteFrame(m);
                if (n) {
                    var m = parseFloat(l.delayUnits) || 0, l = l.notification, q = new cc.AnimationFrame;
                    q.initWithSpriteFrame(n, m, l);
                    h.push(q)
                } else cc.log(cc._LogInfos.animationCache__parseVersion2_2, c, m)
            }
            d = parseFloat(d.delayPerUnit) || 0;
            g = new cc.Animation;
            g.initWithAnimationFrames(h,
                d, e);
            g.setRestoreOriginalFrame(f);
            cc.animationCache.addAnimation(g, c)
        } else cc.log(cc._LogInfos.animationCache__parseVersion2, c)
    }
}, _clear: function () {
    this._animations = {}
}};
cc.SpriteFrame = cc.Class.extend({_offset: null, _originalSize: null, _rectInPixels: null, _rotated: !1, _rect: null, _offsetInPixels: null, _originalSizeInPixels: null, _texture: null, _textureFilename: "", _textureLoaded: !1, _eventListeners: null, ctor: function (a, b, c, d, e) {
    this._offset = cc.p(0, 0);
    this._offsetInPixels = cc.p(0, 0);
    this._originalSize = cc.size(0, 0);
    this._rotated = !1;
    this._originalSizeInPixels = cc.size(0, 0);
    this._textureFilename = "";
    this._texture = null;
    this._textureLoaded = !1;
    void 0 !== a && void 0 !== b && (void 0 === c || void 0 ===
        d || void 0 === e ? this.initWithTexture(a, b) : this.initWithTexture(a, b, c, d, e))
}, textureLoaded: function () {
    return this._textureLoaded
}, addLoadedEventListener: function (a, b) {
    null == this._eventListeners && (this._eventListeners = []);
    this._eventListeners.push({eventCallback: a, eventTarget: b})
}, _callLoadedEventCallbacks: function () {
    var a = this._eventListeners;
    if (a) {
        for (var b = 0, c = a.length; b < c; b++) {
            var d = a[b];
            d.eventCallback.call(d.eventTarget, this)
        }
        a.length = 0
    }
}, getRectInPixels: function () {
    var a = this._rectInPixels;
    return cc.rect(a.x,
        a.y, a.width, a.height)
}, setRectInPixels: function (a) {
    this._rectInPixels || (this._rectInPixels = cc.rect(0, 0, 0, 0));
    this._rectInPixels.x = a.x;
    this._rectInPixels.y = a.y;
    this._rectInPixels.width = a.width;
    this._rectInPixels.height = a.height;
    this._rect = cc.rectPixelsToPoints(a)
}, isRotated: function () {
    return this._rotated
}, setRotated: function (a) {
    this._rotated = a
}, getRect: function () {
    var a = this._rect;
    return cc.rect(a.x, a.y, a.width, a.height)
}, setRect: function (a) {
    this._rect || (this._rect = cc.rect(0, 0, 0, 0));
    this._rect.x = a.x;
    this._rect.y = a.y;
    this._rect.width = a.width;
    this._rect.height = a.height;
    this._rectInPixels = cc.rectPointsToPixels(this._rect)
}, getOffsetInPixels: function () {
    return this._offsetInPixels
}, setOffsetInPixels: function (a) {
    this._offsetInPixels.x = a.x;
    this._offsetInPixels.y = a.y;
    cc._pointPixelsToPointsOut(this._offsetInPixels, this._offset)
}, getOriginalSizeInPixels: function () {
    return this._originalSizeInPixels
}, setOriginalSizeInPixels: function (a) {
    this._originalSizeInPixels.width = a.width;
    this._originalSizeInPixels.height =
        a.height
}, getOriginalSize: function () {
    return this._originalSize
}, setOriginalSize: function (a) {
    this._originalSize.width = a.width;
    this._originalSize.height = a.height
}, getTexture: function () {
    if (this._texture)return this._texture;
    if ("" !== this._textureFilename) {
        var a = cc.textureCache.addImage(this._textureFilename);
        a && (this._textureLoaded = a.isLoaded());
        return a
    }
    return null
}, setTexture: function (a) {
    if (this._texture != a) {
        var b = a.isLoaded();
        this._textureLoaded = b;
        this._texture = a;
        b || a.addLoadedEventListener(function (a) {
            this._textureLoaded = !0;
            if (this._rotated && cc._renderType === cc._RENDER_TYPE_CANVAS) {
                var b = a.getHtmlElementObj(), b = cc.cutRotateImageToCanvas(b, this.getRect()), e = new cc.Texture2D;
                e.initWithElement(b);
                e.handleLoadedTexture();
                this.setTexture(e);
                b = this.getRect();
                this.setRect(cc.rect(0, 0, b.width, b.height))
            }
            b = this._rect;
            0 === b.width && 0 === b.height && (b = a.width, a = a.height, this._rect.width = b, this._rect.height = a, this._rectInPixels = cc.rectPointsToPixels(this._rect), this._originalSizeInPixels.width = this._rectInPixels.width, this._originalSizeInPixels.height =
                this._rectInPixels.height, this._originalSize.width = b, this._originalSize.height = a);
            this._callLoadedEventCallbacks()
        }, this)
    }
}, getOffset: function () {
    return this._offset
}, setOffset: function (a) {
    this._offset.x = a.x;
    this._offset.y = a.y
}, clone: function () {
    var a = new cc.SpriteFrame;
    a.initWithTexture(this._textureFilename, this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels);
    a.setTexture(this._texture);
    return a
}, copyWithZone: function () {
    var a = new cc.SpriteFrame;
    a.initWithTexture(this._textureFilename,
        this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels);
    a.setTexture(this._texture);
    return a
}, copy: function () {
    return this.copyWithZone()
}, initWithTexture: function (a, b, c, d, e) {
    2 === arguments.length && (b = cc.rectPointsToPixels(b));
    d = d || cc.p(0, 0);
    e = e || b;
    c = c || !1;
    "string" == typeof a ? (this._texture = null, this._textureFilename = a) : a instanceof cc.Texture2D && this.setTexture(a);
    if (a = this.getTexture()) {
        var f, g;
        c ? (f = b.x + b.height, g = b.y + b.width) : (f = b.x + b.width, g = b.y + b.height);
        f > a.width && cc.error(cc._LogInfos.RectWidth,
            a.url);
        g > a.height && cc.error(cc._LogInfos.RectHeight, a.url)
    }
    this._rectInPixels = b;
    this._rect = cc.rectPixelsToPoints(b);
    this._offsetInPixels.x = d.x;
    this._offsetInPixels.y = d.y;
    cc._pointPixelsToPointsOut(d, this._offset);
    this._originalSizeInPixels.width = e.width;
    this._originalSizeInPixels.height = e.height;
    cc._sizePixelsToPointsOut(e, this._originalSize);
    this._rotated = c;
    return!0
}});
cc.SpriteFrame.create = function (a, b, c, d, e) {
    return new cc.SpriteFrame(a, b, c, d, e)
};
cc.SpriteFrame._frameWithTextureForCanvas = function (a, b, c, d, e) {
    var f = new cc.SpriteFrame;
    f._texture = a;
    f._rectInPixels = b;
    f._rect = cc.rectPixelsToPoints(b);
    f._offsetInPixels.x = d.x;
    f._offsetInPixels.y = d.y;
    cc._pointPixelsToPointsOut(f._offsetInPixels, f._offset);
    f._originalSizeInPixels.width = e.width;
    f._originalSizeInPixels.height = e.height;
    cc._sizePixelsToPointsOut(f._originalSizeInPixels, f._originalSize);
    f._rotated = c;
    return f
};
cc.spriteFrameCache = {_CCNS_REG1: /^\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*$/, _CCNS_REG2: /^\s*\{\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*,\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*\}\s*$/, _spriteFrames: {}, _spriteFramesAliases: {}, _frameConfigCache: {}, _rectFromString: function (a) {
    a = this._CCNS_REG2.exec(a);
    return!a ? cc.rect(0, 0, 0, 0) : cc.rect(parseFloat(a[1]), parseFloat(a[2]), parseFloat(a[3]), parseFloat(a[4]))
}, _pointFromString: function (a) {
    a = this._CCNS_REG1.exec(a);
    return!a ? cc.p(0, 0) : cc.p(parseFloat(a[1]), parseFloat(a[2]))
}, _sizeFromString: function (a) {
    a = this._CCNS_REG1.exec(a);
    return!a ? cc.size(0, 0) : cc.size(parseFloat(a[1]), parseFloat(a[2]))
}, _getFrameConfig: function (a) {
    var b = cc.loader.getRes(a);
    cc.assert(b, cc._LogInfos.spriteFrameCache__getFrameConfig_2, a);
    cc.loader.release(a);
    if (b._inited)return this._frameConfigCache[a] = b;
    var c = b.frames, d = b.metadata || b.meta, b = {}, e = {}, f = 0;
    d && (f = d.format, f = 1 >= f.length ? parseInt(f) : f, e.image = d.textureFileName || d.textureFileName ||
        d.image);
    for (var g in c) {
        var h = c[g];
        if (h) {
            d = {};
            if (0 == f) {
                d.rect = cc.rect(h.x, h.y, h.width, h.height);
                d.rotated = !1;
                d.offset = cc.p(h.offsetX, h.offsetY);
                var k = h.originalWidth, h = h.originalHeight;
                (!k || !h) && cc.log(cc._LogInfos.spriteFrameCache__getFrameConfig);
                k = Math.abs(k);
                h = Math.abs(h);
                d.size = cc.size(k, h)
            } else if (1 == f || 2 == f)d.rect = this._rectFromString(h.frame), d.rotated = h.rotated || !1, d.offset = this._pointFromString(h.offset), d.size = this._sizeFromString(h.sourceSize); else if (3 == f) {
                var k = this._sizeFromString(h.spriteSize),
                    l = this._rectFromString(h.textureRect);
                k && (l = cc.rect(l.x, l.y, k.width, k.height));
                d.rect = l;
                d.rotated = h.textureRotated || !1;
                d.offset = this._pointFromString(h.spriteOffset);
                d.size = this._sizeFromString(h.spriteSourceSize);
                d.aliases = h.aliases
            } else k = h.frame, l = h.sourceSize, g = h.filename || g, d.rect = cc.rect(k.x, k.y, k.w, k.h), d.rotated = h.rotated || !1, d.offset = cc.p(0, 0), d.size = cc.size(l.w, l.h);
            b[g] = d
        }
    }
    return this._frameConfigCache[a] = {_inited: !0, frames: b, meta: e}
}, addSpriteFrames: function (a, b) {
    cc.assert(a, cc._LogInfos.spriteFrameCache_addSpriteFrames_2);
    var c = this._frameConfigCache[a] || cc.loader.getRes(a);
    if (c && c.frames) {
        var d = this._frameConfigCache[a] || this._getFrameConfig(a), c = d.frames, d = d.meta;
        b ? b instanceof cc.Texture2D || ("string" == typeof b ? b = cc.textureCache.addImage(b) : cc.assert(0, cc._LogInfos.spriteFrameCache_addSpriteFrames_3)) : (d = cc.path.changeBasename(a, d.image || ".png"), b = cc.textureCache.addImage(d));
        var d = this._spriteFramesAliases, e = this._spriteFrames, f;
        for (f in c) {
            var g = c[f], h = e[f];
            if (!h) {
                h = cc.SpriteFrame.create(b, g.rect, g.rotated, g.offset,
                    g.size);
                if (g = g.aliases)for (var k = 0, l = g.length; k < l; k++) {
                    var m = g[k];
                    d[m] && cc.log(cc._LogInfos.spriteFrameCache_addSpriteFrames, m);
                    d[m] = f
                }
                cc._renderType === cc._RENDER_TYPE_CANVAS && h.isRotated() && h.getTexture().isLoaded() && (g = h.getTexture().getHtmlElementObj(), g = cc.cutRotateImageToCanvas(g, h.getRectInPixels()), k = new cc.Texture2D, k.initWithElement(g), k.handleLoadedTexture(), h.setTexture(k), g = h._rect, h.setRect(cc.rect(0, 0, g.width, g.height)));
                e[f] = h
            }
        }
    }
}, _checkConflict: function (a) {
    a = a.frames;
    for (var b in a)this._spriteFrames[b] &&
    cc.log(cc._LogInfos.spriteFrameCache__checkConflict, b)
}, addSpriteFrame: function (a, b) {
    this._spriteFrames[b] = a
}, removeSpriteFrames: function () {
    this._spriteFrames = {};
    this._spriteFramesAliases = {}
}, removeSpriteFrameByName: function (a) {
    a && (this._spriteFramesAliases[a] && delete this._spriteFramesAliases[a], this._spriteFrames[a] && delete this._spriteFrames[a])
}, removeSpriteFramesFromFile: function (a) {
    var b = this._spriteFrames, c = this._spriteFramesAliases;
    if (a = this._frameConfigCache[a]) {
        a = a.frames;
        for (var d in a)if (b[d]) {
            delete b[d];
            for (var e in c)c[e] == d && delete c[e]
        }
    }
}, removeSpriteFramesFromTexture: function (a) {
    var b = this._spriteFrames, c = this._spriteFramesAliases, d;
    for (d in b) {
        var e = b[d];
        if (e && e.getTexture() == a) {
            delete b[d];
            for (var f in c)c[f] == d && delete c[f]
        }
    }
}, getSpriteFrame: function (a) {
    var b = this._spriteFrames[a];
    if (!b) {
        var c = this._spriteFramesAliases[a];
        c && ((b = this._spriteFrames[c.toString()]) || delete this._spriteFramesAliases[a])
    }
    b || cc.log(cc._LogInfos.spriteFrameCache_getSpriteFrame, a);
    return b
}, _clear: function () {
    this._spriteFrames =
    {};
    this._spriteFramesAliases = {};
    this._frameConfigCache = {}
}};
cc.g_NumberOfDraws = 0;
cc.GLToClipTransform = function (a) {
    var b = new cc.kmMat4;
    cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, b);
    var c = new cc.kmMat4;
    cc.kmGLGetMatrix(cc.KM_GL_MODELVIEW, c);
    cc.kmMat4Multiply(a, b, c)
};
cc.Director = cc.Class.extend({_landscape: !1, _nextDeltaTimeZero: !1, _paused: !1, _purgeDirectorInNextLoop: !1, _sendCleanupToScene: !1, _animationInterval: 0, _oldAnimationInterval: 0, _projection: 0, _accumDt: 0, _contentScaleFactor: 1, _displayStats: !1, _deltaTime: 0, _frameRate: 0, _FPSLabel: null, _SPFLabel: null, _drawsLabel: null, _winSizeInPoints: null, _lastUpdate: null, _nextScene: null, _notificationNode: null, _openGLView: null, _scenesStack: null, _projectionDelegate: null, _runningScene: null, _frames: 0, _totalFrames: 0, _secondsPerFrame: 0,
    _dirtyRegion: null, _scheduler: null, _actionManager: null, _eventProjectionChanged: null, _eventAfterDraw: null, _eventAfterVisit: null, _eventAfterUpdate: null, ctor: function () {
        var a = this;
        a._lastUpdate = Date.now();
        cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function () {
            a._lastUpdate = Date.now()
        })
    }, init: function () {
        this._oldAnimationInterval = this._animationInterval = 1 / cc.defaultFPS;
        this._scenesStack = [];
        this._projection = cc.Director.PROJECTION_DEFAULT;
        this._projectionDelegate = null;
        this._frameRate = this._accumDt =
            0;
        this._displayStats = !1;
        this._totalFrames = this._frames = 0;
        this._lastUpdate = Date.now();
        this._purgeDirectorInNextLoop = this._paused = !1;
        this._winSizeInPoints = cc.size(0, 0);
        this._openGLView = null;
        this._contentScaleFactor = 1;
        this._scheduler = new cc.Scheduler;
        this._actionManager = cc.ActionManager ? new cc.ActionManager : null;
        this._scheduler.scheduleUpdateForTarget(this._actionManager, cc.Scheduler.PRIORITY_SYSTEM, !1);
        this._eventAfterDraw = new cc.EventCustom(cc.Director.EVENT_AFTER_DRAW);
        this._eventAfterDraw.setUserData(this);
        this._eventAfterVisit = new cc.EventCustom(cc.Director.EVENT_AFTER_VISIT);
        this._eventAfterVisit.setUserData(this);
        this._eventAfterUpdate = new cc.EventCustom(cc.Director.EVENT_AFTER_UPDATE);
        this._eventAfterUpdate.setUserData(this);
        this._eventProjectionChanged = new cc.EventCustom(cc.Director.EVENT_PROJECTION_CHANGED);
        this._eventProjectionChanged.setUserData(this);
        return!0
    }, calculateDeltaTime: function () {
        var a = Date.now();
        this._nextDeltaTimeZero ? (this._deltaTime = 0, this._nextDeltaTimeZero = !1) : this._deltaTime =
            (a - this._lastUpdate) / 1E3;
        0 < cc.game.config[cc.game.CONFIG_KEY.debugMode] && 0.2 < this._deltaTime && (this._deltaTime = 1 / 60);
        this._lastUpdate = a
    }, drawScene: function () {
        this.calculateDeltaTime();
        this._paused || (this._scheduler.update(this._deltaTime), cc.eventManager.dispatchEvent(this._eventAfterUpdate));
        this._clear();
        this._nextScene && this.setNextScene();
        this._beforeVisitScene && this._beforeVisitScene();
        this._runningScene && (this._runningScene.visit(), cc.eventManager.dispatchEvent(this._eventAfterVisit));
        this._notificationNode &&
        this._notificationNode.visit();
        this._displayStats && this._showStats();
        this._afterVisitScene && this._afterVisitScene();
        cc.eventManager.dispatchEvent(this._eventAfterDraw);
        this._totalFrames++;
        this._displayStats && this._calculateMPF()
    }, _beforeVisitScene: null, _afterVisitScene: null, end: function () {
        this._purgeDirectorInNextLoop = !0
    }, getContentScaleFactor: function () {
        return this._contentScaleFactor
    }, getNotificationNode: function () {
        return this._notificationNode
    }, getWinSize: function () {
        return this._winSizeInPoints
    },
    getWinSizeInPixels: function () {
        return cc.size(this._winSizeInPoints.width * this._contentScaleFactor, this._winSizeInPoints.height * this._contentScaleFactor)
    }, pause: function () {
        this._paused || (this._oldAnimationInterval = this._animationInterval, this.setAnimationInterval(0.25), this._paused = !0)
    }, popScene: function () {
        cc.assert(this._runningScene, cc._LogInfos.Director_popScene);
        this._scenesStack.pop();
        var a = this._scenesStack.length;
        0 == a ? this.end() : (this._sendCleanupToScene = !0, this._nextScene = this._scenesStack[a -
            1])
    }, purgeCachedData: function () {
        cc.animationCache._clear();
        cc.spriteFrameCache._clear();
        cc.textureCache._clear()
    }, purgeDirector: function () {
        this.getScheduler().unscheduleAllCallbacks();
        cc.eventManager && cc.eventManager.setEnabled(!1);
        this._runningScene && (this._runningScene.onExitTransitionDidStart(), this._runningScene.onExit(), this._runningScene.cleanup());
        this._nextScene = this._runningScene = null;
        this._scenesStack.length = 0;
        this.stopAnimation();
        this.purgeCachedData();
        cc.checkGLErrorDebug()
    }, pushScene: function (a) {
        cc.assert(a,
            cc._LogInfos.Director_pushScene);
        this._sendCleanupToScene = !1;
        this._scenesStack.push(a);
        this._nextScene = a
    }, runScene: function (a) {
        cc.assert(a, cc._LogInfos.Director_pushScene);
        if (this._runningScene) {
            var b = this._scenesStack.length;
            0 === b ? (this._sendCleanupToScene = !0, this._scenesStack[b] = a) : (this._sendCleanupToScene = !0, this._scenesStack[b - 1] = a);
            this._nextScene = a
        } else this.pushScene(a), this.startAnimation()
    }, resume: function () {
        this._paused && (this.setAnimationInterval(this._oldAnimationInterval), (this._lastUpdate =
            Date.now()) || cc.log(cc._LogInfos.Director_resume), this._paused = !1, this._deltaTime = 0)
    }, setContentScaleFactor: function (a) {
        a != this._contentScaleFactor && (this._contentScaleFactor = a, this._createStatsLabel())
    }, setDefaultValues: function () {
    }, setNextDeltaTimeZero: function (a) {
        this._nextDeltaTimeZero = a
    }, setNextScene: function () {
        var a = !1, b = !1;
        cc.TransitionScene && (a = this._runningScene ? this._runningScene instanceof cc.TransitionScene : !1, b = this._nextScene ? this._nextScene instanceof cc.TransitionScene : !1);
        if (!b) {
            if (b =
                this._runningScene)b.onExitTransitionDidStart(), b.onExit();
            this._sendCleanupToScene && b && b.cleanup()
        }
        this._runningScene = this._nextScene;
        this._nextScene = null;
        !a && null != this._runningScene && (this._runningScene.onEnter(), this._runningScene.onEnterTransitionDidFinish())
    }, setNotificationNode: function (a) {
        this._notificationNode = a
    }, getDelegate: function () {
        return this._projectionDelegate
    }, setDelegate: function (a) {
        this._projectionDelegate = a
    }, _showStats: function () {
        this._frames++;
        this._accumDt += this._deltaTime;
        this._FPSLabel &&
        this._SPFLabel && this._drawsLabel ? (this._accumDt > cc.DIRECTOR_FPS_INTERVAL && (this._SPFLabel.string = this._secondsPerFrame.toFixed(3), this._frameRate = this._frames / this._accumDt, this._accumDt = this._frames = 0, this._FPSLabel.string = this._frameRate.toFixed(1), this._drawsLabel.string = (0 | cc.g_NumberOfDraws).toString()), this._FPSLabel.visit(), this._SPFLabel.visit(), this._drawsLabel.visit()) : this._createStatsLabel();
        cc.g_NumberOfDraws = 0
    }, isSendCleanupToScene: function () {
        return this._sendCleanupToScene
    }, getRunningScene: function () {
        return this._runningScene
    },
    getAnimationInterval: function () {
        return this._animationInterval
    }, isDisplayStats: function () {
        return this._displayStats
    }, setDisplayStats: function (a) {
        this._displayStats = a
    }, getSecondsPerFrame: function () {
        return this._secondsPerFrame
    }, isNextDeltaTimeZero: function () {
        return this._nextDeltaTimeZero
    }, isPaused: function () {
        return this._paused
    }, getTotalFrames: function () {
        return this._totalFrames
    }, popToRootScene: function () {
        this.popToSceneStackLevel(1)
    }, popToSceneStackLevel: function (a) {
        cc.assert(this._runningScene,
            cc._LogInfos.Director_popToSceneStackLevel_2);
        var b = this._scenesStack, c = b.length;
        if (0 == c)this.end(); else if (!(a > c)) {
            for (; c > a;) {
                var d = b.pop();
                d.running && (d.onExitTransitionDidStart(), d.onExit());
                d.cleanup();
                c--
            }
            this._nextScene = b[b.length - 1];
            this._sendCleanupToScene = !1
        }
    }, getScheduler: function () {
        return this._scheduler
    }, setScheduler: function (a) {
        this._scheduler != a && (this._scheduler = a)
    }, getActionManager: function () {
        return this._actionManager
    }, setActionManager: function (a) {
        this._actionManager != a && (this._actionManager =
            a)
    }, getDeltaTime: function () {
        return this._deltaTime
    }, _createStatsLabel: null, _calculateMPF: function () {
        this._secondsPerFrame = (Date.now() - this._lastUpdate) / 1E3
    }});
cc.Director.EVENT_PROJECTION_CHANGED = "director_projection_changed";
cc.Director.EVENT_AFTER_DRAW = "director_after_draw";
cc.Director.EVENT_AFTER_VISIT = "director_after_visit";
cc.Director.EVENT_AFTER_UPDATE = "director_after_update";
cc.DisplayLinkDirector = cc.Director.extend({invalid: !1, startAnimation: function () {
    this._nextDeltaTimeZero = !0;
    this.invalid = !1
}, mainLoop: function () {
    this._purgeDirectorInNextLoop ? (this._purgeDirectorInNextLoop = !1, this.purgeDirector()) : this.invalid || this.drawScene()
}, stopAnimation: function () {
    this.invalid = !0
}, setAnimationInterval: function (a) {
    this._animationInterval = a;
    this.invalid || (this.stopAnimation(), this.startAnimation())
}});
cc.Director.sharedDirector = null;
cc.Director.firstUseDirector = !0;
cc.Director._getInstance = function () {
    cc.Director.firstUseDirector && (cc.Director.firstUseDirector = !1, cc.Director.sharedDirector = new cc.DisplayLinkDirector, cc.Director.sharedDirector.init());
    return cc.Director.sharedDirector
};
cc.defaultFPS = 60;
cc.Director.PROJECTION_2D = 0;
cc.Director.PROJECTION_3D = 1;
cc.Director.PROJECTION_CUSTOM = 3;
cc.Director.PROJECTION_DEFAULT = cc.Director.PROJECTION_3D;
cc._renderType === cc._RENDER_TYPE_CANVAS ? (_p = cc.Director.prototype, _p.setProjection = function (a) {
    this._projection = a;
    cc.eventManager.dispatchEvent(this._eventProjectionChanged)
}, _p.setDepthTest = function () {
}, _p.setOpenGLView = function (a) {
    this._winSizeInPoints.width = cc._canvas.width;
    this._winSizeInPoints.height = cc._canvas.height;
    this._openGLView = a || cc.view;
    cc.eventManager && cc.eventManager.setEnabled(!0)
}, _p._clear = function () {
    var a = this._openGLView.getViewPortRect();
    cc._renderContext.clearRect(-a.x, a.y,
        a.width, -a.height)
}, _p._createStatsLabel = function () {
    var a = 0, a = this._winSizeInPoints.width > this._winSizeInPoints.height ? 0 | 24 * (this._winSizeInPoints.height / 320) : 0 | 24 * (this._winSizeInPoints.width / 320);
    this._FPSLabel = cc.LabelTTF.create("000.0", "Arial", a);
    this._SPFLabel = cc.LabelTTF.create("0.000", "Arial", a);
    this._drawsLabel = cc.LabelTTF.create("0000", "Arial", a);
    a = cc.DIRECTOR_STATS_POSITION;
    this._drawsLabel.setPosition(this._drawsLabel.width / 2 + a.x, 5 * this._drawsLabel.height / 2 + a.y);
    this._SPFLabel.setPosition(this._SPFLabel.width /
        2 + a.x, 3 * this._SPFLabel.height / 2 + a.y);
    this._FPSLabel.setPosition(this._FPSLabel.width / 2 + a.x, this._FPSLabel.height / 2 + a.y)
}, _p.getVisibleSize = function () {
    return this.getWinSize()
}, _p.getVisibleOrigin = function () {
    return cc.p(0, 0)
}) : (cc.Director._fpsImage = new Image, cc._addEventListener(cc.Director._fpsImage, "load", function () {
    cc.Director._fpsImageLoaded = !0
}), cc._fpsImage && (cc.Director._fpsImage.src = cc._fpsImage), cc.assert("function" === typeof cc._tmp.DirectorWebGL, cc._LogInfos.MissingFile, "CCDirectorWebGL.js"),
    cc._tmp.DirectorWebGL(), delete cc._tmp.DirectorWebGL);
cc.PRIORITY_NON_SYSTEM = cc.PRIORITY_SYSTEM + 1;
cc.arrayVerifyType = function (a, b) {
    if (a && 0 < a.length)for (var c = 0; c < a.length; c++)if (!(a[c]instanceof b))return cc.log(cc._LogInfos.arrayVerifyType), !1;
    return!0
};
cc.arrayRemoveObject = function (a, b) {
    for (var c = 0, d = a.length; c < d; c++)if (a[c] == b) {
        a.splice(c, 1);
        break
    }
};
cc.arrayRemoveArray = function (a, b) {
    for (var c = 0, d = b.length; c < d; c++)cc.arrayRemoveObject(a, b[c])
};
cc.arrayAppendObjectsToIndex = function (a, b, c) {
    a.splice.apply(a, [c, 0].concat(b));
    return a
};
cc.ListEntry = function (a, b, c, d, e, f) {
    this.prev = a;
    this.next = b;
    this.target = c;
    this.priority = d;
    this.paused = e;
    this.markedForDeletion = f
};
cc.HashUpdateEntry = function (a, b, c, d) {
    this.list = a;
    this.entry = b;
    this.target = c;
    this.hh = d
};
cc.HashTimerEntry = function (a, b, c, d, e, f, g) {
    this.timers = a;
    this.target = b;
    this.timerIndex = c;
    this.currentTimer = d;
    this.currentTimerSalvaged = e;
    this.paused = f;
    this.hh = g
};
cc.Timer = cc.Class.extend({_interval: 0, _callback: null, _target: null, _elapsed: 0, _runForever: !1, _useDelay: !1, _timesExecuted: 0, _repeat: 0, _delay: 0, getInterval: function () {
    return this._interval
}, setInterval: function (a) {
    this._interval = a
}, getCallback: function () {
    return this._callback
}, ctor: function (a, b, c, d, e) {
    this._target = a;
    this._callback = b;
    this._elapsed = -1;
    this._interval = c || 0;
    this._delay = e || 0;
    this._useDelay = 0 < this._delay;
    this._repeat = null == d ? cc.REPEAT_FOREVER : d;
    this._runForever = this._repeat == cc.REPEAT_FOREVER
},
    _doCallback: function () {
        if ("string" == typeof this._callback)this._target[this._callback](this._elapsed); else this._callback.call(this._target, this._elapsed)
    }, update: function (a) {
        if (-1 == this._elapsed)this._timesExecuted = this._elapsed = 0; else {
            var b = this._target, c = this._callback;
            this._elapsed += a;
            this._runForever && !this._useDelay ? this._elapsed >= this._interval && (b && c && this._doCallback(), this._elapsed = 0) : (this._useDelay ? this._elapsed >= this._delay && (b && c && this._doCallback(), this._elapsed -= this._delay, this._timesExecuted +=
                1, this._useDelay = !1) : this._elapsed >= this._interval && (b && c && this._doCallback(), this._elapsed = 0, this._timesExecuted += 1), this._timesExecuted > this._repeat && cc.director.getScheduler().unscheduleCallbackForTarget(b, c))
        }
    }});
cc.Scheduler = cc.Class.extend({_timeScale: 1, _updates: null, _hashForUpdates: null, _arrayForUpdates: null, _hashForTimers: null, _arrayForTimes: null, _currentTarget: null, _currentTargetSalvaged: !1, _updateHashLocked: !1, ctor: function () {
    this._timeScale = 1;
    this._updates = [
        [],
        [],
        []
    ];
    this._hashForUpdates = {};
    this._arrayForUpdates = [];
    this._hashForTimers = {};
    this._arrayForTimers = [];
    this._currentTarget = null;
    this._updateHashLocked = this._currentTargetSalvaged = !1
}, _removeHashElement: function (a) {
    delete this._hashForTimers[a.target.__instanceId];
    cc.arrayRemoveObject(this._arrayForTimers, a);
    a.Timer = null;
    a.target = null
}, _removeUpdateFromHash: function (a) {
    if (a = this._hashForUpdates[a.target.__instanceId])cc.arrayRemoveObject(a.list, a.entry), delete this._hashForUpdates[a.target.__instanceId], cc.arrayRemoveObject(this._arrayForUpdates, a), a.entry = null, a.target = null
}, _priorityIn: function (a, b, c, d) {
    d = new cc.ListEntry(null, null, b, c, d, !1);
    if (a) {
        for (var e = a.length - 1, f = 0; f <= e && !(c < a[f].priority); f++);
        a.splice(f, 0, d)
    } else a = [], a.push(d);
    c = new cc.HashUpdateEntry(a,
        d, b, null);
    this._arrayForUpdates.push(c);
    this._hashForUpdates[b.__instanceId] = c;
    return a
}, _appendIn: function (a, b, c) {
    c = new cc.ListEntry(null, null, b, 0, c, !1);
    a.push(c);
    a = new cc.HashUpdateEntry(a, c, b, null);
    this._arrayForUpdates.push(a);
    this._hashForUpdates[b.__instanceId] = a
}, setTimeScale: function (a) {
    this._timeScale = a
}, getTimeScale: function () {
    return this._timeScale
}, update: function (a) {
    var b = this._updates, c = this._arrayForTimers, d, e, f;
    this._updateHashLocked = !0;
    1 != this._timeScale && (a *= this._timeScale);
    e = 0;
    for (f = b.length; e < f && 0 <= e; e++)for (var g = this._updates[e], h = 0, k = g.length; h < k; h++)d = g[h], !d.paused && !d.markedForDeletion && d.target.update(a);
    e = 0;
    for (f = c.length; e < f; e++) {
        d = c[e];
        if (!d)break;
        this._currentTarget = d;
        this._currentTargetSalvaged = !1;
        if (!d.paused)for (d.timerIndex = 0; d.timerIndex < d.timers.length; d.timerIndex++)d.currentTimer = d.timers[d.timerIndex], d.currentTimerSalvaged = !1, d.currentTimer.update(a), d.currentTimer = null;
        this._currentTargetSalvaged && 0 == d.timers.length && (this._removeHashElement(d), e--)
    }
    e =
        0;
    for (f = b.length; e < f; e++) {
        g = this._updates[e];
        h = 0;
        for (k = g.length; h < k;) {
            d = g[h];
            if (!d)break;
            d.markedForDeletion ? this._removeUpdateFromHash(d) : h++
        }
    }
    this._updateHashLocked = !1;
    this._currentTarget = null
}, scheduleCallbackForTarget: function (a, b, c, d, e, f) {
    cc.assert(b, cc._LogInfos.Scheduler_scheduleCallbackForTarget_2);
    cc.assert(a, cc._LogInfos.Scheduler_scheduleCallbackForTarget_3);
    c = c || 0;
    d = null == d ? cc.REPEAT_FOREVER : d;
    e = e || 0;
    f = f || !1;
    var g = this._hashForTimers[a.__instanceId];
    g || (g = new cc.HashTimerEntry(null, a,
        0, null, null, f, null), this._arrayForTimers.push(g), this._hashForTimers[a.__instanceId] = g);
    if (null == g.timers)g.timers = []; else for (var h = 0; h < g.timers.length; h++)if (f = g.timers[h], b == f._callback) {
        cc.log(cc._LogInfos.Scheduler_scheduleCallbackForTarget, f.getInterval().toFixed(4), c.toFixed(4));
        f._interval = c;
        return
    }
    f = new cc.Timer(a, b, c, d, e);
    g.timers.push(f)
}, scheduleUpdateForTarget: function (a, b, c) {
    if (null !== a) {
        var d = this._updates, e = this._hashForUpdates[a.__instanceId];
        e ? e.entry.markedForDeletion = !1 : 0 == b ? this._appendIn(d[1],
            a, c) : 0 > b ? d[0] = this._priorityIn(d[0], a, b, c) : d[2] = this._priorityIn(d[2], a, b, c)
    }
}, unscheduleCallbackForTarget: function (a, b) {
    if (!(null == a || null == b)) {
        var c = this._hashForTimers[a.__instanceId];
        if (c)for (var d = c.timers, e = 0, f = d.length; e < f; e++) {
            var g = d[e];
            if (b == g._callback) {
                g == c.currentTimer && !c.currentTimerSalvaged && (c.currentTimerSalvaged = !0);
                d.splice(e, 1);
                c.timerIndex >= e && c.timerIndex--;
                0 == d.length && (this._currentTarget == c ? this._currentTargetSalvaged = !0 : this._removeHashElement(c));
                break
            }
        }
    }
}, unscheduleUpdateForTarget: function (a) {
    null !=
    a && (a = this._hashForUpdates[a.__instanceId], null != a && (this._updateHashLocked ? a.entry.markedForDeletion = !0 : this._removeUpdateFromHash(a.entry)))
}, unscheduleAllCallbacksForTarget: function (a) {
    if (null != a) {
        var b = this._hashForTimers[a.__instanceId];
        if (b) {
            var c = b.timers;
            !b.currentTimerSalvaged && 0 <= c.indexOf(b.currentTimer) && (b.currentTimerSalvaged = !0);
            c.length = 0;
            this._currentTarget == b ? this._currentTargetSalvaged = !0 : this._removeHashElement(b)
        }
        this.unscheduleUpdateForTarget(a)
    }
}, unscheduleAllCallbacks: function () {
    this.unscheduleAllCallbacksWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM)
},
    unscheduleAllCallbacksWithMinPriority: function (a) {
        for (var b = this._arrayForTimers, c = this._updates, d = 0, e = b.length; d < e; d++)this.unscheduleAllCallbacksForTarget(b[d].target);
        for (d = 2; 0 <= d; d--)if (!(1 == d && 0 < a || 0 == d && 0 <= a))for (var b = c[d], e = 0, f = b.length; e < f; e++)this.unscheduleUpdateForTarget(b[e].target)
    }, pauseAllTargets: function () {
        return this.pauseAllTargetsWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM)
    }, pauseAllTargetsWithMinPriority: function (a) {
        a = [];
        for (var b, c = this._arrayForTimers, d = this._updates, e = 0, f =
            c.length; e < f; e++)if (b = c[e])b.paused = !0, a.push(b.target);
        e = 0;
        for (f = d.length; e < f; e++)for (var c = d[e], g = 0, h = c.length; g < h; g++)if (b = c[g])b.paused = !0, a.push(b.target);
        return a
    }, resumeTargets: function (a) {
        if (a)for (var b = 0; b < a.length; b++)this.resumeTarget(a[b])
    }, pauseTarget: function (a) {
        cc.assert(a, cc._LogInfos.Scheduler_pauseTarget);
        var b = this._hashForTimers[a.__instanceId];
        b && (b.paused = !0);
        if (a = this._hashForUpdates[a.__instanceId])a.entry.paused = !0
    }, resumeTarget: function (a) {
        cc.assert(a, cc._LogInfos.Scheduler_resumeTarget);
        var b = this._hashForTimers[a.__instanceId];
        b && (b.paused = !1);
        if (a = this._hashForUpdates[a.__instanceId])a.entry.paused = !1
    }, isTargetPaused: function (a) {
        cc.assert(a, cc._LogInfos.Scheduler_isTargetPaused);
        return(a = this._hashForTimers[a.__instanceId]) ? a.paused : !1
    }});
cc.Scheduler.PRIORITY_SYSTEM = -2147483648;
cc._tmp.PrototypeLabelTTF = function () {
    var a = cc.LabelTTF.prototype;
    cc.defineGetterSetter(a, "color", a.getColor, a.setColor);
    cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity);
    cc.defineGetterSetter(a, "string", a.getString, a.setString);
    cc.defineGetterSetter(a, "textAlign", a.getHorizontalAlignment, a.setHorizontalAlignment);
    cc.defineGetterSetter(a, "verticalAlign", a.getVerticalAlignment, a.setVerticalAlignment);
    cc.defineGetterSetter(a, "fontSize", a.getFontSize, a.setFontSize);
    cc.defineGetterSetter(a,
        "fontName", a.getFontName, a.setFontName);
    cc.defineGetterSetter(a, "font", a._getFont, a._setFont);
    cc.defineGetterSetter(a, "boundingWidth", a._getBoundingWidth, a._setBoundingWidth);
    cc.defineGetterSetter(a, "boundingHeight", a._getBoundingHeight, a._setBoundingHeight);
    cc.defineGetterSetter(a, "fillStyle", a._getFillStyle, a.setFontFillColor);
    cc.defineGetterSetter(a, "strokeStyle", a._getStrokeStyle, a._setStrokeStyle);
    cc.defineGetterSetter(a, "lineWidth", a._getLineWidth, a._setLineWidth);
    cc.defineGetterSetter(a, "shadowOffsetX",
        a._getShadowOffsetX, a._setShadowOffsetX);
    cc.defineGetterSetter(a, "shadowOffsetY", a._getShadowOffsetY, a._setShadowOffsetY);
    cc.defineGetterSetter(a, "shadowOpacity", a._getShadowOpacity, a._setShadowOpacity);
    cc.defineGetterSetter(a, "shadowBlur", a._getShadowBlur, a._setShadowBlur)
};
cc.LabelTTF = cc.Sprite.extend({_dimensions: null, _hAlignment: cc.TEXT_ALIGNMENT_CENTER, _vAlignment: cc.VERTICAL_TEXT_ALIGNMENT_TOP, _fontName: null, _fontSize: 0, _string: "", _originalText: null, _isMultiLine: !1, _fontStyleStr: null, _shadowEnabled: !1, _shadowOffset: null, _shadowOpacity: 0, _shadowBlur: 0, _shadowColorStr: null, _strokeEnabled: !1, _strokeColor: null, _strokeSize: 0, _strokeColorStr: null, _textFillColor: null, _fillColorStr: null, _strokeShadowOffsetX: 0, _strokeShadowOffsetY: 0, _needUpdateTexture: !1, _labelCanvas: null,
    _labelContext: null, _lineWidths: null, _className: "LabelTTF", ctor: function (a, b, c, d, e, f) {
        cc.Sprite.prototype.ctor.call(this);
        this._dimensions = cc.size(0, 0);
        this._hAlignment = cc.TEXT_ALIGNMENT_LEFT;
        this._vAlignment = cc.VERTICAL_TEXT_ALIGNMENT_TOP;
        this._opacityModifyRGB = !1;
        this._fontStyleStr = "";
        this._fontName = "Arial";
        this._shadowEnabled = this._isMultiLine = !1;
        this._shadowOffset = cc.p(0, 0);
        this._shadowBlur = this._shadowOpacity = 0;
        this._shadowColorStr = "rgba(128, 128, 128, 0.5)";
        this._strokeEnabled = !1;
        this._strokeColor =
            cc.color(255, 255, 255, 255);
        this._strokeSize = 0;
        this._strokeColorStr = "";
        this._textFillColor = cc.color(255, 255, 255, 255);
        this._fillColorStr = "rgba(255,255,255,1)";
        this._strokeShadowOffsetY = this._strokeShadowOffsetX = 0;
        this._needUpdateTexture = !1;
        this._lineWidths = [];
        this._setColorsString();
        b && b instanceof cc.FontDefinition ? this.initWithStringAndTextDefinition(a, b) : cc.LabelTTF.prototype.initWithString.call(this, a, b, c, d, e, f)
    }, init: function () {
        return this.initWithString(" ", this._fontName, this._fontSize)
    }, _measureConfig: function () {
        this._getLabelContext().font =
            this._fontStyleStr
    }, _measure: function (a) {
        return this._getLabelContext().measureText(a).width
    }, _checkNextline: function (a, b) {
        var c = this._measure(a), d = Math.floor(a.length * b / c), e = a.indexOf("\n");
        if (0.8 * d >= e && 0 < e)return e + 1;
        if (c < b)return a.length;
        for (var c = !1, f = b + 1, e = -1, g = d, h, k = cc.LabelTTF._checkRegEx, l = cc.LabelTTF._reverseCheckRegEx, m = cc.LabelTTF._checkEnRegEx, n = a.substr(d); h = k.exec(n);) {
            g += h[0].length;
            f = a.substr(0, g);
            f = this._measure(f);
            if ("\n" == h[2] && f < b) {
                c = !0;
                e = g;
                break
            }
            if (f > b) {
                -1 != e && (c = !0);
                break
            }
            e =
                g;
            n = a.substr(g)
        }
        if (c)return e;
        n = a.substr(0, d);
        for (e = d; h = l.exec(n);)if (e = h[1].length, n = h[1], f = this._measure(n), f < b) {
            m.test(h[2]) && e++;
            break
        }
        return e || 1
    }, description: function () {
        return"\x3ccc.LabelTTF | FontName \x3d" + this._fontName + " FontSize \x3d " + this._fontSize.toFixed(1) + "\x3e"
    }, setColor: null, _setColorsString: null, updateDisplayedColor: null, setOpacity: null, updateDisplayedOpacity: null, updateDisplayedOpacityForCanvas: function (a) {
        cc.NodeRGBA.prototype.updateDisplayedOpacity.call(this, a);
        this._setColorsString()
    },
    getString: function () {
        return this._string
    }, getHorizontalAlignment: function () {
        return this._hAlignment
    }, getVerticalAlignment: function () {
        return this._vAlignment
    }, getDimensions: function () {
        return cc.size(this._dimensions.width, this._dimensions.height)
    }, getFontSize: function () {
        return this._fontSize
    }, getFontName: function () {
        return this._fontName
    }, initWithString: function (a, b, c, d, e, f) {
        a = a ? a + "" : "";
        c = c || 16;
        d = d || cc.size(0, c);
        e = e || cc.TEXT_ALIGNMENT_LEFT;
        f = f || cc.VERTICAL_TEXT_ALIGNMENT_TOP;
        this._opacityModifyRGB = !1;
        this._dimensions = cc.size(d.width, d.height);
        this._fontName = b || "Arial";
        this._hAlignment = e;
        this._vAlignment = f;
        this._fontSize = c;
        this._fontStyleStr = this._fontSize + "px '" + b + "'";
        this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(b, this._fontSize);
        this.string = a;
        this._setColorsString();
        this._updateTexture();
        this._needUpdateTexture = !1;
        return!0
    }, initWithStringAndTextDefinition: null, setTextDefinition: function (a) {
        a && this._updateWithTextDefinition(a, !0)
    }, getTextDefinition: function () {
        return this._prepareTextDefinition(!1)
    },
    enableShadow: function (a, b, c, d) {
        c = c || 0.5;
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        var e = this._shadowOffset;
        if (e && e.x != a || e._y != b)e.x = a, e.y = b;
        this._shadowOpacity != c && (this._shadowOpacity = c);
        this._setColorsString();
        this._shadowBlur != d && (this._shadowBlur = d);
        this._needUpdateTexture = !0
    }, _getShadowOffsetX: function () {
        return this._shadowOffset.x
    }, _setShadowOffsetX: function (a) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        this._shadowOffset.x != a && (this._shadowOffset.x = a, this._needUpdateTexture = !0)
    }, _getShadowOffsetY: function () {
        return this._shadowOffset._y
    }, _setShadowOffsetY: function (a) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        this._shadowOffset._y != a && (this._shadowOffset._y = a, this._needUpdateTexture = !0)
    }, _getShadowOffset: function () {
        return cc.p(this._shadowOffset.x, this._shadowOffset.y)
    }, _setShadowOffset: function (a) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        if (this._shadowOffset.x != a.x || this._shadowOffset.y != a.y)this._shadowOffset.x = a.x, this._shadowOffset.y = a.y, this._needUpdateTexture = !0
    }, _getShadowOpacity: function () {
        return this._shadowOpacity
    }, _setShadowOpacity: function (a) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        this._shadowOpacity != a && (this._shadowOpacity = a, this._setColorsString(), this._needUpdateTexture = !0)
    }, _getShadowBlur: function () {
        return this._shadowBlur
    }, _setShadowBlur: function (a) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        this._shadowBlur != a && (this._shadowBlur = a, this._needUpdateTexture = !0)
    }, disableShadow: function () {
        this._shadowEnabled && (this._shadowEnabled = !1, this._needUpdateTexture = !0)
    }, enableStroke: function (a, b) {
        !1 === this._strokeEnabled && (this._strokeEnabled = !0);
        var c = this._strokeColor;
        if (c.r !== a.r || c.g !== a.g || c.b !== a.b)c.r = a.r, c.g = a.g, c.b = a.b, this._setColorsString();
        this._strokeSize !== b && (this._strokeSize = b || 0);
        this._needUpdateTexture = !0
    }, _getStrokeStyle: function () {
        return this._strokeColor
    }, _setStrokeStyle: function (a) {
        !1 === this._strokeEnabled && (this._strokeEnabled = !0);
        var b = this._strokeColor;
        if (b.r !== a.r || b.g !== a.g || b.b !== a.b)b.r = a.r, b.g = a.g, b.b =
            a.b, this._setColorsString(), this._needUpdateTexture = !0
    }, _getLineWidth: function () {
        return this._strokeSize
    }, _setLineWidth: function (a) {
        !1 === this._strokeEnabled && (this._strokeEnabled = !0);
        this._strokeSize !== a && (this._strokeSize = a || 0, this._needUpdateTexture = !0)
    }, disableStroke: function () {
        this._strokeEnabled && (this._strokeEnabled = !1, this._needUpdateTexture = !0)
    }, setFontFillColor: null, _getFillStyle: function () {
        return this._textFillColor
    }, _updateWithTextDefinition: function (a, b) {
        a.fontDimensions ? (this._dimensions.width =
            a.boundingWidth, this._dimensions.height = a.boundingHeight) : (this._dimensions.width = 0, this._dimensions.height = 0);
        this._hAlignment = a.textAlign;
        this._vAlignment = a.verticalAlign;
        this._fontName = a.fontName;
        this._fontSize = a.fontSize || 12;
        this._fontStyleStr = this._fontSize + "px '" + this._fontName + "'";
        this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(this._fontName, this._fontSize);
        a.shadowEnabled && this.enableShadow(a.shadowOffsetX, a.shadowOffsetY, a.shadowOpacity, a.shadowBlur);
        a.strokeEnabled && this.enableStroke(a.strokeStyle,
            a.lineWidth);
        this.setFontFillColor(a.fillStyle);
        b && this._updateTexture()
    }, _prepareTextDefinition: function (a) {
        var b = new cc.FontDefinition;
        a ? (b.fontSize = this._fontSize, b.boundingWidth = cc.contentScaleFactor() * this._dimensions.width, b.boundingHeight = cc.contentScaleFactor() * this._dimensions.height) : (b.fontSize = this._fontSize, b.boundingWidth = this._dimensions.width, b.boundingHeight = this._dimensions.height);
        b.fontName = this._fontName;
        b.textAlign = this._hAlignment;
        b.verticalAlign = this._vAlignment;
        if (this._strokeEnabled) {
            b.strokeEnabled = !0;
            var c = this._strokeColor;
            b.strokeStyle = cc.color(c.r, c.g, c.b);
            b.lineWidth = this._strokeSize
        } else b.strokeEnabled = !1;
        this._shadowEnabled ? (b.shadowEnabled = !0, b.shadowBlur = this._shadowBlur, b.shadowOpacity = this._shadowOpacity, b.shadowOffsetX = (a ? cc.contentScaleFactor() : 1) * this._shadowOffset.x, b.shadowOffsetY = (a ? cc.contentScaleFactor() : 1) * this._shadowOffset.y) : b._shadowEnabled = !1;
        a = this._textFillColor;
        b.fillStyle = cc.color(a.r, a.g, a.b);
        return b
    }, _fontClientHeight: 18, setString: function (a) {
        a = String(a);
        this._originalText !=
        a && (this._originalText = a + "", this._updateString(), this._needUpdateTexture = !0)
    }, _updateString: function () {
        this._string = this._originalText
    }, setHorizontalAlignment: function (a) {
        a !== this._hAlignment && (this._hAlignment = a, this._needUpdateTexture = !0)
    }, setVerticalAlignment: function (a) {
        a != this._vAlignment && (this._vAlignment = a, this._needUpdateTexture = !0)
    }, setDimensions: function (a) {
        if (a.width != this._dimensions.width || a.height != this._dimensions.height)this._dimensions = a, this._updateString(), this._needUpdateTexture = !0
    }, _getBoundingWidth: function () {
        return this._dimensions.width
    }, _setBoundingWidth: function (a) {
        a != this._dimensions.width && (this._dimensions.width = a, this._updateString(), this._needUpdateTexture = !0)
    }, _getBoundingHeight: function () {
        return this._dimensions.height
    }, _setBoundingHeight: function (a) {
        a != this._dimensions.height && (this._dimensions.height = a, this._updateString(), this._needUpdateTexture = !0)
    }, setFontSize: function (a) {
        this._fontSize !== a && (this._fontSize = a, this._fontStyleStr = a + "px '" + this._fontName + "'",
            this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(this._fontName, a), this._needUpdateTexture = !0)
    }, setFontName: function (a) {
        this._fontName && this._fontName != a && (this._fontName = a, this._fontStyleStr = this._fontSize + "px '" + a + "'", this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(a, this._fontSize), this._needUpdateTexture = !0)
    }, _getFont: function () {
        return this._fontStyleStr
    }, _setFont: function (a) {
        var b = cc.LabelTTF._fontStyleRE.exec(a);
        b && (this._fontSize = parseInt(b[1]), this._fontName = b[2], this._fontStyleStr =
            a, this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(this._fontName, this._fontSize), this._needUpdateTexture = !0)
    }, _drawTTFInCanvas: function (a) {
        if (a) {
            var b = this._strokeShadowOffsetX, c = this._strokeShadowOffsetY, d = this._contentSize.height - c, e = this._vAlignment, f = this._hAlignment, g = this._fontClientHeight, h = this._strokeSize;
            a.setTransform(1, 0, 0, 1, 0 + 0.5 * b, d + 0.5 * c);
            a.font != this._fontStyleStr && (a.font = this._fontStyleStr);
            a.fillStyle = this._fillColorStr;
            var k = c = 0, l = this._strokeEnabled;
            l && (a.lineWidth = 2 *
                h, a.strokeStyle = this._strokeColorStr);
            this._shadowEnabled && (h = this._shadowOffset, a.shadowColor = this._shadowColorStr, a.shadowOffsetX = h.x, a.shadowOffsetY = -h.y, a.shadowBlur = this._shadowBlur);
            a.textBaseline = cc.LabelTTF._textBaseline[e];
            a.textAlign = cc.LabelTTF._textAlign[f];
            b = this._contentSize.width - b;
            c = f === cc.TEXT_ALIGNMENT_RIGHT ? c + b : f === cc.TEXT_ALIGNMENT_CENTER ? c + b / 2 : c + 0;
            if (this._isMultiLine) {
                f = this._strings.length;
                e === cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM ? k = g + d - g * f : e === cc.VERTICAL_TEXT_ALIGNMENT_CENTER &&
                    (k = g / 2 + (d - g * f) / 2);
                for (e = 0; e < f; e++)b = this._strings[e], h = -d + g * e + k, l && a.strokeText(b, c, h), a.fillText(b, c, h)
            } else e !== cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM && (k = e === cc.VERTICAL_TEXT_ALIGNMENT_TOP ? k - d : k - 0.5 * d), l && a.strokeText(this._string, c, k), a.fillText(this._string, c, k)
        }
    }, _getLabelContext: function () {
        if (this._labelContext)return this._labelContext;
        if (!this._labelCanvas) {
            var a = cc.newElement("canvas"), b = new cc.Texture2D;
            b.initWithElement(a);
            this.texture = b;
            this._labelCanvas = a
        }
        return this._labelContext = this._labelCanvas.getContext("2d")
    },
    _updateTTF: function () {
        var a = this._dimensions.width, b, c, d = this._lineWidths;
        d.length = 0;
        this._isMultiLine = !1;
        this._measureConfig();
        if (0 !== a) {
            var e = this._string;
            this._strings = [];
            b = 0;
            for (c = this._string.length; b < c;) {
                var f = this._checkNextline(e.substr(b), a), g = e.substr(b, f);
                this._strings.push(g);
                b += f
            }
        } else {
            this._strings = this._string.split("\n");
            b = 0;
            for (c = this._strings.length; b < c; b++)d.push(this._measure(this._strings[b]))
        }
        0 < this._strings.length && (this._isMultiLine = !0);
        c = b = 0;
        this._strokeEnabled && (b = c = 2 * this._strokeSize);
        this._shadowEnabled && (e = this._shadowOffset, b += 2 * Math.abs(e.x), c += 2 * Math.abs(e.y));
        a = 0 === a ? this._isMultiLine ? cc.size(0 | Math.max.apply(Math, d) + b, 0 | this._fontClientHeight * this._strings.length + c) : cc.size(0 | this._measure(this._string) + b, 0 | this._fontClientHeight + c) : 0 === this._dimensions.height ? this._isMultiLine ? cc.size(0 | a + b, 0 | this._fontClientHeight * this._strings.length + c) : cc.size(0 | a + b, 0 | this._fontClientHeight + c) : cc.size(0 | a + b, 0 | this._dimensions.height + c);
        this.setContentSize(a);
        this._strokeShadowOffsetX =
            b;
        this._strokeShadowOffsetY = c;
        d = this._anchorPoint;
        this._anchorPointInPoints.x = 0.5 * b + (a.width - b) * d.x;
        this._anchorPointInPoints.y = 0.5 * c + (a.height - c) * d.y
    }, getContentSize: function () {
        this._needUpdateTexture && this._updateTTF();
        return cc.Sprite.prototype.getContentSize.call(this)
    }, _getWidth: function () {
        this._needUpdateTexture && this._updateTTF();
        return cc.Sprite.prototype._getWidth.call(this)
    }, _getHeight: function () {
        this._needUpdateTexture && this._updateTTF();
        return cc.Sprite.prototype._getHeight.call(this)
    },
    _updateTexture: function () {
        var a = this._getLabelContext(), b = this._labelCanvas, c = this._contentSize;
        if (0 === this._string.length)return b.width = 1, b.height = c.height, this.setTextureRect(cc.rect(0, 0, 1, c.height)), !0;
        a.font = this._fontStyleStr;
        this._updateTTF();
        var d = c.width, c = c.height, e = b.width == d && b.height == c;
        b.width = d;
        b.height = c;
        e && a.clearRect(0, 0, d, c);
        this._drawTTFInCanvas(a);
        this._texture && this._texture.handleLoadedTexture();
        this.setTextureRect(cc.rect(0, 0, d, c));
        return!0
    }, visit: function (a) {
        this._string &&
            "" != this._string && (this._needUpdateTexture && (this._needUpdateTexture = !1, this._updateTexture()), cc.Sprite.prototype.visit.call(this, a || cc._renderContext))
    }, draw: null, _setTextureCoords: function (a) {
        var b = this._batchNode ? this.textureAtlas.texture : this._texture;
        if (b) {
            var c = b.pixelsWidth, d = b.pixelsHeight, e, f = this._quad;
            this._rectRotated ? (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (b = (2 * a.x + 1) / (2 * c), c = b + (2 * a.height - 2) / (2 * c), e = (2 * a.y + 1) / (2 * d), a = e + (2 * a.width - 2) / (2 * d)) : (b = a.x / c, c = (a.x + a.height) / c, e = a.y / d, a = (a.y + a.width) /
                d), this._flippedX && (d = e, e = a, a = d), this._flippedY && (d = b, b = c, c = d), f.bl.texCoords.u = b, f.bl.texCoords.v = e, f.br.texCoords.u = b, f.br.texCoords.v = a, f.tl.texCoords.u = c, f.tl.texCoords.v = e, f.tr.texCoords.u = c, f.tr.texCoords.v = a) : (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (b = (2 * a.x + 1) / (2 * c), c = b + (2 * a.width - 2) / (2 * c), e = (2 * a.y + 1) / (2 * d), a = e + (2 * a.height - 2) / (2 * d)) : (b = a.x / c, c = (a.x + a.width) / c, e = a.y / d, a = (a.y + a.height) / d), this._flippedX && (d = b, b = c, c = d), this._flippedY && (d = e, e = a, a = d), f.bl.texCoords.u = b, f.bl.texCoords.v = a, f.br.texCoords.u =
                c, f.br.texCoords.v = a, f.tl.texCoords.u = b, f.tl.texCoords.v = e, f.tr.texCoords.u = c, f.tr.texCoords.v = e);
            this._quadDirty = !0
        }
    }});
cc._renderType === cc._RENDER_TYPE_CANVAS ? (_p = cc.LabelTTF.prototype, _p.setColor = function (a) {
    cc.NodeRGBA.prototype.setColor.call(this, a);
    this._setColorsString()
}, _p._setColorsString = function () {
    this._needUpdateTexture = !0;
    var a = this._displayedColor, b = this._displayedOpacity, c = this._strokeColor, d = this._textFillColor;
    this._shadowColorStr = "rgba(" + (0 | 0.5 * a.r) + "," + (0 | 0.5 * a.g) + "," + (0 | 0.5 * a.b) + "," + this._shadowOpacity + ")";
    this._fillColorStr = "rgba(" + (0 | a.r / 255 * d.r) + "," + (0 | a.g / 255 * d.g) + "," + (0 | a.b / 255 * d.b) + ", " + b /
        255 + ")";
    this._strokeColorStr = "rgba(" + (0 | a.r / 255 * c.r) + "," + (0 | a.g / 255 * c.g) + "," + (0 | a.b / 255 * c.b) + ", " + b / 255 + ")"
}, _p.updateDisplayedColor = function (a) {
    cc.NodeRGBA.prototype.updateDisplayedColor.call(this, a);
    this._setColorsString()
}, _p.setOpacity = function (a) {
    this._opacity !== a && (cc.Sprite.prototype.setOpacity.call(this, a), this._setColorsString(), this._needUpdateTexture = !0)
}, _p.updateDisplayedOpacity = cc.Sprite.prototype.updateDisplayedOpacity, _p.initWithStringAndTextDefinition = function (a, b) {
    this._updateWithTextDefinition(b,
        !1);
    this.string = a;
    return!0
}, _p.setFontFillColor = function (a) {
    var b = this._textFillColor;
    if (b.r != a.r || b.g != a.g || b.b != a.b)b.r = a.r, b.g = a.g, b.b = a.b, this._setColorsString(), this._needUpdateTexture = !0
}, _p.draw = cc.Sprite.prototype.draw, _p.setTextureRect = function (a, b, c) {
    this._rectRotated = b || !1;
    this.setContentSize(c || a);
    this.setVertexRect(a);
    b = this._textureRect_Canvas;
    b.x = a.x;
    b.y = a.y;
    b.width = a.width;
    b.height = a.height;
    b.validRect = !(0 === b.width || 0 === b.height || 0 > b.x || 0 > b.y);
    a = this._unflippedOffsetPositionFromCenter;
    this._flippedX && (a.x = -a.x);
    this._flippedY && (a.y = -a.y);
    this._offsetPosition.x = a.x + (this._contentSize.width - this._rect.width) / 2;
    this._offsetPosition.y = a.y + (this._contentSize.height - this._rect.height) / 2;
    this._batchNode && (this.dirty = !0)
}, _p = null) : (cc.assert("function" === typeof cc._tmp.WebGLLabelTTF, cc._LogInfos.MissingFile, "LabelTTFWebGL.js"), cc._tmp.WebGLLabelTTF(), delete cc._tmp.WebGLLabelTTF);
cc.assert("function" === typeof cc._tmp.PrototypeLabelTTF, cc._LogInfos.MissingFile, "LabelTTFPropertyDefine.js");
cc._tmp.PrototypeLabelTTF();
delete cc._tmp.PrototypeLabelTTF;
cc.LabelTTF._textAlign = ["left", "center", "right"];
cc.LabelTTF._textBaseline = ["top", "middle", "bottom"];
cc.LabelTTF._checkRegEx = /(.+?)([\s\n\r\-\/\\\:]|[\u4E00-\u9FA5]|[\uFE30-\uFFA0])/;
cc.LabelTTF._reverseCheckRegEx = /(.*)([\s\n\r\-\/\\\:]|[\u4E00-\u9FA5]|[\uFE30-\uFFA0])/;
cc.LabelTTF._checkEnRegEx = /[\s\-\/\\\:]/;
cc.LabelTTF._fontStyleRE = /^(\d+)px\s+['"]?([\w\s\d]+)['"]?$/;
cc.LabelTTF.create = function (a, b, c, d, e, f) {
    return new cc.LabelTTF(a, b, c, d, e, f)
};
cc.LabelTTF._SHADER_PROGRAM = cc.USE_LA88_LABELS ? cc.SHADER_POSITION_TEXTURECOLOR : cc.SHADER_POSITION_TEXTUREA8COLOR;
cc.LabelTTF.__labelHeightDiv = cc.newElement("div");
cc.LabelTTF.__labelHeightDiv.style.fontFamily = "Arial";
cc.LabelTTF.__labelHeightDiv.style.position = "absolute";
cc.LabelTTF.__labelHeightDiv.style.left = "-100px";
cc.LabelTTF.__labelHeightDiv.style.top = "-100px";
cc.LabelTTF.__labelHeightDiv.style.lineHeight = "normal";
document.body ? document.body.appendChild(cc.LabelTTF.__labelHeightDiv) : cc._addEventListener(window, "load", function () {
    this.removeEventListener("load", arguments.callee, !1);
    document.body.appendChild(cc.LabelTTF.__labelHeightDiv)
}, !1);
cc.LabelTTF.__getFontHeightByDiv = function (a, b) {
    var c = cc.LabelTTF.__fontHeightCache[a + "." + b];
    if (0 < c)return c;
    var d = cc.LabelTTF.__labelHeightDiv;
    d.innerHTML = "ajghl~!";
    d.style.fontFamily = a;
    d.style.fontSize = b + "px";
    c = d.clientHeight;
    cc.LabelTTF.__fontHeightCache[a + "." + b] = c;
    d.innerHTML = "";
    return c
};
cc.LabelTTF.__fontHeightCache = {};var cc = cc || {};
cc._tmp = cc._tmp || {};
cc.associateWithNative = function (a, b) {
};
cc.KEY = {backspace: 8, tab: 9, enter: 13, shift: 16, ctrl: 17, alt: 18, pause: 19, capslock: 20, escape: 27, pageup: 33, pagedown: 34, end: 35, home: 36, left: 37, up: 38, right: 39, down: 40, insert: 45, Delete: 46, "0": 48, 1: 49, 2: 50, 3: 51, 4: 52, 5: 53, 6: 54, 7: 55, 8: 56, 9: 57, a: 65, b: 66, c: 67, d: 68, e: 69, f: 70, g: 71, h: 72, i: 73, j: 74, k: 75, l: 76, m: 77, n: 78, o: 79, p: 80, q: 81, r: 82, s: 83, t: 84, u: 85, v: 86, w: 87, x: 88, y: 89, z: 90, num0: 96, num1: 97, num2: 98, num3: 99, num4: 100, num5: 101, num6: 102, num7: 103, num8: 104, num9: 105, "*": 106, "+": 107, "-": 109, numdel: 110, "/": 111, f1: 112, f2: 113,
    f3: 114, f4: 115, f5: 116, f6: 117, f7: 118, f8: 119, f9: 120, f10: 121, f11: 122, f12: 123, numlock: 144, scrolllock: 145, semicolon: 186, ",": 186, equal: 187, "\x3d": 187, ";": 188, comma: 188, dash: 189, ".": 190, period: 190, forwardslash: 191, grave: 192, "[": 219, openbracket: 219, "]": 221, closebracket: 221, backslash: 220, quote: 222, space: 32};
cc.FMT_JPG = 0;
cc.FMT_PNG = 1;
cc.FMT_TIFF = 2;
cc.FMT_RAWDATA = 3;
cc.FMT_WEBP = 4;
cc.FMT_UNKNOWN = 5;
cc.getImageFormatByData = function (a) {
    return 8 < a.length && 137 == a[0] && 80 == a[1] && 78 == a[2] && 71 == a[3] && 13 == a[4] && 10 == a[5] && 26 == a[6] && 10 == a[7] ? cc.FMT_PNG : 2 < a.length && (73 == a[0] && 73 == a[1] || 77 == a[0] && 77 == a[1] || 255 == a[0] && 216 == a[1]) ? cc.FMT_TIFF : cc.FMT_UNKNOWN
};
cc.inherits = function (a, b) {
    function c() {
    }

    c.prototype = b.prototype;
    a.superClass_ = b.prototype;
    a.prototype = new c;
    a.prototype.constructor = a
};
cc.base = function (a, b, c) {
    var d = arguments.callee.caller;
    if (d.superClass_)return ret = d.superClass_.constructor.apply(a, Array.prototype.slice.call(arguments, 1));
    for (var e = Array.prototype.slice.call(arguments, 2), f = !1, g = a.constructor; g; g = g.superClass_ && g.superClass_.constructor)if (g.prototype[b] === d)f = !0; else if (f)return g.prototype[b].apply(a, e);
    if (a[b] === d)return a.constructor.prototype[b].apply(a, e);
    throw Error("cc.base called from a method of one name to a method of a different name");
};
cc.screen = {_supportsFullScreen: !1, _preOnFullScreenChange: null, _touchEvent: "", _fn: null, _fnMap: [
    ["requestFullscreen", "exitFullscreen", "fullscreenchange", "fullscreenEnabled", "fullscreenElement"],
    ["requestFullScreen", "exitFullScreen", "fullScreenchange", "fullScreenEnabled", "fullScreenElement"],
    ["webkitRequestFullScreen", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitIsFullScreen", "webkitCurrentFullScreenElement"],
    ["mozRequestFullScreen", "mozCancelFullScreen", "mozfullscreenchange", "mozFullScreen",
        "mozFullScreenElement"],
    ["msRequestFullscreen", "msExitFullscreen", "MSFullscreenChange", "msFullscreenEnabled", "msFullscreenElement"]
], init: function () {
    this._fn = {};
    var a, b, c = this._fnMap, d;
    a = 0;
    for (l = c.length; a < l; a++)if ((b = c[a]) && b[1]in document) {
        a = 0;
        for (d = b.length; a < d; a++)this._fn[c[0][a]] = b[a];
        break
    }
    this._supportsFullScreen = void 0 != this._fn.requestFullscreen;
    this._touchEvent = "ontouchstart"in window ? "touchstart" : "mousedown"
}, fullScreen: function () {
    return this._supportsFullScreen && document[this._fn.fullscreenEnabled]
},
    requestFullScreen: function (a, b) {
        if (this._supportsFullScreen) {
            a = a || document.documentElement;
            a[this._fn.requestFullscreen]();
            if (b) {
                var c = this._fn.fullscreenchange;
                this._preOnFullScreenChange && document.removeEventListener(c, this._preOnFullScreenChange);
                this._preOnFullScreenChange = b;
                cc._addEventListener(document, c, b, !1)
            }
            return a[this._fn.requestFullscreen]()
        }
    }, exitFullScreen: function () {
        return this._supportsFullScreen ? document[this._fn.exitFullscreen]() : !0
    }, autoFullScreen: function (a, b) {
        function c() {
            e.requestFullScreen(a,
                b);
            d.removeEventListener(e._touchEvent, c)
        }

        a = a || document.body;
        var d = cc._canvas || a, e = this;
        this.requestFullScreen(a, b);
        cc._addEventListener(d, this._touchEvent, c)
    }};
cc.screen.init();
var _p = cc.inputManager;
_p.setAccelerometerEnabled = function (a) {
    this._accelEnabled !== a && (this._accelEnabled = a, a = cc.director.getScheduler(), this._accelEnabled ? (this._accelCurTime = 0, a.scheduleUpdateForTarget(this)) : (this._accelCurTime = 0, a.unscheduleUpdateForTarget(this)))
};
_p.setAccelerometerInterval = function (a) {
    this._accelInterval !== a && (this._accelInterval = a)
};
_p._registerKeyboardEvent = function () {
    cc._addEventListener(cc._canvas, "keydown", function (a) {
        cc.eventManager.dispatchEvent(new cc.EventKeyboard(a.keyCode, !0));
        a.stopPropagation();
        a.preventDefault()
    }, !1);
    cc._addEventListener(cc._canvas, "keyup", function (a) {
        cc.eventManager.dispatchEvent(new cc.EventKeyboard(a.keyCode, !1));
        a.stopPropagation();
        a.preventDefault()
    }, !1)
};
_p._registerAccelerometerEvent = function () {
    var a = window;
    this._acceleration = new cc.Acceleration;
    this._accelDeviceEvent = a.DeviceMotionEvent || a.DeviceOrientationEvent;
    cc.sys.browserType == cc.sys.BROWSER_TYPE_MOBILE_QQ && (this._accelDeviceEvent = window.DeviceOrientationEvent);
    var b = this._accelDeviceEvent == a.DeviceMotionEvent ? "devicemotion" : "deviceorientation", c = navigator.userAgent;
    if (/Android/.test(c) || /Adr/.test(c) && cc.sys.browserType == cc.BROWSER_TYPE_UC)this._minus = -1;
    cc._addEventListener(a, b, this.didAccelerate.bind(this),
        !1)
};
_p.didAccelerate = function (a) {
    var b = window;
    if (this._accelEnabled) {
        var c = this._acceleration;
        if (this._accelDeviceEvent == window.DeviceMotionEvent) {
            var d = a.accelerationIncludingGravity;
            c.x = 0.1 * this._accelMinus * d.x;
            c.y = 0.1 * this._accelMinus * d.y;
            c.z = 0.1 * d.z
        } else c.x = 0.981 * (a.gamma / 90), c.y = 0.981 * -(a.beta / 90), c.z = 0.981 * (a.alpha / 90);
        c.timestamp = a.timeStamp || Date.now();
        a = c.x;
        b.orientation === cc.UIInterfaceOrientationLandscapeRight ? (c.x = -c.y, c.y = a) : b.orientation === cc.UIInterfaceOrientationLandscapeLeft ? (c.x = c.y,
            c.y = -a) : b.orientation === cc.UIInterfaceOrientationPortraitUpsideDown && (c.x = -c.x, c.y = -c.y)
    }
};
delete _p;
cc.vertexLineToPolygon = function (a, b, c, d, e) {
    e += d;
    if (!(1 >= e)) {
        b *= 0.5;
        for (var f, g = e - 1, h = d; h < e; h++) {
            f = 2 * h;
            var k = cc.p(a[2 * h], a[2 * h + 1]), m;
            if (0 === h)m = cc.pPerp(cc.pNormalize(cc.pSub(k, cc.p(a[2 * (h + 1)], a[2 * (h + 1) + 1])))); else if (h === g)m = cc.pPerp(cc.pNormalize(cc.pSub(cc.p(a[2 * (h - 1)], a[2 * (h - 1) + 1]), k))); else {
                m = cc.p(a[2 * (h - 1)], a[2 * (h - 1) + 1]);
                var q = cc.p(a[2 * (h + 1)], a[2 * (h + 1) + 1]), n = cc.pNormalize(cc.pSub(q, k)), p = cc.pNormalize(cc.pSub(m, k)), r = Math.acos(cc.pDot(n, p));
                m = r < cc.degreesToRadians(70) ? cc.pPerp(cc.pNormalize(cc.pMidpoint(n,
                    p))) : r < cc.degreesToRadians(170) ? cc.pNormalize(cc.pMidpoint(n, p)) : cc.pPerp(cc.pNormalize(cc.pSub(q, m)))
            }
            m = cc.pMult(m, b);
            c[2 * f] = k.x + m.x;
            c[2 * f + 1] = k.y + m.y;
            c[2 * (f + 1)] = k.x - m.x;
            c[2 * (f + 1) + 1] = k.y - m.y
        }
        for (h = 0 == d ? 0 : d - 1; h < g; h++) {
            f = 2 * h;
            a = f + 2;
            b = cc.vertex2(c[2 * f], c[2 * f + 1]);
            e = cc.vertex2(c[2 * (f + 1)], c[2 * (f + 1) + 1]);
            f = cc.vertex2(c[2 * a], c[2 * a]);
            d = cc.vertex2(c[2 * (a + 1)], c[2 * (a + 1) + 1]);
            b = !cc.vertexLineIntersect(b.x, b.y, d.x, d.y, e.x, e.y, f.x, f.y);
            if (!b.isSuccess && (0 > b.value || 1 < b.value))b.isSuccess = !0;
            b.isSuccess && (c[2 * a] = d.x,
                c[2 * a + 1] = d.y, c[2 * (a + 1)] = f.x, c[2 * (a + 1) + 1] = f.y)
        }
    }
};
cc.vertexLineIntersect = function (a, b, c, d, e, f, g, h) {
    if (a == c && b == d || e == g && f == h)return{isSuccess: !1, value: 0};
    c -= a;
    d -= b;
    e -= a;
    f -= b;
    g -= a;
    h -= b;
    a = Math.sqrt(c * c + d * d);
    c /= a;
    d /= a;
    b = e * c + f * d;
    f = f * c - e * d;
    e = b;
    b = g * c + h * d;
    h = h * c - g * d;
    g = b;
    return f == h ? {isSuccess: !1, value: 0} : {isSuccess: !0, value: (g + (e - g) * h / (h - f)) / a}
};
cc.vertexListIsClockwise = function (a) {
    for (var b = 0, c = a.length; b < c; b++) {
        var d = a[(b + 1) % c], e = a[(b + 2) % c];
        if (0 < cc.pCross(cc.pSub(d, a[b]), cc.pSub(e, d)))return!1
    }
    return!0
};
cc.CGAffineToGL = function (a, b) {
    b[2] = b[3] = b[6] = b[7] = b[8] = b[9] = b[11] = b[14] = 0;
    b[10] = b[15] = 1;
    b[0] = a.a;
    b[4] = a.c;
    b[12] = a.tx;
    b[1] = a.b;
    b[5] = a.d;
    b[13] = a.ty
};
cc.GLToCGAffine = function (a, b) {
    b.a = a[0];
    b.c = a[4];
    b.tx = a[12];
    b.b = a[1];
    b.d = a[5];
    b.ty = a[13]
};
cc.EventAcceleration = cc.Event.extend({_acc: null, ctor: function (a) {
    cc.Event.prototype.ctor.call(this, cc.Event.ACCELERATION);
    this._acc = a
}});
cc.EventKeyboard = cc.Event.extend({_keyCode: 0, _isPressed: !1, ctor: function (a, b) {
    cc.Event.prototype.ctor.call(this, cc.Event.KEYBOARD);
    this._keyCode = a;
    this._isPressed = b
}});
cc._EventListenerAcceleration = cc.EventListener.extend({_onAccelerationEvent: null, ctor: function (a) {
    this._onAccelerationEvent = a;
    var b = this;
    cc.EventListener.prototype.ctor.call(this, cc.EventListener.ACCELERATION, cc._EventListenerAcceleration.LISTENER_ID, function (a) {
        b._onAccelerationEvent(a._acc, a)
    })
}, checkAvailable: function () {
    cc.assert(this._onAccelerationEvent, cc._LogInfos._EventListenerAcceleration_checkAvailable);
    return!0
}, clone: function () {
    return new cc._EventListenerAcceleration(this._onAccelerationEvent)
}});
cc._EventListenerAcceleration.LISTENER_ID = "__cc_acceleration";
cc._EventListenerAcceleration.create = function (a) {
    return new cc._EventListenerAcceleration(a)
};
cc._EventListenerKeyboard = cc.EventListener.extend({onKeyPressed: null, onKeyReleased: null, ctor: function () {
    var a = this;
    cc.EventListener.prototype.ctor.call(this, cc.EventListener.KEYBOARD, cc._EventListenerKeyboard.LISTENER_ID, function (b) {
        if (b._isPressed) {
            if (a.onKeyPressed)a.onKeyPressed(b._keyCode, b)
        } else if (a.onKeyReleased)a.onKeyReleased(b._keyCode, b)
    })
}, clone: function () {
    var a = new cc._EventListenerKeyboard;
    a.onKeyPressed = this.onKeyPressed;
    a.onKeyReleased = this.onKeyReleased;
    return a
}, checkAvailable: function () {
    return null ==
        this.onKeyPressed && null == this.onKeyReleased ? (cc.log(cc._LogInfos._EventListenerKeyboard_checkAvailable), !1) : !0
}});
cc._EventListenerKeyboard.LISTENER_ID = "__cc_keyboard";
cc._EventListenerKeyboard.create = function () {
    return new cc._EventListenerKeyboard
};
cc.AtlasNode = cc.NodeRGBA.extend({textureAtlas: null, quadsToDraw: 0, RGBAProtocol: !0, _itemsPerRow: 0, _itemsPerColumn: 0, _itemWidth: 0, _itemHeight: 0, _colorUnmodified: null, _opacityModifyRGB: !1, _blendFunc: null, _ignoreContentScaleFactor: !1, _className: "AtlasNode", ctor: function (a, b, c, d) {
    cc.NodeRGBA.prototype.ctor.call(this);
    this._colorUnmodified = cc.color.WHITE;
    this._blendFunc = {src: cc.BLEND_SRC, dst: cc.BLEND_DST};
    this._ignoreContentScaleFactor = !1;
    void 0 !== d && this.initWithTileFile(a, b, c, d)
}, updateAtlasValues: function () {
    cc.log(cc._LogInfos.AtlasNode_updateAtlasValues)
},
    getColor: function () {
        return this._opacityModifyRGB ? this._colorUnmodified : cc.NodeRGBA.prototype.getColor.call(this)
    }, setOpacityModifyRGB: function (a) {
        var b = this.color;
        this._opacityModifyRGB = a;
        this.color = b
    }, isOpacityModifyRGB: function () {
        return this._opacityModifyRGB
    }, getBlendFunc: function () {
        return this._blendFunc
    }, setBlendFunc: function (a, b) {
        this._blendFunc = void 0 === b ? a : {src: a, dst: b}
    }, setTextureAtlas: function (a) {
        this.textureAtlas = a
    }, getTextureAtlas: function () {
        return this.textureAtlas
    }, getQuadsToDraw: function () {
        return this.quadsToDraw
    },
    setQuadsToDraw: function (a) {
        this.quadsToDraw = a
    }, _textureForCanvas: null, _originalTexture: null, _uniformColor: null, _colorF32Array: null, initWithTileFile: function (a, b, c, d) {
        if (!a)throw"cc.AtlasNode.initWithTileFile(): title should not be null";
        a = cc.textureCache.addImage(a);
        return this.initWithTexture(a, b, c, d)
    }, initWithTexture: null, _initWithTextureForCanvas: function (a, b, c, d) {
        this._itemWidth = b;
        this._itemHeight = c;
        this._opacityModifyRGB = !0;
        this._originalTexture = a;
        if (!this._originalTexture)return cc.log(cc._LogInfos.AtlasNode__initWithTexture),
            !1;
        this._textureForCanvas = this._originalTexture;
        this._calculateMaxItems();
        this.quadsToDraw = d;
        return!0
    }, _initWithTextureForWebGL: function (a, b, c, d) {
        this._itemWidth = b;
        this._itemHeight = c;
        this._colorUnmodified = cc.color.WHITE;
        this._opacityModifyRGB = !0;
        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;
        b = this._realColor;
        this._colorF32Array = new Float32Array([b.r / 255, b.g / 255, b.b / 255, this._realOpacity / 255]);
        this.textureAtlas = new cc.TextureAtlas;
        this.textureAtlas.initWithTexture(a, d);
        if (!this.textureAtlas)return cc.log(cc._LogInfos.AtlasNode__initWithTexture),
            !1;
        this._updateBlendFunc();
        this._updateOpacityModifyRGB();
        this._calculateMaxItems();
        this.quadsToDraw = d;
        this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE_UCOLOR);
        this._uniformColor = cc._renderContext.getUniformLocation(this.shaderProgram.getProgram(), "u_color");
        return!0
    }, draw: null, _drawForWebGL: function (a) {
        a = a || cc._renderContext;
        cc.nodeDrawSetup(this);
        cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst);
        this._uniformColor && this._colorF32Array && (a.uniform4fv(this._uniformColor,
            this._colorF32Array), this.textureAtlas.drawNumberOfQuads(this.quadsToDraw, 0))
    }, setColor: null, _setColorForCanvas: function (a) {
        var b = this._realColor;
        if (!(b.r == a.r && b.g == a.g && b.b == a.b)) {
            b = cc.color(a.r, a.g, a.b);
            this._colorUnmodified = a;
            if (this._opacityModifyRGB) {
                var c = this._displayedOpacity;
                b.r = b.r * c / 255;
                b.g = b.g * c / 255;
                b.b = b.b * c / 255
            }
            cc.NodeRGBA.prototype.setColor.call(this, a);
            if (this.texture && (a = this._originalTexture.getHtmlElementObj()))if (b = cc.textureCache.getTextureColors(a))c = cc.rect(0, 0, a.width, a.height),
                a = cc.generateTintImage(a, b, this._realColor, c), b = new cc.Texture2D, b.initWithElement(a), b.handleLoadedTexture(), this.texture = b
        }
    }, _setColorForWebGL: function (a) {
        var b = cc.color(a.r, a.g, a.b);
        this._colorUnmodified = a;
        var c = this._displayedOpacity;
        this._opacityModifyRGB && (b.r = b.r * c / 255, b.g = b.g * c / 255, b.b = b.b * c / 255);
        cc.NodeRGBA.prototype.setColor.call(this, a);
        a = this._displayedColor;
        this._colorF32Array = new Float32Array([a.r / 255, a.g / 255, a.b / 255, c / 255])
    }, setOpacity: function (a) {
    }, _setOpacityForCanvas: function (a) {
        cc.NodeRGBA.prototype.setOpacity.call(this,
            a);
        this._opacityModifyRGB && (this.color = this._colorUnmodified)
    }, _setOpacityForWebGL: function (a) {
        cc.NodeRGBA.prototype.setOpacity.call(this, a);
        this._opacityModifyRGB ? this.color = this._colorUnmodified : (a = this._displayedColor, this._colorF32Array = new Float32Array([a.r / 255, a.g / 255, a.b / 255, this._displayedOpacity / 255]))
    }, getTexture: null, _getTextureForCanvas: function () {
        return this._textureForCanvas
    }, _getTextureForWebGL: function () {
        return this.textureAtlas.texture
    }, setTexture: null, _setTextureForCanvas: function (a) {
        this._textureForCanvas =
            a
    }, _setTextureForWebGL: function (a) {
        this.textureAtlas.texture = a;
        this._updateBlendFunc();
        this._updateOpacityModifyRGB()
    }, _calculateMaxItems: null, _calculateMaxItemsForCanvas: function () {
        var a = this.texture.getContentSize();
        this._itemsPerColumn = 0 | a.height / this._itemHeight;
        this._itemsPerRow = 0 | a.width / this._itemWidth
    }, _calculateMaxItemsForWebGL: function () {
        var a = this.texture, b = a.getContentSize();
        this._ignoreContentScaleFactor && (b = a.getContentSizeInPixels());
        this._itemsPerColumn = 0 | b.height / this._itemHeight;
        this._itemsPerRow = 0 | b.width / this._itemWidth
    }, _updateBlendFunc: function () {
        this.textureAtlas.texture.hasPremultipliedAlpha() || (this._blendFunc.src = cc.SRC_ALPHA, this._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA)
    }, _updateOpacityModifyRGB: function () {
        this._opacityModifyRGB = this.textureAtlas.texture.hasPremultipliedAlpha()
    }, _setIgnoreContentScaleFactor: function (a) {
        this._ignoreContentScaleFactor = a
    }});
_p = cc.AtlasNode.prototype;
cc._renderType === cc._RENDER_TYPE_WEBGL ? (_p.initWithTexture = _p._initWithTextureForWebGL, _p.draw = _p._drawForWebGL, _p.setColor = _p._setColorForWebGL, _p.setOpacity = _p._setOpacityForWebGL, _p.getTexture = _p._getTextureForWebGL, _p.setTexture = _p._setTextureForWebGL, _p._calculateMaxItems = _p._calculateMaxItemsForWebGL) : (_p.initWithTexture = _p._initWithTextureForCanvas, _p.draw = cc.Node.prototype.draw, _p.setColor = _p._setColorForCanvas, _p.setOpacity = _p._setOpacityForCanvas, _p.getTexture = _p._getTextureForCanvas, _p.setTexture =
    _p._setTextureForCanvas, _p._calculateMaxItems = _p._calculateMaxItemsForCanvas);
cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
cc.defineGetterSetter(_p, "color", _p.getColor, _p.setColor);
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.AtlasNode.create = function (a, b, c, d) {
    return new cc.AtlasNode(a, b, c, d)
};
cc.TextureAtlas = cc.Class.extend({dirty: !1, texture: null, _indices: null, _buffersVBO: null, _capacity: 0, _quads: null, _quadsArrayBuffer: null, _quadsWebBuffer: null, _quadsReader: null, ctor: function (a, b) {
    this._buffersVBO = [];
    "string" == typeof a ? this.initWithFile(a, b) : a instanceof cc.Texture2D && this.initWithTexture(a, b)
}, getTotalQuads: function () {
    return this._totalQuads
}, getCapacity: function () {
    return this._capacity
}, getTexture: function () {
    return this.texture
}, setTexture: function (a) {
    this.texture = a
}, setDirty: function (a) {
    this.dirty =
        a
}, isDirty: function () {
    return this.dirty
}, getQuads: function () {
    return this._quads
}, setQuads: function (a) {
    this._quads = a
}, _copyQuadsToTextureAtlas: function (a, b) {
    if (a)for (var c = 0; c < a.length; c++)this._setQuadToArray(a[c], b + c)
}, _setQuadToArray: function (a, b) {
    var c = this._quads;
    c[b] ? (c[b].bl = a.bl, c[b].br = a.br, c[b].tl = a.tl, c[b].tr = a.tr) : c[b] = new cc.V3F_C4B_T2F_Quad(a.tl, a.bl, a.tr, a.br, this._quadsArrayBuffer, b * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT)
}, description: function () {
    return"\x3ccc.TextureAtlas | totalQuads \x3d" +
        this._totalQuads + "\x3e"
}, _setupIndices: function () {
    if (0 !== this._capacity)for (var a = this._indices, b = this._capacity, c = 0; c < b; c++)cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP ? (a[6 * c + 0] = 4 * c + 0, a[6 * c + 1] = 4 * c + 0, a[6 * c + 2] = 4 * c + 2, a[6 * c + 3] = 4 * c + 1, a[6 * c + 4] = 4 * c + 3, a[6 * c + 5] = 4 * c + 3) : (a[6 * c + 0] = 4 * c + 0, a[6 * c + 1] = 4 * c + 1, a[6 * c + 2] = 4 * c + 2, a[6 * c + 3] = 4 * c + 3, a[6 * c + 4] = 4 * c + 2, a[6 * c + 5] = 4 * c + 1)
}, _setupVBO: function () {
    var a = cc._renderContext;
    this._buffersVBO[0] = a.createBuffer();
    this._buffersVBO[1] = a.createBuffer();
    this._quadsWebBuffer = a.createBuffer();
    this._mapBuffers()
}, _mapBuffers: function () {
    var a = cc._renderContext;
    a.bindBuffer(a.ARRAY_BUFFER, this._quadsWebBuffer);
    a.bufferData(a.ARRAY_BUFFER, this._quadsArrayBuffer, a.DYNAMIC_DRAW);
    a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
    a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indices, a.STATIC_DRAW)
}, initWithFile: function (a, b) {
    var c = cc.textureCache.addImage(a);
    if (c)return this.initWithTexture(c, b);
    cc.log(cc._LogInfos.TextureAtlas_initWithFile, a);
    return!1
}, initWithTexture: function (a, b) {
    cc.assert(a,
        cc._LogInfos.TextureAtlas_initWithTexture);
    this._capacity = b |= 0;
    this._totalQuads = 0;
    this.texture = a;
    this._quads = [];
    this._indices = new Uint16Array(6 * b);
    var c = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
    this._quadsArrayBuffer = new ArrayBuffer(c * b);
    this._quadsReader = new Uint8Array(this._quadsArrayBuffer);
    if ((!this._quads || !this._indices) && 0 < b)return!1;
    for (var d = this._quads, e = 0; e < b; e++)d[e] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, e * c);
    this._setupIndices();
    this._setupVBO();
    return this.dirty = !0
}, updateQuad: function (a, b) {
    cc.assert(a, cc._LogInfos.TextureAtlas_updateQuad);
    cc.assert(0 <= b && b < this._capacity, cc._LogInfos.TextureAtlas_updateQuad_2);
    this._totalQuads = Math.max(b + 1, this._totalQuads);
    this._setQuadToArray(a, b);
    this.dirty = !0
}, insertQuad: function (a, b) {
    cc.assert(b < this._capacity, cc._LogInfos.TextureAtlas_insertQuad_2);
    this._totalQuads++;
    if (this._totalQuads > this._capacity)cc.log(cc._LogInfos.TextureAtlas_insertQuad); else {
        var c = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, d = b * c, e = (this._totalQuads -
            1 - b) * c;
        this._quads[this._totalQuads - 1] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, (this._totalQuads - 1) * c);
        this._quadsReader.set(this._quadsReader.subarray(d, d + e), d + c);
        this._setQuadToArray(a, b);
        this.dirty = !0
    }
}, insertQuads: function (a, b, c) {
    c = c || a.length;
    cc.assert(b + c <= this._capacity, cc._LogInfos.TextureAtlas_insertQuads);
    var d = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
    this._totalQuads += c;
    if (this._totalQuads > this._capacity)cc.log(cc._LogInfos.TextureAtlas_insertQuad); else {
        var e = b *
            d, f = (this._totalQuads - 1 - b - c) * d, g = this._totalQuads - 1 - c, h;
        for (h = 0; h < c; h++)this._quads[g + h] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, (this._totalQuads - 1) * d);
        this._quadsReader.set(this._quadsReader.subarray(e, e + f), e + d * c);
        for (h = 0; h < c; h++)this._setQuadToArray(a[h], b + h);
        this.dirty = !0
    }
}, insertQuadFromIndex: function (a, b) {
    if (a !== b) {
        cc.assert(0 <= b || b < this._totalQuads, cc._LogInfos.TextureAtlas_insertQuadFromIndex);
        cc.assert(0 <= a || a < this._totalQuads, cc._LogInfos.TextureAtlas_insertQuadFromIndex_2);
        var c = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, d = this._quadsReader, e = d.subarray(a * c, c), f;
        a > b ? (f = b * c, d.set(d.subarray(f, f + (a - b) * c), f + c), d.set(e, f)) : (f = (a + 1) * c, d.set(d.subarray(f, f + (b - a) * c), f - c), d.set(e, b * c));
        this.dirty = !0
    }
}, removeQuadAtIndex: function (a) {
    cc.assert(a < this._totalQuads, cc._LogInfos.TextureAtlas_removeQuadAtIndex);
    var b = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
    this._totalQuads--;
    this._quads.length = this._totalQuads;
    if (a !== this._totalQuads) {
        var c = (a + 1) * b;
        this._quadsReader.set(this._quadsReader.subarray(c,
                c + (this._totalQuads - a) * b), c - b)
    }
    this.dirty = !0
}, removeQuadsAtIndex: function (a, b) {
    cc.assert(a + b <= this._totalQuads, cc._LogInfos.TextureAtlas_removeQuadsAtIndex);
    this._totalQuads -= b;
    if (a !== this._totalQuads) {
        var c = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, d = (a + b) * c;
        this._quadsReader.set(this._quadsReader.subarray(d, d + (this._totalQuads - a) * c), a * c)
    }
    this.dirty = !0
}, removeAllQuads: function () {
    this._totalQuads = this._quads.length = 0
}, _setDirty: function (a) {
    this.dirty = a
}, resizeCapacity: function (a) {
    if (a == this._capacity)return!0;
    var b = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, c = this._capacity;
    this._totalQuads = Math.min(this._totalQuads, a);
    var d = this._capacity = 0 | a, e = this._totalQuads;
    if (null == this._quads) {
        this._quads = [];
        this._quadsArrayBuffer = new ArrayBuffer(b * d);
        this._quadsReader = new Uint8Array(this._quadsArrayBuffer);
        for (a = 0; a < d; a++)this._quads = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, a * b)
    } else {
        var f, g, h = this._quads;
        if (d > c) {
            f = [];
            g = new ArrayBuffer(b * d);
            for (a = 0; a < e; a++)f[a] = new cc.V3F_C4B_T2F_Quad(h[a].tl,
                h[a].bl, h[a].tr, h[a].br, g, a * b);
            for (; a < d; a++)f[a] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, g, a * b)
        } else {
            e = Math.max(e, d);
            f = [];
            g = new ArrayBuffer(b * d);
            for (a = 0; a < e; a++)f[a] = new cc.V3F_C4B_T2F_Quad(h[a].tl, h[a].bl, h[a].tr, h[a].br, g, a * b)
        }
        this._quadsReader = new Uint8Array(g);
        this._quads = f;
        this._quadsArrayBuffer = g
    }
    null == this._indices ? this._indices = new Uint16Array(6 * d) : d > c ? (b = new Uint16Array(6 * d), b.set(this._indices, 0), this._indices = b) : this._indices = this._indices.subarray(0, 6 * d);
    this._setupIndices();
    this._mapBuffers();
    return this.dirty = !0
}, increaseTotalQuadsWith: function (a) {
    this._totalQuads += a
}, moveQuadsFromIndex: function (a, b, c) {
    if (void 0 === c) {
        if (c = b, b = this._totalQuads - a, cc.assert(c + (this._totalQuads - a) <= this._capacity, cc._LogInfos.TextureAtlas_moveQuadsFromIndex), 0 === b)return
    } else if (cc.assert(c + b <= this._totalQuads, cc._LogInfos.TextureAtlas_moveQuadsFromIndex_2), cc.assert(a < this._totalQuads, cc._LogInfos.TextureAtlas_moveQuadsFromIndex_3), a == c)return;
    var d = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, e = a * d, f = b * d, g = this._quadsReader,
        h = g.subarray(e, e + f), k = c * d;
    c < a ? (b = c * d, g.set(g.subarray(b, b + (a - c) * d), b + f)) : (b = (a + b) * d, g.set(g.subarray(b, b + (c - a) * d), e));
    g.set(h, k);
    this.dirty = !0
}, fillWithEmptyQuadsFromIndex: function (a, b) {
    for (var c = b * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, d = new Uint8Array(this._quadsArrayBuffer, a * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, c), e = 0; e < c; e++)d[e] = 0
}, drawQuads: function () {
    this.drawNumberOfQuads(this._totalQuads, 0)
}, _releaseBuffer: function () {
    var a = cc._renderContext;
    this._buffersVBO && (this._buffersVBO[0] && a.deleteBuffer(this._buffersVBO[0]),
        this._buffersVBO[1] && a.deleteBuffer(this._buffersVBO[1]));
    this._quadsWebBuffer && a.deleteBuffer(this._quadsWebBuffer)
}});
_p = cc.TextureAtlas.prototype;
cc.defineGetterSetter(_p, "totalQuads", _p.getTotalQuads);
cc.defineGetterSetter(_p, "capacity", _p.getCapacity);
cc.defineGetterSetter(_p, "quads", _p.getQuads, _p.setQuads);
cc.TextureAtlas.create = function (a, b) {
    return new cc.TextureAtlas(a, b)
};
cc._renderType === cc._RENDER_TYPE_WEBGL && (cc.assert("function" === typeof cc._tmp.WebGLTextureAtlas, cc._LogInfos.MissingFile, "TexturesWebGL.js"), cc._tmp.WebGLTextureAtlas(), delete cc._tmp.WebGLTextureAtlas);
cc.assert("function" === typeof cc._tmp.PrototypeTextureAtlas, cc._LogInfos.MissingFile, "TexturesPropertyDefine.js");
cc._tmp.PrototypeTextureAtlas();
delete cc._tmp.PrototypeTextureAtlas;
cc.DEFAULT_SPRITE_BATCH_CAPACITY = 29;
cc.SpriteBatchNode = cc.Node.extend({textureAtlas: null, _blendFunc: null, _descendants: null, _className: "SpriteBatchNode", addSpriteWithoutQuad: function (a, b, c) {
    cc.assert(a, cc._LogInfos.SpriteBatchNode_addSpriteWithoutQuad_2);
    if (!(a instanceof cc.Sprite))return cc.log(cc._LogInfos.SpriteBatchNode_addSpriteWithoutQuad), null;
    a.atlasIndex = b;
    var d = 0, e = this._descendants;
    if (e && 0 < e.length)for (var f = 0; f < e.length; f++) {
        var g = e[f];
        g && g.atlasIndex >= b && ++d
    }
    e.splice(d, 0, a);
    cc.Node.prototype.addChild.call(this, a, b, c);
    this.reorderBatch(!1);
    return this
}, getTextureAtlas: function () {
    return this.textureAtlas
}, setTextureAtlas: function (a) {
    a != this.textureAtlas && (this.textureAtlas = a)
}, getDescendants: function () {
    return this._descendants
}, initWithFile: function (a, b) {
    var c = cc.textureCache.textureForKey(a);
    c || (c = cc.textureCache.addImage(a));
    return this.initWithTexture(c, b)
}, _setNodeDirtyForCache: function () {
    this._cacheDirty = !0
}, init: function (a, b) {
    var c = cc.textureCache.textureForKey(a);
    c || (c = cc.textureCache.addImage(a));
    return this.initWithTexture(c,
        b)
}, increaseAtlasCapacity: function () {
    var a = this.textureAtlas.capacity, b = Math.floor(4 * (a + 1) / 3);
    cc.log(cc._LogInfos.SpriteBatchNode_increaseAtlasCapacity, a, b);
    this.textureAtlas.resizeCapacity(b) || cc.log(cc._LogInfos.SpriteBatchNode_increaseAtlasCapacity_2)
}, removeChildAtIndex: function (a, b) {
    this.removeChild(this._children[a], b)
}, rebuildIndexInOrder: function (a, b) {
    var c = a.children;
    if (c && 0 < c.length)for (var d = 0; d < c.length; d++) {
        var e = c[d];
        e && 0 > e.zIndex && (b = this.rebuildIndexInOrder(e, b))
    }
    !a == this && (a.atlasIndex =
        b, b++);
    if (c && 0 < c.length)for (d = 0; d < c.length; d++)(e = c[d]) && 0 <= e.zIndex && (b = this.rebuildIndexInOrder(e, b));
    return b
}, highestAtlasIndexInChild: function (a) {
    var b = a.children;
    return!b || 0 == b.length ? a.atlasIndex : this.highestAtlasIndexInChild(b[b.length - 1])
}, lowestAtlasIndexInChild: function (a) {
    var b = a.children;
    return!b || 0 == b.length ? a.atlasIndex : this.lowestAtlasIndexInChild(b[b.length - 1])
}, atlasIndexForChild: function (a, b) {
    var c = a.parent, d = c.children, e = d.indexOf(a), f = null;
    0 < e && e < cc.UINT_MAX && (f = d[e - 1]);
    return c ==
        this ? 0 == e ? 0 : this.highestAtlasIndexInChild(f) + 1 : 0 == e ? 0 > b ? c.atlasIndex : c.atlasIndex + 1 : 0 > f.zIndex && 0 > b || 0 <= f.zIndex && 0 <= b ? this.highestAtlasIndexInChild(f) + 1 : c.atlasIndex + 1
}, reorderBatch: function (a) {
    this._reorderChildDirty = a
}, setBlendFunc: function (a, b) {
    this._blendFunc = void 0 === b ? a : {src: a, dst: b}
}, getBlendFunc: function () {
    return this._blendFunc
}, reorderChild: function (a, b) {
    cc.assert(a, cc._LogInfos.SpriteBatchNode_reorderChild_2);
    -1 === this._children.indexOf(a) ? cc.log(cc._LogInfos.SpriteBatchNode_reorderChild) :
        b !== a.zIndex && (cc.Node.prototype.reorderChild.call(this, a, b), this.setNodeDirty())
}, removeChild: function (a, b) {
    null != a && (-1 === this._children.indexOf(a) ? cc.log(cc._LogInfos.SpriteBatchNode_removeChild) : (this.removeSpriteFromAtlas(a), cc.Node.prototype.removeChild.call(this, a, b)))
}, _mvpMatrix: null, _textureForCanvas: null, _useCache: !1, _originalTexture: null, ctor: null, _ctorForCanvas: function (a, b) {
    cc.Node.prototype.ctor.call(this);
    var c;
    b = b || cc.DEFAULT_SPRITE_BATCH_CAPACITY;
    "string" == typeof a ? (c = cc.textureCache.textureForKey(a)) ||
        (c = cc.textureCache.addImage(a)) : a instanceof cc.Texture2D && (c = a);
    c && this.initWithTexture(c, b)
}, _ctorForWebGL: function (a, b) {
    cc.Node.prototype.ctor.call(this);
    this._mvpMatrix = new cc.kmMat4;
    var c;
    b = b || cc.DEFAULT_SPRITE_BATCH_CAPACITY;
    "string" == typeof a ? (c = cc.textureCache.textureForKey(a)) || (c = cc.textureCache.addImage(a)) : a instanceof cc.Texture2D && (c = a);
    c && this.initWithTexture(c, b)
}, updateQuadFromSprite: null, _updateQuadFromSpriteForCanvas: function (a, b) {
    cc.assert(a, cc._LogInfos.CCSpriteBatchNode_updateQuadFromSprite_2);
    a instanceof cc.Sprite ? (a.batchNode = this, a.atlasIndex = b, a.dirty = !0, a.updateTransform()) : cc.log(cc._LogInfos.CCSpriteBatchNode_updateQuadFromSprite)
}, _updateQuadFromSpriteForWebGL: function (a, b) {
    cc.assert(a, cc._LogInfos.CCSpriteBatchNode_updateQuadFromSprite);
    if (a instanceof cc.Sprite) {
        for (var c = this.textureAtlas.capacity; b >= c || c == this.textureAtlas.totalQuads;)this.increaseAtlasCapacity();
        a.batchNode = this;
        a.atlasIndex = b;
        a.dirty = !0;
        a.updateTransform()
    } else cc.log(cc._LogInfos.CCSpriteBatchNode_updateQuadFromSprite)
},
    _swap: function (a, b) {
        var c = this._descendants, d = this.textureAtlas, e = d.quads, f = c[a], g = cc.V3F_C4B_T2F_QuadCopy(e[a]);
        c[b].atlasIndex = a;
        c[a] = c[b];
        d.updateQuad(e[b], a);
        c[b] = f;
        d.updateQuad(g, b)
    }, insertQuadFromSprite: null, _insertQuadFromSpriteForCanvas: function (a, b) {
        cc.assert(a, cc._LogInfos.CCSpriteBatchNode_insertQuadFromSprite_2);
        a instanceof cc.Sprite ? (a.batchNode = this, a.atlasIndex = b, a.dirty = !0, a.updateTransform(), this._children.splice(b, 0, a)) : cc.log(cc._LogInfos.CCSpriteBatchNode_insertQuadFromSprite)
    },
    _insertQuadFromSpriteForWebGL: function (a, b) {
        cc.assert(a, cc._LogInfos.Sprite_insertQuadFromSprite_2);
        if (a instanceof cc.Sprite) {
            for (var c = this.textureAtlas; b >= c.capacity || c.capacity === c.totalQuads;)this.increaseAtlasCapacity();
            a.batchNode = this;
            a.atlasIndex = b;
            c.insertQuad(a.quad, b);
            a.dirty = !0;
            a.updateTransform()
        } else cc.log(cc._LogInfos.Sprite_insertQuadFromSprite)
    }, _updateAtlasIndex: function (a, b) {
        var c = 0, d = a.children;
        d && (c = d.length);
        var e = 0;
        if (0 === c)e = a.atlasIndex, a.atlasIndex = b, a.arrivalOrder = 0, e !=
            b && this._swap(e, b), b++; else {
            e = !0;
            0 <= d[0].zIndex && (e = a.atlasIndex, a.atlasIndex = b, a.arrivalOrder = 0, e != b && this._swap(e, b), b++, e = !1);
            for (c = 0; c < d.length; c++) {
                var f = d[c];
                e && 0 <= f.zIndex && (e = a.atlasIndex, a.atlasIndex = b, a.arrivalOrder = 0, e != b && this._swap(e, b), b++, e = !1);
                b = this._updateAtlasIndex(f, b)
            }
            e && (e = a.atlasIndex, a.atlasIndex = b, a.arrivalOrder = 0, e != b && this._swap(e, b), b++)
        }
        return b
    }, _updateBlendFunc: function () {
        this.textureAtlas.texture.hasPremultipliedAlpha() || (this._blendFunc.src = cc.SRC_ALPHA, this._blendFunc.dst =
            cc.ONE_MINUS_SRC_ALPHA)
    }, initWithTexture: null, _initWithTextureForCanvas: function (a, b) {
        this._children = [];
        this._descendants = [];
        this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
        this._textureForCanvas = this._originalTexture = a;
        return!0
    }, _initWithTextureForWebGL: function (a, b) {
        this._children = [];
        this._descendants = [];
        this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
        b = b || cc.DEFAULT_SPRITE_BATCH_CAPACITY;
        this.textureAtlas = new cc.TextureAtlas;
        this.textureAtlas.initWithTexture(a, b);
        this._updateBlendFunc();
        this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
        return!0
    }, insertChild: function (a, b) {
        a.batchNode = this;
        a.atlasIndex = b;
        a.dirty = !0;
        var c = this.textureAtlas;
        c.totalQuads >= c.capacity && this.increaseAtlasCapacity();
        c.insertQuad(a.quad, b);
        this._descendants.splice(b, 0, a);
        var c = b + 1, d = this._descendants;
        if (d && 0 < d.length)for (; c < d.length; c++)d[c].atlasIndex++;
        var d = a.children, e;
        if (d) {
            c = 0;
            for (l = d.length || 0; c < l; c++)if (e = d[c]) {
                var f = this.atlasIndexForChild(e, e.zIndex);
                this.insertChild(e,
                    f)
            }
        }
    }, appendChild: null, _appendChildForCanvas: function (a) {
        this._reorderChildDirty = !0;
        a.batchNode = this;
        a.dirty = !0;
        this._descendants.push(a);
        a.atlasIndex = this._descendants.length - 1;
        a = a.children;
        for (var b = 0, c = a.length || 0; b < c; b++)this.appendChild(a[b])
    }, _appendChildForWebGL: function (a) {
        this._reorderChildDirty = !0;
        a.batchNode = this;
        a.dirty = !0;
        this._descendants.push(a);
        var b = this._descendants.length - 1;
        a.atlasIndex = b;
        var c = this.textureAtlas;
        c.totalQuads == c.capacity && this.increaseAtlasCapacity();
        c.insertQuad(a.quad,
            b);
        a = a.children;
        b = 0;
        for (c = a.length || 0; b < c; b++)this.appendChild(a[b])
    }, removeSpriteFromAtlas: null, _removeSpriteFromAtlasForCanvas: function (a) {
        a.batchNode = null;
        var b = this._descendants, c = b.indexOf(a);
        if (-1 != c) {
            b.splice(c, 1);
            for (var d = b.length; c < d; ++c)b[c].atlasIndex--
        }
        if (a = a.children) {
            b = 0;
            for (c = a.length || 0; b < c; b++)a[b] && this.removeSpriteFromAtlas(a[b])
        }
    }, _removeSpriteFromAtlasForWebGL: function (a) {
        this.textureAtlas.removeQuadAtIndex(a.atlasIndex);
        a.batchNode = null;
        var b = this._descendants, c = b.indexOf(a);
        if (-1 != c) {
            b.splice(c, 1);
            for (var d = b.length; c < d; ++c)b[c].atlasIndex--
        }
        if (a = a.children) {
            b = 0;
            for (c = a.length || 0; b < c; b++)a[b] && this.removeSpriteFromAtlas(a[b])
        }
    }, getTexture: null, _getTextureForCanvas: function () {
        return this._textureForCanvas
    }, _getTextureForWebGL: function () {
        return this.textureAtlas.texture
    }, setTexture: null, _setTextureForCanvas: function (a) {
        this._textureForCanvas = a;
        for (var b = this._children, c = 0; c < b.length; c++)b[c].texture = a
    }, _setTextureForWebGL: function (a) {
        this.textureAtlas.texture = a;
        this._updateBlendFunc()
    },
    visit: null, _visitForCanvas: function (a) {
        var b = a || cc._renderContext;
        if (this._visible) {
            b.save();
            this.transform(a);
            var c = this._children;
            if (c) {
                this.sortAllChildren();
                for (a = 0; a < c.length; a++)c[a] && c[a].visit(b)
            }
            b.restore()
        }
    }, _visitForWebGL: function (a) {
        a = a || cc._renderContext;
        if (this._visible) {
            cc.kmGLPushMatrix();
            var b = this.grid;
            b && b.isActive() && (b.beforeDraw(), this.transformAncestors());
            this.sortAllChildren();
            this.transform(a);
            this.draw(a);
            b && b.isActive() && b.afterDraw(this);
            cc.kmGLPopMatrix();
            this.arrivalOrder =
                0
        }
    }, addChild: null, _addChildForCanvas: function (a, b, c) {
        cc.assert(null != a, cc._LogInfos.CCSpriteBatchNode_addChild_3);
        a instanceof cc.Sprite ? (b = null == b ? a.zIndex : b, c = null == c ? a.tag : c, cc.Node.prototype.addChild.call(this, a, b, c), this.appendChild(a), this.setNodeDirty()) : cc.log(cc._LogInfos.CCSpriteBatchNode_addChild)
    }, _addChildForWebGL: function (a, b, c) {
        cc.assert(null != a, cc._LogInfos.Sprite_addChild_6);
        a instanceof cc.Sprite ? a.texture != this.textureAtlas.texture ? cc.log(cc._LogInfos.Sprite_addChild_5) : (b = null ==
            b ? a.zIndex : b, c = null == c ? a.tag : c, cc.Node.prototype.addChild.call(this, a, b, c), this.appendChild(a), this.setNodeDirty()) : cc.log(cc._LogInfos.Sprite_addChild_4)
    }, removeAllChildren: null, _removeAllChildrenForCanvas: function (a) {
        var b = this._descendants;
        if (b && 0 < b.length)for (var c = 0, d = b.length; c < d; c++)b[c] && (b[c].batchNode = null);
        cc.Node.prototype.removeAllChildren.call(this, a);
        this._descendants.length = 0
    }, _removeAllChildrenForWebGL: function (a) {
        var b = this._descendants;
        if (b && 0 < b.length)for (var c = 0, d = b.length; c <
            d; c++)b[c] && (b[c].batchNode = null);
        cc.Node.prototype.removeAllChildren.call(this, a);
        this._descendants.length = 0;
        this.textureAtlas.removeAllQuads()
    }, sortAllChildren: null, _sortAllChildrenForCanvas: function () {
        if (this._reorderChildDirty) {
            var a, b = 0, c = this._children, d = c.length, e;
            for (a = 1; a < d; a++) {
                var f = c[a], b = a - 1;
                for (e = c[b]; 0 <= b && (f._localZOrder < e._localZOrder || f._localZOrder == e._localZOrder && f.arrivalOrder < e.arrivalOrder);)c[b + 1] = e, b -= 1, e = c[b];
                c[b + 1] = f
            }
            0 < c.length && this._arrayMakeObjectsPerformSelector(c,
                cc.Node.StateCallbackType.sortAllChildren);
            this._reorderChildDirty = !1
        }
    }, _sortAllChildrenForWebGL: function () {
        if (this._reorderChildDirty) {
            var a = this._children, b, c = 0, d = a.length, e;
            for (b = 1; b < d; b++) {
                var f = a[b], c = b - 1;
                for (e = a[c]; 0 <= c && (f._localZOrder < e._localZOrder || f._localZOrder == e._localZOrder && f.arrivalOrder < e.arrivalOrder);)a[c + 1] = e, c -= 1, e = a[c];
                a[c + 1] = f
            }
            if (0 < a.length) {
                this._arrayMakeObjectsPerformSelector(a, cc.Node.StateCallbackType.sortAllChildren);
                for (b = c = 0; b < a.length; b++)c = this._updateAtlasIndex(a[b],
                    c)
            }
            this._reorderChildDirty = !1
        }
    }, draw: null, _drawForWebGL: function () {
        0 !== this.textureAtlas.totalQuads && (this._shaderProgram.use(), this._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4(), this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.updateTransform), cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst), this.textureAtlas.drawQuads())
    }});
_p = cc.SpriteBatchNode.prototype;
cc._renderType === cc._RENDER_TYPE_WEBGL ? (_p.ctor = _p._ctorForWebGL, _p.updateQuadFromSprite = _p._updateQuadFromSpriteForWebGL, _p.insertQuadFromSprite = _p._insertQuadFromSpriteForWebGL, _p.initWithTexture = _p._initWithTextureForWebGL, _p.appendChild = _p._appendChildForWebGL, _p.removeSpriteFromAtlas = _p._removeSpriteFromAtlasForWebGL, _p.getTexture = _p._getTextureForWebGL, _p.setTexture = _p._setTextureForWebGL, _p.visit = _p._visitForWebGL, _p.addChild = _p._addChildForWebGL, _p.removeAllChildren = _p._removeAllChildrenForWebGL,
    _p.sortAllChildren = _p._sortAllChildrenForWebGL, _p.draw = _p._drawForWebGL) : (_p.ctor = _p._ctorForCanvas, _p.updateQuadFromSprite = _p._updateQuadFromSpriteForCanvas, _p.insertQuadFromSprite = _p._insertQuadFromSpriteForCanvas, _p.initWithTexture = _p._initWithTextureForCanvas, _p.appendChild = _p._appendChildForCanvas, _p.removeSpriteFromAtlas = _p._removeSpriteFromAtlasForCanvas, _p.getTexture = _p._getTextureForCanvas, _p.setTexture = _p._setTextureForCanvas, _p.visit = _p._visitForCanvas, _p.removeAllChildren = _p._removeAllChildrenForCanvas,
    _p.addChild = _p._addChildForCanvas, _p.sortAllChildren = _p._sortAllChildrenForCanvas, _p.draw = cc.Node.prototype.draw);
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.defineGetterSetter(_p, "descendants", _p.getDescendants);
cc.SpriteBatchNode.create = function (a, b) {
    return new cc.SpriteBatchNode(a, b)
};
cc.configuration = {ERROR: 0, STRING: 1, INT: 2, DOUBLE: 3, BOOLEAN: 4, _maxTextureSize: 0, _maxModelviewStackDepth: 0, _supportsPVRTC: !1, _supportsNPOT: !1, _supportsBGRA8888: !1, _supportsDiscardFramebuffer: !1, _supportsShareableVAO: !1, _maxSamplesAllowed: 0, _maxTextureUnits: 0, _GlExtensions: "", _valueDict: {}, _inited: !1, _init: function () {
    var a = this._valueDict;
    a["cocos2d.x.version"] = cc.ENGINE_VERSION;
    a["cocos2d.x.compiled_with_profiler"] = !1;
    a["cocos2d.x.compiled_with_gl_state_cache"] = cc.ENABLE_GL_STATE_CACHE;
    this._inited = !0
}, getMaxTextureSize: function () {
    return this._maxTextureSize
}, getMaxModelviewStackDepth: function () {
    return this._maxModelviewStackDepth
}, getMaxTextureUnits: function () {
    return this._maxTextureUnits
}, supportsNPOT: function () {
    return this._supportsNPOT
}, supportsPVRTC: function () {
    return this._supportsPVRTC
}, supportsETC: function () {
    return!1
}, supportsS3TC: function () {
    return!1
}, supportsATITC: function () {
    return!1
}, supportsBGRA8888: function () {
    return this._supportsBGRA8888
}, supportsDiscardFramebuffer: function () {
    return this._supportsDiscardFramebuffer
},
    supportsShareableVAO: function () {
        return this._supportsShareableVAO
    }, checkForGLExtension: function (a) {
        return-1 < this._GlExtensions.indexOf(a)
    }, getValue: function (a, b) {
        this._inited || this._init();
        var c = this._valueDict;
        return c[a] ? c[a] : b
    }, setValue: function (a, b) {
        this._valueDict[a] = b
    }, dumpInfo: function () {
        0 === cc.ENABLE_GL_STATE_CACHE && (cc.log(""), cc.log(cc._LogInfos.configuration_dumpInfo), cc.log(""))
    }, gatherGPUInfo: function () {
        if (cc._renderType !== cc._RENDER_TYPE_CANVAS) {
            this._inited || this._init();
            var a = cc._renderContext,
                b = this._valueDict;
            b["gl.vendor"] = a.getParameter(a.VENDOR);
            b["gl.renderer"] = a.getParameter(a.RENDERER);
            b["gl.version"] = a.getParameter(a.VERSION);
            this._GlExtensions = "";
            for (var c = a.getSupportedExtensions(), d = 0; d < c.length; d++)this._GlExtensions += c[d] + " ";
            this._maxTextureSize = a.getParameter(a.MAX_TEXTURE_SIZE);
            b["gl.max_texture_size"] = this._maxTextureSize;
            this._maxTextureUnits = a.getParameter(a.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
            b["gl.max_texture_units"] = this._maxTextureUnits;
            this._supportsPVRTC = this.checkForGLExtension("GL_IMG_texture_compression_pvrtc");
            b["gl.supports_PVRTC"] = this._supportsPVRTC;
            this._supportsNPOT = !1;
            b["gl.supports_NPOT"] = this._supportsNPOT;
            this._supportsBGRA8888 = this.checkForGLExtension("GL_IMG_texture_format_BGRA888");
            b["gl.supports_BGRA8888"] = this._supportsBGRA8888;
            this._supportsDiscardFramebuffer = this.checkForGLExtension("GL_EXT_discard_framebuffer");
            b["gl.supports_discard_framebuffer"] = this._supportsDiscardFramebuffer;
            this._supportsShareableVAO = this.checkForGLExtension("vertex_array_object");
            b["gl.supports_vertex_array_object"] =
                this._supportsShareableVAO;
            cc.checkGLErrorDebug()
        }
    }, loadConfigFile: function (a) {
        this._inited || this._init();
        var b = cc.loader.getRes(a);
        if (!b)throw"Please load the resource first : " + a;
        cc.assert(b, cc._LogInfos.configuration_loadConfigFile_2, a);
        if (b = b.data)for (var c in b)this._valueDict[c] = b[c]; else cc.log(cc._LogInfos.configuration_loadConfigFile, a)
    }};
cc.Camera = cc.Class.extend({_eyeX: null, _eyeY: null, _eyeZ: null, _centerX: null, _centerY: null, _centerZ: null, _upX: null, _upY: null, _upZ: null, _dirty: null, _lookupMatrix: null, ctor: function () {
    this._lookupMatrix = new cc.kmMat4;
    this.restore()
}, description: function () {
    return"\x3cCCCamera | center \x3d(" + this._centerX + "," + this._centerY + "," + this._centerZ + ")\x3e"
}, setDirty: function (a) {
    this._dirty = a
}, isDirty: function () {
    return this._dirty
}, restore: function () {
    this._eyeX = this._eyeY = 0;
    this._eyeZ = cc.Camera.getZEye();
    this._upX =
        this._centerX = this._centerY = this._centerZ = 0;
    this._upY = 1;
    this._upZ = 0;
    cc.kmMat4Identity(this._lookupMatrix);
    this._dirty = !1
}, locate: function () {
    if (this._dirty) {
        var a = new cc.kmVec3, b = new cc.kmVec3, c = new cc.kmVec3;
        cc.kmVec3Fill(a, this._eyeX, this._eyeY, this._eyeZ);
        cc.kmVec3Fill(b, this._centerX, this._centerY, this._centerZ);
        cc.kmVec3Fill(c, this._upX, this._upY, this._upZ);
        cc.kmMat4LookAt(this._lookupMatrix, a, b, c);
        this._dirty = !1
    }
    cc.kmGLMultMatrix(this._lookupMatrix)
}, setEyeXYZ: function (a, b, c) {
    this.setEye(a, b,
        c)
}, setEye: function (a, b, c) {
    this._eyeX = a;
    this._eyeY = b;
    this._eyeZ = c;
    this._dirty = !0
}, setCenterXYZ: function (a, b, c) {
    this.setCenter(a, b, c)
}, setCenter: function (a, b, c) {
    this._centerX = a;
    this._centerY = b;
    this._centerZ = c;
    this._dirty = !0
}, setUpXYZ: function (a, b, c) {
    this.setUp(a, b, c)
}, setUp: function (a, b, c) {
    this._upX = a;
    this._upY = b;
    this._upZ = c;
    this._dirty = !0
}, getEyeXYZ: function (a, b, c) {
    return{x: this._eyeX, y: this._eyeY, z: this._eyeZ}
}, getEye: function () {
    return{x: this._eyeX, y: this._eyeY, z: this._eyeZ}
}, getCenterXYZ: function (a, b, c) {
    return{x: this._centerX, y: this._centerY, z: this._centerZ}
}, getCenter: function () {
    return{x: this._centerX, y: this._centerY, z: this._centerZ}
}, getUpXYZ: function (a, b, c) {
    return{x: this._upX, y: this._upY, z: this._upZ}
}, getUp: function () {
    return{x: this._upX, y: this._upY, z: this._upZ}
}, _DISALLOW_COPY_AND_ASSIGN: function (a) {
}});
cc.Camera.getZEye = function () {
    return cc.FLT_EPSILON
};
cc.PI2 = 2 * Math.PI;
cc.DrawingPrimitiveCanvas = cc.Class.extend({_cacheArray: [], _renderContext: null, ctor: function (a) {
    this._renderContext = a
}, drawPoint: function (a, b) {
    b || (b = 1);
    var c = cc.view.getScaleX(), d = cc.view.getScaleY(), d = cc.p(a.x * c, a.y * d);
    this._renderContext.beginPath();
    this._renderContext.arc(d.x, -d.y, b * c, 0, 2 * Math.PI, !1);
    this._renderContext.closePath();
    this._renderContext.fill()
}, drawPoints: function (a, b, c) {
    if (null != a) {
        c || (c = 1);
        b = this._renderContext;
        var d = cc.view.getScaleX(), e = cc.view.getScaleY();
        b.beginPath();
        for (var f =
            0, g = a.length; f < g; f++)b.arc(a[f].x * d, -a[f].y * e, c * d, 0, 2 * Math.PI, !1);
        b.closePath();
        b.fill()
    }
}, drawLine: function (a, b) {
    var c = this._renderContext, d = cc.view.getScaleX(), e = cc.view.getScaleY();
    c.beginPath();
    c.moveTo(a.x * d, -a.y * e);
    c.lineTo(b.x * d, -b.y * e);
    c.closePath();
    c.stroke()
}, drawRect: function (a, b) {
    this.drawLine(cc.p(a.x, a.y), cc.p(b.x, a.y));
    this.drawLine(cc.p(b.x, a.y), cc.p(b.x, b.y));
    this.drawLine(cc.p(b.x, b.y), cc.p(a.x, b.y));
    this.drawLine(cc.p(a.x, b.y), cc.p(a.x, a.y))
}, drawSolidRect: function (a, b, c) {
    a = [a,
        cc.p(b.x, a.y), b, cc.p(a.x, b.y)];
    this.drawSolidPoly(a, 4, c)
}, drawPoly: function (a, b, c, d) {
    d = d || !1;
    if (null != a) {
        if (3 > a.length)throw Error("Polygon's point must greater than 2");
        var e = a[0];
        b = this._renderContext;
        var f = cc.view.getScaleX(), g = cc.view.getScaleY();
        b.beginPath();
        b.moveTo(e.x * f, -e.y * g);
        for (var e = 1, h = a.length; e < h; e++)b.lineTo(a[e].x * f, -a[e].y * g);
        c && b.closePath();
        d ? b.fill() : b.stroke()
    }
}, drawSolidPoly: function (a, b, c) {
    this.setDrawColor(c.r, c.g, c.b, c.a);
    this.drawPoly(a, b, !0, !0)
}, drawCircle: function (a, b, c, d, e) {
    e = e || !1;
    d = this._renderContext;
    var f = cc.view.getScaleX(), g = cc.view.getScaleY();
    d.beginPath();
    d.arc(0 | a.x * f, 0 | -(a.y * g), b * f, -c, -(c - 2 * Math.PI), !1);
    e && d.lineTo(0 | a.x * f, 0 | -(a.y * g));
    d.stroke()
}, drawQuadBezier: function (a, b, c, d) {
    for (var e = this._cacheArray, f = e.length = 0, g = 0; g < d; g++) {
        var h = Math.pow(1 - f, 2) * a.x + 2 * (1 - f) * f * b.x + f * f * c.x, k = Math.pow(1 - f, 2) * a.y + 2 * (1 - f) * f * b.y + f * f * c.y;
        e.push(cc.p(h, k));
        f += 1 / d
    }
    e.push(cc.p(c.x, c.y));
    this.drawPoly(e, d + 1, !1, !1)
}, drawCubicBezier: function (a, b, c, d, e) {
    for (var f = this._cacheArray,
             g = f.length = 0, h = 0; h < e; h++) {
        var k = Math.pow(1 - g, 3) * a.x + 3 * Math.pow(1 - g, 2) * g * b.x + 3 * (1 - g) * g * g * c.x + g * g * g * d.x, m = Math.pow(1 - g, 3) * a.y + 3 * Math.pow(1 - g, 2) * g * b.y + 3 * (1 - g) * g * g * c.y + g * g * g * d.y;
        f.push(cc.p(k, m));
        g += 1 / e
    }
    f.push(cc.p(d.x, d.y));
    this.drawPoly(f, e + 1, !1, !1)
}, drawCatmullRom: function (a, b) {
    this.drawCardinalSpline(a, 0.5, b)
}, drawCardinalSpline: function (a, b, c) {
    cc._renderContext.strokeStyle = "rgba(255,255,255,1)";
    var d = this._cacheArray;
    d.length = 0;
    for (var e, f, g = 1 / a.length, h = 0; h < c + 1; h++)f = h / c, 1 == f ? (e = a.length - 1, f = 1) :
        (e = 0 | f / g, f = (f - g * e) / g), e = cc.CardinalSplineAt(cc.getControlPointAt(a, e - 1), cc.getControlPointAt(a, e - 0), cc.getControlPointAt(a, e + 1), cc.getControlPointAt(a, e + 2), b, f), d.push(e);
    this.drawPoly(d, c + 1, !1, !1)
}, drawImage: function (a, b, c, d, e) {
    switch (arguments.length) {
        case 2:
            this._renderContext.drawImage(a, b.x, -(b.y + a.height));
            break;
        case 3:
            this._renderContext.drawImage(a, b.x, -(b.y + c.height), c.width, c.height);
            break;
        case 5:
            this._renderContext.drawImage(a, b.x, b.y, c.width, c.height, d.x, -(d.y + e.height), e.width, e.height);
            break;
        default:
            throw Error("Argument must be non-nil");
    }
}, drawStar: function (a, b, c) {
    a = a || this._renderContext;
    b *= cc.view.getScaleX();
    c = "rgba(" + (0 | c.r) + "," + (0 | c.g) + "," + (0 | c.b);
    a.fillStyle = c + ",1)";
    var d = b / 10;
    a.beginPath();
    a.moveTo(-b, b);
    a.lineTo(0, d);
    a.lineTo(b, b);
    a.lineTo(d, 0);
    a.lineTo(b, -b);
    a.lineTo(0, -d);
    a.lineTo(-b, -b);
    a.lineTo(-d, 0);
    a.lineTo(-b, b);
    a.closePath();
    a.fill();
    var e = a.createRadialGradient(0, 0, d, 0, 0, b);
    e.addColorStop(0, c + ", 1)");
    e.addColorStop(0.3, c + ", 0.8)");
    e.addColorStop(1, c + ", 0.0)");
    a.fillStyle = e;
    a.beginPath();
    a.arc(0, 0, b - d, 0, cc.PI2, !1);
    a.closePath();
    a.fill()
}, drawColorBall: function (a, b, c) {
    a = a || this._renderContext;
    b *= cc.view.getScaleX();
    c = "rgba(" + (0 | c.r) + "," + (0 | c.g) + "," + (0 | c.b);
    var d = a.createRadialGradient(0, 0, b / 10, 0, 0, b);
    d.addColorStop(0, c + ", 1)");
    d.addColorStop(0.3, c + ", 0.8)");
    d.addColorStop(0.6, c + ", 0.4)");
    d.addColorStop(1, c + ", 0.0)");
    a.fillStyle = d;
    a.beginPath();
    a.arc(0, 0, b, 0, cc.PI2, !1);
    a.closePath();
    a.fill()
}, fillText: function (a, b, c) {
    this._renderContext.fillText(a, b, -c)
},
    setDrawColor: function (a, b, c, d) {
        this._renderContext.fillStyle = "rgba(" + a + "," + b + "," + c + "," + d / 255 + ")";
        this._renderContext.strokeStyle = "rgba(" + a + "," + b + "," + c + "," + d / 255 + ")"
    }, setPointSize: function (a) {
    }, setLineWidth: function (a) {
        this._renderContext.lineWidth = a * cc.view.getScaleX()
    }});
cc.DrawingPrimitiveWebGL = cc.Class.extend({_renderContext: null, _initialized: !1, _shader: null, _colorLocation: -1, _colorArray: null, _pointSizeLocation: -1, _pointSize: -1, ctor: function (a) {
    null == a && (a = cc._renderContext);
    if (!a instanceof WebGLRenderingContext)throw"Can't initialise DrawingPrimitiveWebGL. context need is WebGLRenderingContext";
    this._renderContext = a;
    this._colorArray = new Float32Array([1, 1, 1, 1])
}, lazy_init: function () {
    this._initialized || (this._shader = cc.shaderCache.programForKey(cc.SHADER_POSITION_UCOLOR),
        this._colorLocation = this._renderContext.getUniformLocation(this._shader.getProgram(), "u_color"), this._pointSizeLocation = this._renderContext.getUniformLocation(this._shader.getProgram(), "u_pointSize"), this._initialized = !0)
}, drawInit: function () {
    this._initialized = !1
}, drawPoint: function (a) {
    this.lazy_init();
    var b = this._renderContext;
    this._shader.use();
    this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
    cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
    b.uniform4fv(this._colorLocation,
        this._colorArray);
    this._shader.setUniformLocationWith1f(this._pointSizeLocation, this._pointSize);
    var c = b.createBuffer();
    b.bindBuffer(b.ARRAY_BUFFER, c);
    b.bufferData(b.ARRAY_BUFFER, new Float32Array([a.x, a.y]), b.STATIC_DRAW);
    b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, b.FLOAT, !1, 0, 0);
    b.drawArrays(b.POINTS, 0, 1);
    b.deleteBuffer(c);
    cc.incrementGLDraws(1)
}, drawPoints: function (a, b) {
    if (a && 0 != a.length) {
        this.lazy_init();
        var c = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        c.uniform4fv(this._colorLocation, this._colorArray);
        this._shader.setUniformLocationWith1f(this._pointSizeLocation, this._pointSize);
        var d = c.createBuffer();
        c.bindBuffer(c.ARRAY_BUFFER, d);
        c.bufferData(c.ARRAY_BUFFER, this._pointsToTypeArray(a), c.STATIC_DRAW);
        c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, c.FLOAT, !1, 0, 0);
        c.drawArrays(c.POINTS, 0, a.length);
        c.deleteBuffer(d);
        cc.incrementGLDraws(1)
    }
}, _pointsToTypeArray: function (a) {
    for (var b = new Float32Array(2 *
        a.length), c = 0; c < a.length; c++)b[2 * c] = a[c].x, b[2 * c + 1] = a[c].y;
    return b
}, drawLine: function (a, b) {
    this.lazy_init();
    var c = this._renderContext;
    this._shader.use();
    this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
    cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
    c.uniform4fv(this._colorLocation, this._colorArray);
    var d = c.createBuffer();
    c.bindBuffer(c.ARRAY_BUFFER, d);
    c.bufferData(c.ARRAY_BUFFER, this._pointsToTypeArray([a, b]), c.STATIC_DRAW);
    c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION,
        2, c.FLOAT, !1, 0, 0);
    c.drawArrays(c.LINES, 0, 2);
    c.deleteBuffer(d);
    cc.incrementGLDraws(1)
}, drawRect: function (a, b) {
    this.drawLine(cc.p(a.x, a.y), cc.p(b.x, a.y));
    this.drawLine(cc.p(b.x, a.y), cc.p(b.x, b.y));
    this.drawLine(cc.p(b.x, b.y), cc.p(a.x, b.y));
    this.drawLine(cc.p(a.x, b.y), cc.p(a.x, a.y))
}, drawSolidRect: function (a, b, c) {
    a = [a, cc.p(b.x, a.y), b, cc.p(a.x, b.y)];
    this.drawSolidPoly(a, 4, c)
}, drawPoly: function (a, b, c) {
    this.lazy_init();
    b = this._renderContext;
    this._shader.use();
    this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
    cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
    b.uniform4fv(this._colorLocation, this._colorArray);
    var d = b.createBuffer();
    b.bindBuffer(b.ARRAY_BUFFER, d);
    b.bufferData(b.ARRAY_BUFFER, this._pointsToTypeArray(a), b.STATIC_DRAW);
    b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, b.FLOAT, !1, 0, 0);
    c ? b.drawArrays(b.LINE_LOOP, 0, a.length) : b.drawArrays(b.LINE_STRIP, 0, a.length);
    b.deleteBuffer(d);
    cc.incrementGLDraws(1)
}, drawSolidPoly: function (a, b, c) {
    this.lazy_init();
    c && this.setDrawColor(c.r, c.g, c.b, c.a);
    b = this._renderContext;
    this._shader.use();
    this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
    cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
    b.uniform4fv(this._colorLocation, this._colorArray);
    c = b.createBuffer();
    b.bindBuffer(b.ARRAY_BUFFER, c);
    b.bufferData(b.ARRAY_BUFFER, this._pointsToTypeArray(a), b.STATIC_DRAW);
    b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, b.FLOAT, !1, 0, 0);
    b.drawArrays(b.TRIANGLE_FAN, 0, a.length);
    b.deleteBuffer(c);
    cc.incrementGLDraws(1)
}, drawCircle: function (a, b, c, d, e) {
    this.lazy_init();
    var f = 1;
    e && f++;
    var g = 2 * Math.PI / d;
    if (e = new Float32Array(2 * (d + 2))) {
        for (var h = 0; h <= d; h++) {
            var k = h * g, m = b * Math.cos(k + c) + a.x, k = b * Math.sin(k + c) + a.y;
            e[2 * h] = m;
            e[2 * h + 1] = k
        }
        e[2 * (d + 1)] = a.x;
        e[2 * (d + 1) + 1] = a.y;
        a = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        a.uniform4fv(this._colorLocation, this._colorArray);
        b = a.createBuffer();
        a.bindBuffer(a.ARRAY_BUFFER, b);
        a.bufferData(a.ARRAY_BUFFER,
            e, a.STATIC_DRAW);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
        a.drawArrays(a.LINE_STRIP, 0, d + f);
        a.deleteBuffer(b);
        cc.incrementGLDraws(1)
    }
}, drawQuadBezier: function (a, b, c, d) {
    this.lazy_init();
    for (var e = new Float32Array(2 * (d + 1)), f = 0, g = 0; g < d; g++)e[2 * g] = Math.pow(1 - f, 2) * a.x + 2 * (1 - f) * f * b.x + f * f * c.x, e[2 * g + 1] = Math.pow(1 - f, 2) * a.y + 2 * (1 - f) * f * b.y + f * f * c.y, f += 1 / d;
    e[2 * d] = c.x;
    e[2 * d + 1] = c.y;
    a = this._renderContext;
    this._shader.use();
    this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
    cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
    a.uniform4fv(this._colorLocation, this._colorArray);
    b = a.createBuffer();
    a.bindBuffer(a.ARRAY_BUFFER, b);
    a.bufferData(a.ARRAY_BUFFER, e, a.STATIC_DRAW);
    a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
    a.drawArrays(a.LINE_STRIP, 0, d + 1);
    a.deleteBuffer(b);
    cc.incrementGLDraws(1)
}, drawCubicBezier: function (a, b, c, d, e) {
    this.lazy_init();
    for (var f = new Float32Array(2 * (e + 1)), g = 0, h = 0; h < e; h++)f[2 * h] = Math.pow(1 - g, 3) * a.x + 3 * Math.pow(1 - g, 2) * g * b.x + 3 * (1 - g) * g * g * c.x + g * g * g * d.x, f[2 * h + 1] = Math.pow(1 - g, 3) * a.y + 3 * Math.pow(1 -
        g, 2) * g * b.y + 3 * (1 - g) * g * g * c.y + g * g * g * d.y, g += 1 / e;
    f[2 * e] = d.x;
    f[2 * e + 1] = d.y;
    a = this._renderContext;
    this._shader.use();
    this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
    cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
    a.uniform4fv(this._colorLocation, this._colorArray);
    b = a.createBuffer();
    a.bindBuffer(a.ARRAY_BUFFER, b);
    a.bufferData(a.ARRAY_BUFFER, f, a.STATIC_DRAW);
    a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
    a.drawArrays(a.LINE_STRIP, 0, e + 1);
    a.deleteBuffer(b);
    cc.incrementGLDraws(1)
},
    drawCatmullRom: function (a, b) {
        this.drawCardinalSpline(a, 0.5, b)
    }, drawCardinalSpline: function (a, b, c) {
        this.lazy_init();
        for (var d = new Float32Array(2 * (c + 1)), e, f, g = 1 / a.length, h = 0; h < c + 1; h++)f = h / c, 1 == f ? (e = a.length - 1, f = 1) : (e = 0 | f / g, f = (f - g * e) / g), e = cc.CardinalSplineAt(cc.getControlPointAt(a, e - 1), cc.getControlPointAt(a, e), cc.getControlPointAt(a, e + 1), cc.getControlPointAt(a, e + 2), b, f), d[2 * h] = e.x, d[2 * h + 1] = e.y;
        a = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        a.uniform4fv(this._colorLocation, this._colorArray);
        b = a.createBuffer();
        a.bindBuffer(a.ARRAY_BUFFER, b);
        a.bufferData(a.ARRAY_BUFFER, d, a.STATIC_DRAW);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
        a.drawArrays(a.LINE_STRIP, 0, c + 1);
        a.deleteBuffer(b);
        cc.incrementGLDraws(1)
    }, setDrawColor: function (a, b, c, d) {
        this._colorArray[0] = a / 255;
        this._colorArray[1] = b / 255;
        this._colorArray[2] = c / 255;
        this._colorArray[3] = d / 255
    }, setPointSize: function (a) {
        this._pointSize =
            a * cc.contentScaleFactor()
    }, setLineWidth: function (a) {
        this._renderContext.lineWidth && this._renderContext.lineWidth(a)
    }});
cc.HashElement = cc.Class.extend({actions: null, target: null, actionIndex: 0, currentAction: null, currentActionSalvaged: !1, paused: !1, hh: null, ctor: function () {
    this.actions = [];
    this.target = null;
    this.actionIndex = 0;
    this.currentAction = null;
    this.paused = this.currentActionSalvaged = !1;
    this.hh = null
}});
cc.ActionManager = cc.Class.extend({_hashTargets: null, _arrayTargets: null, _currentTarget: null, _currentTargetSalvaged: !1, _searchElementByTarget: function (a, b) {
    for (var c = 0; c < a.length; c++)if (b == a[c].target)return a[c];
    return null
}, ctor: function () {
    this._hashTargets = {};
    this._arrayTargets = [];
    this._currentTarget = null;
    this._currentTargetSalvaged = !1
}, addAction: function (a, b, c) {
    if (!a)throw"cc.ActionManager.addAction(): action must be non-null";
    if (!b)throw"cc.ActionManager.addAction(): action must be non-null";
    var d =
        this._hashTargets[b.__instanceId];
    d || (d = new cc.HashElement, d.paused = c, d.target = b, this._hashTargets[b.__instanceId] = d, this._arrayTargets.push(d));
    this._actionAllocWithHashElement(d);
    d.actions.push(a);
    a.startWithTarget(b)
}, removeAllActions: function () {
    for (var a = this._arrayTargets, b = 0; b < a.length; b++) {
        var c = a[b];
        c && this.removeAllActionsFromTarget(c.target, !0)
    }
}, removeAllActionsFromTarget: function (a, b) {
    if (null != a) {
        var c = this._hashTargets[a.__instanceId];
        c && (-1 !== c.actions.indexOf(c.currentAction) && !c.currentActionSalvaged &&
            (c.currentActionSalvaged = !0), c.actions.length = 0, this._currentTarget == c && !b ? this._currentTargetSalvaged = !0 : this._deleteHashElement(c))
    }
}, removeAction: function (a) {
    if (null != a) {
        var b = a.getOriginalTarget();
        if (b = this._hashTargets[b.__instanceId])for (var c = 0; c < b.actions.length; c++) {
            if (b.actions[c] == a) {
                b.actions.splice(c, 1);
                break
            }
        } else cc.log(cc._LogInfos.ActionManager_removeAction)
    }
}, removeActionByTag: function (a, b) {
    a == cc.ACTION_TAG_INVALID && cc.log(cc._LogInfos.ActionManager_addAction);
    cc.assert(b, cc._LogInfos.ActionManager_addAction);
    var c = this._hashTargets[b.__instanceId];
    if (c)for (var d = c.actions.length, e = 0; e < d; ++e) {
        var f = c.actions[e];
        if (f && f.getTag() === a && f.getOriginalTarget() == b) {
            this._removeActionAtIndex(e, c);
            break
        }
    }
}, getActionByTag: function (a, b) {
    a == cc.ACTION_TAG_INVALID && cc.log(cc._LogInfos.ActionManager_getActionByTag);
    var c = this._hashTargets[b.__instanceId];
    if (c) {
        if (null != c.actions)for (var d = 0; d < c.actions.length; ++d) {
            var e = c.actions[d];
            if (e && e.getTag() === a)return e
        }
        cc.log(cc._LogInfos.ActionManager_getActionByTag_2, a)
    }
    return null
},
    numberOfRunningActionsInTarget: function (a) {
        return(a = this._hashTargets[a.__instanceId]) ? a.actions ? a.actions.length : 0 : 0
    }, pauseTarget: function (a) {
        if (a = this._hashTargets[a.__instanceId])a.paused = !0
    }, resumeTarget: function (a) {
        if (a = this._hashTargets[a.__instanceId])a.paused = !1
    }, pauseAllRunningActions: function () {
        for (var a = [], b = this._arrayTargets, c = 0; c < b.length; c++) {
            var d = b[c];
            d && !d.paused && (d.paused = !0, a.push(d.target))
        }
        return a
    }, resumeTargets: function (a) {
        if (a)for (var b = 0; b < a.length; b++)a[b] && this.resumeTarget(a[b])
    },
    purgeSharedManager: function () {
        cc.director.getScheduler().unscheduleUpdateForTarget(this)
    }, _removeActionAtIndex: function (a, b) {
        b.actions[a] == b.currentAction && !b.currentActionSalvaged && (b.currentActionSalvaged = !0);
        b.actions.splice(a, 1);
        b.actionIndex >= a && b.actionIndex--;
        0 == b.actions.length && (this._currentTarget == b ? this._currentTargetSalvaged = !0 : this._deleteHashElement(b))
    }, _deleteHashElement: function (a) {
        a && (delete this._hashTargets[a.target.__instanceId], cc.arrayRemoveObject(this._arrayTargets, a), a.actions =
            null, a.target = null)
    }, _actionAllocWithHashElement: function (a) {
        null == a.actions && (a.actions = [])
    }, update: function (a) {
        for (var b = this._arrayTargets, c, d = 0; d < b.length; d++) {
            c = this._currentTarget = b[d];
            if (!c.paused)for (c.actionIndex = 0; c.actionIndex < c.actions.length; c.actionIndex++)if (c.currentAction = c.actions[c.actionIndex], c.currentAction) {
                c.currentActionSalvaged = !1;
                c.currentAction.step(a * (c.currentAction._speedMethod ? c.currentAction._speed : 1));
                if (c.currentActionSalvaged)c.currentAction = null; else if (c.currentAction.isDone()) {
                    c.currentAction.stop();
                    var e = c.currentAction;
                    c.currentAction = null;
                    this.removeAction(e)
                }
                c.currentAction = null
            }
            this._currentTargetSalvaged && 0 === c.actions.length && this._deleteHashElement(c)
        }
    }});cc._LogInfos = {ActionManager_addAction: "cc.ActionManager.addAction(): action must be non-null", ActionManager_removeAction: "cocos2d: removeAction: Target not found", ActionManager_removeActionByTag: "cc.ActionManager.removeActionByTag(): an invalid tag", ActionManager_removeActionByTag_2: "cc.ActionManager.removeActionByTag(): target must be non-null", ActionManager_getActionByTag: "cc.ActionManager.getActionByTag(): an invalid tag", ActionManager_getActionByTag_2: "cocos2d : getActionByTag(tag \x3d %s): Action not found",
    configuration_dumpInfo: "cocos2d: **** WARNING **** CC_ENABLE_PROFILERS is defined. Disable it when you finish profiling (from ccConfig.js)", configuration_loadConfigFile: "Expected 'data' dict, but not found. Config file: %s", configuration_loadConfigFile_2: "Please load the resource first : %s", Director_resume: "cocos2d: Director: Error in gettimeofday", Director_setProjection: "cocos2d: Director: unrecognized projection", Director_popToSceneStackLevel: "cocos2d: Director: unrecognized projection", Director_popToSceneStackLevel_2: "cocos2d: Director: Error in gettimeofday",
    Director_popScene: "running scene should not null", Director_pushScene: "the scene should not null", arrayVerifyType: "element type is wrong!", Scheduler_scheduleCallbackForTarget: "CCSheduler#scheduleCallback. Callback already scheduled. Updating interval from:%s to %s", Scheduler_scheduleCallbackForTarget_2: "cc.scheduler.scheduleCallbackForTarget(): callback_fn should be non-null.", Scheduler_scheduleCallbackForTarget_3: "cc.scheduler.scheduleCallbackForTarget(): target should be non-null.", Scheduler_pauseTarget: "cc.Scheduler.pauseTarget():target should be non-null",
    Scheduler_resumeTarget: "cc.Scheduler.resumeTarget():target should be non-null", Scheduler_isTargetPaused: "cc.Scheduler.isTargetPaused():target should be non-null", Node_getZOrder: "getZOrder is deprecated. Please use getLocalZOrder instead.", Node_setZOrder: "setZOrder is deprecated. Please use setLocalZOrder instead.", Node_getRotation: "RotationX !\x3d RotationY. Don't know which one to return", Node_getScale: "ScaleX !\x3d ScaleY. Don't know which one to return", Node_addChild: "An Node can't be added as a child of itself.",
    Node_addChild_2: "child already added. It can't be added again", Node_addChild_3: "child must be non-null", Node_removeFromParentAndCleanup: "removeFromParentAndCleanup is deprecated. Use removeFromParent instead", Node_removeChildByTag: "argument tag is an invalid tag", Node_removeChildByTag_2: "cocos2d: removeChildByTag(tag \x3d %s): child not found!", Node_removeAllChildrenWithCleanup: "removeAllChildrenWithCleanup is deprecated. Use removeAllChildren instead", Node_stopActionByTag: "cc.Node.stopActionBy(): argument tag an invalid tag",
    Node_getActionByTag: "cc.Node.getActionByTag(): argument tag is an invalid tag", Node_resumeSchedulerAndActions: "resumeSchedulerAndActions is deprecated, please use resume instead.", Node_pauseSchedulerAndActions: "pauseSchedulerAndActions is deprecated, please use pause instead.", Node__arrayMakeObjectsPerformSelector: "Unknown callback function", Node_reorderChild: "child must be non-null", Node_runAction: "cc.Node.runAction(): action must be non-null", Node_schedule: "callback function must be non-null", Node_schedule_2: "interval must be positive",
    Node_initWithTexture: "cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.", AtlasNode_updateAtlasValues: "cc.AtlasNode.updateAtlasValues(): Shall be overridden in subclasses", AtlasNode_initWithTileFile: "", AtlasNode__initWithTexture: "cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.", _EventListenerKeyboard_checkAvailable: "cc._EventListenerKeyboard.checkAvailable(): Invalid EventListenerKeyboard!", _EventListenerTouchOneByOne_checkAvailable: "cc._EventListenerTouchOneByOne.checkAvailable(): Invalid EventListenerTouchOneByOne!",
    _EventListenerTouchAllAtOnce_checkAvailable: "cc._EventListenerTouchAllAtOnce.checkAvailable(): Invalid EventListenerTouchAllAtOnce!", _EventListenerAcceleration_checkAvailable: "cc._EventListenerAcceleration.checkAvailable(): _onAccelerationEvent must be non-nil", EventListener_create: "Invalid parameter.", __getListenerID: "Don't call this method if the event is for touch.", eventManager__forceAddEventListener: "Invalid scene graph priority!", eventManager_addListener: "0 priority is forbidden for fixed priority since it's used for scene graph based priority.",
    eventManager_removeListeners: "Invalid listener type!", eventManager_setPriority: "Can't set fixed priority with scene graph based listener.", eventManager_addListener_2: "Invalid parameters.", eventManager_addListener_3: "listener must be a cc.EventListener object when adding a fixed priority listener", eventManager_addListener_4: "The listener has been registered, please don't register it again.", LayerMultiplex_initWithLayers: "parameters should not be ending with null in Javascript", LayerMultiplex_switchTo: "Invalid index in MultiplexLayer switchTo message",
    LayerMultiplex_switchToAndReleaseMe: "Invalid index in MultiplexLayer switchTo message", LayerMultiplex_addLayer: "cc.Layer.addLayer(): layer should be non-null", EGLView_setDesignResolutionSize: "Resolution not valid", EGLView_setDesignResolutionSize_2: "should set resolutionPolicy", inputManager_handleTouchesBegin: "The touches is more than MAX_TOUCHES, nUnusedIndex \x3d %s", swap: "cc.swap is being modified from original macro, please check usage", checkGLErrorDebug: "WebGL error %s", animationCache__addAnimationsWithDictionary: "cocos2d: cc.AnimationCache: No animations were found in provided dictionary.",
    animationCache__addAnimationsWithDictionary_2: "cc.AnimationCache. Invalid animation format", animationCache_addAnimations: "cc.AnimationCache.addAnimations(): File could not be found", animationCache__parseVersion1: "cocos2d: cc.AnimationCache: Animation '%s' found in dictionary without any frames - cannot add to animation cache.", animationCache__parseVersion1_2: "cocos2d: cc.AnimationCache: Animation '%s' refers to frame '%s' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.",
    animationCache__parseVersion1_3: "cocos2d: cc.AnimationCache: None of the frames for animation '%s' were found in the cc.SpriteFrameCache. Animation is not being added to the Animation Cache.", animationCache__parseVersion1_4: "cocos2d: cc.AnimationCache: An animation in your dictionary refers to a frame which is not in the cc.SpriteFrameCache. Some or all of the frames for the animation '%s' may be missing.", animationCache__parseVersion2: "cocos2d: CCAnimationCache: Animation '%s' found in dictionary without any frames - cannot add to animation cache.",
    animationCache__parseVersion2_2: "cocos2d: cc.AnimationCache: Animation '%s' refers to frame '%s' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.", animationCache_addAnimations_2: "cc.AnimationCache.addAnimations(): Invalid texture file name", Sprite_reorderChild: "cc.Sprite.reorderChild(): this child is not in children list", Sprite_ignoreAnchorPointForPosition: "cc.Sprite.ignoreAnchorPointForPosition(): it is invalid in cc.Sprite when using SpriteBatchNode",
    Sprite_setDisplayFrameWithAnimationName: "cc.Sprite.setDisplayFrameWithAnimationName(): Frame not found", Sprite_setDisplayFrameWithAnimationName_2: "cc.Sprite.setDisplayFrameWithAnimationName(): Invalid frame index", Sprite_setDisplayFrame: "setDisplayFrame is deprecated, please use setSpriteFrame instead.", Sprite__updateBlendFunc: "cc.Sprite._updateBlendFunc(): _updateBlendFunc doesn't work when the sprite is rendered using a cc.CCSpriteBatchNode", Sprite_initWithSpriteFrame: "cc.Sprite.initWithSpriteFrame(): spriteFrame should be non-null",
    Sprite_initWithSpriteFrameName: "cc.Sprite.initWithSpriteFrameName(): spriteFrameName should be non-null", Sprite_initWithSpriteFrameName1: " is null, please check.", Sprite_initWithFile: "cc.Sprite.initWithFile(): filename should be non-null", Sprite_setDisplayFrameWithAnimationName_3: "cc.Sprite.setDisplayFrameWithAnimationName(): animationName must be non-null", Sprite_reorderChild_2: "cc.Sprite.reorderChild(): child should be non-null", Sprite_addChild: "cc.Sprite.addChild(): cc.Sprite only supports cc.Sprites as children when using cc.SpriteBatchNode",
    Sprite_addChild_2: "cc.Sprite.addChild(): cc.Sprite only supports a sprite using same texture as children when using cc.SpriteBatchNode", Sprite_addChild_3: "cc.Sprite.addChild(): child should be non-null", Sprite_setTexture: "cc.Sprite.texture setter: Batched sprites should use the same texture as the batchnode", Sprite_updateQuadFromSprite: "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children", Sprite_insertQuadFromSprite: "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    Sprite_addChild_4: "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children", Sprite_addChild_5: "cc.SpriteBatchNode.addChild(): cc.Sprite is not using the same texture", Sprite_initWithTexture: "Sprite.initWithTexture(): Argument must be non-nil ", Sprite_setSpriteFrame: "Invalid spriteFrameName", Sprite_setTexture_2: "Invalid argument: cc.Sprite.texture setter expects a CCTexture2D.", Sprite_updateQuadFromSprite_2: "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
    Sprite_insertQuadFromSprite_2: "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null", Sprite_addChild_6: "cc.SpriteBatchNode.addChild(): child should be non-null", SpriteBatchNode_addSpriteWithoutQuad: "cc.SpriteBatchNode.addQuadFromSprite(): SpriteBatchNode only supports cc.Sprites as children", SpriteBatchNode_increaseAtlasCapacity: "cocos2d: CCSpriteBatchNode: resizing TextureAtlas capacity from %s to %s.", SpriteBatchNode_increaseAtlasCapacity_2: "cocos2d: WARNING: Not enough memory to resize the atlas",
    SpriteBatchNode_reorderChild: "cc.SpriteBatchNode.addChild(): Child doesn't belong to Sprite", SpriteBatchNode_removeChild: "cc.SpriteBatchNode.addChild(): sprite batch node should contain the child", SpriteBatchNode_addSpriteWithoutQuad_2: "cc.SpriteBatchNode.addQuadFromSprite(): child should be non-null", SpriteBatchNode_reorderChild_2: "cc.SpriteBatchNode.addChild():child should be non-null", spriteFrameCache__getFrameConfig: "cocos2d: WARNING: originalWidth/Height not found on the cc.SpriteFrame. AnchorPoint won't work as expected. Regenrate the .plist",
    spriteFrameCache_addSpriteFrames: "cocos2d: WARNING: an alias with name %s already exists", spriteFrameCache__checkConflict: "cocos2d: WARNING: Sprite frame: %s has already been added by another source, please fix name conflit", spriteFrameCache_getSpriteFrame: "cocos2d: cc.SpriteFrameCahce: Frame %s not found", spriteFrameCache__getFrameConfig_2: "Please load the resource first : %s", spriteFrameCache_addSpriteFrames_2: "cc.SpriteFrameCache.addSpriteFrames(): plist should be non-null", spriteFrameCache_addSpriteFrames_3: "Argument must be non-nil",
    CCSpriteBatchNode_updateQuadFromSprite: "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children", CCSpriteBatchNode_insertQuadFromSprite: "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children", CCSpriteBatchNode_addChild: "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children", CCSpriteBatchNode_initWithTexture: "Sprite.initWithTexture(): Argument must be non-nil ", CCSpriteBatchNode_addChild_2: "cc.Sprite.addChild(): child should be non-null",
    CCSpriteBatchNode_setSpriteFrame: "Invalid spriteFrameName", CCSpriteBatchNode_setTexture: "Invalid argument: cc.Sprite texture setter expects a CCTexture2D.", CCSpriteBatchNode_updateQuadFromSprite_2: "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null", CCSpriteBatchNode_insertQuadFromSprite_2: "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null", CCSpriteBatchNode_addChild_3: "cc.SpriteBatchNode.addChild(): child should be non-null", TextureAtlas_initWithFile: "cocos2d: Could not open file: %s",
    TextureAtlas_insertQuad: "cc.TextureAtlas.insertQuad(): invalid totalQuads", TextureAtlas_initWithTexture: "cc.TextureAtlas.initWithTexture():texture should be non-null", TextureAtlas_updateQuad: "cc.TextureAtlas.updateQuad(): quad should be non-null", TextureAtlas_updateQuad_2: "cc.TextureAtlas.updateQuad(): Invalid index", TextureAtlas_insertQuad_2: "cc.TextureAtlas.insertQuad(): Invalid index", TextureAtlas_insertQuads: "cc.TextureAtlas.insertQuad(): Invalid index + amount", TextureAtlas_insertQuadFromIndex: "cc.TextureAtlas.insertQuadFromIndex(): Invalid newIndex",
    TextureAtlas_insertQuadFromIndex_2: "cc.TextureAtlas.insertQuadFromIndex(): Invalid fromIndex", TextureAtlas_removeQuadAtIndex: "cc.TextureAtlas.removeQuadAtIndex(): Invalid index", TextureAtlas_removeQuadsAtIndex: "cc.TextureAtlas.removeQuadsAtIndex(): index + amount out of bounds", TextureAtlas_moveQuadsFromIndex: "cc.TextureAtlas.moveQuadsFromIndex(): move is out of bounds", TextureAtlas_moveQuadsFromIndex_2: "cc.TextureAtlas.moveQuadsFromIndex(): Invalid newIndex", TextureAtlas_moveQuadsFromIndex_3: "cc.TextureAtlas.moveQuadsFromIndex(): Invalid oldIndex",
    textureCache_addPVRTCImage: "TextureCache:addPVRTCImage does not support on HTML5", textureCache_addETCImage: "TextureCache:addPVRTCImage does not support on HTML5", textureCache_addPVRImage: "addPVRImage does not support on HTML5", textureCache_addUIImage: "cocos2d: Couldn't add UIImage in TextureCache", textureCache_dumpCachedTextureInfo: "cocos2d: '%s' id\x3d%s %s x %s", textureCache_dumpCachedTextureInfo_2: "cocos2d: '%s' id\x3d HTMLCanvasElement %s x %s", textureCache_dumpCachedTextureInfo_3: "cocos2d: TextureCache dumpDebugInfo: %s textures, HTMLCanvasElement for %s KB (%s MB)",
    textureCache_addUIImage_2: "cc.Texture.addUIImage(): image should be non-null", Texture2D_initWithETCFile: "initWithETCFile does not support on HTML5", Texture2D_initWithPVRFile: "initWithPVRFile does not support on HTML5", Texture2D_initWithPVRTCData: "initWithPVRTCData does not support on HTML5", Texture2D_addImage: "cc.Texture.addImage(): path should be non-null", Texture2D_initWithImage: "cocos2d: cc.Texture2D. Can't create Texture. UIImage is nil", Texture2D_initWithImage_2: "cocos2d: WARNING: Image (%s x %s) is bigger than the supported %s x %s",
    Texture2D_initWithString: "initWithString isn't supported on cocos2d-html5", Texture2D_initWithETCFile_2: "initWithETCFile does not support on HTML5", Texture2D_initWithPVRFile_2: "initWithPVRFile does not support on HTML5", Texture2D_initWithPVRTCData_2: "initWithPVRTCData does not support on HTML5", Texture2D_bitsPerPixelForFormat: "bitsPerPixelForFormat: %s, cannot give useful result, it's a illegal pixel format", Texture2D__initPremultipliedATextureWithImage: "cocos2d: cc.Texture2D: Using RGB565 texture since image has no alpha",
    Texture2D_addImage_2: "cc.Texture.addImage(): path should be non-null", Texture2D_initWithData: "NSInternalInconsistencyException", MissingFile: "Missing file: %s", radiansToDegress: "cc.radiansToDegress() should be called cc.radiansToDegrees()", RectWidth: "Rect width exceeds maximum margin: %s", RectHeight: "Rect height exceeds maximum margin: %s", EventManager__updateListeners: "If program goes here, there should be event in dispatch.", EventManager__updateListeners_2: "_inDispatch should be 1 here."};
cc._logToWebPage = function (msg) {
    if (!cc._canvas)return;
    var logList = cc._logList;
    var doc = document;
    if (!logList) {
        var logDiv = doc.createElement("Div");
        var logDivStyle = logDiv.style;
        logDiv.setAttribute("id", "logInfoDiv");
        cc._canvas.parentNode.appendChild(logDiv);
        logDiv.setAttribute("width", "200");
        logDiv.setAttribute("height", cc._canvas.height);
        logDivStyle.zIndex = "99999";
        logDivStyle.position = "absolute";
        logDivStyle.top = "0";
        logDivStyle.left = "0";
        logList = cc._logList = doc.createElement("textarea");
        var logListStyle =
            logList.style;
        logList.setAttribute("rows", "20");
        logList.setAttribute("cols", "30");
        logList.setAttribute("disabled", true);
        logDiv.appendChild(logList);
        logListStyle.backgroundColor = "transparent";
        logListStyle.borderBottom = "1px solid #cccccc";
        logListStyle.borderRightWidth = "0px";
        logListStyle.borderLeftWidth = "0px";
        logListStyle.borderTopWidth = "0px";
        logListStyle.borderTopStyle = "none";
        logListStyle.borderRightStyle = "none";
        logListStyle.borderLeftStyle = "none";
        logListStyle.padding = "0px";
        logListStyle.margin = 0
    }
    msg =
            typeof msg == "string" ? msg : JSON.stringify(msg);
    logList.value = logList.value + msg + "\r\n";
    logList.scrollTop = logList.scrollHeight
};
cc._formatString = function (arg) {
    if (typeof arg === "object")try {
        return JSON.stringify(arg)
    } catch (err) {
        return""
    } else return arg
};
if (console.log) {
    cc.log = function (msg) {
        for (var i = 1; i < arguments.length; i++)msg = msg.replace(/(%s)|(%d)/, cc._formatString(arguments[i]));
        console.log(msg)
    };
    cc.warn = console.warn ? function (msg) {
        for (var i = 1; i < arguments.length; i++)msg = msg.replace(/(%s)|(%d)/, cc._formatString(arguments[i]));
        console.warn(msg)
    } : cc.log;
    cc.error = console.error ? function (msg) {
        for (var i = 1; i < arguments.length; i++)msg = msg.replace(/(%s)|(%d)/, cc._formatString(arguments[i]));
        console.error(msg)
    } : cc.log;
    cc.assert = function (cond, msg) {
        if (!cond &&
            msg) {
            for (var i = 2; i < arguments.length; i++)msg = msg.replace(/(%s)|(%d)/, cc._formatString(arguments[i]));
            throw msg;
        }
    }
}
var mode = cc.game.config[cc.game.CONFIG_KEY.debugMode];
var ccGame = cc.game;
if (console.log && mode === ccGame.DEBUG_MODE_INFO); else if (mode == ccGame.DEBUG_MODE_INFO_FOR_WEB_PAGE)cc.log = cc._logToWebPage.bind(cc); else cc.log = function () {
};
if (!mode || mode == ccGame.DEBUG_MODE_NONE || mode == ccGame.DEBUG_MODE_ERROR || mode == ccGame.DEBUG_MODE_ERROR_FOR_WEB_PAGE)cc.warn = function () {
};
if (mode == ccGame.DEBUG_MODE_INFO_FOR_WEB_PAGE || mode == ccGame.DEBUG_MODE_WARN_FOR_WEB_PAGE || !console.warn)cc.warn = cc._logToWebPage.bind(cc);
if (!mode || mode == ccGame.DEBUG_MODE_NONE) {
    cc.error = function () {
    };
    cc.assert = function () {
    }
} else if (mode == ccGame.DEBUG_MODE_INFO_FOR_WEB_PAGE || mode == ccGame.DEBUG_MODE_WARN_FOR_WEB_PAGE || mode == ccGame.DEBUG_MODE_ERROR_FOR_WEB_PAGE || !console.error) {
    cc.error = cc._logToWebPage.bind(cc);
    cc.assert = function (cond, msg) {
        if (!cond && msg) {
            for (var i = 2; i < arguments.length; i++)msg = msg.replace("%s", arguments[i]);
            cc._logToWebPage(msg)
        }
    }
}
;cc.ACTION_TAG_INVALID = -1;
cc.Action = cc.Class.extend({originalTarget: null, target: null, tag: cc.ACTION_TAG_INVALID, ctor: function () {
    this.originalTarget = null;
    this.target = null;
    this.tag = cc.ACTION_TAG_INVALID
}, copy: function () {
    cc.log("copy is deprecated. Please use clone instead.");
    return this.clone()
}, clone: function () {
    var action = new cc.Action;
    action.originalTarget = null;
    action.target = null;
    action.tag = this.tag;
    return action
}, isDone: function () {
    return true
}, startWithTarget: function (target) {
    this.originalTarget = target;
    this.target = target
},
    stop: function () {
        this.target = null
    }, step: function (dt) {
        cc.log("[Action step]. override me")
    }, update: function (time) {
        cc.log("[Action update]. override me")
    }, getTarget: function () {
        return this.target
    }, setTarget: function (target) {
        this.target = target
    }, getOriginalTarget: function () {
        return this.originalTarget
    }, setOriginalTarget: function (originalTarget) {
        this.originalTarget = originalTarget
    }, getTag: function () {
        return this.tag
    }, setTag: function (tag) {
        this.tag = tag
    }, retain: function () {
    }, release: function () {
    }});
cc.Action.create = function () {
    return new cc.Action
};
cc.FiniteTimeAction = cc.Action.extend({_duration: 0, ctor: function () {
    cc.Action.prototype.ctor.call(this);
    this._duration = 0
}, getDuration: function () {
    return this._duration * (this._times || 1)
}, setDuration: function (duration) {
    this._duration = duration
}, reverse: function () {
    cc.log("cocos2d: FiniteTimeAction#reverse: Implement me");
    return null
}, clone: function () {
    return new cc.FiniteTimeAction
}});
cc.Speed = cc.Action.extend({_speed: 0, _innerAction: null, ctor: function (action, speed) {
    cc.Action.prototype.ctor.call(this);
    this._speed = 0;
    this._innerAction = null;
    action && this.initWithAction(action, speed)
}, getSpeed: function () {
    return this._speed
}, setSpeed: function (speed) {
    this._speed = speed
}, initWithAction: function (action, speed) {
    if (!action)throw"cc.Speed.initWithAction(): action must be non nil";
    this._innerAction = action;
    this._speed = speed;
    return true
}, clone: function () {
    var action = new cc.Speed;
    action.initWithAction(this._innerAction.clone(),
        this._speed);
    return action
}, startWithTarget: function (target) {
    cc.Action.prototype.startWithTarget.call(this, target);
    this._innerAction.startWithTarget(target)
}, stop: function () {
    this._innerAction.stop();
    cc.Action.prototype.stop.call(this)
}, step: function (dt) {
    this._innerAction.step(dt * this._speed)
}, isDone: function () {
    return this._innerAction.isDone()
}, reverse: function () {
    return cc.Speed.create(this._innerAction.reverse(), this._speed)
}, setInnerAction: function (action) {
    if (this._innerAction != action)this._innerAction =
        action
}, getInnerAction: function () {
    return this._innerAction
}});
cc.Speed.create = function (action, speed) {
    return new cc.Speed(action, speed)
};
cc.Follow = cc.Action.extend({_followedNode: null, _boundarySet: false, _boundaryFullyCovered: false, _halfScreenSize: null, _fullScreenSize: null, leftBoundary: 0, rightBoundary: 0, topBoundary: 0, bottomBoundary: 0, _worldRect: null, ctor: function (followedNode, rect) {
    cc.Action.prototype.ctor.call(this);
    this._followedNode = null;
    this._boundarySet = false;
    this._boundaryFullyCovered = false;
    this._halfScreenSize = null;
    this._fullScreenSize = null;
    this.leftBoundary = 0;
    this.rightBoundary = 0;
    this.topBoundary = 0;
    this.bottomBoundary = 0;
    this._worldRect =
        cc.rect(0, 0, 0, 0);
    if (followedNode)rect ? this.initWithTarget(followedNode, rect) : this.initWithTarget(followedNode)
}, clone: function () {
    var action = new cc.Follow;
    var locRect = this._worldRect;
    var rect = new cc.Rect(locRect.x, locRect.y, locRect.width, locRect.height);
    action.initWithTarget(this._followedNode, rect);
    return action
}, isBoundarySet: function () {
    return this._boundarySet
}, setBoudarySet: function (value) {
    this._boundarySet = value
}, initWithTarget: function (followedNode, rect) {
    if (!followedNode)throw"cc.Follow.initWithAction(): followedNode must be non nil";
    var _this = this;
    rect = rect || cc.rect(0, 0, 0, 0);
    _this._followedNode = followedNode;
    _this._worldRect = rect;
    _this._boundarySet = !cc._rectEqualToZero(rect);
    _this._boundaryFullyCovered = false;
    var winSize = cc.director.getWinSize();
    _this._fullScreenSize = cc.p(winSize.width, winSize.height);
    _this._halfScreenSize = cc.pMult(_this._fullScreenSize, 0.5);
    if (_this._boundarySet) {
        _this.leftBoundary = -(rect.x + rect.width - _this._fullScreenSize.x);
        _this.rightBoundary = -rect.x;
        _this.topBoundary = -rect.y;
        _this.bottomBoundary = -(rect.y +
            rect.height - _this._fullScreenSize.y);
        if (_this.rightBoundary < _this.leftBoundary)_this.rightBoundary = _this.leftBoundary = (_this.leftBoundary + _this.rightBoundary) / 2;
        if (_this.topBoundary < _this.bottomBoundary)_this.topBoundary = _this.bottomBoundary = (_this.topBoundary + _this.bottomBoundary) / 2;
        if (_this.topBoundary == _this.bottomBoundary && _this.leftBoundary == _this.rightBoundary)_this._boundaryFullyCovered = true
    }
    return true
}, step: function (dt) {
    var tempPosX = this._followedNode.x;
    var tempPosY = this._followedNode.y;
    tempPosX = this._halfScreenSize.x - tempPosX;
    tempPosY = this._halfScreenSize.y - tempPosY;
    if (this._boundarySet) {
        if (this._boundaryFullyCovered)return;
        this.target.setPosition(cc.clampf(tempPosX, this.leftBoundary, this.rightBoundary), cc.clampf(tempPosY, this.bottomBoundary, this.topBoundary))
    } else this.target.setPosition(tempPosX, tempPosY)
}, isDone: function () {
    return!this._followedNode.running
}, stop: function () {
    this.target = null;
    cc.Action.prototype.stop.call(this)
}});
cc.Follow.create = function (followedNode, rect) {
    return new cc.Follow(followedNode, rect)
};
cc.ActionInterval = cc.FiniteTimeAction.extend({_elapsed: 0, _firstTick: false, _easeList: null, _times: 1, _repeatForever: false, _repeatMethod: false, _speed: 1, _speedMethod: false, ctor: function (d) {
    this._speed = 1;
    this._times = 1;
    this._repeatForever = false;
    this.MAX_VALUE = 2;
    this._repeatMethod = false;
    this._speedMethod = false;
    cc.FiniteTimeAction.prototype.ctor.call(this);
    d !== undefined && this.initWithDuration(d)
}, getElapsed: function () {
    return this._elapsed
}, initWithDuration: function (d) {
    this._duration = d === 0 ? cc.FLT_EPSILON : d;
    this._elapsed = 0;
    this._firstTick = true;
    return true
}, isDone: function () {
    return this._elapsed >= this._duration
}, _cloneDecoration: function (action) {
    action._repeatForever = this._repeatForever;
    action._speed = this._speed;
    action._times = this._times;
    action._easeList = this._easeList;
    action._speedMethod = this._speedMethod;
    action._repeatMethod = this._repeatMethod
}, _reverseEaseList: function (action) {
    if (this._easeList) {
        action._easeList = [];
        for (var i = 0; i < this._easeList.length; i++)action._easeList.push(this._easeList[i].reverse())
    }
},
    clone: function () {
        var action = new cc.ActionInterval(this._duration);
        this._cloneDecoration(action);
        return action
    }, easing: function (easeObj) {
        if (this._easeList)this._easeList.length = 0; else this._easeList = [];
        for (var i = 0; i < arguments.length; i++)this._easeList.push(arguments[i]);
        return this
    }, _computeEaseTime: function (dt) {
        var locList = this._easeList;
        if (!locList || locList.length === 0)return dt;
        for (var i = 0, n = locList.length; i < n; i++)dt = locList[i].easing(dt);
        return dt
    }, step: function (dt) {
        if (this._firstTick) {
            this._firstTick =
                false;
            this._elapsed = 0
        } else this._elapsed += dt;
        var t = this._elapsed / (this._duration > 1.192092896E-7 ? this._duration : 1.192092896E-7);
        t = 1 > t ? t : 1;
        this.update(t > 0 ? t : 0);
        if (this._repeatMethod && this._times > 1 && this.isDone()) {
            if (!this._repeatForever)this._times--;
            this.startWithTarget(this.target);
            this.step(this._elapsed - this._duration)
        }
    }, startWithTarget: function (target) {
        cc.Action.prototype.startWithTarget.call(this, target);
        this._elapsed = 0;
        this._firstTick = true
    }, reverse: function () {
        cc.log("cc.IntervalAction: reverse not implemented.");
        return null
    }, setAmplitudeRate: function (amp) {
        cc.log("cc.ActionInterval.setAmplitudeRate(): it should be overridden in subclass.")
    }, getAmplitudeRate: function () {
        cc.log("cc.ActionInterval.getAmplitudeRate(): it should be overridden in subclass.");
        return 0
    }, speed: function (speed) {
        if (speed <= 0) {
            cc.log("The speed parameter error");
            return this
        }
        this._speedMethod = true;
        this._speed *= speed;
        return this
    }, getSpeed: function () {
        return this._speed
    }, setSpeed: function (speed) {
        this._speed = speed;
        return this
    }, repeat: function (times) {
        times =
            Math.round(times);
        if (isNaN(times) || times < 1) {
            cc.log("The repeat parameter error");
            return this
        }
        this._repeatMethod = true;
        this._times *= times;
        return this
    }, repeatForever: function () {
        this._repeatMethod = true;
        this._times = this.MAX_VALUE;
        this._repeatForever = true;
        return this
    }});
cc.ActionInterval.create = function (d) {
    return new cc.ActionInterval(d)
};
cc.Sequence = cc.ActionInterval.extend({_actions: null, _split: null, _last: 0, ctor: function (tempArray) {
    cc.ActionInterval.prototype.ctor.call(this);
    this._actions = [];
    var paramArray = tempArray instanceof Array ? tempArray : arguments;
    var last = paramArray.length - 1;
    if (last >= 0 && paramArray[last] == null)cc.log("parameters should not be ending with null in Javascript");
    if (last >= 0) {
        var prev = paramArray[0], action1;
        for (var i = 1; i < last; i++)if (paramArray[i]) {
            action1 = prev;
            prev = cc.Sequence._actionOneTwo(action1, paramArray[i])
        }
        this.initWithTwoActions(prev,
            paramArray[last])
    }
}, initWithTwoActions: function (actionOne, actionTwo) {
    if (!actionOne || !actionTwo)throw"cc.Sequence.initWithTwoActions(): arguments must all be non nil";
    var d = actionOne._duration + actionTwo._duration;
    this.initWithDuration(d);
    this._actions[0] = actionOne;
    this._actions[1] = actionTwo;
    return true
}, clone: function () {
    var action = new cc.Sequence;
    this._cloneDecoration(action);
    action.initWithTwoActions(this._actions[0].clone(), this._actions[1].clone());
    return action
}, startWithTarget: function (target) {
    cc.ActionInterval.prototype.startWithTarget.call(this,
        target);
    this._split = this._actions[0]._duration / this._duration;
    this._last = -1
}, stop: function () {
    if (this._last !== -1)this._actions[this._last].stop();
    cc.Action.prototype.stop.call(this)
}, update: function (time) {
    time = this._computeEaseTime(time);
    var new_t, found = 0;
    var locSplit = this._split, locActions = this._actions, locLast = this._last;
    if (time < locSplit) {
        new_t = locSplit !== 0 ? time / locSplit : 1;
        if (found === 0 && locLast === 1) {
            locActions[1].update(0);
            locActions[1].stop()
        }
    } else {
        found = 1;
        new_t = locSplit === 1 ? 1 : (time - locSplit) / (1 -
            locSplit);
        if (locLast === -1) {
            locActions[0].startWithTarget(this.target);
            locActions[0].update(1);
            locActions[0].stop()
        }
        if (!locLast) {
            locActions[0].update(1);
            locActions[0].stop()
        }
    }
    if (locLast === found && locActions[found].isDone())return;
    if (locLast !== found)locActions[found].startWithTarget(this.target);
    locActions[found].update(new_t);
    this._last = found
}, reverse: function () {
    var action = cc.Sequence._actionOneTwo(this._actions[1].reverse(), this._actions[0].reverse());
    this._cloneDecoration(action);
    this._reverseEaseList(action);
    return action
}});
cc.Sequence.create = function (tempArray) {
    var paramArray = tempArray instanceof Array ? tempArray : arguments;
    if (paramArray.length > 0 && paramArray[paramArray.length - 1] == null)cc.log("parameters should not be ending with null in Javascript");
    var prev = paramArray[0];
    for (var i = 1; i < paramArray.length; i++)if (paramArray[i])prev = cc.Sequence._actionOneTwo(prev, paramArray[i]);
    return prev
};
cc.Sequence._actionOneTwo = function (actionOne, actionTwo) {
    var sequence = new cc.Sequence;
    sequence.initWithTwoActions(actionOne, actionTwo);
    return sequence
};
cc.Repeat = cc.ActionInterval.extend({_times: 0, _total: 0, _nextDt: 0, _actionInstant: false, _innerAction: null, ctor: function (action, times) {
    cc.ActionInterval.prototype.ctor.call(this);
    times !== undefined && this.initWithAction(action, times)
}, initWithAction: function (action, times) {
    var duration = action._duration * times;
    if (this.initWithDuration(duration)) {
        this._times = times;
        this._innerAction = action;
        if (action instanceof cc.ActionInstant) {
            this._actionInstant = true;
            this._times -= 1
        }
        this._total = 0;
        return true
    }
    return false
},
    clone: function () {
        var action = new cc.Repeat;
        this._cloneDecoration(action);
        action.initWithAction(this._innerAction.clone(), this._times);
        return action
    }, startWithTarget: function (target) {
        this._total = 0;
        this._nextDt = this._innerAction._duration / this._duration;
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._innerAction.startWithTarget(target)
    }, stop: function () {
        this._innerAction.stop();
        cc.Action.prototype.stop.call(this)
    }, update: function (time) {
        time = this._computeEaseTime(time);
        var locInnerAction =
            this._innerAction;
        var locDuration = this._duration;
        var locTimes = this._times;
        var locNextDt = this._nextDt;
        if (time >= locNextDt) {
            while (time > locNextDt && this._total < locTimes) {
                locInnerAction.update(1);
                this._total++;
                locInnerAction.stop();
                locInnerAction.startWithTarget(this.target);
                locNextDt += locInnerAction._duration / locDuration;
                this._nextDt = locNextDt
            }
            if (time >= 1 && this._total < locTimes)this._total++;
            if (!this._actionInstant)if (this._total === locTimes) {
                locInnerAction.update(1);
                locInnerAction.stop()
            } else locInnerAction.update(time -
                (locNextDt - locInnerAction._duration / locDuration))
        } else locInnerAction.update(time * locTimes % 1)
    }, isDone: function () {
        return this._total == this._times
    }, reverse: function () {
        var action = cc.Repeat.create(this._innerAction.reverse(), this._times);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action
    }, setInnerAction: function (action) {
        if (this._innerAction != action)this._innerAction = action
    }, getInnerAction: function () {
        return this._innerAction
    }});
cc.Repeat.create = function (action, times) {
    return new cc.Repeat(action, times)
};
cc.RepeatForever = cc.ActionInterval.extend({_innerAction: null, ctor: function (action) {
    cc.ActionInterval.prototype.ctor.call(this);
    this._innerAction = null;
    action && this.initWithAction(action)
}, initWithAction: function (action) {
    if (!action)throw"cc.RepeatForever.initWithAction(): action must be non null";
    this._innerAction = action;
    return true
}, clone: function () {
    var action = new cc.RepeatForever;
    this._cloneDecoration(action);
    action.initWithAction(this._innerAction.clone());
    return action
}, startWithTarget: function (target) {
    cc.ActionInterval.prototype.startWithTarget.call(this,
        target);
    this._innerAction.startWithTarget(target)
}, step: function (dt) {
    var locInnerAction = this._innerAction;
    locInnerAction.step(dt);
    if (locInnerAction.isDone()) {
        locInnerAction.startWithTarget(this.target);
        locInnerAction.step(locInnerAction.getElapsed() - locInnerAction._duration)
    }
}, isDone: function () {
    return false
}, reverse: function () {
    var action = cc.RepeatForever.create(this._innerAction.reverse());
    this._cloneDecoration(action);
    this._reverseEaseList(action);
    return action
}, setInnerAction: function (action) {
    if (this._innerAction !=
        action)this._innerAction = action
}, getInnerAction: function () {
    return this._innerAction
}});
cc.RepeatForever.create = function (action) {
    return new cc.RepeatForever(action)
};
cc.Spawn = cc.ActionInterval.extend({_one: null, _two: null, ctor: function (tempArray) {
    cc.ActionInterval.prototype.ctor.call(this);
    this._one = null;
    this._two = null;
    var paramArray = tempArray instanceof Array ? tempArray : arguments;
    var last = paramArray.length - 1;
    if (last >= 0 && paramArray[last] == null)cc.log("parameters should not be ending with null in Javascript");
    if (last >= 0) {
        var prev = paramArray[0], action1;
        for (var i = 1; i < last; i++)if (paramArray[i]) {
            action1 = prev;
            prev = cc.Spawn._actionOneTwo(action1, paramArray[i])
        }
        this.initWithTwoActions(prev,
            paramArray[last])
    }
}, initWithTwoActions: function (action1, action2) {
    if (!action1 || !action2)throw"cc.Spawn.initWithTwoActions(): arguments must all be non null";
    var ret = false;
    var d1 = action1._duration;
    var d2 = action2._duration;
    if (this.initWithDuration(Math.max(d1, d2))) {
        this._one = action1;
        this._two = action2;
        if (d1 > d2)this._two = cc.Sequence._actionOneTwo(action2, cc.DelayTime.create(d1 - d2)); else if (d1 < d2)this._one = cc.Sequence._actionOneTwo(action1, cc.DelayTime.create(d2 - d1));
        ret = true
    }
    return ret
}, clone: function () {
    var action =
        new cc.Spawn;
    this._cloneDecoration(action);
    action.initWithTwoActions(this._one.clone(), this._two.clone());
    return action
}, startWithTarget: function (target) {
    cc.ActionInterval.prototype.startWithTarget.call(this, target);
    this._one.startWithTarget(target);
    this._two.startWithTarget(target)
}, stop: function () {
    this._one.stop();
    this._two.stop();
    cc.Action.prototype.stop.call(this)
}, update: function (time) {
    time = this._computeEaseTime(time);
    if (this._one)this._one.update(time);
    if (this._two)this._two.update(time)
}, reverse: function () {
    var action =
        cc.Spawn._actionOneTwo(this._one.reverse(), this._two.reverse());
    this._cloneDecoration(action);
    this._reverseEaseList(action);
    return action
}});
cc.Spawn.create = function (tempArray) {
    var paramArray = tempArray instanceof Array ? tempArray : arguments;
    if (paramArray.length > 0 && paramArray[paramArray.length - 1] == null)cc.log("parameters should not be ending with null in Javascript");
    var prev = paramArray[0];
    for (var i = 1; i < paramArray.length; i++)if (paramArray[i] != null)prev = cc.Spawn._actionOneTwo(prev, paramArray[i]);
    return prev
};
cc.Spawn._actionOneTwo = function (action1, action2) {
    var pSpawn = new cc.Spawn;
    pSpawn.initWithTwoActions(action1, action2);
    return pSpawn
};
cc.RotateTo = cc.ActionInterval.extend({_dstAngleX: 0, _startAngleX: 0, _diffAngleX: 0, _dstAngleY: 0, _startAngleY: 0, _diffAngleY: 0, ctor: function (duration, deltaAngleX, deltaAngleY) {
    cc.ActionInterval.prototype.ctor.call(this);
    deltaAngleX !== undefined && this.initWithDuration(duration, deltaAngleX, deltaAngleY)
}, initWithDuration: function (duration, deltaAngleX, deltaAngleY) {
    if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
        this._dstAngleX = deltaAngleX || 0;
        this._dstAngleY = deltaAngleY || this._dstAngleX;
        return true
    }
    return false
}, clone: function () {
    var action = new cc.RotateTo;
    this._cloneDecoration(action);
    action.initWithDuration(this._duration, this._dstAngleX, this._dstAngleY);
    return action
}, startWithTarget: function (target) {
    cc.ActionInterval.prototype.startWithTarget.call(this, target);
    var locStartAngleX = target.rotationX % 360;
    var locDiffAngleX = this._dstAngleX - locStartAngleX;
    if (locDiffAngleX > 180)locDiffAngleX -= 360;
    if (locDiffAngleX < -180)locDiffAngleX += 360;
    this._startAngleX = locStartAngleX;
    this._diffAngleX =
        locDiffAngleX;
    this._startAngleY = target.rotationY % 360;
    var locDiffAngleY = this._dstAngleY - this._startAngleY;
    if (locDiffAngleY > 180)locDiffAngleY -= 360;
    if (locDiffAngleY < -180)locDiffAngleY += 360;
    this._diffAngleY = locDiffAngleY
}, reverse: function () {
    cc.log("cc.RotateTo.reverse(): it should be overridden in subclass.")
}, update: function (time) {
    time = this._computeEaseTime(time);
    if (this.target) {
        this.target.rotationX = this._startAngleX + this._diffAngleX * time;
        this.target.rotationY = this._startAngleY + this._diffAngleY * time
    }
}});
cc.RotateTo.create = function (duration, deltaAngleX, deltaAngleY) {
    return new cc.RotateTo(duration, deltaAngleX, deltaAngleY)
};
cc.RotateBy = cc.ActionInterval.extend({_angleX: 0, _startAngleX: 0, _angleY: 0, _startAngleY: 0, ctor: function (duration, deltaAngleX, deltaAngleY) {
    cc.ActionInterval.prototype.ctor.call(this);
    deltaAngleX !== undefined && this.initWithDuration(duration, deltaAngleX, deltaAngleY)
}, initWithDuration: function (duration, deltaAngleX, deltaAngleY) {
    if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
        this._angleX = deltaAngleX || 0;
        this._angleY = deltaAngleY || this._angleX;
        return true
    }
    return false
}, clone: function () {
    var action =
        new cc.RotateBy;
    this._cloneDecoration(action);
    action.initWithDuration(this._duration, this._angleX, this._angleY);
    return action
}, startWithTarget: function (target) {
    cc.ActionInterval.prototype.startWithTarget.call(this, target);
    this._startAngleX = target.rotationX;
    this._startAngleY = target.rotationY
}, update: function (time) {
    time = this._computeEaseTime(time);
    if (this.target) {
        this.target.rotationX = this._startAngleX + this._angleX * time;
        this.target.rotationY = this._startAngleY + this._angleY * time
    }
}, reverse: function () {
    var action =
        cc.RotateBy.create(this._duration, -this._angleX, -this._angleY);
    this._cloneDecoration(action);
    this._reverseEaseList(action);
    return action
}});
cc.RotateBy.create = function (duration, deltaAngleX, deltaAngleY) {
    var rotateBy = new cc.RotateBy;
    rotateBy.initWithDuration(duration, deltaAngleX, deltaAngleY);
    return rotateBy
};
cc.MoveBy = cc.ActionInterval.extend({_positionDelta: null, _startPosition: null, _previousPosition: null, ctor: function (duration, deltaPos, deltaY) {
    cc.ActionInterval.prototype.ctor.call(this);
    this._positionDelta = cc.p(0, 0);
    this._startPosition = cc.p(0, 0);
    this._previousPosition = cc.p(0, 0);
    deltaPos !== undefined && this.initWithDuration(duration, deltaPos, deltaY)
}, initWithDuration: function (duration, position, y) {
    if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
        if (position.x !== undefined) {
            y = position.y;
            position = position.x
        }
        this._positionDelta.x = position;
        this._positionDelta.y = y;
        return true
    }
    return false
}, clone: function () {
    var action = new cc.MoveBy;
    this._cloneDecoration(action);
    action.initWithDuration(this._duration, this._positionDelta);
    return action
}, startWithTarget: function (target) {
    cc.ActionInterval.prototype.startWithTarget.call(this, target);
    var locPosX = target.getPositionX();
    var locPosY = target.getPositionY();
    this._previousPosition.x = locPosX;
    this._previousPosition.y = locPosY;
    this._startPosition.x = locPosX;
    this._startPosition.y = locPosY
}, update: function (time) {
    time = this._computeEaseTime(time);
    if (this.target) {
        var x = this._positionDelta.x * time;
        var y = this._positionDelta.y * time;
        var locStartPosition = this._startPosition;
        if (cc.ENABLE_STACKABLE_ACTIONS) {
            var targetX = this.target.getPositionX();
            var targetY = this.target.getPositionY();
            var locPreviousPosition = this._previousPosition;
            locStartPosition.x = locStartPosition.x + targetX - locPreviousPosition.x;
            locStartPosition.y = locStartPosition.y + targetY - locPreviousPosition.y;
            x = x + locStartPosition.x;
            y = y + locStartPosition.y;
            locPreviousPosition.x = x;
            locPreviousPosition.y = y;
            this.target.setPosition(x, y)
        } else this.target.setPosition(locStartPosition.x + x, locStartPosition.y + y)
    }
}, reverse: function () {
    var action = cc.MoveBy.create(this._duration, cc.p(-this._positionDelta.x, -this._positionDelta.y));
    this._cloneDecoration(action);
    this._reverseEaseList(action);
    return action
}});
cc.MoveBy.create = function (duration, deltaPos, deltaY) {
    return new cc.MoveBy(duration, deltaPos, deltaY)
};
cc.MoveTo = cc.MoveBy.extend({_endPosition: null, ctor: function (duration, position, y) {
    cc.MoveBy.prototype.ctor.call(this);
    this._endPosition = cc.p(0, 0);
    position !== undefined && this.initWithDuration(duration, position, y)
}, initWithDuration: function (duration, position, y) {
    if (cc.MoveBy.prototype.initWithDuration.call(this, duration, position, y)) {
        if (position.x !== undefined) {
            y = position.y;
            position = position.x
        }
        this._endPosition.x = position;
        this._endPosition.y = y;
        return true
    }
    return false
}, clone: function () {
    var action = new cc.MoveTo;
    this._cloneDecoration(action);
    action.initWithDuration(this._duration, this._endPosition);
    return action
}, startWithTarget: function (target) {
    cc.MoveBy.prototype.startWithTarget.call(this, target);
    this._positionDelta.x = this._endPosition.x - target.getPositionX();
    this._positionDelta.y = this._endPosition.y - target.getPositionY()
}});
cc.MoveTo.create = function (duration, position, y) {
    return new cc.MoveTo(duration, position, y)
};
cc.SkewTo = cc.ActionInterval.extend({_skewX: 0, _skewY: 0, _startSkewX: 0, _startSkewY: 0, _endSkewX: 0, _endSkewY: 0, _deltaX: 0, _deltaY: 0, ctor: function (t, sx, sy) {
    cc.ActionInterval.prototype.ctor.call(this);
    sy !== undefined && this.initWithDuration(t, sx, sy)
}, initWithDuration: function (t, sx, sy) {
    var ret = false;
    if (cc.ActionInterval.prototype.initWithDuration.call(this, t)) {
        this._endSkewX = sx;
        this._endSkewY = sy;
        ret = true
    }
    return ret
}, clone: function () {
    var action = new cc.SkewTo;
    this._cloneDecoration(action);
    action.initWithDuration(this._duration,
        this._endSkewX, this._endSkewY);
    return action
}, startWithTarget: function (target) {
    cc.ActionInterval.prototype.startWithTarget.call(this, target);
    this._startSkewX = target.skewX % 180;
    this._deltaX = this._endSkewX - this._startSkewX;
    if (this._deltaX > 180)this._deltaX -= 360;
    if (this._deltaX < -180)this._deltaX += 360;
    this._startSkewY = target.skewY % 360;
    this._deltaY = this._endSkewY - this._startSkewY;
    if (this._deltaY > 180)this._deltaY -= 360;
    if (this._deltaY < -180)this._deltaY += 360
}, update: function (t) {
    t = this._computeEaseTime(t);
    this.target.skewX =
        this._startSkewX + this._deltaX * t;
    this.target.skewY = this._startSkewY + this._deltaY * t
}});
cc.SkewTo.create = function (t, sx, sy) {
    return new cc.SkewTo(t, sx, sy)
};
cc.SkewBy = cc.SkewTo.extend({ctor: function (t, sx, sy) {
    cc.SkewTo.prototype.ctor.call(this);
    sy !== undefined && this.initWithDuration(t, sx, sy)
}, initWithDuration: function (t, deltaSkewX, deltaSkewY) {
    var ret = false;
    if (cc.SkewTo.prototype.initWithDuration.call(this, t, deltaSkewX, deltaSkewY)) {
        this._skewX = deltaSkewX;
        this._skewY = deltaSkewY;
        ret = true
    }
    return ret
}, clone: function () {
    var action = new cc.SkewBy;
    this._cloneDecoration(action);
    action.initWithDuration(this._duration, this._skewX, this._skewY);
    return action
}, startWithTarget: function (target) {
    cc.SkewTo.prototype.startWithTarget.call(this,
        target);
    this._deltaX = this._skewX;
    this._deltaY = this._skewY;
    this._endSkewX = this._startSkewX + this._deltaX;
    this._endSkewY = this._startSkewY + this._deltaY
}, reverse: function () {
    var action = cc.SkewBy.create(this._duration, -this._skewX, -this._skewY);
    this._cloneDecoration(action);
    this._reverseEaseList(action);
    return action
}});
cc.SkewBy.create = function (t, sx, sy) {
    var skewBy = new cc.SkewBy;
    if (skewBy)skewBy.initWithDuration(t, sx, sy);
    return skewBy
};
cc.JumpBy = cc.ActionInterval.extend({_startPosition: null, _delta: null, _height: 0, _jumps: 0, _previousPosition: null, ctor: function (duration, position, y, height, jumps) {
    cc.ActionInterval.prototype.ctor.call(this);
    this._startPosition = cc.p(0, 0);
    this._previousPosition = cc.p(0, 0);
    this._delta = cc.p(0, 0);
    height !== undefined && this.initWithDuration(duration, position, y, height, jumps)
}, initWithDuration: function (duration, position, y, height, jumps) {
    if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
        if (jumps ===
            undefined) {
            jumps = height;
            height = y;
            y = position.y;
            position = position.x
        }
        this._delta.x = position;
        this._delta.y = y;
        this._height = height;
        this._jumps = jumps;
        return true
    }
    return false
}, clone: function () {
    var action = new cc.JumpBy;
    this._cloneDecoration(action);
    action.initWithDuration(this._duration, this._delta, this._height, this._jumps);
    return action
}, startWithTarget: function (target) {
    cc.ActionInterval.prototype.startWithTarget.call(this, target);
    var locPosX = target.getPositionX();
    var locPosY = target.getPositionY();
    this._previousPosition.x =
        locPosX;
    this._previousPosition.y = locPosY;
    this._startPosition.x = locPosX;
    this._startPosition.y = locPosY
}, update: function (time) {
    time = this._computeEaseTime(time);
    if (this.target) {
        var frac = time * this._jumps % 1;
        var y = this._height * 4 * frac * (1 - frac);
        y += this._delta.y * time;
        var x = this._delta.x * time;
        var locStartPosition = this._startPosition;
        if (cc.ENABLE_STACKABLE_ACTIONS) {
            var targetX = this.target.getPositionX();
            var targetY = this.target.getPositionY();
            var locPreviousPosition = this._previousPosition;
            locStartPosition.x = locStartPosition.x +
                targetX - locPreviousPosition.x;
            locStartPosition.y = locStartPosition.y + targetY - locPreviousPosition.y;
            x = x + locStartPosition.x;
            y = y + locStartPosition.y;
            locPreviousPosition.x = x;
            locPreviousPosition.y = y;
            this.target.setPosition(x, y)
        } else this.target.setPosition(locStartPosition.x + x, locStartPosition.y + y)
    }
}, reverse: function () {
    var action = cc.JumpBy.create(this._duration, cc.p(-this._delta.x, -this._delta.y), this._height, this._jumps);
    this._cloneDecoration(action);
    this._reverseEaseList(action);
    return action
}});
cc.JumpBy.create = function (duration, position, y, height, jumps) {
    return new cc.JumpBy(duration, position, y, height, jumps)
};
cc.JumpTo = cc.JumpBy.extend({_endPosition: null, ctor: function (duration, position, y, height, jumps) {
    cc.JumpBy.prototype.ctor.call(this);
    this._endPosition = cc.p(0, 0);
    height !== undefined && this.initWithDuration(duration, position, y, height, jumps)
}, initWithDuration: function (duration, position, y, height, jumps) {
    if (cc.JumpBy.prototype.initWithDuration.call(this, duration, position, y, height, jumps)) {
        if (jumps === undefined) {
            y = position.y;
            position = position.x
        }
        this._endPosition.x = position;
        this._endPosition.y = y;
        return true
    }
    return false
},
    startWithTarget: function (target) {
        cc.JumpBy.prototype.startWithTarget.call(this, target);
        this._delta.x = this._endPosition.x - this._startPosition.x;
        this._delta.y = this._endPosition.y - this._startPosition.y
    }, clone: function () {
        var action = new cc.JumpTo;
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._endPosition, this._height, this._jumps);
        return action
    }});
cc.JumpTo.create = function (duration, position, y, height, jumps) {
    return new cc.JumpTo(duration, position, y, height, jumps)
};
cc.bezierAt = function (a, b, c, d, t) {
    return Math.pow(1 - t, 3) * a + 3 * t * Math.pow(1 - t, 2) * b + 3 * Math.pow(t, 2) * (1 - t) * c + Math.pow(t, 3) * d
};
cc.BezierBy = cc.ActionInterval.extend({_config: null, _startPosition: null, _previousPosition: null, ctor: function (t, c) {
    cc.ActionInterval.prototype.ctor.call(this);
    this._config = [];
    this._startPosition = cc.p(0, 0);
    this._previousPosition = cc.p(0, 0);
    c && this.initWithDuration(t, c)
}, initWithDuration: function (t, c) {
    if (cc.ActionInterval.prototype.initWithDuration.call(this, t)) {
        this._config = c;
        return true
    }
    return false
}, clone: function () {
    var action = new cc.BezierBy;
    this._cloneDecoration(action);
    var newConfigs = [];
    for (var i =
        0; i < this._config.length; i++) {
        var selConf = this._config[i];
        newConfigs.push(cc.p(selConf.x, selConf.y))
    }
    action.initWithDuration(this._duration, newConfigs);
    return action
}, startWithTarget: function (target) {
    cc.ActionInterval.prototype.startWithTarget.call(this, target);
    var locPosX = target.getPositionX();
    var locPosY = target.getPositionY();
    this._previousPosition.x = locPosX;
    this._previousPosition.y = locPosY;
    this._startPosition.x = locPosX;
    this._startPosition.y = locPosY
}, update: function (time) {
    time = this._computeEaseTime(time);
    if (this.target) {
        var locConfig = this._config;
        var xa = 0;
        var xb = locConfig[0].x;
        var xc = locConfig[1].x;
        var xd = locConfig[2].x;
        var ya = 0;
        var yb = locConfig[0].y;
        var yc = locConfig[1].y;
        var yd = locConfig[2].y;
        var x = cc.bezierAt(xa, xb, xc, xd, time);
        var y = cc.bezierAt(ya, yb, yc, yd, time);
        var locStartPosition = this._startPosition;
        if (cc.ENABLE_STACKABLE_ACTIONS) {
            var targetX = this.target.getPositionX();
            var targetY = this.target.getPositionY();
            var locPreviousPosition = this._previousPosition;
            locStartPosition.x = locStartPosition.x +
                targetX - locPreviousPosition.x;
            locStartPosition.y = locStartPosition.y + targetY - locPreviousPosition.y;
            x = x + locStartPosition.x;
            y = y + locStartPosition.y;
            locPreviousPosition.x = x;
            locPreviousPosition.y = y;
            this.target.setPosition(x, y)
        } else this.target.setPosition(locStartPosition.x + x, locStartPosition.y + y)
    }
}, reverse: function () {
    var locConfig = this._config;
    var r = [cc.pAdd(locConfig[1], cc.pNeg(locConfig[2])), cc.pAdd(locConfig[0], cc.pNeg(locConfig[2])), cc.pNeg(locConfig[2])];
    var action = cc.BezierBy.create(this._duration,
        r);
    this._cloneDecoration(action);
    this._reverseEaseList(action);
    return action
}});
cc.BezierBy.create = function (t, c) {
    return new cc.BezierBy(t, c)
};
cc.BezierTo = cc.BezierBy.extend({_toConfig: null, ctor: function (t, c) {
    cc.BezierBy.prototype.ctor.call(this);
    this._toConfig = [];
    c && this.initWithDuration(t, c)
}, initWithDuration: function (t, c) {
    if (cc.ActionInterval.prototype.initWithDuration.call(this, t)) {
        this._toConfig = c;
        return true
    }
    return false
}, clone: function () {
    var action = new cc.BezierTo;
    this._cloneDecoration(action);
    action.initWithDuration(this._duration, this._toConfig);
    return action
}, startWithTarget: function (target) {
    cc.BezierBy.prototype.startWithTarget.call(this,
        target);
    var locStartPos = this._startPosition;
    var locToConfig = this._toConfig;
    var locConfig = this._config;
    locConfig[0] = cc.pSub(locToConfig[0], locStartPos);
    locConfig[1] = cc.pSub(locToConfig[1], locStartPos);
    locConfig[2] = cc.pSub(locToConfig[2], locStartPos)
}});
cc.BezierTo.create = function (t, c) {
    return new cc.BezierTo(t, c)
};
cc.ScaleTo = cc.ActionInterval.extend({_scaleX: 1, _scaleY: 1, _startScaleX: 1, _startScaleY: 1, _endScaleX: 0, _endScaleY: 0, _deltaX: 0, _deltaY: 0, ctor: function (duration, sx, sy) {
    cc.ActionInterval.prototype.ctor.call(this);
    sx !== undefined && this.initWithDuration(duration, sx, sy)
}, initWithDuration: function (duration, sx, sy) {
    if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
        this._endScaleX = sx;
        this._endScaleY = sy != null ? sy : sx;
        return true
    }
    return false
}, clone: function () {
    var action = new cc.ScaleTo;
    this._cloneDecoration(action);
    action.initWithDuration(this._duration, this._endScaleX, this._endScaleY);
    return action
}, startWithTarget: function (target) {
    cc.ActionInterval.prototype.startWithTarget.call(this, target);
    this._startScaleX = target.scaleX;
    this._startScaleY = target.scaleY;
    this._deltaX = this._endScaleX - this._startScaleX;
    this._deltaY = this._endScaleY - this._startScaleY
}, update: function (time) {
    time = this._computeEaseTime(time);
    if (this.target) {
        this.target.scaleX = this._startScaleX + this._deltaX * time;
        this.target.scaleY = this._startScaleY +
            this._deltaY * time
    }
}});
cc.ScaleTo.create = function (duration, sx, sy) {
    var scaleTo = new cc.ScaleTo;
    scaleTo.initWithDuration(duration, sx, sy);
    return scaleTo
};
cc.ScaleBy = cc.ScaleTo.extend({startWithTarget: function (target) {
    cc.ScaleTo.prototype.startWithTarget.call(this, target);
    this._deltaX = this._startScaleX * this._endScaleX - this._startScaleX;
    this._deltaY = this._startScaleY * this._endScaleY - this._startScaleY
}, reverse: function () {
    var action = cc.ScaleBy.create(this._duration, 1 / this._endScaleX, 1 / this._endScaleY);
    this._cloneDecoration(action);
    this._reverseEaseList(action);
    return action
}, clone: function () {
    var action = new cc.ScaleBy;
    this._cloneDecoration(action);
    action.initWithDuration(this._duration,
        this._endScaleX, this._endScaleY);
    return action
}});
cc.ScaleBy.create = function (duration, sx, sy) {
    return new cc.ScaleBy(duration, sx, sy)
};
cc.Blink = cc.ActionInterval.extend({_times: 0, _originalState: false, ctor: function (duration, blinks) {
    cc.ActionInterval.prototype.ctor.call(this);
    blinks !== undefined && this.initWithDuration(duration, blinks)
}, initWithDuration: function (duration, blinks) {
    if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
        this._times = blinks;
        return true
    }
    return false
}, clone: function () {
    var action = new cc.Blink;
    this._cloneDecoration(action);
    action.initWithDuration(this._duration, this._times);
    return action
}, update: function (time) {
    time =
        this._computeEaseTime(time);
    if (this.target && !this.isDone()) {
        var slice = 1 / this._times;
        var m = time % slice;
        this.target.visible = m > slice / 2
    }
}, startWithTarget: function (target) {
    cc.ActionInterval.prototype.startWithTarget.call(this, target);
    this._originalState = target.visible
}, stop: function () {
    this.target.visible = this._originalState;
    cc.ActionInterval.prototype.stop.call(this)
}, reverse: function () {
    var action = cc.Blink.create(this._duration, this._times);
    this._cloneDecoration(action);
    this._reverseEaseList(action);
    return action
}});
cc.Blink.create = function (duration, blinks) {
    var blink = new cc.Blink;
    blink.initWithDuration(duration, blinks);
    return blink
};
cc.FadeTo = cc.ActionInterval.extend({_toOpacity: 0, _fromOpacity: 0, ctor: function (duration, opacity) {
    cc.ActionInterval.prototype.ctor.call(this);
    opacity !== undefined && this.initWithDuration(duration, opacity)
}, initWithDuration: function (duration, opacity) {
    if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
        this._toOpacity = opacity;
        return true
    }
    return false
}, clone: function () {
    var action = new cc.FadeTo;
    this._cloneDecoration(action);
    action.initWithDuration(this._duration, this._toOpacity);
    return action
},
    update: function (time) {
        time = this._computeEaseTime(time);
        if (this.target.RGBAProtocol) {
            var fromOpacity = this._fromOpacity !== undefined ? this._fromOpacity : 255;
            this.target.opacity = fromOpacity + (this._toOpacity - fromOpacity) * time
        }
    }, startWithTarget: function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        if (this.target.RGBAProtocol)this._fromOpacity = target.opacity
    }});
cc.FadeTo.create = function (duration, opacity) {
    return new cc.FadeTo(duration, opacity)
};
cc.FadeIn = cc.FadeTo.extend({_reverseAction: null, reverse: function () {
    var action = new cc.FadeOut;
    action.initWithDuration(this._duration, 0);
    this._cloneDecoration(action);
    this._reverseEaseList(action);
    return action
}, clone: function () {
    var action = new cc.FadeIn;
    this._cloneDecoration(action);
    action.initWithDuration(this._duration, this._toOpacity);
    return action
}, startWithTarget: function (target) {
    if (this._reverseAction)this._toOpacity = this._reverseAction._fromOpacity;
    cc.FadeTo.prototype.startWithTarget.call(this,
        target)
}});
cc.FadeIn.create = function (duration) {
    return new cc.FadeIn(duration, 255)
};
cc.FadeOut = cc.FadeTo.extend({reverse: function () {
    var action = new cc.FadeIn;
    action._reverseAction = this;
    action.initWithDuration(this._duration, 255);
    this._cloneDecoration(action);
    this._reverseEaseList(action);
    return action
}, clone: function () {
    var action = new cc.FadeOut;
    this._cloneDecoration(action);
    action.initWithDuration(this._duration, this._toOpacity);
    return action
}});
cc.FadeOut.create = function (d) {
    var action = new cc.FadeOut;
    action.initWithDuration(d, 0);
    return action
};
cc.TintTo = cc.ActionInterval.extend({_to: null, _from: null, ctor: function (duration, red, green, blue) {
    cc.ActionInterval.prototype.ctor.call(this);
    this._to = cc.color(0, 0, 0);
    this._from = cc.color(0, 0, 0);
    blue !== undefined && this.initWithDuration(duration, red, green, blue)
}, initWithDuration: function (duration, red, green, blue) {
    if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
        this._to = cc.color(red, green, blue);
        return true
    }
    return false
}, clone: function () {
    var action = new cc.TintTo;
    this._cloneDecoration(action);
    var locTo = this._to;
    action.initWithDuration(this._duration, locTo.r, locTo.g, locTo.b);
    return action
}, startWithTarget: function (target) {
    cc.ActionInterval.prototype.startWithTarget.call(this, target);
    if (this.target.RGBAProtocol)this._from = this.target.color
}, update: function (time) {
    time = this._computeEaseTime(time);
    var locFrom = this._from, locTo = this._to;
    if (locFrom && this.target.RGBAProtocol)this.target.color = cc.color(locFrom.r + (locTo.r - locFrom.r) * time, locFrom.g + (locTo.g - locFrom.g) * time, locFrom.b + (locTo.b - locFrom.b) *
        time)
}});
cc.TintTo.create = function (duration, red, green, blue) {
    return new cc.TintTo(duration, red, green, blue)
};
cc.TintBy = cc.ActionInterval.extend({_deltaR: 0, _deltaG: 0, _deltaB: 0, _fromR: 0, _fromG: 0, _fromB: 0, ctor: function (duration, deltaRed, deltaGreen, deltaBlue) {
    cc.ActionInterval.prototype.ctor.call(this);
    deltaBlue !== undefined && this.initWithDuration(duration, deltaRed, deltaGreen, deltaBlue)
}, initWithDuration: function (duration, deltaRed, deltaGreen, deltaBlue) {
    if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
        this._deltaR = deltaRed;
        this._deltaG = deltaGreen;
        this._deltaB = deltaBlue;
        return true
    }
    return false
},
    clone: function () {
        var action = new cc.TintBy;
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._deltaR, this._deltaG, this._deltaB);
        return action
    }, startWithTarget: function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        if (target.RGBAProtocol) {
            var color = target.color;
            this._fromR = color.r;
            this._fromG = color.g;
            this._fromB = color.b
        }
    }, update: function (time) {
        time = this._computeEaseTime(time);
        if (this.target.RGBAProtocol)this.target.color = cc.color(this._fromR + this._deltaR *
            time, this._fromG + this._deltaG * time, this._fromB + this._deltaB * time)
    }, reverse: function () {
        var action = cc.TintBy.create(this._duration, -this._deltaR, -this._deltaG, -this._deltaB);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action
    }});
cc.TintBy.create = function (duration, deltaRed, deltaGreen, deltaBlue) {
    return new cc.TintBy(duration, deltaRed, deltaGreen, deltaBlue)
};
cc.DelayTime = cc.ActionInterval.extend({update: function (time) {
}, reverse: function () {
    var action = cc.DelayTime.create(this._duration);
    this._cloneDecoration(action);
    this._reverseEaseList(action);
    return action
}, clone: function () {
    var action = new cc.DelayTime;
    this._cloneDecoration(action);
    action.initWithDuration(this._duration);
    return action
}});
cc.DelayTime.create = function (d) {
    return new cc.DelayTime(d)
};
cc.ReverseTime = cc.ActionInterval.extend({_other: null, ctor: function (action) {
    cc.ActionInterval.prototype.ctor.call(this);
    this._other = null;
    action && this.initWithAction(action)
}, initWithAction: function (action) {
    if (!action)throw"cc.ReverseTime.initWithAction(): action must be non null";
    if (action == this._other)throw"cc.ReverseTime.initWithAction(): the action was already passed in.";
    if (cc.ActionInterval.prototype.initWithDuration.call(this, action._duration)) {
        this._other = action;
        return true
    }
    return false
}, clone: function () {
    var action =
        new cc.ReverseTime;
    this._cloneDecoration(action);
    action.initWithAction(this._other.clone());
    return action
}, startWithTarget: function (target) {
    cc.ActionInterval.prototype.startWithTarget.call(this, target);
    this._other.startWithTarget(target)
}, update: function (time) {
    time = this._computeEaseTime(time);
    if (this._other)this._other.update(1 - time)
}, reverse: function () {
    return this._other.clone()
}, stop: function () {
    this._other.stop();
    cc.Action.prototype.stop.call(this)
}});
cc.ReverseTime.create = function (action) {
    return new cc.ReverseTime(action)
};
cc.Animate = cc.ActionInterval.extend({_animation: null, _nextFrame: 0, _origFrame: null, _executedLoops: 0, _splitTimes: null, ctor: function (animation) {
    cc.ActionInterval.prototype.ctor.call(this);
    this._splitTimes = [];
    animation && this.initWithAnimation(animation)
}, getAnimation: function () {
    return this._animation
}, setAnimation: function (animation) {
    this._animation = animation
}, initWithAnimation: function (animation) {
    if (!animation)throw"cc.Animate.initWithAnimation(): animation must be non-NULL";
    var singleDuration = animation.getDuration();
    if (this.initWithDuration(singleDuration * animation.getLoops())) {
        this._nextFrame = 0;
        this.setAnimation(animation);
        this._origFrame = null;
        this._executedLoops = 0;
        var locTimes = this._splitTimes;
        locTimes.length = 0;
        var accumUnitsOfTime = 0;
        var newUnitOfTimeValue = singleDuration / animation.getTotalDelayUnits();
        var frames = animation.getFrames();
        cc.arrayVerifyType(frames, cc.AnimationFrame);
        for (var i = 0; i < frames.length; i++) {
            var frame = frames[i];
            var value = accumUnitsOfTime * newUnitOfTimeValue / singleDuration;
            accumUnitsOfTime +=
                frame.getDelayUnits();
            locTimes.push(value)
        }
        return true
    }
    return false
}, clone: function () {
    var action = new cc.Animate;
    this._cloneDecoration(action);
    action.initWithAnimation(this._animation.clone());
    return action
}, startWithTarget: function (target) {
    cc.ActionInterval.prototype.startWithTarget.call(this, target);
    if (this._animation.getRestoreOriginalFrame())this._origFrame = target.displayFrame();
    this._nextFrame = 0;
    this._executedLoops = 0
}, update: function (time) {
    time = this._computeEaseTime(time);
    if (time < 1) {
        time *= this._animation.getLoops();
        var loopNumber = 0 | time;
        if (loopNumber > this._executedLoops) {
            this._nextFrame = 0;
            this._executedLoops++
        }
        time = time % 1
    }
    var frames = this._animation.getFrames();
    var numberOfFrames = frames.length, locSplitTimes = this._splitTimes;
    for (var i = this._nextFrame; i < numberOfFrames; i++)if (locSplitTimes[i] <= time) {
        this.target.setSpriteFrame(frames[i].getSpriteFrame());
        this._nextFrame = i + 1
    } else break
}, reverse: function () {
    var locAnimation = this._animation;
    var oldArray = locAnimation.getFrames();
    var newArray = [];
    cc.arrayVerifyType(oldArray,
        cc.AnimationFrame);
    if (oldArray.length > 0)for (var i = oldArray.length - 1; i >= 0; i--) {
        var element = oldArray[i];
        if (!element)break;
        newArray.push(element.clone())
    }
    var newAnim = cc.Animation.create(newArray, locAnimation.getDelayPerUnit(), locAnimation.getLoops());
    newAnim.setRestoreOriginalFrame(locAnimation.getRestoreOriginalFrame());
    var action = cc.Animate.create(newAnim);
    this._cloneDecoration(action);
    this._reverseEaseList(action);
    return action
}, stop: function () {
    if (this._animation.getRestoreOriginalFrame() && this.target)this.target.setSpriteFrame(this._origFrame);
    cc.Action.prototype.stop.call(this)
}});
cc.Animate.create = function (animation) {
    return new cc.Animate(animation)
};
cc.TargetedAction = cc.ActionInterval.extend({_action: null, _forcedTarget: null, ctor: function (target, action) {
    cc.ActionInterval.prototype.ctor.call(this);
    action && this.initWithTarget(target, action)
}, initWithTarget: function (target, action) {
    if (this.initWithDuration(action._duration)) {
        this._forcedTarget = target;
        this._action = action;
        return true
    }
    return false
}, clone: function () {
    var action = new cc.TargetedAction;
    this._cloneDecoration(action);
    action.initWithTarget(this._forcedTarget, this._action.clone());
    return action
},
    startWithTarget: function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._action.startWithTarget(this._forcedTarget)
    }, stop: function () {
        this._action.stop()
    }, update: function (time) {
        time = this._computeEaseTime(time);
        this._action.update(time)
    }, getForcedTarget: function () {
        return this._forcedTarget
    }, setForcedTarget: function (forcedTarget) {
        if (this._forcedTarget != forcedTarget)this._forcedTarget = forcedTarget
    }});
cc.TargetedAction.create = function (target, action) {
    return new cc.TargetedAction(target, action)
};
cc.ActionInstant = cc.FiniteTimeAction.extend({isDone: function () {
    return true
}, step: function (dt) {
    this.update(1)
}, update: function (time) {
}, reverse: function () {
    return this.clone()
}, clone: function () {
    return new cc.ActionInstant
}});
cc.Show = cc.ActionInstant.extend({update: function (time) {
    this.target.visible = true
}, reverse: function () {
    return cc.Hide.create()
}, clone: function () {
    return new cc.Show
}});
cc.Show.create = function () {
    return new cc.Show
};
cc.Hide = cc.ActionInstant.extend({update: function (time) {
    this.target.visible = false
}, reverse: function () {
    return cc.Show.create()
}, clone: function () {
    return new cc.Hide
}});
cc.Hide.create = function () {
    return new cc.Hide
};
cc.ToggleVisibility = cc.ActionInstant.extend({update: function (time) {
    this.target.visible = !this.target.visible
}, reverse: function () {
    return new cc.ToggleVisibility
}, clone: function () {
    return new cc.ToggleVisibility
}});
cc.ToggleVisibility.create = function () {
    return new cc.ToggleVisibility
};
cc.RemoveSelf = cc.ActionInstant.extend({_isNeedCleanUp: true, ctor: function (isNeedCleanUp) {
    cc.FiniteTimeAction.prototype.ctor.call(this);
    isNeedCleanUp !== undefined && this.init(isNeedCleanUp)
}, update: function (time) {
    this.target.removeFromParent(this._isNeedCleanUp)
}, init: function (isNeedCleanUp) {
    this._isNeedCleanUp = isNeedCleanUp;
    return true
}, reverse: function () {
    return new cc.RemoveSelf(this._isNeedCleanUp)
}, clone: function () {
    return new cc.RemoveSelf(this._isNeedCleanUp)
}});
cc.RemoveSelf.create = function (isNeedCleanUp) {
    return new cc.RemoveSelf(isNeedCleanUp)
};
cc.FlipX = cc.ActionInstant.extend({_flippedX: false, ctor: function (flip) {
    cc.FiniteTimeAction.prototype.ctor.call(this);
    this._flippedX = false;
    flip !== undefined && this.initWithFlipX(flip)
}, initWithFlipX: function (flip) {
    this._flippedX = flip;
    return true
}, update: function (time) {
    this.target.flippedX = this._flippedX
}, reverse: function () {
    return cc.FlipX.create(!this._flippedX)
}, clone: function () {
    var action = new cc.FlipX;
    action.initWithFlipX(this._flippedX);
    return action
}});
cc.FlipX.create = function (flip) {
    return new cc.FlipX(flip)
};
cc.FlipY = cc.ActionInstant.extend({_flippedY: false, ctor: function (flip) {
    cc.FiniteTimeAction.prototype.ctor.call(this);
    this._flippedY = false;
    flip !== undefined && this.initWithFlipY(flip)
}, initWithFlipY: function (flip) {
    this._flippedY = flip;
    return true
}, update: function (time) {
    this.target.flippedY = this._flippedY
}, reverse: function () {
    return cc.FlipY.create(!this._flippedY)
}, clone: function () {
    var action = new cc.FlipY;
    action.initWithFlipY(this._flippedY);
    return action
}});
cc.FlipY.create = function (flip) {
    return new cc.FlipY(flip)
};
cc.Place = cc.ActionInstant.extend({_x: 0, _y: 0, ctor: function (pos, y) {
    cc.FiniteTimeAction.prototype.ctor.call(this);
    this._x = 0;
    this._y = 0;
    if (pos !== undefined) {
        if (pos.x !== undefined) {
            y = pos.y;
            pos = pos.x
        }
        this.initWithPosition(pos, y)
    }
}, initWithPosition: function (x, y) {
    this._x = x;
    this._y = y;
    return true
}, update: function (time) {
    this.target.setPosition(this._x, this._y)
}, clone: function () {
    var action = new cc.Place;
    action.initWithPosition(this._x, this._y);
    return action
}});
cc.Place.create = function (pos, y) {
    return new cc.Place(pos, y)
};
cc.CallFunc = cc.ActionInstant.extend({_selectorTarget: null, _callFunc: null, _function: null, _data: null, ctor: function (selector, selectorTarget, data) {
    cc.FiniteTimeAction.prototype.ctor.call(this);
    if (selector !== undefined)if (selectorTarget === undefined)this.initWithFunction(selector); else this.initWithFunction(selector, selectorTarget, data)
}, initWithFunction: function (selector, selectorTarget, data) {
    if (selectorTarget) {
        this._data = data;
        this._callFunc = selector;
        this._selectorTarget = selectorTarget
    } else if (selector)this._function =
        selector;
    return true
}, execute: function () {
    if (this._callFunc != null)this._callFunc.call(this._selectorTarget, this.target, this._data); else if (this._function)this._function.call(null, this.target)
}, update: function (time) {
    this.execute()
}, getTargetCallback: function () {
    return this._selectorTarget
}, setTargetCallback: function (sel) {
    if (sel != this._selectorTarget) {
        if (this._selectorTarget)this._selectorTarget = null;
        this._selectorTarget = sel
    }
}, clone: function () {
    var action = new cc.CallFunc;
    if (this._selectorTarget)action.initWithFunction(this._callFunc,
        this._selectorTarget, this._data); else if (this._function)action.initWithFunction(this._function);
    return action
}});
cc.CallFunc.create = function (selector, selectorTarget, data) {
    return new cc.CallFunc(selector, selectorTarget, data)
};
cc.ActionCamera = cc.ActionInterval.extend({_centerXOrig: 0, _centerYOrig: 0, _centerZOrig: 0, _eyeXOrig: 0, _eyeYOrig: 0, _eyeZOrig: 0, _upXOrig: 0, _upYOrig: 0, _upZOrig: 0, ctor: function () {
    var _t = this;
    cc.ActionInterval.prototype.ctor.call(_t);
    _t._centerXOrig = 0;
    _t._centerYOrig = 0;
    _t._centerZOrig = 0;
    _t._eyeXOrig = 0;
    _t._eyeYOrig = 0;
    _t._eyeZOrig = 0;
    _t._upXOrig = 0;
    _t._upYOrig = 0;
    _t._upZOrig = 0
}, startWithTarget: function (target) {
    var _t = this;
    cc.ActionInterval.prototype.startWithTarget.call(_t, target);
    var camera = target.getCamera();
    var centerXYZ = camera.getCenter();
    _t._centerXOrig = centerXYZ.x;
    _t._centerYOrig = centerXYZ.y;
    _t._centerZOrig = centerXYZ.z;
    var eyeXYZ = camera.getEye();
    _t._eyeXOrig = eyeXYZ.x;
    _t._eyeYOrig = eyeXYZ.y;
    _t._eyeZOrig = eyeXYZ.z;
    var upXYZ = camera.getUp();
    _t._upXOrig = upXYZ.x;
    _t._upYOrig = upXYZ.y;
    _t._upZOrig = upXYZ.z
}, clone: function () {
    return new cc.ActionCamera
}, reverse: function () {
    return cc.ReverseTime.create(this)
}});
cc.OrbitCamera = cc.ActionCamera.extend({_radius: 0, _deltaRadius: 0, _angleZ: 0, _deltaAngleZ: 0, _angleX: 0, _deltaAngleX: 0, _radZ: 0, _radDeltaZ: 0, _radX: 0, _radDeltaX: 0, ctor: function (t, radius, deltaRadius, angleZ, deltaAngleZ, angleX, deltaAngleX) {
    cc.ActionCamera.prototype.ctor.call(this);
    deltaAngleX !== undefined && this.initWithDuration(t, radius, deltaRadius, angleZ, deltaAngleZ, angleX, deltaAngleX)
}, initWithDuration: function (t, radius, deltaRadius, angleZ, deltaAngleZ, angleX, deltaAngleX) {
    if (cc.ActionInterval.prototype.initWithDuration.call(this,
        t)) {
        var _t = this;
        _t._radius = radius;
        _t._deltaRadius = deltaRadius;
        _t._angleZ = angleZ;
        _t._deltaAngleZ = deltaAngleZ;
        _t._angleX = angleX;
        _t._deltaAngleX = deltaAngleX;
        _t._radDeltaZ = cc.degreesToRadians(deltaAngleZ);
        _t._radDeltaX = cc.degreesToRadians(deltaAngleX);
        return true
    }
    return false
}, sphericalRadius: function () {
    var newRadius, zenith, azimuth;
    var camera = this.target.getCamera();
    var eyeXYZ = camera.getEye();
    var centerXYZ = camera.getCenter();
    var x = eyeXYZ.x - centerXYZ.x, y = eyeXYZ.y - centerXYZ.y, z = eyeXYZ.z - centerXYZ.z;
    var r =
        Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2) + Math.pow(z, 2));
    var s = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
    if (s === 0)s = cc.FLT_EPSILON;
    if (r === 0)r = cc.FLT_EPSILON;
    zenith = Math.acos(z / r);
    if (x < 0)azimuth = Math.PI - Math.asin(y / s); else azimuth = Math.asin(y / s);
    newRadius = r / cc.Camera.getZEye();
    return{newRadius: newRadius, zenith: zenith, azimuth: azimuth}
}, startWithTarget: function (target) {
    var _t = this;
    cc.ActionInterval.prototype.startWithTarget.call(_t, target);
    var retValue = _t.sphericalRadius();
    if (isNaN(_t._radius))_t._radius = retValue.newRadius;
    if (isNaN(_t._angleZ))_t._angleZ = cc.radiansToDegrees(retValue.zenith);
    if (isNaN(_t._angleX))_t._angleX = cc.radiansToDegrees(retValue.azimuth);
    _t._radZ = cc.degreesToRadians(_t._angleZ);
    _t._radX = cc.degreesToRadians(_t._angleX)
}, clone: function () {
    var a = new cc.OrbitCamera, _t = this;
    a.initWithDuration(_t._duration, _t._radius, _t._deltaRadius, _t._angleZ, _t._deltaAngleZ, _t._angleX, _t._deltaAngleX);
    return a
}, update: function (dt) {
    dt = this._computeEaseTime(dt);
    var r = (this._radius + this._deltaRadius * dt) * cc.Camera.getZEye();
    var za = this._radZ + this._radDeltaZ * dt;
    var xa = this._radX + this._radDeltaX * dt;
    var i = Math.sin(za) * Math.cos(xa) * r + this._centerXOrig;
    var j = Math.sin(za) * Math.sin(xa) * r + this._centerYOrig;
    var k = Math.cos(za) * r + this._centerZOrig;
    this.target.getCamera().setEye(i, j, k)
}});
cc.OrbitCamera.create = function (t, radius, deltaRadius, angleZ, deltaAngleZ, angleX, deltaAngleX) {
    return new cc.OrbitCamera(t, radius, deltaRadius, angleZ, deltaAngleZ, angleX, deltaAngleX)
};
cc.ActionEase = cc.ActionInterval.extend({_inner: null, ctor: function (action) {
    cc.ActionInterval.prototype.ctor.call(this);
    action && this.initWithAction(action)
}, initWithAction: function (action) {
    if (!action)throw"cc.ActionEase.initWithAction(): action must be non nil";
    if (this.initWithDuration(action.getDuration())) {
        this._inner = action;
        return true
    }
    return false
}, clone: function () {
    var action = new cc.ActionEase;
    action.initWithAction(this._inner.clone());
    return action
}, startWithTarget: function (target) {
    cc.ActionInterval.prototype.startWithTarget.call(this,
        target);
    this._inner.startWithTarget(this.target)
}, stop: function () {
    this._inner.stop();
    cc.ActionInterval.prototype.stop.call(this)
}, update: function (time1) {
    this._inner.update(time1)
}, reverse: function () {
    return cc.ActionEase.create(this._inner.reverse())
}, getInnerAction: function () {
    return this._inner
}});
cc.ActionEase.create = function (action) {
    return new cc.ActionEase(action)
};
cc.EaseRateAction = cc.ActionEase.extend({_rate: 0, ctor: function (action, rate) {
    cc.ActionEase.prototype.ctor.call(this);
    rate !== undefined && this.initWithAction(action, rate)
}, setRate: function (rate) {
    this._rate = rate
}, getRate: function () {
    return this._rate
}, initWithAction: function (action, rate) {
    if (cc.ActionEase.prototype.initWithAction.call(this, action)) {
        this._rate = rate;
        return true
    }
    return false
}, clone: function () {
    var action = new cc.EaseRateAction;
    action.initWithAction(this._inner.clone(), this._rate);
    return action
},
    reverse: function () {
        return cc.EaseRateAction.create(this._inner.reverse(), 1 / this._rate)
    }});
cc.EaseRateAction.create = function (action, rate) {
    return new cc.EaseRateAction(action, rate)
};
cc.EaseIn = cc.EaseRateAction.extend({update: function (time1) {
    this._inner.update(Math.pow(time1, this._rate))
}, reverse: function () {
    return cc.EaseIn.create(this._inner.reverse(), 1 / this._rate)
}, clone: function () {
    var action = new cc.EaseIn;
    action.initWithAction(this._inner.clone(), this._rate);
    return action
}});
cc.EaseIn.create = function (action, rate) {
    return new cc.EaseIn(action, rate)
};
cc.easeIn = function (rate) {
    return{_rate: rate, easing: function (dt) {
        return Math.pow(dt, this._rate)
    }, reverse: function () {
        return cc.easeIn(1 / this._rate)
    }}
};
cc.EaseOut = cc.EaseRateAction.extend({update: function (time1) {
    this._inner.update(Math.pow(time1, 1 / this._rate))
}, reverse: function () {
    return cc.EaseOut.create(this._inner.reverse(), 1 / this._rate)
}, clone: function () {
    var action = new cc.EaseOut;
    action.initWithAction(this._inner.clone(), this._rate);
    return action
}});
cc.EaseOut.create = function (action, rate) {
    return new cc.EaseOut(action, rate)
};
cc.easeOut = function (rate) {
    return{_rate: rate, easing: function (dt) {
        return Math.pow(dt, 1 / this._rate)
    }, reverse: function () {
        return cc.easeOut(1 / this._rate)
    }}
};
cc.EaseInOut = cc.EaseRateAction.extend({update: function (time1) {
    time1 *= 2;
    if (time1 < 1)this._inner.update(0.5 * Math.pow(time1, this._rate)); else this._inner.update(1 - 0.5 * Math.pow(2 - time1, this._rate))
}, clone: function () {
    var action = new cc.EaseInOut;
    action.initWithAction(this._inner.clone(), this._rate);
    return action
}, reverse: function () {
    return cc.EaseInOut.create(this._inner.reverse(), this._rate)
}});
cc.EaseInOut.create = function (action, rate) {
    return new cc.EaseInOut(action, rate)
};
cc.easeInOut = function (rate) {
    return{_rate: rate, easing: function (dt) {
        dt *= 2;
        if (dt < 1)return 0.5 * Math.pow(dt, this._rate); else return 1 - 0.5 * Math.pow(2 - dt, this._rate)
    }, reverse: function () {
        return cc.easeInOut(this._rate)
    }}
};
cc.EaseExponentialIn = cc.ActionEase.extend({update: function (time1) {
    this._inner.update(time1 === 0 ? 0 : Math.pow(2, 10 * (time1 - 1)))
}, reverse: function () {
    return cc.EaseExponentialOut.create(this._inner.reverse())
}, clone: function () {
    var action = new cc.EaseExponentialIn;
    action.initWithAction(this._inner.clone());
    return action
}});
cc.EaseExponentialIn.create = function (action) {
    return new cc.EaseExponentialIn(action)
};
cc._easeExponentialInObj = {easing: function (dt) {
    return dt === 0 ? 0 : Math.pow(2, 10 * (dt - 1))
}, reverse: function () {
    return cc._easeExponentialOutObj
}};
cc.easeExponentialIn = function () {
    return cc._easeExponentialInObj
};
cc.EaseExponentialOut = cc.ActionEase.extend({update: function (time1) {
    this._inner.update(time1 == 1 ? 1 : -Math.pow(2, -10 * time1) + 1)
}, reverse: function () {
    return cc.EaseExponentialIn.create(this._inner.reverse())
}, clone: function () {
    var action = new cc.EaseExponentialOut;
    action.initWithAction(this._inner.clone());
    return action
}});
cc.EaseExponentialOut.create = function (action) {
    return new cc.EaseExponentialOut(action)
};
cc._easeExponentialOutObj = {easing: function (dt) {
    return dt == 1 ? 1 : -Math.pow(2, -10 * dt) + 1
}, reverse: function () {
    return cc._easeExponentialInObj
}};
cc.easeExponentialOut = function () {
    return cc._easeExponentialOutObj
};
cc.EaseExponentialInOut = cc.ActionEase.extend({update: function (time) {
    if (time != 1 && time !== 0) {
        time *= 2;
        if (time < 1)time = 0.5 * Math.pow(2, 10 * (time - 1)); else time = 0.5 * (-Math.pow(2, -10 * (time - 1)) + 2)
    }
    this._inner.update(time)
}, reverse: function () {
    return cc.EaseExponentialInOut.create(this._inner.reverse())
}, clone: function () {
    var action = new cc.EaseExponentialInOut;
    action.initWithAction(this._inner.clone());
    return action
}});
cc.EaseExponentialInOut.create = function (action) {
    return new cc.EaseExponentialInOut(action)
};
cc._easeExponentialInOutObj = {easing: function (dt) {
    if (dt !== 1 && dt !== 0) {
        dt *= 2;
        if (dt < 1)return 0.5 * Math.pow(2, 10 * (dt - 1)); else return 0.5 * (-Math.pow(2, -10 * (dt - 1)) + 2)
    }
    return dt
}, reverse: function () {
    return cc._easeExponentialInOutObj
}};
cc.easeExponentialInOut = function () {
    return cc._easeExponentialInOutObj
};
cc.EaseSineIn = cc.ActionEase.extend({update: function (time1) {
    time1 = time1 === 0 || time1 === 1 ? time1 : -1 * Math.cos(time1 * Math.PI / 2) + 1;
    this._inner.update(time1)
}, reverse: function () {
    return cc.EaseSineOut.create(this._inner.reverse())
}, clone: function () {
    var action = new cc.EaseSineIn;
    action.initWithAction(this._inner.clone());
    return action
}});
cc.EaseSineIn.create = function (action) {
    return new cc.EaseSineIn(action)
};
cc._easeSineInObj = {easing: function (dt) {
    return dt === 0 || dt === 1 ? dt : -1 * Math.cos(dt * Math.PI / 2) + 1
}, reverse: function () {
    return cc._easeSineOutObj
}};
cc.easeSineIn = function () {
    return cc._easeSineInObj
};
cc.EaseSineOut = cc.ActionEase.extend({update: function (time1) {
    time1 = time1 === 0 || time1 === 1 ? time1 : Math.sin(time1 * Math.PI / 2);
    this._inner.update(time1)
}, reverse: function () {
    return cc.EaseSineIn.create(this._inner.reverse())
}, clone: function () {
    var action = new cc.EaseSineOut;
    action.initWithAction(this._inner.clone());
    return action
}});
cc.EaseSineOut.create = function (action) {
    return new cc.EaseSineOut(action)
};
cc._easeSineOutObj = {easing: function (dt) {
    return dt === 0 || dt == 1 ? dt : Math.sin(dt * Math.PI / 2)
}, reverse: function () {
    return cc._easeSineInObj
}};
cc.easeSineOut = function () {
    return cc._easeSineOutObj
};
cc.EaseSineInOut = cc.ActionEase.extend({update: function (time1) {
    time1 = time1 === 0 || time1 === 1 ? time1 : -0.5 * (Math.cos(Math.PI * time1) - 1);
    this._inner.update(time1)
}, clone: function () {
    var action = new cc.EaseSineInOut;
    action.initWithAction(this._inner.clone());
    return action
}, reverse: function () {
    return cc.EaseSineInOut.create(this._inner.reverse())
}});
cc.EaseSineInOut.create = function (action) {
    return new cc.EaseSineInOut(action)
};
cc._easeSineInOutObj = {easing: function (dt) {
    return dt === 0 || dt === 1 ? dt : -0.5 * (Math.cos(Math.PI * dt) - 1)
}, reverse: function () {
    return cc._easeSineInOutObj
}};
cc.easeSineInOut = function () {
    return cc._easeSineInOutObj
};
cc.EaseElastic = cc.ActionEase.extend({_period: 0.3, ctor: function (action, period) {
    cc.ActionEase.prototype.ctor.call(this);
    action && this.initWithAction(action, period)
}, getPeriod: function () {
    return this._period
}, setPeriod: function (period) {
    this._period = period
}, initWithAction: function (action, period) {
    cc.ActionEase.prototype.initWithAction.call(this, action);
    this._period = period == null ? 0.3 : period;
    return true
}, reverse: function () {
    cc.log("cc.EaseElastic.reverse(): it should be overridden in subclass.");
    return null
},
    clone: function () {
        var action = new cc.EaseElastic;
        action.initWithAction(this._inner.clone(), this._period);
        return action
    }});
cc.EaseElastic.create = function (action, period) {
    return new cc.EaseElastic(action, period)
};
cc.EaseElasticIn = cc.EaseElastic.extend({update: function (time1) {
    var newT = 0;
    if (time1 === 0 || time1 === 1)newT = time1; else {
        var s = this._period / 4;
        time1 = time1 - 1;
        newT = -Math.pow(2, 10 * time1) * Math.sin((time1 - s) * Math.PI * 2 / this._period)
    }
    this._inner.update(newT)
}, reverse: function () {
    return cc.EaseElasticOut.create(this._inner.reverse(), this._period)
}, clone: function () {
    var action = new cc.EaseElasticIn;
    action.initWithAction(this._inner.clone(), this._period);
    return action
}});
cc.EaseElasticIn.create = function (action, period) {
    return new cc.EaseElasticIn(action, period)
};
cc._easeElasticInObj = {easing: function (dt) {
    if (dt === 0 || dt === 1)return dt;
    dt = dt - 1;
    return-Math.pow(2, 10 * dt) * Math.sin((dt - 0.3 / 4) * Math.PI * 2 / 0.3)
}, reverse: function () {
    return cc._easeElasticOutObj
}};
cc.easeElasticIn = function (period) {
    if (period && period !== 0.3)return{_period: period, easing: function (dt) {
        if (dt === 0 || dt === 1)return dt;
        dt = dt - 1;
        return-Math.pow(2, 10 * dt) * Math.sin((dt - this._period / 4) * Math.PI * 2 / this._period)
    }, reverse: function () {
        return cc.easeElasticOut(this._period)
    }};
    return cc._easeElasticInObj
};
cc.EaseElasticOut = cc.EaseElastic.extend({update: function (time1) {
    var newT = 0;
    if (time1 === 0 || time1 == 1)newT = time1; else {
        var s = this._period / 4;
        newT = Math.pow(2, -10 * time1) * Math.sin((time1 - s) * Math.PI * 2 / this._period) + 1
    }
    this._inner.update(newT)
}, reverse: function () {
    return cc.EaseElasticIn.create(this._inner.reverse(), this._period)
}, clone: function () {
    var action = new cc.EaseElasticOut;
    action.initWithAction(this._inner.clone(), this._period);
    return action
}});
cc.EaseElasticOut.create = function (action, period) {
    return new cc.EaseElasticOut(action, period)
};
cc._easeElasticOutObj = {easing: function (dt) {
    return dt === 0 || dt === 1 ? dt : Math.pow(2, -10 * dt) * Math.sin((dt - 0.3 / 4) * Math.PI * 2 / 0.3) + 1
}, reverse: function () {
    return cc._easeElasticInObj
}};
cc.easeElasticOut = function (period) {
    if (period && period !== 0.3)return{_period: period, easing: function (dt) {
        return dt === 0 || dt === 1 ? dt : Math.pow(2, -10 * dt) * Math.sin((dt - this._period / 4) * Math.PI * 2 / this._period) + 1
    }, reverse: function () {
        return cc.easeElasticIn(this._period)
    }};
    return cc._easeElasticOutObj
};
cc.EaseElasticInOut = cc.EaseElastic.extend({update: function (time1) {
    var newT = 0;
    var locPeriod = this._period;
    if (time1 === 0 || time1 == 1)newT = time1; else {
        time1 = time1 * 2;
        if (!locPeriod)locPeriod = this._period = 0.3 * 1.5;
        var s = locPeriod / 4;
        time1 = time1 - 1;
        if (time1 < 0)newT = -0.5 * Math.pow(2, 10 * time1) * Math.sin((time1 - s) * Math.PI * 2 / locPeriod); else newT = Math.pow(2, -10 * time1) * Math.sin((time1 - s) * Math.PI * 2 / locPeriod) * 0.5 + 1
    }
    this._inner.update(newT)
}, reverse: function () {
    return cc.EaseElasticInOut.create(this._inner.reverse(), this._period)
},
    clone: function () {
        var action = new cc.EaseElasticInOut;
        action.initWithAction(this._inner.clone(), this._period);
        return action
    }});
cc.EaseElasticInOut.create = function (action, period) {
    return new cc.EaseElasticInOut(action, period)
};
cc.easeElasticInOut = function (period) {
    period = period || 0.3;
    return{_period: period, easing: function (dt) {
        var newT = 0;
        var locPeriod = this._period;
        if (dt === 0 || dt === 1)newT = dt; else {
            dt = dt * 2;
            if (!locPeriod)locPeriod = this._period = 0.3 * 1.5;
            var s = locPeriod / 4;
            dt = dt - 1;
            if (dt < 0)newT = -0.5 * Math.pow(2, 10 * dt) * Math.sin((dt - s) * Math.PI * 2 / locPeriod); else newT = Math.pow(2, -10 * dt) * Math.sin((dt - s) * Math.PI * 2 / locPeriod) * 0.5 + 1
        }
        return newT
    }, reverse: function () {
        return cc.easeElasticInOut(this._period)
    }}
};
cc.EaseBounce = cc.ActionEase.extend({bounceTime: function (time1) {
    if (time1 < 1 / 2.75)return 7.5625 * time1 * time1; else if (time1 < 2 / 2.75) {
        time1 -= 1.5 / 2.75;
        return 7.5625 * time1 * time1 + 0.75
    } else if (time1 < 2.5 / 2.75) {
        time1 -= 2.25 / 2.75;
        return 7.5625 * time1 * time1 + 0.9375
    }
    time1 -= 2.625 / 2.75;
    return 7.5625 * time1 * time1 + 0.984375
}, clone: function () {
    var action = new cc.EaseBounce;
    action.initWithAction(this._inner.clone());
    return action
}, reverse: function () {
    return cc.EaseBounce.create(this._inner.reverse())
}});
cc.EaseBounce.create = function (action) {
    return new cc.EaseBounce(action)
};
cc.EaseBounceIn = cc.EaseBounce.extend({update: function (time1) {
    var newT = 1 - this.bounceTime(1 - time1);
    this._inner.update(newT)
}, reverse: function () {
    return cc.EaseBounceOut.create(this._inner.reverse())
}, clone: function () {
    var action = new cc.EaseBounceIn;
    action.initWithAction(this._inner.clone());
    return action
}});
cc.EaseBounceIn.create = function (action) {
    return new cc.EaseBounceIn(action)
};
cc._bounceTime = function (time1) {
    if (time1 < 1 / 2.75)return 7.5625 * time1 * time1; else if (time1 < 2 / 2.75) {
        time1 -= 1.5 / 2.75;
        return 7.5625 * time1 * time1 + 0.75
    } else if (time1 < 2.5 / 2.75) {
        time1 -= 2.25 / 2.75;
        return 7.5625 * time1 * time1 + 0.9375
    }
    time1 -= 2.625 / 2.75;
    return 7.5625 * time1 * time1 + 0.984375
};
cc._easeBounceInObj = {easing: function (dt) {
    return 1 - cc._bounceTime(1 - dt)
}, reverse: function () {
    return cc._easeBounceOutObj
}};
cc.easeBounceIn = function () {
    return cc._easeBounceInObj
};
cc.EaseBounceOut = cc.EaseBounce.extend({update: function (time1) {
    var newT = this.bounceTime(time1);
    this._inner.update(newT)
}, reverse: function () {
    return cc.EaseBounceIn.create(this._inner.reverse())
}, clone: function () {
    var action = new cc.EaseBounceOut;
    action.initWithAction(this._inner.clone());
    return action
}});
cc.EaseBounceOut.create = function (action) {
    return new cc.EaseBounceOut(action)
};
cc._easeBounceOutObj = {easing: function (dt) {
    return cc._bounceTime(dt)
}, reverse: function () {
    return cc._easeBounceInObj
}};
cc.easeBounceOut = function () {
    return cc._easeBounceOutObj
};
cc.EaseBounceInOut = cc.EaseBounce.extend({update: function (time1) {
    var newT = 0;
    if (time1 < 0.5) {
        time1 = time1 * 2;
        newT = (1 - this.bounceTime(1 - time1)) * 0.5
    } else newT = this.bounceTime(time1 * 2 - 1) * 0.5 + 0.5;
    this._inner.update(newT)
}, clone: function () {
    var action = new cc.EaseBounceInOut;
    action.initWithAction(this._inner.clone());
    return action
}, reverse: function () {
    return cc.EaseBounceInOut.create(this._inner.reverse())
}});
cc.EaseBounceInOut.create = function (action) {
    return new cc.EaseBounceInOut(action)
};
cc._easeBounceInOutObj = {easing: function (time1) {
    var newT;
    if (time1 < 0.5) {
        time1 = time1 * 2;
        newT = (1 - cc._bounceTime(1 - time1)) * 0.5
    } else newT = cc._bounceTime(time1 * 2 - 1) * 0.5 + 0.5;
    return newT
}, reverse: function () {
    return cc._easeBounceInOutObj
}};
cc.easeBounceInOut = function () {
    return cc._easeBounceInOutObj
};
cc.EaseBackIn = cc.ActionEase.extend({update: function (time1) {
    var overshoot = 1.70158;
    time1 = time1 === 0 || time1 == 1 ? time1 : time1 * time1 * ((overshoot + 1) * time1 - overshoot);
    this._inner.update(time1)
}, reverse: function () {
    return cc.EaseBackOut.create(this._inner.reverse())
}, clone: function () {
    var action = new cc.EaseBackIn;
    action.initWithAction(this._inner.clone());
    return action
}});
cc.EaseBackIn.create = function (action) {
    return new cc.EaseBackIn(action)
};
cc._easeBackInObj = {easing: function (time1) {
    var overshoot = 1.70158;
    return time1 === 0 || time1 === 1 ? time1 : time1 * time1 * ((overshoot + 1) * time1 - overshoot)
}, reverse: function () {
    return cc._easeBackOutObj
}};
cc.easeBackIn = function () {
    return cc._easeBackInObj
};
cc.EaseBackOut = cc.ActionEase.extend({update: function (time1) {
    var overshoot = 1.70158;
    time1 = time1 - 1;
    this._inner.update(time1 * time1 * ((overshoot + 1) * time1 + overshoot) + 1)
}, reverse: function () {
    return cc.EaseBackIn.create(this._inner.reverse())
}, clone: function () {
    var action = new cc.EaseBackOut;
    action.initWithAction(this._inner.clone());
    return action
}});
cc.EaseBackOut.create = function (action) {
    return new cc.EaseBackOut(action)
};
cc._easeBackOutObj = {easing: function (time1) {
    var overshoot = 1.70158;
    time1 = time1 - 1;
    return time1 * time1 * ((overshoot + 1) * time1 + overshoot) + 1
}, reverse: function () {
    return cc._easeBackInObj
}};
cc.easeBackOut = function () {
    return cc._easeBackOutObj
};
cc.EaseBackInOut = cc.ActionEase.extend({update: function (time1) {
    var overshoot = 1.70158 * 1.525;
    time1 = time1 * 2;
    if (time1 < 1)this._inner.update(time1 * time1 * ((overshoot + 1) * time1 - overshoot) / 2); else {
        time1 = time1 - 2;
        this._inner.update(time1 * time1 * ((overshoot + 1) * time1 + overshoot) / 2 + 1)
    }
}, clone: function () {
    var action = new cc.EaseBackInOut;
    action.initWithAction(this._inner.clone());
    return action
}, reverse: function () {
    return cc.EaseBackInOut.create(this._inner.reverse())
}});
cc.EaseBackInOut.create = function (action) {
    return new cc.EaseBackInOut(action)
};
cc._easeBackInOutObj = {easing: function (time1) {
    var overshoot = 1.70158 * 1.525;
    time1 = time1 * 2;
    if (time1 < 1)return time1 * time1 * ((overshoot + 1) * time1 - overshoot) / 2; else {
        time1 = time1 - 2;
        return time1 * time1 * ((overshoot + 1) * time1 + overshoot) / 2 + 1
    }
}, reverse: function () {
    return cc._easeBackInOutObj
}};
cc.easeBackInOut = function () {
    return cc._easeBackInOutObj
};
cc.EaseBezierAction = cc.ActionEase.extend({_p0: null, _p1: null, _p2: null, _p3: null, ctor: function (action) {
    cc.ActionEase.prototype.ctor.call(this, action)
}, _updateTime: function (a, b, c, d, t) {
    return Math.pow(1 - t, 3) * a + 3 * t * Math.pow(1 - t, 2) * b + 3 * Math.pow(t, 2) * (1 - t) * c + Math.pow(t, 3) * d
}, update: function (time) {
    var t = this._updateTime(this._p0, this._p1, this._p2, this._p3, time);
    this._inner.update(t)
}, clone: function () {
    var action = new cc.EaseBezierAction;
    action.initWithAction(this._inner.clone());
    action.setBezierParamer(this._p0,
        this._p1, this._p2, this._p3);
    return action
}, reverse: function () {
    var action = cc.EaseBezierAction.create(this._inner.reverse());
    action.setBezierParamer(this._p3, this._p2, this._p1, this._p0);
    return action
}, setBezierParamer: function (p0, p1, p2, p3) {
    this._p0 = p0 || 0;
    this._p1 = p1 || 0;
    this._p2 = p2 || 0;
    this._p3 = p3 || 0
}});
cc.EaseBezierAction.create = function (action) {
    return new cc.EaseBezierAction(action)
};
cc.easeBezierAction = function (p0, p1, p2, p3) {
    return{easing: function (time) {
        return cc.EaseBezierAction.prototype._updateTime(p0, p1, p2, p3, time)
    }, reverse: function () {
        return cc.easeBezierAction(p3, p2, p1, p0)
    }}
};
cc.EaseQuadraticActionIn = cc.ActionEase.extend({_updateTime: function (time) {
    return Math.pow(time, 2)
}, update: function (time) {
    this._inner.update(this._updateTime(time))
}, clone: function () {
    var action = new cc.EaseQuadraticActionIn;
    action.initWithAction(this._inner.clone());
    return action
}, reverse: function () {
    return cc.EaseQuadraticActionIn.create(this._inner.reverse())
}});
cc.EaseQuadraticActionIn.create = function (action) {
    return new cc.EaseQuadraticActionIn(action)
};
cc._easeQuadraticActionIn = {easing: cc.EaseQuadraticActionIn.prototype._updateTime, reverse: function () {
    return cc._easeQuadraticActionIn
}};
cc.easeQuadraticActionIn = function () {
    return cc._easeQuadraticActionIn
};
cc.EaseQuadraticActionOut = cc.ActionEase.extend({_updateTime: function (time) {
    return-time * (time - 2)
}, update: function (time) {
    this._inner.update(this._updateTime(time))
}, clone: function () {
    var action = new cc.EaseQuadraticActionOut;
    action.initWithAction();
    return action
}, reverse: function () {
    return cc.EaseQuadraticActionOut.create(this._inner.reverse())
}});
cc.EaseQuadraticActionOut.create = function (action) {
    return new cc.EaseQuadraticActionOut(action)
};
cc._easeQuadraticActionOut = {easing: cc.EaseQuadraticActionOut.prototype._updateTime, reverse: function () {
    return cc._easeQuadraticActionOut
}};
cc.easeQuadraticActionOut = function () {
    return cc._easeQuadraticActionOut
};
cc.EaseQuadraticActionInOut = cc.ActionEase.extend({_updateTime: function (time) {
    var resultTime = time;
    time *= 2;
    if (time < 1)resultTime = time * time * 0.5; else {
        --time;
        resultTime = -0.5 * (time * (time - 2) - 1)
    }
    return resultTime
}, update: function (time) {
    this._inner.update(this._updateTime(time))
}, clone: function () {
    var action = new cc.EaseQuadraticActionInOut;
    action.initWithAction(this._inner.clone());
    return action
}, reverse: function () {
    return cc.EaseQuadraticActionInOut.create(this._inner.reverse())
}});
cc.EaseQuadraticActionInOut.create = function (action) {
    return new cc.EaseQuadraticActionInOut(action)
};
cc._easeQuadraticActionInOut = {easing: cc.EaseQuadraticActionInOut.prototype._updateTime, reverse: function () {
    return cc._easeQuadraticActionInOut
}};
cc.easeQuadraticActionInOut = function () {
    return cc._easeQuadraticActionInOut
};
cc.EaseQuarticActionIn = cc.ActionEase.extend({_updateTime: function (time) {
    return time * time * time * time
}, update: function (time) {
    this._inner.update(this._updateTime(time))
}, clone: function () {
    var action = new cc.EaseQuarticActionIn;
    action.initWithAction(this._inner.clone());
    return action
}, reverse: function () {
    return cc.EaseQuarticActionIn.create(this._inner.reverse())
}});
cc.EaseQuarticActionIn.create = function (action) {
    return new cc.EaseQuarticActionIn(action)
};
cc._easeQuarticActionIn = {easing: cc.EaseQuarticActionIn.prototype._updateTime, reverse: function () {
    return cc._easeQuarticActionIn
}};
cc.easeQuarticActionIn = function () {
    return cc._easeQuarticActionIn
};
cc.EaseQuarticActionOut = cc.ActionEase.extend({_updateTime: function (time) {
    time -= 1;
    return-(time * time * time * time - 1)
}, update: function (time) {
    this._inner.update(this._updateTime(time))
}, clone: function () {
    var action = new cc.EaseQuarticActionOut;
    action.initWithAction(this._inner.clone());
    return action
}, reverse: function () {
    return cc.EaseQuarticActionOut.create(this._inner.reverse())
}});
cc.EaseQuarticActionOut.create = function (action) {
    return new cc.EaseQuarticActionOut(action)
};
cc._easeQuarticActionOut = {easing: cc.EaseQuarticActionOut.prototype._updateTime, reverse: function () {
    return cc._easeQuarticActionOut
}};
cc.easeQuarticActionOut = function () {
    return cc._easeQuarticActionOut
};
cc.EaseQuarticActionInOut = cc.ActionEase.extend({_updateTime: function (time) {
    time = time * 2;
    if (time < 1)return 0.5 * time * time * time * time;
    time -= 2;
    return-0.5 * (time * time * time * time - 2)
}, update: function (time) {
    this._inner.update(this._updateTime(time))
}, clone: function () {
    var action = new cc.EaseQuarticActionInOut;
    action.initWithAction(this._inner.clone());
    return action
}, reverse: function () {
    return cc.EaseQuarticActionInOut.create(this._inner.reverse())
}});
cc.EaseQuarticActionInOut.create = function (action) {
    return new cc.EaseQuarticActionInOut(action)
};
cc._easeQuarticActionInOut = {easing: cc.EaseQuarticActionInOut.prototype._updateTime, reverse: function () {
    return cc._easeQuarticActionInOut
}};
cc.easeQuarticActionInOut = function () {
    return cc._easeQuarticActionInOut
};
cc.EaseQuinticActionIn = cc.ActionEase.extend({_updateTime: function (time) {
    return time * time * time * time * time
}, update: function (time) {
    this._inner.update(this._updateTime(time))
}, clone: function () {
    var action = new cc.EaseQuinticActionIn;
    action.initWithAction(this._inner.clone());
    return action
}, reverse: function () {
    return cc.EaseQuinticActionIn.create(this._inner.reverse())
}});
cc.EaseQuinticActionIn.create = function (action) {
    return new cc.EaseQuinticActionIn(action)
};
cc._easeQuinticActionIn = {easing: cc.EaseQuinticActionIn.prototype._updateTime, reverse: function () {
    return cc._easeQuinticActionIn
}};
cc.easeQuinticActionIn = function () {
    return cc._easeQuinticActionIn
};
cc.EaseQuinticActionOut = cc.ActionEase.extend({_updateTime: function (time) {
    time -= 1;
    return time * time * time * time * time + 1
}, update: function (time) {
    this._inner.update(this._updateTime(time))
}, clone: function () {
    var action = new cc.EaseQuinticActionOut;
    action.initWithAction(this._inner.clone());
    return action
}, reverse: function () {
    return cc.EaseQuinticActionOut.create(this._inner.reverse())
}});
cc.EaseQuinticActionOut.create = function (action) {
    return new cc.EaseQuinticActionOut(action)
};
cc._easeQuinticActionOut = {easing: cc.EaseQuinticActionOut.prototype._updateTime, reverse: function () {
    return cc._easeQuinticActionOut
}};
cc.easeQuinticActionOut = function () {
    return cc._easeQuinticActionOut
};
cc.EaseQuinticActionInOut = cc.ActionEase.extend({_updateTime: function (time) {
    time = time * 2;
    if (time < 1)return 0.5 * time * time * time * time * time;
    time -= 2;
    return 0.5 * (time * time * time * time * time + 2)
}, update: function (time) {
    this._inner.update(this._updateTime(time))
}, clone: function () {
    var action = new cc.EaseQuinticActionInOut;
    action.initWithAction(this._inner.clone());
    return action
}, reverse: function () {
    return cc.EaseQuinticActionInOut.create(this._inner.reverse())
}});
cc.EaseQuinticActionInOut.create = function (action) {
    return new cc.EaseQuinticActionInOut(action)
};
cc._easeQuinticActionInOut = {easing: cc.EaseQuinticActionInOut.prototype._updateTime, reverse: function () {
    return cc._easeQuinticActionInOut
}};
cc.easeQuinticActionInOut = function () {
    return cc._easeQuinticActionInOut
};
cc.EaseCircleActionIn = cc.ActionEase.extend({_updateTime: function (time) {
    return-1 * (Math.sqrt(1 - time * time) - 1)
}, update: function (time) {
    this._inner.update(this._updateTime(time))
}, clone: function () {
    var action = new cc.EaseCircleActionIn;
    action.initWithAction(this._inner.clone());
    return action
}, reverse: function () {
    return cc.EaseCircleActionIn.create(this._inner.reverse())
}});
cc.EaseCircleActionIn.create = function (action) {
    return new cc.EaseCircleActionIn(action)
};
cc._easeCircleActionIn = {easing: cc.EaseCircleActionIn.prototype._updateTime, reverse: function () {
    return cc._easeCircleActionIn
}};
cc.easeCircleActionIn = function () {
    return cc._easeCircleActionIn
};
cc.EaseCircleActionOut = cc.ActionEase.extend({_updateTime: function (time) {
    time = time - 1;
    return Math.sqrt(1 - time * time)
}, update: function (time) {
    this._inner.update(this._updateTime(time))
}, clone: function () {
    var action = new cc.EaseCircleActionOut;
    action.initWithAction(this._inner.clone());
    return action
}, reverse: function () {
    return cc.EaseCircleActionOut.create(this._inner.reverse())
}});
cc.EaseCircleActionOut.create = function (action) {
    return new cc.EaseCircleActionOut(action)
};
cc._easeCircleActionOut = {easing: cc.EaseCircleActionOut.prototype._updateTime, reverse: function () {
    return cc._easeCircleActionOut
}};
cc.easeCircleActionOut = function () {
    return cc._easeCircleActionOut
};
cc.EaseCircleActionInOut = cc.ActionEase.extend({_updateTime: function (time) {
    time = time * 2;
    if (time < 1)return-0.5 * (Math.sqrt(1 - time * time) - 1);
    time -= 2;
    return 0.5 * (Math.sqrt(1 - time * time) + 1)
}, update: function (time) {
    this._inner.update(this._updateTime(time))
}, clone: function () {
    var action = new cc.EaseCircleActionInOut;
    action.initWithAction(this._inner.clone());
    return action
}, reverse: function () {
    return cc.EaseCircleActionInOut.create(this._inner.reverse())
}});
cc.EaseCircleActionInOut.create = function (action) {
    return new cc.EaseCircleActionInOut(action)
};
cc._easeCircleActionInOut = {easing: cc.EaseCircleActionInOut.prototype._updateTime, reverse: function () {
    return cc._easeCircleActionInOut
}};
cc.easeCircleActionInOut = function () {
    return cc._easeCircleActionInOut
};
cc.EaseCubicActionIn = cc.ActionEase.extend({_updateTime: function (time) {
    return time * time * time
}, update: function (time) {
    this._inner.update(this._updateTime(time))
}, clone: function () {
    var action = new cc.EaseCubicActionIn;
    action.initWithAction(this._inner.clone());
    return action
}, reverse: function () {
    return cc.EaseCubicActionIn.create(this._inner.reverse())
}});
cc.EaseCubicActionIn.create = function (action) {
    return new cc.EaseCubicActionIn(action)
};
cc._easeCubicActionIn = {easing: cc.EaseCubicActionIn.prototype._updateTime, reverse: function () {
    return cc._easeCubicActionIn
}};
cc.easeCubicActionIn = function () {
    return cc._easeCubicActionIn
};
cc.EaseCubicActionOut = cc.ActionEase.extend({_updateTime: function (time) {
    time -= 1;
    return time * time * time + 1
}, update: function (time) {
    this._inner.update(this._updateTime(time))
}, clone: function () {
    var action = new cc.EaseCubicActionOut;
    action.initWithAction(this._inner.clone());
    return action
}, reverse: function () {
    return cc.EaseCubicActionOut.create(this._inner.reverse())
}});
cc.EaseCubicActionOut.create = function (action) {
    return new cc.EaseCubicActionOut(action)
};
cc._easeCubicActionOut = {easing: cc.EaseCubicActionOut.prototype._updateTime, reverse: function () {
    return cc._easeCubicActionOut
}};
cc.easeCubicActionOut = function () {
    return cc._easeCubicActionOut
};
cc.EaseCubicActionInOut = cc.ActionEase.extend({_updateTime: function (time) {
    time = time * 2;
    if (time < 1)return 0.5 * time * time * time;
    time -= 2;
    return 0.5 * (time * time * time + 2)
}, update: function (time) {
    this._inner.update(this._updateTime(time))
}, clone: function () {
    var action = new cc.EaseCubicActionInOut;
    action.initWithAction(this._inner.clone());
    return action
}, reverse: function () {
    return cc.EaseCubicActionInOut.create(this._inner.reverse())
}});
cc.EaseCubicActionInOut.create = function (action) {
    return new cc.EaseCubicActionInOut(action)
};
cc._easeCubicActionInOut = {easing: cc.EaseCubicActionInOut.prototype._updateTime, reverse: function () {
    return cc._easeCubicActionInOut
}};
cc.easeCubicActionInOut = function () {
    return cc._easeCubicActionInOut
};
cc.cardinalSplineAt = function (p0, p1, p2, p3, tension, t) {
    var t2 = t * t;
    var t3 = t2 * t;
    var s = (1 - tension) / 2;
    var b1 = s * (-t3 + 2 * t2 - t);
    var b2 = s * (-t3 + t2) + (2 * t3 - 3 * t2 + 1);
    var b3 = s * (t3 - 2 * t2 + t) + (-2 * t3 + 3 * t2);
    var b4 = s * (t3 - t2);
    var x = p0.x * b1 + p1.x * b2 + p2.x * b3 + p3.x * b4;
    var y = p0.y * b1 + p1.y * b2 + p2.y * b3 + p3.y * b4;
    return cc.p(x, y)
};
cc.reverseControlPoints = function (controlPoints) {
    var newArray = [];
    for (var i = controlPoints.length - 1; i >= 0; i--)newArray.push(cc.p(controlPoints[i].x, controlPoints[i].y));
    return newArray
};
cc.copyControlPoints = function (controlPoints) {
    var newArray = [];
    for (var i = 0; i < controlPoints.length; i++)newArray.push(cc.p(controlPoints[i].x, controlPoints[i].y));
    return newArray
};
cc.getControlPointAt = function (controlPoints, pos) {
    var p = Math.min(controlPoints.length - 1, Math.max(pos, 0));
    return controlPoints[p]
};
cc.reverseControlPointsInline = function (controlPoints) {
    var len = controlPoints.length;
    var mid = 0 | len / 2;
    for (var i = 0; i < mid; ++i) {
        var temp = controlPoints[i];
        controlPoints[i] = controlPoints[len - i - 1];
        controlPoints[len - i - 1] = temp
    }
};
cc.CardinalSplineTo = cc.ActionInterval.extend({_points: null, _deltaT: 0, _tension: 0, _previousPosition: null, _accumulatedDiff: null, ctor: function (duration, points, tension) {
    cc.ActionInterval.prototype.ctor.call(this);
    this._points = [];
    tension !== undefined && this.initWithDuration(duration, points, tension)
}, initWithDuration: function (duration, points, tension) {
    if (!points || points.length == 0)throw"Invalid configuration. It must at least have one control point";
    if (cc.ActionInterval.prototype.initWithDuration.call(this,
        duration)) {
        this.setPoints(points);
        this._tension = tension;
        return true
    }
    return false
}, clone: function () {
    var action = new cc.CardinalSplineTo;
    action.initWithDuration(this._duration, cc.copyControlPoints(this._points), this._tension);
    return action
}, startWithTarget: function (target) {
    cc.ActionInterval.prototype.startWithTarget.call(this, target);
    this._deltaT = 1 / (this._points.length - 1);
    this._previousPosition = cc.p(this.target.getPositionX(), this.target.getPositionY());
    this._accumulatedDiff = cc.p(0, 0)
}, update: function (time) {
    time =
        this._computeEaseTime(time);
    var p, lt;
    var ps = this._points;
    if (time == 1) {
        p = ps.length - 1;
        lt = 1
    } else {
        var locDT = this._deltaT;
        p = 0 | time / locDT;
        lt = (time - locDT * p) / locDT
    }
    var newPos = cc.cardinalSplineAt(cc.getControlPointAt(ps, p - 1), cc.getControlPointAt(ps, p - 0), cc.getControlPointAt(ps, p + 1), cc.getControlPointAt(ps, p + 2), this._tension, lt);
    if (cc.ENABLE_STACKABLE_ACTIONS) {
        var tempX, tempY;
        tempX = this.target.getPositionX() - this._previousPosition.x;
        tempY = this.target.getPositionY() - this._previousPosition.y;
        if (tempX != 0 || tempY !=
            0) {
            var locAccDiff = this._accumulatedDiff;
            tempX = locAccDiff.x + tempX;
            tempY = locAccDiff.y + tempY;
            locAccDiff.x = tempX;
            locAccDiff.y = tempY;
            newPos.x += tempX;
            newPos.y += tempY
        }
    }
    this.updatePosition(newPos)
}, reverse: function () {
    var reversePoints = cc.reverseControlPoints(this._points);
    return cc.CardinalSplineTo.create(this._duration, reversePoints, this._tension)
}, updatePosition: function (newPos) {
    this.target.setPosition(newPos);
    this._previousPosition = newPos
}, getPoints: function () {
    return this._points
}, setPoints: function (points) {
    this._points =
        points
}});
cc.CardinalSplineTo.create = function (duration, points, tension) {
    return new cc.CardinalSplineTo(duration, points, tension)
};
cc.CardinalSplineBy = cc.CardinalSplineTo.extend({_startPosition: null, ctor: function (duration, points, tension) {
    cc.CardinalSplineTo.prototype.ctor.call(this);
    this._startPosition = cc.p(0, 0);
    tension !== undefined && this.initWithDuration(duration, points, tension)
}, startWithTarget: function (target) {
    cc.CardinalSplineTo.prototype.startWithTarget.call(this, target);
    this._startPosition.x = target.getPositionX();
    this._startPosition.y = target.getPositionY()
}, reverse: function () {
    var copyConfig = this._points.slice();
    var current;
    var p = copyConfig[0];
    for (var i = 1; i < copyConfig.length; ++i) {
        current = copyConfig[i];
        copyConfig[i] = cc.pSub(current, p);
        p = current
    }
    var reverseArray = cc.reverseControlPoints(copyConfig);
    p = reverseArray[reverseArray.length - 1];
    reverseArray.pop();
    p.x = -p.x;
    p.y = -p.y;
    reverseArray.unshift(p);
    for (var i = 1; i < reverseArray.length; ++i) {
        current = reverseArray[i];
        current.x = -current.x;
        current.y = -current.y;
        current.x += p.x;
        current.y += p.y;
        reverseArray[i] = current;
        p = current
    }
    return cc.CardinalSplineBy.create(this._duration, reverseArray,
        this._tension)
}, updatePosition: function (newPos) {
    var pos = this._startPosition;
    var posX = newPos.x + pos.x;
    var posY = newPos.y + pos.y;
    this._previousPosition.x = posX;
    this._previousPosition.y = posY;
    this.target.setPosition(posX, posY)
}, clone: function () {
    var a = new cc.CardinalSplineBy;
    a.initWithDuration(this._duration, cc.copyControlPoints(this._points), this._tension);
    return a
}});
cc.CardinalSplineBy.create = function (duration, points, tension) {
    return new cc.CardinalSplineBy(duration, points, tension)
};
cc.CatmullRomTo = cc.CardinalSplineTo.extend({ctor: function (dt, points) {
    points && this.initWithDuration(dt, points)
}, initWithDuration: function (dt, points) {
    return cc.CardinalSplineTo.prototype.initWithDuration.call(this, dt, points, 0.5)
}, clone: function () {
    var action = new cc.CatmullRomTo;
    action.initWithDuration(this._duration, cc.copyControlPoints(this._points));
    return action
}});
cc.CatmullRomTo.create = function (dt, points) {
    return new cc.CatmullRomTo(dt, points)
};
cc.CatmullRomBy = cc.CardinalSplineBy.extend({ctor: function (dt, points) {
    cc.CardinalSplineBy.prototype.ctor.call(this);
    points && this.initWithDuration(dt, points)
}, initWithDuration: function (dt, points) {
    return cc.CardinalSplineTo.prototype.initWithDuration.call(this, dt, points, 0.5)
}, clone: function () {
    var action = new cc.CatmullRomBy;
    action.initWithDuration(this._duration, cc.copyControlPoints(this._points));
    return action
}});
cc.CatmullRomBy.create = function (dt, points) {
    return new cc.CatmullRomBy(dt, points)
};
cc.ActionTweenDelegate = cc.Class.extend({updateTweenAction: function (value, key) {
}});
cc.ActionTween = cc.ActionInterval.extend({key: "", from: 0, to: 0, delta: 0, ctor: function (duration, key, from, to) {
    cc.ActionInterval.prototype.ctor.call(this);
    this.key = "";
    to !== undefined && this.initWithDuration(duration, key, from, to)
}, initWithDuration: function (duration, key, from, to) {
    if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
        this.key = key;
        this.to = to;
        this.from = from;
        return true
    }
    return false
}, startWithTarget: function (target) {
    if (!target || !target.updateTweenAction)throw"cc.ActionTween.startWithTarget(): target must be non-null, and target must implement updateTweenAction function";
    cc.ActionInterval.prototype.startWithTarget.call(this, target);
    this.delta = this.to - this.from
}, update: function (dt) {
    this.target.updateTweenAction(this.to - this.delta * (1 - dt), this.key)
}, reverse: function () {
    return cc.ActionTween.create(this.duration, this.key, this.to, this.from)
}, clone: function () {
    var action = new cc.ActionTween;
    action.initWithDuration(this._duration, this.key, this.from, this.to);
    return action
}});
cc.ActionTween.create = function (duration, key, from, to) {
    var ret = new cc.ActionTween;
    if (ret.initWithDuration(duration, key, from, to))return ret;
    return null
};
cc.action = cc.Action.create;
cc.speed = cc.Speed.create;
cc.follow = cc.Follow.create;
cc.orbitCamera = cc.OrbitCamera.create;
cc.cardinalSplineTo = cc.CardinalSplineTo.create;
cc.cardinalSplineBy = cc.CardinalSplineBy.create;
cc.catmullRomTo = cc.CatmullRomTo.create;
cc.catmullRomBy = cc.CatmullRomBy.create;
cc.show = cc.Show.create;
cc.hide = cc.Hide.create;
cc.toggleVisibility = cc.ToggleVisibility.create;
cc.removeSelf = cc.RemoveSelf.create;
cc.flipX = cc.FlipX.create;
cc.flipY = cc.FlipY.create;
cc.place = cc.Place.create;
cc.callFunc = cc.CallFunc.create;
cc.actionInterval = cc.ActionInterval.create;
cc.sequence = cc.Sequence.create;
cc.repeat = cc.Repeat.create;
cc.repeatForever = cc.RepeatForever.create;
cc.spawn = cc.Spawn.create;
cc.rotateTo = cc.RotateTo.create;
cc.rotateBy = cc.RotateBy.create;
cc.moveBy = cc.MoveBy.create;
cc.moveTo = cc.MoveTo.create;
cc.skewTo = cc.SkewTo.create;
cc.skewBy = cc.SkewBy.create;
cc.jumpBy = cc.JumpBy.create;
cc.jumpTo = cc.JumpTo.create;
cc.bezierBy = cc.BezierBy.create;
cc.bezierTo = cc.BezierTo.create;
cc.scaleTo = cc.ScaleTo.create;
cc.scaleBy = cc.ScaleBy.create;
cc.blink = cc.Blink.create;
cc.fadeTo = cc.FadeTo.create;
cc.fadeIn = cc.FadeIn.create;
cc.fadeOut = cc.FadeOut.create;
cc.tintTo = cc.TintTo.create;
cc.tintBy = cc.TintBy.create;
cc.delayTime = cc.DelayTime.create;
cc.reverseTime = cc.ReverseTime.create;
cc.animate = cc.Animate.create;
cc.targetedAction = cc.TargetedAction.create;
cc.actionTween = cc.ActionTween.create;if (cc.sys._supportWebAudio) {
    var _ctx = cc.webAudioContext = new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext);
    cc.WebAudio = cc.Class.extend({_events: null, _buffer: null, _sourceNode: null, _volumeNode: null, src: null, preload: null, autoplay: null, controls: null, mediagroup: null, currentTime: 0, startTime: 0, duration: 0, _loop: null, _volume: 1, _pauseTime: 0, _paused: false, _stopped: true, _loadState: -1, ctor: function (src) {
        var self = this;
        self._events = {};
        self.src = src;
        if (_ctx["createGain"])self._volumeNode =
            _ctx["createGain"](); else self._volumeNode = _ctx["createGainNode"]();
        self._onSuccess1 = self._onSuccess.bind(this);
        self._onError1 = self._onError.bind(this)
    }, _play: function (offset) {
        var self = this;
        var sourceNode = self._sourceNode = _ctx["createBufferSource"]();
        var volumeNode = self._volumeNode;
        offset = offset || 0;
        sourceNode.buffer = self._buffer;
        volumeNode["gain"].value = self._volume;
        sourceNode["connect"](volumeNode);
        volumeNode["connect"](_ctx["destination"]);
        sourceNode.loop = self._loop;
        self._paused = false;
        self._stopped =
            false;
        if (sourceNode.start)sourceNode.start(0, offset); else if (sourceNode["noteGrainOn"]) {
            var duration = sourceNode.buffer.duration;
            if (self.loop)sourceNode["noteGrainOn"](0, offset, duration); else sourceNode["noteGrainOn"](0, offset, duration - offset)
        } else sourceNode["noteOn"](0);
        self._pauseTime = 0
    }, _stop: function () {
        var self = this, sourceNode = self._sourceNode;
        if (self._stopped)return;
        if (sourceNode.stop)sourceNode.stop(0); else sourceNode.noteOff(0);
        self._stopped = true
    }, play: function () {
        var self = this;
        if (self._loadState == -1) {
            self._loadState = 0;
            return
        } else if (self._loadState != 1)return;
        var sourceNode = self._sourceNode;
        if (!self._stopped && sourceNode && sourceNode["playbackState"] == 2)return;
        self.startTime = _ctx.currentTime;
        this._play(0)
    }, pause: function () {
        this._pauseTime = _ctx.currentTime;
        this._paused = true;
        this._stop()
    }, resume: function () {
        var self = this;
        if (self._paused) {
            var offset = self._buffer ? (self._pauseTime - self.startTime) % self._buffer.duration : 0;
            this._play(offset)
        }
    }, stop: function () {
        this._pauseTime = 0;
        this._paused = false;
        this._stop()
    },
        load: function () {
            var self = this;
            if (self._loadState == 1)return;
            self._loadState = -1;
            self.played = false;
            self.ended = true;
            var request = new XMLHttpRequest;
            request.open("GET", self.src, true);
            request.responseType = "arraybuffer";
            request.onload = function () {
                _ctx["decodeAudioData"](request.response, self._onSuccess1, self._onError1)
            };
            request.send()
        }, addEventListener: function (eventName, event) {
            this._events[eventName] = event.bind(this)
        }, removeEventListener: function (eventName) {
            delete this._events[eventName]
        }, canplay: function () {
            return cc.sys._supportWebAudio
        },
        _onSuccess: function (buffer) {
            var self = this;
            self._buffer = buffer;
            var success = self._events["success"], canplaythrough = self._events["canplaythrough"];
            if (success)success();
            if (canplaythrough)canplaythrough();
            if (self._loadState == 0 || self.autoplay == "autoplay" || self.autoplay == true)self._play();
            self._loadState = 1
        }, _onError: function () {
            var error = this._events["error"];
            if (error)error();
            this._loadState = -2
        }, cloneNode: function () {
            var self = this, obj = new cc.WebAudio(self.src);
            obj.volume = self.volume;
            obj._loadState = self._loadState;
            obj._buffer = self._buffer;
            if (obj._loadState == 0 || obj._loadState == -1)obj.load();
            return obj
        }});
    var _p = cc.WebAudio.prototype;
    _p.loop;
    cc.defineGetterSetter(_p, "loop", function () {
        return this._loop
    }, function (loop) {
        this._loop = loop;
        if (this._sourceNode)this._sourceNode.loop = loop
    });
    _p.volume;
    cc.defineGetterSetter(_p, "volume", function () {
        return this._volume
    }, function (volume) {
        this._volume = volume;
        this._volumeNode["gain"].value = volume
    });
    _p.paused;
    cc.defineGetterSetter(_p, "paused", function () {
        return this._paused
    });
    _p.ended;
    cc.defineGetterSetter(_p, "ended", function () {
        var sourceNode = this._sourceNode;
        return!this._paused && (this._stopped || !sourceNode || sourceNode["playbackState"] == 3)
    });
    _p.played;
    cc.defineGetterSetter(_p, "played", function () {
        var sourceNode = this._sourceNode;
        return sourceNode && sourceNode["playbackState"] == 2
    })
}
cc.AudioEngine = cc.Class.extend({_soundSupported: false, _currMusic: null, _currMusicPath: null, _musicPlayState: 0, _audioID: 0, _effects: {}, _audioPool: {}, _effectsVolume: 1, _maxAudioInstance: 5, _effectPauseCb: null, _playings: [], ctor: function () {
    var self = this;
    self._soundSupported = cc._audioLoader._supportedAudioTypes.length > 0;
    if (self._effectPauseCb)self._effectPauseCb = self._effectPauseCb.bind(self)
}, willPlayMusic: function () {
    return false
}, getEffectsVolume: function () {
    return this._effectsVolume
}, playMusic: function (url, loop) {
    var self = this;
    if (!self._soundSupported)return;
    var audio = self._currMusic;
    if (audio)this._stopAudio(audio);
    if (url != self._currMusicPath) {
        audio = self._getAudioByUrl(url);
        self._currMusic = audio;
        self._currMusicPath = url
    }
    if (!audio)return;
    audio.loop = loop || false;
    self._playMusic(audio)
}, _getAudioByUrl: function (url) {
    var locLoader = cc.loader, audio = locLoader.getRes(url);
    if (!audio) {
        locLoader.load(url);
        audio = locLoader.getRes(url)
    }
    return audio
}, _playMusic: function (audio) {
    if (!audio.ended)if (audio.stop)audio.stop();
    else {
        audio.pause();
        audio.currentTime = 0
    }
    this._musicPlayState = 2;
    audio.play()
}, stopMusic: function (releaseData) {
    if (this._musicPlayState > 0) {
        var audio = this._currMusic;
        if (!audio)return;
        if (!this._stopAudio(audio))return;
        if (releaseData)cc.loader.release(this._currMusicPath);
        this._currMusic = null;
        this._currMusicPath = null;
        this._musicPlayState = 0
    }
}, _stopAudio: function (audio) {
    if (audio && !audio.ended) {
        if (audio.stop)audio.stop(); else if (audio.duration && audio.duration != Infinity)audio.currentTime = audio.duration; else audio.pause();
        return true
    }
    return false
}, pauseMusic: function () {
    if (this._musicPlayState == 2) {
        this._currMusic.pause();
        this._musicPlayState = 1
    }
}, resumeMusic: function () {
    if (this._musicPlayState == 1) {
        var audio = this._currMusic;
        this._resumeAudio(audio);
        this._musicPlayState = 2
    }
}, _resumeAudio: function (audio) {
    if (audio && !audio.ended)if (audio.resume)audio.resume(); else audio.play()
}, rewindMusic: function () {
    if (this._currMusic)this._playMusic(this._currMusic)
}, getMusicVolume: function () {
    return this._musicPlayState == 0 ? 0 : this._currMusic.volume
},
    setMusicVolume: function (volume) {
        if (this._musicPlayState > 0)this._currMusic.volume = Math.min(Math.max(volume, 0), 1)
    }, isMusicPlaying: function () {
        return this._musicPlayState == 2 && this._currMusic && !this._currMusic.ended
    }, _getEffectList: function (url) {
        var list = this._audioPool[url];
        if (!list)list = this._audioPool[url] = [];
        return list
    }, _getEffect: function (url) {
        var self = this, audio;
        if (!self._soundSupported)return null;
        var effList = this._getEffectList(url);
        for (var i = 0, li = effList.length; i < li; i++) {
            var eff = effList[i];
            if (eff.ended) {
                audio =
                    eff;
                audio.currentTime = 0;
                if (window.chrome)audio.load();
                break
            }
        }
        if (!audio) {
            if (effList.length >= this._maxAudioInstance) {
                cc.log("Error: " + url + " greater than " + this._maxAudioInstance);
                return null
            }
            audio = self._getAudioByUrl(url);
            if (!audio)return null;
            audio = audio.cloneNode(true);
            if (self._effectPauseCb)cc._addEventListener(audio, "pause", self._effectPauseCb);
            audio.volume = this._effectsVolume;
            effList.push(audio)
        }
        return audio
    }, playEffect: function (url, loop) {
        var audio = this._getEffect(url);
        if (!audio)return null;
        audio.loop =
            loop || false;
        audio.play();
        var audioId = this._audioID++;
        this._effects[audioId] = audio;
        return audioId
    }, setEffectsVolume: function (volume) {
        volume = this._effectsVolume = Math.min(Math.max(volume, 0), 1);
        var effects = this._effects;
        for (var key in effects)effects[key].volume = volume
    }, pauseEffect: function (audioID) {
        var audio = this._effects[audioID];
        if (audio && !audio.ended)audio.pause()
    }, pauseAllEffects: function () {
        var effects = this._effects;
        for (var key in effects) {
            var eff = effects[key];
            if (!eff.ended)eff.pause()
        }
    }, resumeEffect: function (effectId) {
        this._resumeAudio(this._effects[effectId])
    },
    resumeAllEffects: function () {
        var effects = this._effects;
        for (var key in effects)this._resumeAudio(effects[key])
    }, stopEffect: function (effectId) {
        this._stopAudio(this._effects[effectId]);
        delete this._effects[effectId]
    }, stopAllEffects: function () {
        var effects = this._effects;
        for (var key in effects) {
            this._stopAudio(effects[key]);
            delete effects[key]
        }
    }, unloadEffect: function (url) {
        var locLoader = cc.loader, locEffects = this._effects, effectList = this._getEffectList(url);
        locLoader.release(url);
        if (effectList.length == 0)return;
        var realUrl = effectList[0].src;
        delete this._audioPool[url];
        for (var key in locEffects)if (locEffects[key].src == realUrl) {
            this._stopAudio(locEffects[key]);
            delete locEffects[key]
        }
    }, end: function () {
        this.stopMusic();
        this.stopAllEffects()
    }, _pausePlaying: function () {
        var self = this, effects = self._effects, eff;
        for (var key in effects) {
            eff = effects[key];
            if (eff && !eff.ended && !eff.paused) {
                self._playings.push(eff);
                eff.pause()
            }
        }
        if (self.isMusicPlaying()) {
            self._playings.push(self._currMusic);
            self._currMusic.pause()
        }
    }, _resumePlaying: function () {
        var self =
            this, playings = this._playings;
        for (var i = 0, li = playings.length; i < li; i++)self._resumeAudio(playings[i]);
        playings.length = 0
    }});
if (!cc.sys._supportWebAudio && cc.sys._supportMultipleAudio < 0)cc.AudioEngineForSingle = cc.AudioEngine.extend({_waitingEffIds: [], _pausedEffIds: [], _currEffect: null, _maxAudioInstance: 2, _effectCache4Single: {}, _needToResumeMusic: false, _expendTime4Music: 0, _isHiddenMode: false, _playMusic: function (audio) {
    this._stopAllEffects();
    this._super(audio)
}, resumeMusic: function () {
    var self = this;
    if (self._musicPlayState == 1) {
        self._stopAllEffects();
        self._needToResumeMusic = false;
        self._expendTime4Music = 0;
        self._super()
    }
}, playEffect: function (url, loop) {
    var self = this, currEffect = self._currEffect;
    var audio = loop ? self._getEffect(url) : self._getSingleEffect(url);
    if (!audio)return null;
    audio.loop = loop || false;
    var audioId = self._audioID++;
    self._effects[audioId] = audio;
    if (self.isMusicPlaying()) {
        self.pauseMusic();
        self._needToResumeMusic = true
    }
    if (currEffect) {
        if (currEffect != audio)self._waitingEffIds.push(self._currEffectId);
        self._waitingEffIds.push(audioId);
        currEffect.pause()
    } else {
        self._currEffect = audio;
        self._currEffectId = audioId;
        audio.play()
    }
    return audioId
},
    pauseEffect: function (effectId) {
        cc.log("pauseEffect not supported in single audio mode!")
    }, pauseAllEffects: function () {
        var self = this, waitings = self._waitingEffIds, pauseds = self._pausedEffIds, currEffect = self._currEffect;
        if (!currEffect)return;
        for (var i = 0, li = waitings.length; i < li; i++)pauseds.push(waitings[i]);
        waitings.length = 0;
        pauseds.push(self._currEffectId);
        currEffect.pause()
    }, resumeEffect: function (effectId) {
        cc.log("resumeEffect not supported in single audio mode!")
    }, resumeAllEffects: function () {
        var self =
            this, waitings = self._waitingEffIds, pauseds = self._pausedEffIds;
        if (self.isMusicPlaying()) {
            self.pauseMusic();
            self._needToResumeMusic = true
        }
        for (var i = 0, li = pauseds.length; i < li; i++)waitings.push(pauseds[i]);
        pauseds.length = 0;
        if (!self._currEffect && waitings.length >= 0) {
            var effId = waitings.pop();
            var eff = self._effects[effId];
            if (eff) {
                self._currEffectId = effId;
                self._currEffect = eff;
                self._resumeAudio(eff)
            }
        }
    }, stopEffect: function (effectId) {
        var self = this, currEffect = self._currEffect, waitings = self._waitingEffIds, pauseds =
            self._pausedEffIds;
        if (currEffect && this._currEffectId == effectId)this._stopAudio(currEffect); else {
            var index = waitings.indexOf(effectId);
            if (index >= 0)waitings.splice(index, 1); else {
                index = pauseds.indexOf(effectId);
                if (index >= 0)pauseds.splice(index, 1)
            }
        }
    }, stopAllEffects: function () {
        var self = this;
        self._stopAllEffects();
        if (!self._currEffect && self._needToResumeMusic) {
            self._resumeAudio(self._currMusic);
            self._musicPlayState = 2;
            self._needToResumeMusic = false;
            self._expendTime4Music = 0
        }
    }, unloadEffect: function (url) {
        var self =
            this, locLoader = cc.loader, locEffects = self._effects, effCache = self._effectCache4Single, effectList = self._getEffectList(url), currEffect = self._currEffect;
        locLoader.release(url);
        if (effectList.length == 0 && !effCache[url])return;
        var realUrl = effectList.length > 0 ? effectList[0].src : effCache[url].src;
        delete self._audioPool[url];
        delete effCache[url];
        for (var key in locEffects)if (locEffects[key].src == realUrl)delete locEffects[key];
        if (currEffect && currEffect.src == realUrl)self._stopAudio(currEffect)
    }, _getSingleEffect: function (url) {
        var self =
            this, audio = self._effectCache4Single[url], locLoader = cc.loader, waitings = self._waitingEffIds, pauseds = self._pausedEffIds, effects = self._effects;
        if (audio)audio.currentTime = 0; else {
            audio = self._getAudioByUrl(url);
            if (!audio)return null;
            audio = audio.cloneNode(true);
            if (self._effectPauseCb)cc._addEventListener(audio, "pause", self._effectPauseCb);
            audio.volume = self._effectsVolume;
            self._effectCache4Single[url] = audio
        }
        for (var i = 0, li = waitings.length; i < li;)if (effects[waitings[i]] == audio)waitings.splice(i, 1); else i++;
        for (var i =
            0, li = pauseds.length; i < li;)if (effects[pauseds[i]] == audio)pauseds.splice(i, 1); else i++;
        audio._isToPlay = true;
        return audio
    }, _stopAllEffects: function () {
        var self = this, currEffect = self._currEffect, audioPool = self._audioPool, sglCache = self._effectCache4Single, waitings = self._waitingEffIds, pauseds = self._pausedEffIds;
        if (!currEffect && waitings.length == 0 && pauseds.length == 0)return;
        for (var key in sglCache) {
            var eff = sglCache[key];
            if (eff.duration && eff.duration != Infinity)eff.currentTime = eff.duration
        }
        waitings.length = 0;
        pauseds.length =
            0;
        for (var key in audioPool) {
            var list = audioPool[key];
            for (var i = 0, li = list.length; i < li; i++) {
                var eff = list[i];
                eff.loop = false;
                if (eff.duration && eff.duration != Infinity)eff.currentTime = eff.duration
            }
        }
        if (currEffect)self._stopAudio(currEffect)
    }, _effectPauseCb: function () {
        var self = this;
        if (self._isHiddenMode)return;
        var currEffect = self._getWaitingEffToPlay();
        if (currEffect)if (currEffect._isToPlay) {
            delete currEffect._isToPlay;
            currEffect.play()
        } else self._resumeAudio(currEffect); else if (self._needToResumeMusic) {
            var currMusic =
                self._currMusic;
            if (currMusic.duration && currMusic.duration != Infinity) {
                var temp = currMusic.currentTime + self._expendTime4Music;
                temp = temp - currMusic.duration * (temp / currMusic.duration | 0);
                currMusic.currentTime = temp
            }
            self._expendTime4Music = 0;
            self._resumeAudio(currMusic);
            self._musicPlayState = 2;
            self._needToResumeMusic = false
        }
    }, _getWaitingEffToPlay: function () {
        var self = this, waitings = self._waitingEffIds, effects = self._effects, currEffect = self._currEffect;
        var expendTime = currEffect ? currEffect.currentTime - (currEffect.startTime ||
            0) : 0;
        self._expendTime4Music += expendTime;
        while (true) {
            if (waitings.length == 0)break;
            var effId = waitings.pop();
            var eff = effects[effId];
            if (!eff)continue;
            if (eff._isToPlay || eff.loop || eff.duration && eff.currentTime + expendTime < eff.duration) {
                self._currEffectId = effId;
                self._currEffect = eff;
                if (!eff._isToPlay && eff.duration && eff.duration != Infinity) {
                    var temp = eff.currentTime + expendTime;
                    temp = temp - eff.duration * (temp / eff.duration | 0);
                    eff.currentTime = temp
                }
                eff._isToPlay = false;
                return eff
            } else if (eff.duration && eff.duration != Infinity)eff.currentTime =
                eff.duration
        }
        self._currEffectId = null;
        self._currEffect = null;
        return null
    }, _pausePlaying: function () {
        var self = this, currEffect = self._currEffect;
        self._isHiddenMode = true;
        var audio = self._musicPlayState == 2 ? self._currMusic : currEffect;
        if (audio) {
            self._playings.push(audio);
            audio.pause()
        }
    }, _resumePlaying: function () {
        var self = this, playings = self._playings;
        self._isHiddenMode = false;
        if (playings.length > 0) {
            self._resumeAudio(playings[0]);
            playings.length = 0
        }
    }});
cc._audioLoader = {_supportedAudioTypes: null, getBasePath: function () {
    return cc.loader.audioPath
}, _load: function (realUrl, url, res, count, tryArr, audio, cb) {
    var self = this, locLoader = cc.loader, path = cc.path;
    var types = this._supportedAudioTypes;
    var extname = "";
    if (types.length == 0)return cb("can not support audio!");
    if (count == -1) {
        extname = (path.extname(realUrl) || "").toLowerCase();
        if (!self.audioTypeSupported(extname)) {
            extname = types[0];
            count = 0
        }
    } else if (count < types.length)extname = types[count]; else return cb("can not found the resource of audio! Last match url is : " +
        realUrl);
    if (tryArr.indexOf(extname) >= 0)return self._load(realUrl, url, res, count + 1, tryArr, audio, cb);
    realUrl = path.changeExtname(realUrl, extname);
    tryArr.push(extname);
    var delFlag = count == types.length - 1;
    audio = self._loadAudio(realUrl, audio, function (err) {
        if (err)return self._load(realUrl, url, res, count + 1, tryArr, audio, cb);
        cb(null, audio)
    }, delFlag);
    locLoader.cache[url] = audio
}, audioTypeSupported: function (type) {
    if (!type)return false;
    return this._supportedAudioTypes.indexOf(type.toLowerCase()) >= 0
}, _loadAudio: function (url, audio, cb, delFlag) {
    var _Audio = location.origin == "file://" ? Audio : cc.WebAudio || Audio;
    if (arguments.length == 2) {
        cb = audio;
        audio = new _Audio
    } else if (arguments.length > 3 && !audio)audio = new _Audio;
    audio.src = url;
    audio.preload = "auto";
    var ua = navigator.userAgent;
    if (/Mobile/.test(ua) && (/iPhone OS/.test(ua) || /iPad/.test(ua) || /Firefox/.test(ua)) || /MSIE/.test(ua)) {
        audio.load();
        cb(null, audio)
    } else {
        var canplaythrough = "canplaythrough", error = "error";
        cc._addEventListener(audio, canplaythrough, function () {
            cb(null, audio);
            this.removeEventListener(canplaythrough,
                arguments.callee, false);
            this.removeEventListener(error, arguments.callee, false)
        }, false);
        cc._addEventListener(audio, error, function () {
            cb("load " + url + " failed");
            if (delFlag) {
                this.removeEventListener(canplaythrough, arguments.callee, false);
                this.removeEventListener(error, arguments.callee, false)
            }
        }, false);
        audio.load()
    }
    return audio
}, load: function (realUrl, url, res, cb) {
    var tryArr = [];
    this._load(realUrl, url, res, -1, tryArr, null, cb)
}};
cc._audioLoader._supportedAudioTypes = function () {
    var au = cc.newElement("audio"), arr = [];
    if (au.canPlayType) {
        var _check = function (typeStr) {
            var result = au.canPlayType(typeStr);
            return result != "no" && result != ""
        };
        if (_check('audio/ogg; codecs\x3d"vorbis"'))arr.push(".ogg");
        if (_check("audio/mpeg"))arr.push(".mp3");
        if (_check('audio/wav; codecs\x3d"1"'))arr.push(".wav");
        if (_check("audio/mp4"))arr.push(".mp4");
        if (_check("audio/x-m4a") || _check("audio/aac"))arr.push(".m4a")
    }
    return arr
}();
cc.loader.register(["mp3", "ogg", "wav", "mp4", "m4a"], cc._audioLoader);
cc.audioEngine = cc.AudioEngineForSingle ? new cc.AudioEngineForSingle : new cc.AudioEngine;
cc.eventManager.addCustomListener(cc.game.EVENT_HIDE, function () {
    cc.audioEngine._pausePlaying()
});
cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function () {
    cc.audioEngine._resumePlaying()
});cc.kmScalar = Number;
cc.kmBool = Number;
cc.kmEnum = Number;
cc.KM_FALSE = 0;
cc.KM_TRUE = 1;
cc.kmPI = 3.141592;
cc.kmPIOver180 = 0.017453;
cc.kmPIUnder180 = 57.295779;
cc.kmEpsilon = 1 / 64;
cc.kmSQR = function (s) {
    return s * s
};
cc.kmDegreesToRadians = function (degrees) {
    return degrees * cc.kmPIOver180
};
cc.kmRadiansToDegrees = function (radians) {
    return radians * cc.kmPIUnder180
};
cc.kmMin = function (lhs, rhs) {
    return lhs < rhs ? lhs : rhs
};
cc.kmMax = function (lhs, rhs) {
    return lhs > rhs ? lhs : rhs
};
cc.kmAlmostEqual = function (lhs, rhs) {
    return lhs + cc.kmEpsilon > rhs && lhs - cc.kmEpsilon < rhs
};
cc.kmVec2 = function (x, y) {
    this.x = x || 0;
    this.y = y || 0
};
cc.kmVec2Fill = function (pOut, x, y) {
    pOut.x = x;
    pOut.y = y;
    return pOut
};
cc.kmVec2Length = function (pIn) {
    return Math.sqrt(cc.kmSQR(pIn.x) + cc.kmSQR(pIn.y))
};
cc.kmVec2LengthSq = function (pIn) {
    return cc.kmSQR(pIn.x) + cc.kmSQR(pIn.y)
};
cc.kmVec2Normalize = function (pOut, pIn) {
    var l = 1 / cc.kmVec2Length(pIn);
    var v = new cc.kmVec2;
    v.x = pIn.x * l;
    v.y = pIn.y * l;
    pOut.x = v.x;
    pOut.y = v.y;
    return pOut
};
cc.kmVec2Add = function (pOut, pV1, pV2) {
    pOut.x = pV1.x + pV2.x;
    pOut.y = pV1.y + pV2.y;
    return pOut
};
cc.kmVec2Dot = function (pV1, pV2) {
    return pV1.x * pV2.x + pV1.y * pV2.y
};
cc.kmVec2Subtract = function (pOut, pV1, pV2) {
    pOut.x = pV1.x - pV2.x;
    pOut.y = pV1.y - pV2.y;
    return pOut
};
cc.kmVec2Transform = function (pOut, pV, pM) {
    var v = new cc.kmVec2;
    v.x = pV.x * pM.mat[0] + pV.y * pM.mat[3] + pM.mat[6];
    v.y = pV.x * pM.mat[1] + pV.y * pM.mat[4] + pM.mat[7];
    pOut.x = v.x;
    pOut.y = v.y;
    return pOut
};
cc.kmVec2TransformCoord = function (pOut, pV, pM) {
    return null
};
cc.kmVec2Scale = function (pOut, pIn, s) {
    pOut.x = pIn.x * s;
    pOut.y = pIn.y * s;
    return pOut
};
cc.kmVec2AreEqual = function (p1, p2) {
    return p1.x < p2.x + cc.kmEpsilon && p1.x > p2.x - cc.kmEpsilon && p1.y < p2.y + cc.kmEpsilon && p1.y > p2.y - cc.kmEpsilon
};
cc.kmVec3 = function (x, y, z) {
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0
};
cc.kmVec3Fill = function (pOut, x, y, z) {
    if (!pOut)return new cc.kmVec3(x, y, z);
    pOut.x = x;
    pOut.y = y;
    pOut.z = z;
    return pOut
};
cc.kmVec3Length = function (pIn) {
    return Math.sqrt(cc.kmSQR(pIn.x) + cc.kmSQR(pIn.y) + cc.kmSQR(pIn.z))
};
cc.kmVec3LengthSq = function (pIn) {
    return cc.kmSQR(pIn.x) + cc.kmSQR(pIn.y) + cc.kmSQR(pIn.z)
};
cc.kmVec3Normalize = function (pOut, pIn) {
    var l = 1 / cc.kmVec3Length(pIn);
    pOut.x = pIn.x * l;
    pOut.y = pIn.y * l;
    pOut.z = pIn.z * l;
    return pOut
};
cc.kmVec3Cross = function (pOut, pV1, pV2) {
    pOut.x = pV1.y * pV2.z - pV1.z * pV2.y;
    pOut.y = pV1.z * pV2.x - pV1.x * pV2.z;
    pOut.z = pV1.x * pV2.y - pV1.y * pV2.x;
    return pOut
};
cc.kmVec3Dot = function (pV1, pV2) {
    return pV1.x * pV2.x + pV1.y * pV2.y + pV1.z * pV2.z
};
cc.kmVec3Add = function (pOut, pV1, pV2) {
    pOut.x = pV1.x + pV2.x;
    pOut.y = pV1.y + pV2.y;
    pOut.z = pV1.z + pV2.z;
    return pOut
};
cc.kmVec3Subtract = function (pOut, pV1, pV2) {
    pOut.x = pV1.x - pV2.x;
    pOut.y = pV1.y - pV2.y;
    pOut.z = pV1.z - pV2.z;
    return pOut
};
cc.kmVec3Transform = function (pOut, pV, pM) {
    pOut.x = pV.x * pM.mat[0] + pV.y * pM.mat[4] + pV.z * pM.mat[8] + pM.mat[12];
    pOut.y = pV.x * pM.mat[1] + pV.y * pM.mat[5] + pV.z * pM.mat[9] + pM.mat[13];
    pOut.z = pV.x * pM.mat[2] + pV.y * pM.mat[6] + pV.z * pM.mat[10] + pM.mat[14];
    return pOut
};
cc.kmVec3TransformNormal = function (pOut, pV, pM) {
    pOut.x = pV.x * pM.mat[0] + pV.y * pM.mat[4] + pV.z * pM.mat[8];
    pOut.y = pV.x * pM.mat[1] + pV.y * pM.mat[5] + pV.z * pM.mat[9];
    pOut.z = pV.x * pM.mat[2] + pV.y * pM.mat[6] + pV.z * pM.mat[10];
    return pOut
};
cc.kmVec3TransformCoord = function (pOut, pV, pM) {
    var v = new cc.kmVec4;
    var inV = new cc.kmVec4;
    cc.kmVec4Fill(inV, pV.x, pV.y, pV.z, 1);
    cc.kmVec4Transform(v, inV, pM);
    pOut.x = v.x / v.w;
    pOut.y = v.y / v.w;
    pOut.z = v.z / v.w;
    return pOut
};
cc.kmVec3Scale = function (pOut, pIn, s) {
    pOut.x = pIn.x * s;
    pOut.y = pIn.y * s;
    pOut.z = pIn.z * s;
    return pOut
};
cc.kmVec3AreEqual = function (p1, p2) {
    if (p1.x < p2.x + cc.kmEpsilon && p1.x > p2.x - cc.kmEpsilon && p1.y < p2.y + cc.kmEpsilon && p1.y > p2.y - cc.kmEpsilon && p1.z < p2.z + cc.kmEpsilon && p1.z > p2.z - cc.kmEpsilon)return 1;
    return 0
};
cc.kmVec3InverseTransform = function (pOut, pVect, pM) {
    var v1 = new cc.kmVec3(pVect.x - pM.mat[12], pVect.y - pM.mat[13], pVect.z - pM.mat[14]);
    pOut.x = v1.x * pM.mat[0] + v1.y * pM.mat[1] + v1.z * pM.mat[2];
    pOut.y = v1.x * pM.mat[4] + v1.y * pM.mat[5] + v1.z * pM.mat[6];
    pOut.z = v1.x * pM.mat[8] + v1.y * pM.mat[9] + v1.z * pM.mat[10];
    return pOut
};
cc.kmVec3InverseTransformNormal = function (pOut, pVect, pM) {
    pOut.x = pVect.x * pM.mat[0] + pVect.y * pM.mat[1] + pVect.z * pM.mat[2];
    pOut.y = pVect.x * pM.mat[4] + pVect.y * pM.mat[5] + pVect.z * pM.mat[6];
    pOut.z = pVect.x * pM.mat[8] + pVect.y * pM.mat[9] + pVect.z * pM.mat[10];
    return pOut
};
cc.kmVec3Assign = function (pOut, pIn) {
    if (pOut == pIn)return pOut;
    pOut.x = pIn.x;
    pOut.y = pIn.y;
    pOut.z = pIn.z;
    return pOut
};
cc.kmVec3Zero = function (pOut) {
    pOut.x = 0;
    pOut.y = 0;
    pOut.z = 0;
    return pOut
};
cc.kmVec3ToTypeArray = function (vecValue) {
    if (!vecValue)return null;
    var tyArr = new Float32Array(3);
    tyArr[0] = vecValue.x;
    tyArr[1] = vecValue.y;
    tyArr[2] = vecValue.z;
    return tyArr
};
cc.kmVec4 = function (x, y, z, w) {
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
    this.w = w || 0
};
cc.kmVec4Fill = function (outVec, x, y, z, w) {
    outVec.x = x;
    outVec.y = y;
    outVec.z = z;
    outVec.w = w;
    return outVec
};
cc.kmVec4Add = function (outVec, pV1, pV2) {
    outVec.x = pV1.x + pV2.x;
    outVec.y = pV1.y + pV2.y;
    outVec.z = pV1.z + pV2.z;
    outVec.w = pV1.w + pV2.w;
    return outVec
};
cc.kmVec4Dot = function (vec1, vec2) {
    return vec1.x * vec2.x + vec1.y * vec2.y + vec1.z * vec2.z + vec1.w * vec2.w
};
cc.kmVec4Length = function (inVec) {
    return Math.sqrt(cc.kmSQR(inVec.x) + cc.kmSQR(inVec.y) + cc.kmSQR(inVec.z) + cc.kmSQR(inVec.w))
};
cc.kmVec4LengthSq = function (inVec) {
    return cc.kmSQR(inVec.x) + cc.kmSQR(inVec.y) + cc.kmSQR(inVec.z) + cc.kmSQR(inVec.w)
};
cc.kmVec4Lerp = function (outVec, pV1, pV2, t) {
    return outVec
};
cc.kmVec4Normalize = function (outVec, inVec) {
    var l = 1 / cc.kmVec4Length(inVec);
    outVec.x *= l;
    outVec.y *= l;
    outVec.z *= l;
    outVec.w *= l;
    return outVec
};
cc.kmVec4Scale = function (outVec, inVec, scale) {
    cc.kmVec4Normalize(outVec, inVec);
    outVec.x *= scale;
    outVec.y *= scale;
    outVec.z *= scale;
    outVec.w *= scale;
    return outVec
};
cc.kmVec4Subtract = function (outVec, vec1, vec2) {
    outVec.x = vec1.x - vec2.x;
    outVec.y = vec1.y - vec2.y;
    outVec.z = vec1.z - vec2.z;
    outVec.w = vec1.w - vec2.w;
    return outVec
};
cc.kmVec4Transform = function (outVec, vec, mat4Obj) {
    outVec.x = vec.x * mat4Obj.mat[0] + vec.y * mat4Obj.mat[4] + vec.z * mat4Obj.mat[8] + vec.w * mat4Obj.mat[12];
    outVec.y = vec.x * mat4Obj.mat[1] + vec.y * mat4Obj.mat[5] + vec.z * mat4Obj.mat[9] + vec.w * mat4Obj.mat[13];
    outVec.z = vec.x * mat4Obj.mat[2] + vec.y * mat4Obj.mat[6] + vec.z * mat4Obj.mat[10] + vec.w * mat4Obj.mat[14];
    outVec.w = vec.x * mat4Obj.mat[3] + vec.y * mat4Obj.mat[7] + vec.z * mat4Obj.mat[11] + vec.w * mat4Obj.mat[15];
    return outVec
};
cc.kmVec4TransformArray = function (outVec, outStride, vecObj, stride, mat4Obj, count) {
    var i = 0;
    while (i < count) {
        var currIn = vecObj + i * stride;
        var out = outVec + i * outStride;
        cc.kmVec4Transform(out, currIn, mat4Obj);
        ++i
    }
    return outVec
};
cc.kmVec4AreEqual = function (vec1, vec2) {
    return vec1.x < vec2.x + cc.kmEpsilon && vec1.x > vec2.x - cc.kmEpsilon && vec1.y < vec2.y + cc.kmEpsilon && vec1.y > vec2.y - cc.kmEpsilon && vec1.z < vec2.z + cc.kmEpsilon && vec1.z > vec2.z - cc.kmEpsilon && vec1.w < vec2.w + cc.kmEpsilon && vec1.w > vec2.w - cc.kmEpsilon
};
cc.kmVec4Assign = function (destVec, srcVec) {
    if (destVec == srcVec) {
        cc.log("destVec and srcVec are same object");
        return destVec
    }
    destVec.x = srcVec.x;
    destVec.y = srcVec.y;
    destVec.z = srcVec.z;
    destVec.w = srcVec.w;
    return destVec
};
cc.kmVec4ToTypeArray = function (vecValue) {
    if (!vecValue)return null;
    var tyArr = new Float32Array(4);
    tyArr[0] = vecValue.x;
    tyArr[1] = vecValue.y;
    tyArr[2] = vecValue.z;
    tyArr[3] = vecValue.w;
    return tyArr
};
cc.kmRay2 = function (start, dir) {
    this.start = start || new cc.kmVec2;
    this.start = start || new cc.kmVec2
};
cc.kmRay2Fill = function (ray, px, py, vx, vy) {
    ray.start.x = px;
    ray.start.y = py;
    ray.dir.x = vx;
    ray.dir.y = vy
};
cc.kmRay2IntersectLineSegment = function (ray, p1, p2, intersection) {
    var x1 = ray.start.x;
    var y1 = ray.start.y;
    var x2 = ray.start.x + ray.dir.x;
    var y2 = ray.start.y + ray.dir.y;
    var x3 = p1.x;
    var y3 = p1.y;
    var x4 = p2.x;
    var y4 = p2.y;
    var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
    var ua, x, y;
    if (denom > -cc.kmEpsilon && denom < cc.kmEpsilon)return cc.KM_FALSE;
    ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
    x = x1 + ua * (x2 - x1);
    y = y1 + ua * (y2 - y1);
    if (x < cc.kmMin(p1.x, p2.x) - cc.kmEpsilon || x > cc.kmMax(p1.x, p2.x) + cc.kmEpsilon || y < cc.kmMin(p1.y, p2.y) - cc.kmEpsilon ||
        y > cc.kmMax(p1.y, p2.y) + cc.kmEpsilon)return cc.KM_FALSE;
    if (x < cc.kmMin(x1, x2) - cc.kmEpsilon || x > cc.kmMax(x1, x2) + cc.kmEpsilon || y < cc.kmMin(y1, y2) - cc.kmEpsilon || y > cc.kmMax(y1, y2) + cc.kmEpsilon)return cc.KM_FALSE;
    intersection.x = x;
    intersection.y = y;
    return cc.KM_TRUE
};
cc.calculate_line_normal = function (p1, p2, normal_out) {
    var tmp = new cc.kmVec2;
    cc.kmVec2Subtract(tmp, p2, p1);
    normal_out.x = -tmp.y;
    normal_out.y = tmp.x;
    cc.kmVec2Normalize(normal_out, normal_out)
};
cc.kmRay2IntersectTriangle = function (ray, p1, p2, p3, intersection, normal_out) {
    var intersect = new cc.kmVec2;
    var final_intersect = new cc.kmVec2;
    var normal = new cc.kmVec2;
    var distance = 1E4;
    var intersected = cc.KM_FALSE;
    var tmp, this_distance;
    if (cc.kmRay2IntersectLineSegment(ray, p1, p2, intersect)) {
        tmp = new cc.kmVec2;
        intersected = cc.KM_TRUE;
        this_distance = cc.kmVec2Length(cc.kmVec2Subtract(tmp, intersect, ray.start));
        if (this_distance < distance) {
            final_intersect.x = intersect.x;
            final_intersect.y = intersect.y;
            distance = this_distance;
            cc.calculate_line_normal(p1, p2, normal)
        }
    }
    if (cc.kmRay2IntersectLineSegment(ray, p2, p3, intersect)) {
        tmp = new cc.kmVec2;
        intersected = cc.KM_TRUE;
        this_distance = cc.kmVec2Length(cc.kmVec2Subtract(tmp, intersect, ray.start));
        if (this_distance < distance) {
            final_intersect.x = intersect.x;
            final_intersect.y = intersect.y;
            distance = this_distance;
            cc.calculate_line_normal(p2, p3, normal)
        }
    }
    if (cc.kmRay2IntersectLineSegment(ray, p3, p1, intersect)) {
        tmp = new cc.kmVec2;
        intersected = cc.KM_TRUE;
        this_distance = cc.kmVec2Length(cc.kmVec2Subtract(tmp,
            intersect, ray.start));
        if (this_distance < distance) {
            final_intersect.x = intersect.x;
            final_intersect.y = intersect.y;
            distance = this_distance;
            cc.calculate_line_normal(p3, p1, normal)
        }
    }
    if (intersected) {
        intersection.x = final_intersect.x;
        intersection.y = final_intersect.y;
        if (normal_out) {
            normal_out.x = normal.x;
            normal_out.y = normal.y
        }
    }
    return intersected
};
cc.kmRay2IntersectCircle = function (ray, centre, radius, intersection) {
    cc.log("cc.kmRay2IntersectCircle() has not been implemented.")
};
var Float32Array = Float32Array || Array;
cc.kmMat3 = function () {
    this.mat = new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0])
};
cc.kmMat3Fill = function (pOut, pMat) {
    for (var i = 0; i < 9; i++)pOut.mat[i] = pMat;
    return pOut
};
cc.kmMat3Adjugate = function (pOut, pIn) {
    pOut.mat[0] = pIn.mat[4] * pIn.mat[8] - pIn.mat[5] * pIn.mat[7];
    pOut.mat[1] = pIn.mat[2] * pIn.mat[7] - pIn.mat[1] * pIn.mat[8];
    pOut.mat[2] = pIn.mat[1] * pIn.mat[5] - pIn.mat[2] * pIn.mat[4];
    pOut.mat[3] = pIn.mat[5] * pIn.mat[6] - pIn.mat[3] * pIn.mat[8];
    pOut.mat[4] = pIn.mat[0] * pIn.mat[8] - pIn.mat[2] * pIn.mat[6];
    pOut.mat[5] = pIn.mat[2] * pIn.mat[3] - pIn.mat[0] * pIn.mat[5];
    pOut.mat[6] = pIn.mat[3] * pIn.mat[7] - pIn.mat[4] * pIn.mat[6];
    pOut.mat[8] = pIn.mat[0] * pIn.mat[4] - pIn.mat[1] * pIn.mat[3];
    return pOut
};
cc.kmMat3Identity = function (pOut) {
    pOut.mat[1] = pOut.mat[2] = pOut.mat[3] = pOut.mat[5] = pOut.mat[6] = pOut.mat[7] = 0;
    pOut.mat[0] = pOut.mat[4] = pOut.mat[8] = 1;
    return pOut
};
cc.kmMat3Inverse = function (pOut, pDeterminate, pM) {
    var detInv;
    var adjugate = new cc.kmMat3;
    if (pDeterminate === 0)return null;
    detInv = 1 / pDeterminate;
    cc.kmMat3Adjugate(adjugate, pM);
    cc.kmMat3ScalarMultiply(pOut, adjugate, detInv);
    return pOut
};
cc.kmMat3._identity = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
cc.kmMat3IsIdentity = function (pIn) {
    for (var i = 0; i < 9; i++)if (cc.kmMat3._identity[i] !== pIn.mat[i])return false;
    return true
};
cc.kmMat3Transpose = function (pOut, pIn) {
    var z, x;
    for (z = 0; z < 3; ++z)for (x = 0; x < 3; ++x)pOut.mat[z * 3 + x] = pIn.mat[x * 3 + z];
    return pOut
};
cc.kmMat3Determinant = function (pIn) {
    var output;
    output = pIn.mat[0] * pIn.mat[4] * pIn.mat[8] + pIn.mat[1] * pIn.mat[5] * pIn.mat[6] + pIn.mat[2] * pIn.mat[3] * pIn.mat[7];
    output -= pIn.mat[2] * pIn.mat[4] * pIn.mat[6] + pIn.mat[0] * pIn.mat[5] * pIn.mat[7] + pIn.mat[1] * pIn.mat[3] * pIn.mat[8];
    return output
};
cc.kmMat3Multiply = function (pOut, pM1, pM2) {
    var m1 = pM1.mat, m2 = pM2.mat;
    pOut.mat[0] = m1[0] * m2[0] + m1[3] * m2[1] + m1[6] * m2[2];
    pOut.mat[1] = m1[1] * m2[0] + m1[4] * m2[1] + m1[7] * m2[2];
    pOut.mat[2] = m1[2] * m2[0] + m1[5] * m2[1] + m1[8] * m2[2];
    pOut.mat[3] = m1[0] * m2[3] + m1[3] * m2[4] + m1[6] * m2[5];
    pOut.mat[4] = m1[1] * m2[3] + m1[4] * m2[4] + m1[7] * m2[5];
    pOut.mat[5] = m1[2] * m2[3] + m1[5] * m2[4] + m1[8] * m2[5];
    pOut.mat[6] = m1[0] * m2[6] + m1[3] * m2[7] + m1[6] * m2[8];
    pOut.mat[7] = m1[1] * m2[6] + m1[4] * m2[7] + m1[7] * m2[8];
    pOut.mat[8] = m1[2] * m2[6] + m1[5] * m2[7] + m1[8] * m2[8];
    return pOut
};
cc.kmMat3ScalarMultiply = function (pOut, pM, pFactor) {
    for (var i = 0; i < 9; i++)pOut.mat[i] = pM.mat[i] * pFactor;
    return pOut
};
cc.kmMat3RotationAxisAngle = function (pOut, axis, radians) {
    var rcos = Math.cos(radians);
    var rsin = Math.sin(radians);
    pOut.mat[0] = rcos + axis.x * axis.x * (1 - rcos);
    pOut.mat[1] = axis.z * rsin + axis.y * axis.x * (1 - rcos);
    pOut.mat[2] = -axis.y * rsin + axis.z * axis.x * (1 - rcos);
    pOut.mat[3] = -axis.z * rsin + axis.x * axis.y * (1 - rcos);
    pOut.mat[4] = rcos + axis.y * axis.y * (1 - rcos);
    pOut.mat[5] = axis.x * rsin + axis.z * axis.y * (1 - rcos);
    pOut.mat[6] = axis.y * rsin + axis.x * axis.z * (1 - rcos);
    pOut.mat[7] = -axis.x * rsin + axis.y * axis.z * (1 - rcos);
    pOut.mat[8] = rcos + axis.z * axis.z *
        (1 - rcos);
    return pOut
};
cc.kmMat3Assign = function (pOut, pIn) {
    if (pOut == pIn) {
        cc.log("cc.kmMat3Assign(): pOut equals pIn");
        return pOut
    }
    for (var i = 0; i < 9; i++)pOut.mat[i] = pIn.mat[i];
    return pOut
};
cc.kmMat3AreEqual = function (pMat1, pMat2) {
    if (pMat1 == pMat2)return true;
    for (var i = 0; i < 9; ++i)if (!(pMat1.mat[i] + cc.kmEpsilon > pMat2.mat[i] && pMat1.mat[i] - cc.kmEpsilon < pMat2.mat[i]))return false;
    return true
};
cc.kmMat3RotationX = function (pOut, radians) {
    pOut.mat[0] = 1;
    pOut.mat[1] = 0;
    pOut.mat[2] = 0;
    pOut.mat[3] = 0;
    pOut.mat[4] = Math.cos(radians);
    pOut.mat[5] = Math.sin(radians);
    pOut.mat[6] = 0;
    pOut.mat[7] = -Math.sin(radians);
    pOut.mat[8] = Math.cos(radians);
    return pOut
};
cc.kmMat3RotationY = function (pOut, radians) {
    pOut.mat[0] = Math.cos(radians);
    pOut.mat[1] = 0;
    pOut.mat[2] = -Math.sin(radians);
    pOut.mat[3] = 0;
    pOut.mat[4] = 1;
    pOut.mat[5] = 0;
    pOut.mat[6] = Math.sin(radians);
    pOut.mat[7] = 0;
    pOut.mat[8] = Math.cos(radians);
    return pOut
};
cc.kmMat3RotationZ = function (pOut, radians) {
    pOut.mat[0] = Math.cos(radians);
    pOut.mat[1] = -Math.sin(radians);
    pOut.mat[2] = 0;
    pOut.mat[3] = Math.sin(radians);
    pOut.mat[4] = Math.cos(radians);
    pOut.mat[5] = 0;
    pOut.mat[6] = 0;
    pOut.mat[7] = 0;
    pOut.mat[8] = 1;
    return pOut
};
cc.kmMat3Rotation = function (pOut, radians) {
    pOut.mat[0] = Math.cos(radians);
    pOut.mat[1] = Math.sin(radians);
    pOut.mat[2] = 0;
    pOut.mat[3] = -Math.sin(radians);
    pOut.mat[4] = Math.cos(radians);
    pOut.mat[5] = 0;
    pOut.mat[6] = 0;
    pOut.mat[7] = 0;
    pOut.mat[8] = 1;
    return pOut
};
cc.kmMat3Scaling = function (pOut, x, y) {
    cc.kmMat3Identity(pOut);
    pOut.mat[0] = x;
    pOut.mat[4] = y;
    return pOut
};
cc.kmMat3Translation = function (pOut, x, y) {
    cc.kmMat3Identity(pOut);
    pOut.mat[6] = x;
    pOut.mat[7] = y;
    return pOut
};
cc.kmMat3RotationQuaternion = function (pOut, pIn) {
    if (!pIn || !pOut)return null;
    pOut.mat[0] = 1 - 2 * (pIn.y * pIn.y + pIn.z * pIn.z);
    pOut.mat[1] = 2 * (pIn.x * pIn.y - pIn.w * pIn.z);
    pOut.mat[2] = 2 * (pIn.x * pIn.z + pIn.w * pIn.y);
    pOut.mat[3] = 2 * (pIn.x * pIn.y + pIn.w * pIn.z);
    pOut.mat[4] = 1 - 2 * (pIn.x * pIn.x + pIn.z * pIn.z);
    pOut.mat[5] = 2 * (pIn.y * pIn.z - pIn.w * pIn.x);
    pOut.mat[6] = 2 * (pIn.x * pIn.z - pIn.w * pIn.y);
    pOut.mat[7] = 2 * (pIn.y * pIn.z + pIn.w * pIn.x);
    pOut.mat[8] = 1 - 2 * (pIn.x * pIn.x + pIn.y * pIn.y);
    return pOut
};
cc.kmMat3RotationToAxisAngle = function (pAxis, radians, pIn) {
    var temp;
    cc.kmQuaternionRotationMatrix(temp, pIn);
    cc.kmQuaternionToAxisAngle(temp, pAxis, radians);
    return pAxis
};
cc.kmMat4 = function () {
    this.mat = new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
};
cc.kmMat4Fill = function (pOut, pMat) {
    pOut.mat[0] = pOut.mat[1] = pOut.mat[2] = pOut.mat[3] = pOut.mat[4] = pOut.mat[5] = pOut.mat[6] = pOut.mat[7] = pOut.mat[8] = pOut.mat[9] = pOut.mat[10] = pOut.mat[11] = pOut.mat[12] = pOut.mat[13] = pOut.mat[14] = pOut.mat[15] = pMat
};
cc.kmMat4Identity = function (pOut) {
    pOut.mat[1] = pOut.mat[2] = pOut.mat[3] = pOut.mat[4] = pOut.mat[6] = pOut.mat[7] = pOut.mat[8] = pOut.mat[9] = pOut.mat[11] = pOut.mat[12] = pOut.mat[13] = pOut.mat[14] = 0;
    pOut.mat[0] = pOut.mat[5] = pOut.mat[10] = pOut.mat[15] = 1;
    return pOut
};
cc.kmMat4._get = function (pIn, row, col) {
    return pIn.mat[row + 4 * col]
};
cc.kmMat4._set = function (pIn, row, col, value) {
    pIn.mat[row + 4 * col] = value
};
cc.kmMat4._swap = function (pIn, r1, c1, r2, c2) {
    var tmp = cc.kmMat4._get(pIn, r1, c1);
    cc.kmMat4._set(pIn, r1, c1, cc.kmMat4._get(pIn, r2, c2));
    cc.kmMat4._set(pIn, r2, c2, tmp)
};
cc.kmMat4._gaussj = function (a, b) {
    var i, icol = 0, irow = 0, j, k, l, ll, n = 4, m = 4;
    var big, dum, pivinv;
    var indxc = [0, 0, 0, 0];
    var indxr = [0, 0, 0, 0];
    var ipiv = [0, 0, 0, 0];
    for (i = 0; i < n; i++) {
        big = 0;
        for (j = 0; j < n; j++)if (ipiv[j] != 1)for (k = 0; k < n; k++)if (ipiv[k] == 0)if (Math.abs(cc.kmMat4._get(a, j, k)) >= big) {
            big = Math.abs(cc.kmMat4._get(a, j, k));
            irow = j;
            icol = k
        }
        ++ipiv[icol];
        if (irow != icol) {
            for (l = 0; l < n; l++)cc.kmMat4._swap(a, irow, l, icol, l);
            for (l = 0; l < m; l++)cc.kmMat4._swap(b, irow, l, icol, l)
        }
        indxr[i] = irow;
        indxc[i] = icol;
        if (cc.kmMat4._get(a, icol, icol) ==
            0)return cc.KM_FALSE;
        pivinv = 1 / cc.kmMat4._get(a, icol, icol);
        cc.kmMat4._set(a, icol, icol, 1);
        for (l = 0; l < n; l++)cc.kmMat4._set(a, icol, l, cc.kmMat4._get(a, icol, l) * pivinv);
        for (l = 0; l < m; l++)cc.kmMat4._set(b, icol, l, cc.kmMat4._get(b, icol, l) * pivinv);
        for (ll = 0; ll < n; ll++)if (ll != icol) {
            dum = cc.kmMat4._get(a, ll, icol);
            cc.kmMat4._set(a, ll, icol, 0);
            for (l = 0; l < n; l++)cc.kmMat4._set(a, ll, l, cc.kmMat4._get(a, ll, l) - cc.kmMat4._get(a, icol, l) * dum);
            for (l = 0; l < m; l++)cc.kmMat4._set(b, ll, l, cc.kmMat4._get(a, ll, l) - cc.kmMat4._get(b, icol, l) *
                dum)
        }
    }
    for (l = n - 1; l >= 0; l--)if (indxr[l] != indxc[l])for (k = 0; k < n; k++)cc.kmMat4._swap(a, k, indxr[l], k, indxc[l]);
    return cc.KM_TRUE
};
cc.kmMat4._identity = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
cc.kmMat4Inverse = function (pOut, pM) {
    var inv = new cc.kmMat4;
    var tmp = new cc.kmMat4;
    cc.kmMat4Assign(inv, pM);
    cc.kmMat4Identity(tmp);
    if (cc.kmMat4._gaussj(inv, tmp) == cc.KM_FALSE)return null;
    cc.kmMat4Assign(pOut, inv);
    return pOut
};
cc.kmMat4IsIdentity = function (pIn) {
    for (var i = 0; i < 16; i++)if (cc.kmMat4._identity[i] != pIn.mat[i])return false;
    return true
};
cc.kmMat4Transpose = function (pOut, pIn) {
    var x, z, outArr = pOut.mat, inArr = pIn.mat;
    for (z = 0; z < 4; ++z)for (x = 0; x < 4; ++x)outArr[z * 4 + x] = inArr[x * 4 + z];
    return pOut
};
cc.kmMat4Multiply = function (pOut, pM1, pM2) {
    var outArray = pOut.mat;
    var a00 = pM1.mat[0], a01 = pM1.mat[1], a02 = pM1.mat[2], a03 = pM1.mat[3];
    var a10 = pM1.mat[4], a11 = pM1.mat[5], a12 = pM1.mat[6], a13 = pM1.mat[7];
    var a20 = pM1.mat[8], a21 = pM1.mat[9], a22 = pM1.mat[10], a23 = pM1.mat[11];
    var a30 = pM1.mat[12], a31 = pM1.mat[13], a32 = pM1.mat[14], a33 = pM1.mat[15];
    var b00 = pM2.mat[0], b01 = pM2.mat[1], b02 = pM2.mat[2], b03 = pM2.mat[3];
    var b10 = pM2.mat[4], b11 = pM2.mat[5], b12 = pM2.mat[6], b13 = pM2.mat[7];
    var b20 = pM2.mat[8], b21 = pM2.mat[9], b22 = pM2.mat[10],
        b23 = pM2.mat[11];
    var b30 = pM2.mat[12], b31 = pM2.mat[13], b32 = pM2.mat[14], b33 = pM2.mat[15];
    outArray[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;
    outArray[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;
    outArray[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;
    outArray[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;
    outArray[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;
    outArray[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;
    outArray[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;
    outArray[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;
    outArray[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;
    outArray[9] = b20 * a01 + b21 *
        a11 + b22 * a21 + b23 * a31;
    outArray[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;
    outArray[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;
    outArray[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;
    outArray[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;
    outArray[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;
    outArray[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;
    return pOut
};
cc.getMat4MultiplyValue = function (pM1, pM2) {
    var m1 = pM1.mat, m2 = pM2.mat;
    var mat = new Float32Array(16);
    mat[0] = m1[0] * m2[0] + m1[4] * m2[1] + m1[8] * m2[2] + m1[12] * m2[3];
    mat[1] = m1[1] * m2[0] + m1[5] * m2[1] + m1[9] * m2[2] + m1[13] * m2[3];
    mat[2] = m1[2] * m2[0] + m1[6] * m2[1] + m1[10] * m2[2] + m1[14] * m2[3];
    mat[3] = m1[3] * m2[0] + m1[7] * m2[1] + m1[11] * m2[2] + m1[15] * m2[3];
    mat[4] = m1[0] * m2[4] + m1[4] * m2[5] + m1[8] * m2[6] + m1[12] * m2[7];
    mat[5] = m1[1] * m2[4] + m1[5] * m2[5] + m1[9] * m2[6] + m1[13] * m2[7];
    mat[6] = m1[2] * m2[4] + m1[6] * m2[5] + m1[10] * m2[6] + m1[14] * m2[7];
    mat[7] = m1[3] *
        m2[4] + m1[7] * m2[5] + m1[11] * m2[6] + m1[15] * m2[7];
    mat[8] = m1[0] * m2[8] + m1[4] * m2[9] + m1[8] * m2[10] + m1[12] * m2[11];
    mat[9] = m1[1] * m2[8] + m1[5] * m2[9] + m1[9] * m2[10] + m1[13] * m2[11];
    mat[10] = m1[2] * m2[8] + m1[6] * m2[9] + m1[10] * m2[10] + m1[14] * m2[11];
    mat[11] = m1[3] * m2[8] + m1[7] * m2[9] + m1[11] * m2[10] + m1[15] * m2[11];
    mat[12] = m1[0] * m2[12] + m1[4] * m2[13] + m1[8] * m2[14] + m1[12] * m2[15];
    mat[13] = m1[1] * m2[12] + m1[5] * m2[13] + m1[9] * m2[14] + m1[13] * m2[15];
    mat[14] = m1[2] * m2[12] + m1[6] * m2[13] + m1[10] * m2[14] + m1[14] * m2[15];
    mat[15] = m1[3] * m2[12] + m1[7] * m2[13] + m1[11] *
        m2[14] + m1[15] * m2[15];
    return mat
};
cc.getMat4MultiplyWithMat4 = function (pM1, pM2, swapMat) {
    var m1 = pM1.mat, m2 = pM2.mat;
    var mat = swapMat.mat;
    mat[0] = m1[0] * m2[0] + m1[4] * m2[1] + m1[8] * m2[2] + m1[12] * m2[3];
    mat[1] = m1[1] * m2[0] + m1[5] * m2[1] + m1[9] * m2[2] + m1[13] * m2[3];
    mat[2] = m1[2] * m2[0] + m1[6] * m2[1] + m1[10] * m2[2] + m1[14] * m2[3];
    mat[3] = m1[3] * m2[0] + m1[7] * m2[1] + m1[11] * m2[2] + m1[15] * m2[3];
    mat[4] = m1[0] * m2[4] + m1[4] * m2[5] + m1[8] * m2[6] + m1[12] * m2[7];
    mat[5] = m1[1] * m2[4] + m1[5] * m2[5] + m1[9] * m2[6] + m1[13] * m2[7];
    mat[6] = m1[2] * m2[4] + m1[6] * m2[5] + m1[10] * m2[6] + m1[14] * m2[7];
    mat[7] =
        m1[3] * m2[4] + m1[7] * m2[5] + m1[11] * m2[6] + m1[15] * m2[7];
    mat[8] = m1[0] * m2[8] + m1[4] * m2[9] + m1[8] * m2[10] + m1[12] * m2[11];
    mat[9] = m1[1] * m2[8] + m1[5] * m2[9] + m1[9] * m2[10] + m1[13] * m2[11];
    mat[10] = m1[2] * m2[8] + m1[6] * m2[9] + m1[10] * m2[10] + m1[14] * m2[11];
    mat[11] = m1[3] * m2[8] + m1[7] * m2[9] + m1[11] * m2[10] + m1[15] * m2[11];
    mat[12] = m1[0] * m2[12] + m1[4] * m2[13] + m1[8] * m2[14] + m1[12] * m2[15];
    mat[13] = m1[1] * m2[12] + m1[5] * m2[13] + m1[9] * m2[14] + m1[13] * m2[15];
    mat[14] = m1[2] * m2[12] + m1[6] * m2[13] + m1[10] * m2[14] + m1[14] * m2[15];
    mat[15] = m1[3] * m2[12] + m1[7] * m2[13] +
        m1[11] * m2[14] + m1[15] * m2[15];
    return swapMat.mat
};
cc.kmMat4Assign = function (pOut, pIn) {
    if (pOut == pIn) {
        cc.log("cc.kmMat4Assign(): pOut equals pIn");
        return pOut
    }
    var outArr = pOut.mat;
    var inArr = pIn.mat;
    outArr[0] = inArr[0];
    outArr[1] = inArr[1];
    outArr[2] = inArr[2];
    outArr[3] = inArr[3];
    outArr[4] = inArr[4];
    outArr[5] = inArr[5];
    outArr[6] = inArr[6];
    outArr[7] = inArr[7];
    outArr[8] = inArr[8];
    outArr[9] = inArr[9];
    outArr[10] = inArr[10];
    outArr[11] = inArr[11];
    outArr[12] = inArr[12];
    outArr[13] = inArr[13];
    outArr[14] = inArr[14];
    outArr[15] = inArr[15];
    return pOut
};
cc.kmMat4AreEqual = function (pMat1, pMat2) {
    if (pMat1 == pMat2) {
        cc.log("cc.kmMat4AreEqual(): pMat1 and pMat2 are same object.");
        return true
    }
    for (var i = 0; i < 16; i++)if (!(pMat1.mat[i] + cc.kmEpsilon > pMat2.mat[i] && pMat1.mat[i] - cc.kmEpsilon < pMat2.mat[i]))return false;
    return true
};
cc.kmMat4RotationX = function (pOut, radians) {
    pOut.mat[0] = 1;
    pOut.mat[1] = 0;
    pOut.mat[2] = 0;
    pOut.mat[3] = 0;
    pOut.mat[4] = 0;
    pOut.mat[5] = Math.cos(radians);
    pOut.mat[6] = Math.sin(radians);
    pOut.mat[7] = 0;
    pOut.mat[8] = 0;
    pOut.mat[9] = -Math.sin(radians);
    pOut.mat[10] = Math.cos(radians);
    pOut.mat[11] = 0;
    pOut.mat[12] = 0;
    pOut.mat[13] = 0;
    pOut.mat[14] = 0;
    pOut.mat[15] = 1;
    return pOut
};
cc.kmMat4RotationY = function (pOut, radians) {
    pOut.mat[0] = Math.cos(radians);
    pOut.mat[1] = 0;
    pOut.mat[2] = -Math.sin(radians);
    pOut.mat[3] = 0;
    pOut.mat[4] = 0;
    pOut.mat[5] = 1;
    pOut.mat[6] = 0;
    pOut.mat[7] = 0;
    pOut.mat[8] = Math.sin(radians);
    pOut.mat[9] = 0;
    pOut.mat[10] = Math.cos(radians);
    pOut.mat[11] = 0;
    pOut.mat[12] = 0;
    pOut.mat[13] = 0;
    pOut.mat[14] = 0;
    pOut.mat[15] = 1;
    return pOut
};
cc.kmMat4RotationZ = function (pOut, radians) {
    pOut.mat[0] = Math.cos(radians);
    pOut.mat[1] = Math.sin(radians);
    pOut.mat[2] = 0;
    pOut.mat[3] = 0;
    pOut.mat[4] = -Math.sin(radians);
    pOut.mat[5] = Math.cos(radians);
    pOut.mat[6] = 0;
    pOut.mat[7] = 0;
    pOut.mat[8] = 0;
    pOut.mat[9] = 0;
    pOut.mat[10] = 1;
    pOut.mat[11] = 0;
    pOut.mat[12] = 0;
    pOut.mat[13] = 0;
    pOut.mat[14] = 0;
    pOut.mat[15] = 1;
    return pOut
};
cc.kmMat4RotationPitchYawRoll = function (pOut, pitch, yaw, roll) {
    var cr = Math.cos(pitch);
    var sr = Math.sin(pitch);
    var cp = Math.cos(yaw);
    var sp = Math.sin(yaw);
    var cy = Math.cos(roll);
    var sy = Math.sin(roll);
    var srsp = sr * sp;
    var crsp = cr * sp;
    pOut.mat[0] = cp * cy;
    pOut.mat[4] = cp * sy;
    pOut.mat[8] = -sp;
    pOut.mat[1] = srsp * cy - cr * sy;
    pOut.mat[5] = srsp * sy + cr * cy;
    pOut.mat[9] = sr * cp;
    pOut.mat[2] = crsp * cy + sr * sy;
    pOut.mat[6] = crsp * sy - sr * cy;
    pOut.mat[10] = cr * cp;
    pOut.mat[3] = pOut.mat[7] = pOut.mat[11] = 0;
    pOut.mat[15] = 1;
    return pOut
};
cc.kmMat4RotationQuaternion = function (pOut, pQ) {
    pOut.mat[0] = 1 - 2 * (pQ.y * pQ.y + pQ.z * pQ.z);
    pOut.mat[1] = 2 * (pQ.x * pQ.y + pQ.z * pQ.w);
    pOut.mat[2] = 2 * (pQ.x * pQ.z - pQ.y * pQ.w);
    pOut.mat[3] = 0;
    pOut.mat[4] = 2 * (pQ.x * pQ.y - pQ.z * pQ.w);
    pOut.mat[5] = 1 - 2 * (pQ.x * pQ.x + pQ.z * pQ.z);
    pOut.mat[6] = 2 * (pQ.z * pQ.y + pQ.x * pQ.w);
    pOut.mat[7] = 0;
    pOut.mat[8] = 2 * (pQ.x * pQ.z + pQ.y * pQ.w);
    pOut.mat[9] = 2 * (pQ.y * pQ.z - pQ.x * pQ.w);
    pOut.mat[10] = 1 - 2 * (pQ.x * pQ.x + pQ.y * pQ.y);
    pOut.mat[11] = 0;
    pOut.mat[12] = 0;
    pOut.mat[13] = 0;
    pOut.mat[14] = 0;
    pOut.mat[15] = 1;
    return pOut
};
cc.kmMat4RotationTranslation = function (pOut, rotation, translation) {
    pOut.mat[0] = rotation.mat[0];
    pOut.mat[1] = rotation.mat[1];
    pOut.mat[2] = rotation.mat[2];
    pOut.mat[3] = 0;
    pOut.mat[4] = rotation.mat[3];
    pOut.mat[5] = rotation.mat[4];
    pOut.mat[6] = rotation.mat[5];
    pOut.mat[7] = 0;
    pOut.mat[8] = rotation.mat[6];
    pOut.mat[9] = rotation.mat[7];
    pOut.mat[10] = rotation.mat[8];
    pOut.mat[11] = 0;
    pOut.mat[12] = translation.x;
    pOut.mat[13] = translation.y;
    pOut.mat[14] = translation.z;
    pOut.mat[15] = 1;
    return pOut
};
cc.kmMat4Scaling = function (pOut, x, y, z) {
    pOut.mat[0] = x;
    pOut.mat[5] = y;
    pOut.mat[10] = z;
    pOut.mat[15] = 1;
    pOut.mat[1] = pOut.mat[2] = pOut.mat[3] = pOut.mat[4] = pOut.mat[6] = pOut.mat[7] = pOut.mat[8] = pOut.mat[9] = pOut.mat[11] = pOut.mat[12] = pOut.mat[13] = pOut.mat[14] = 0;
    return pOut
};
cc.kmMat4Translation = function (pOut, x, y, z) {
    pOut.mat[0] = pOut.mat[5] = pOut.mat[10] = pOut.mat[15] = 1;
    pOut.mat[1] = pOut.mat[2] = pOut.mat[3] = pOut.mat[4] = pOut.mat[6] = pOut.mat[7] = pOut.mat[8] = pOut.mat[9] = pOut.mat[11] = 0;
    pOut.mat[12] = x;
    pOut.mat[13] = y;
    pOut.mat[14] = z;
    return pOut
};
cc.kmMat4GetUpVec3 = function (pOut, pIn) {
    pOut.x = pIn.mat[4];
    pOut.y = pIn.mat[5];
    pOut.z = pIn.mat[6];
    cc.kmVec3Normalize(pOut, pOut);
    return pOut
};
cc.kmMat4GetRightVec3 = function (pOut, pIn) {
    pOut.x = pIn.mat[0];
    pOut.y = pIn.mat[1];
    pOut.z = pIn.mat[2];
    cc.kmVec3Normalize(pOut, pOut);
    return pOut
};
cc.kmMat4GetForwardVec3 = function (pOut, pIn) {
    pOut.x = pIn.mat[8];
    pOut.y = pIn.mat[9];
    pOut.z = pIn.mat[10];
    cc.kmVec3Normalize(pOut, pOut);
    return pOut
};
cc.kmMat4PerspectiveProjection = function (pOut, fovY, aspect, zNear, zFar) {
    var r = cc.kmDegreesToRadians(fovY / 2);
    var deltaZ = zFar - zNear;
    var s = Math.sin(r);
    if (deltaZ == 0 || s == 0 || aspect == 0)return null;
    var cotangent = Math.cos(r) / s;
    cc.kmMat4Identity(pOut);
    pOut.mat[0] = cotangent / aspect;
    pOut.mat[5] = cotangent;
    pOut.mat[10] = -(zFar + zNear) / deltaZ;
    pOut.mat[11] = -1;
    pOut.mat[14] = -2 * zNear * zFar / deltaZ;
    pOut.mat[15] = 0;
    return pOut
};
cc.kmMat4OrthographicProjection = function (pOut, left, right, bottom, top, nearVal, farVal) {
    cc.kmMat4Identity(pOut);
    pOut.mat[0] = 2 / (right - left);
    pOut.mat[5] = 2 / (top - bottom);
    pOut.mat[10] = -2 / (farVal - nearVal);
    pOut.mat[12] = -((right + left) / (right - left));
    pOut.mat[13] = -((top + bottom) / (top - bottom));
    pOut.mat[14] = -((farVal + nearVal) / (farVal - nearVal));
    return pOut
};
cc.kmMat4LookAt = function (pOut, pEye, pCenter, pUp) {
    var f = new cc.kmVec3, up = new cc.kmVec3, s = new cc.kmVec3, u = new cc.kmVec3;
    var translate = new cc.kmMat4;
    cc.kmVec3Subtract(f, pCenter, pEye);
    cc.kmVec3Normalize(f, f);
    cc.kmVec3Assign(up, pUp);
    cc.kmVec3Normalize(up, up);
    cc.kmVec3Cross(s, f, up);
    cc.kmVec3Normalize(s, s);
    cc.kmVec3Cross(u, s, f);
    cc.kmVec3Normalize(s, s);
    cc.kmMat4Identity(pOut);
    pOut.mat[0] = s.x;
    pOut.mat[4] = s.y;
    pOut.mat[8] = s.z;
    pOut.mat[1] = u.x;
    pOut.mat[5] = u.y;
    pOut.mat[9] = u.z;
    pOut.mat[2] = -f.x;
    pOut.mat[6] = -f.y;
    pOut.mat[10] = -f.z;
    cc.kmMat4Translation(translate, -pEye.x, -pEye.y, -pEye.z);
    cc.kmMat4Multiply(pOut, pOut, translate);
    return pOut
};
cc.kmMat4RotationAxisAngle = function (pOut, axis, radians) {
    var rcos = Math.cos(radians);
    var rsin = Math.sin(radians);
    var normalizedAxis = new cc.kmVec3;
    cc.kmVec3Normalize(normalizedAxis, axis);
    pOut.mat[0] = rcos + normalizedAxis.x * normalizedAxis.x * (1 - rcos);
    pOut.mat[1] = normalizedAxis.z * rsin + normalizedAxis.y * normalizedAxis.x * (1 - rcos);
    pOut.mat[2] = -normalizedAxis.y * rsin + normalizedAxis.z * normalizedAxis.x * (1 - rcos);
    pOut.mat[3] = 0;
    pOut.mat[4] = -normalizedAxis.z * rsin + normalizedAxis.x * normalizedAxis.y * (1 - rcos);
    pOut.mat[5] =
        rcos + normalizedAxis.y * normalizedAxis.y * (1 - rcos);
    pOut.mat[6] = normalizedAxis.x * rsin + normalizedAxis.z * normalizedAxis.y * (1 - rcos);
    pOut.mat[7] = 0;
    pOut.mat[8] = normalizedAxis.y * rsin + normalizedAxis.x * normalizedAxis.z * (1 - rcos);
    pOut.mat[9] = -normalizedAxis.x * rsin + normalizedAxis.y * normalizedAxis.z * (1 - rcos);
    pOut.mat[10] = rcos + normalizedAxis.z * normalizedAxis.z * (1 - rcos);
    pOut.mat[11] = 0;
    pOut.mat[12] = 0;
    pOut.mat[13] = 0;
    pOut.mat[14] = 0;
    pOut.mat[15] = 1;
    return pOut
};
cc.kmMat4ExtractRotation = function (pOut, pIn) {
    pOut.mat[0] = pIn.mat[0];
    pOut.mat[1] = pIn.mat[1];
    pOut.mat[2] = pIn.mat[2];
    pOut.mat[3] = pIn.mat[4];
    pOut.mat[4] = pIn.mat[5];
    pOut.mat[5] = pIn.mat[6];
    pOut.mat[6] = pIn.mat[8];
    pOut.mat[7] = pIn.mat[9];
    pOut.mat[8] = pIn.mat[10];
    return pOut
};
cc.kmMat4ExtractPlane = function (pOut, pIn, plane) {
    switch (plane) {
        case cc.KM_PLANE_RIGHT:
            pOut.a = pIn.mat[3] - pIn.mat[0];
            pOut.b = pIn.mat[7] - pIn.mat[4];
            pOut.c = pIn.mat[11] - pIn.mat[8];
            pOut.d = pIn.mat[15] - pIn.mat[12];
            break;
        case cc.KM_PLANE_LEFT:
            pOut.a = pIn.mat[3] + pIn.mat[0];
            pOut.b = pIn.mat[7] + pIn.mat[4];
            pOut.c = pIn.mat[11] + pIn.mat[8];
            pOut.d = pIn.mat[15] + pIn.mat[12];
            break;
        case cc.KM_PLANE_BOTTOM:
            pOut.a = pIn.mat[3] + pIn.mat[1];
            pOut.b = pIn.mat[7] + pIn.mat[5];
            pOut.c = pIn.mat[11] + pIn.mat[9];
            pOut.d = pIn.mat[15] + pIn.mat[13];
            break;
        case cc.KM_PLANE_TOP:
            pOut.a = pIn.mat[3] - pIn.mat[1];
            pOut.b = pIn.mat[7] - pIn.mat[5];
            pOut.c = pIn.mat[11] - pIn.mat[9];
            pOut.d = pIn.mat[15] - pIn.mat[13];
            break;
        case cc.KM_PLANE_FAR:
            pOut.a = pIn.mat[3] - pIn.mat[2];
            pOut.b = pIn.mat[7] - pIn.mat[6];
            pOut.c = pIn.mat[11] - pIn.mat[10];
            pOut.d = pIn.mat[15] - pIn.mat[14];
            break;
        case cc.KM_PLANE_NEAR:
            pOut.a = pIn.mat[3] + pIn.mat[2];
            pOut.b = pIn.mat[7] + pIn.mat[6];
            pOut.c = pIn.mat[11] + pIn.mat[10];
            pOut.d = pIn.mat[15] + pIn.mat[14];
            break;
        default:
            cc.log("cc.kmMat4ExtractPlane(): Invalid plane index");
            break
    }
    var t = Math.sqrt(pOut.a * pOut.a + pOut.b * pOut.b + pOut.c * pOut.c);
    pOut.a /= t;
    pOut.b /= t;
    pOut.c /= t;
    pOut.d /= t;
    return pOut
};
cc.kmMat4RotationToAxisAngle = function (pAxis, radians, pIn) {
    var temp = new cc.kmQuaternion;
    var rotation = new cc.kmMat3;
    cc.kmMat4ExtractRotation(rotation, pIn);
    cc.kmQuaternionRotationMatrix(temp, rotation);
    cc.kmQuaternionToAxisAngle(temp, pAxis, radians);
    return pAxis
};
cc.KM_PLANE_LEFT = 0;
cc.KM_PLANE_RIGHT = 1;
cc.KM_PLANE_BOTTOM = 2;
cc.KM_PLANE_TOP = 3;
cc.KM_PLANE_NEAR = 4;
cc.KM_PLANE_FAR = 5;
cc.kmPlane = function (a, b, c, d) {
    this.a = a || 0;
    this.b = b || 0;
    this.c = c || 0;
    this.d = d || 0
};
cc.POINT_INFRONT_OF_PLANE = 0;
cc.POINT_BEHIND_PLANE = 1;
cc.POINT_ON_PLANE = 2;
cc.kmPlaneDot = function (pP, pV) {
    return pP.a * pV.x + pP.b * pV.y + pP.c * pV.z + pP.d * pV.w
};
cc.kmPlaneDotCoord = function (pP, pV) {
    return pP.a * pV.x + pP.b * pV.y + pP.c * pV.z + pP.d
};
cc.kmPlaneDotNormal = function (pP, pV) {
    return pP.a * pV.x + pP.b * pV.y + pP.c * pV.z
};
cc.kmPlaneFromPointNormal = function (pOut, pPoint, pNormal) {
    pOut.a = pNormal.x;
    pOut.b = pNormal.y;
    pOut.c = pNormal.z;
    pOut.d = -cc.kmVec3Dot(pNormal, pPoint);
    return pOut
};
cc.kmPlaneFromPoints = function (pOut, p1, p2, p3) {
    var n = new cc.kmVec3, v1 = new cc.kmVec3, v2 = new cc.kmVec3;
    cc.kmVec3Subtract(v1, p2, p1);
    cc.kmVec3Subtract(v2, p3, p1);
    cc.kmVec3Cross(n, v1, v2);
    cc.kmVec3Normalize(n, n);
    pOut.a = n.x;
    pOut.b = n.y;
    pOut.c = n.z;
    pOut.d = cc.kmVec3Dot(cc.kmVec3Scale(n, n, -1), p1);
    return pOut
};
cc.kmPlaneIntersectLine = function (pOut, pP, pV1, pV2) {
    throw"cc.kmPlaneIntersectLine() hasn't been implemented.";
};
cc.kmPlaneNormalize = function (pOut, pP) {
    var n = new cc.kmVec3;
    n.x = pP.a;
    n.y = pP.b;
    n.z = pP.c;
    var l = 1 / cc.kmVec3Length(n);
    cc.kmVec3Normalize(n, n);
    pOut.a = n.x;
    pOut.b = n.y;
    pOut.c = n.z;
    pOut.d = pP.d * l;
    return pOut
};
cc.kmPlaneScale = function (pOut, pP, s) {
    cc.log("cc.kmPlaneScale() has not been implemented.")
};
cc.kmPlaneClassifyPoint = function (pIn, pP) {
    var distance = pIn.a * pP.x + pIn.b * pP.y + pIn.c * pP.z + pIn.d;
    if (distance > 0.001)return cc.POINT_INFRONT_OF_PLANE;
    if (distance < -0.001)return cc.POINT_BEHIND_PLANE;
    return cc.POINT_ON_PLANE
};
cc.kmQuaternion = function (x, y, z, w) {
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
    this.w = w || 0
};
cc.kmQuaternionConjugate = function (pOut, pIn) {
    pOut.x = -pIn.x;
    pOut.y = -pIn.y;
    pOut.z = -pIn.z;
    pOut.w = pIn.w;
    return pOut
};
cc.kmQuaternionDot = function (q1, q2) {
    return q1.w * q2.w + q1.x * q2.x + q1.y * q2.y + q1.z * q2.z
};
cc.kmQuaternionExp = function (pOut, pIn) {
    return pOut
};
cc.kmQuaternionIdentity = function (pOut) {
    pOut.x = 0;
    pOut.y = 0;
    pOut.z = 0;
    pOut.w = 1;
    return pOut
};
cc.kmQuaternionInverse = function (pOut, pIn) {
    var l = cc.kmQuaternionLength(pIn);
    var tmp = new cc.kmQuaternion;
    if (Math.abs(l) > cc.kmEpsilon) {
        pOut.x = 0;
        pOut.y = 0;
        pOut.z = 0;
        pOut.w = 0;
        return pOut
    }
    cc.kmQuaternionScale(pOut, cc.kmQuaternionConjugate(tmp, pIn), 1 / l);
    return pOut
};
cc.kmQuaternionIsIdentity = function (pIn) {
    return pIn.x == 0 && pIn.y == 0 && pIn.z == 0 && pIn.w == 1
};
cc.kmQuaternionLength = function (pIn) {
    return Math.sqrt(cc.kmQuaternionLengthSq(pIn))
};
cc.kmQuaternionLengthSq = function (pIn) {
    return pIn.x * pIn.x + pIn.y * pIn.y + pIn.z * pIn.z + pIn.w * pIn.w
};
cc.kmQuaternionLn = function (pOut, pIn) {
    return pOut
};
cc.kmQuaternionMultiply = function (pOut, q1, q2) {
    pOut.w = q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z;
    pOut.x = q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y;
    pOut.y = q1.w * q2.y + q1.y * q2.w + q1.z * q2.x - q1.x * q2.z;
    pOut.z = q1.w * q2.z + q1.z * q2.w + q1.x * q2.y - q1.y * q2.x;
    return pOut
};
cc.kmQuaternionNormalize = function (pOut, pIn) {
    var length = cc.kmQuaternionLength(pIn);
    if (Math.abs(length) <= cc.kmEpsilon)throw"cc.kmQuaternionNormalize(): pIn is an invalid value";
    cc.kmQuaternionScale(pOut, pIn, 1 / length);
    return pOut
};
cc.kmQuaternionRotationAxis = function (pOut, pV, angle) {
    var rad = angle * 0.5;
    var scale = Math.sin(rad);
    pOut.w = Math.cos(rad);
    pOut.x = pV.x * scale;
    pOut.y = pV.y * scale;
    pOut.z = pV.z * scale;
    return pOut
};
cc.kmQuaternionRotationMatrix = function (pOut, pIn) {
    var x, y, z, w;
    var m4x4 = [];
    var scale = 0;
    var diagonal = 0;
    if (!pIn)return null;
    m4x4[0] = pIn.mat[0];
    m4x4[1] = pIn.mat[3];
    m4x4[2] = pIn.mat[6];
    m4x4[4] = pIn.mat[1];
    m4x4[5] = pIn.mat[4];
    m4x4[6] = pIn.mat[7];
    m4x4[8] = pIn.mat[2];
    m4x4[9] = pIn.mat[5];
    m4x4[10] = pIn.mat[8];
    m4x4[15] = 1;
    var pMatrix = m4x4[0];
    diagonal = pMatrix[0] + pMatrix[5] + pMatrix[10] + 1;
    if (diagonal > cc.kmEpsilon) {
        scale = Math.sqrt(diagonal) * 2;
        x = (pMatrix[9] - pMatrix[6]) / scale;
        y = (pMatrix[2] - pMatrix[8]) / scale;
        z = (pMatrix[4] - pMatrix[1]) /
            scale;
        w = 0.25 * scale
    } else if (pMatrix[0] > pMatrix[5] && pMatrix[0] > pMatrix[10]) {
        scale = Math.sqrt(1 + pMatrix[0] - pMatrix[5] - pMatrix[10]) * 2;
        x = 0.25 * scale;
        y = (pMatrix[4] + pMatrix[1]) / scale;
        z = (pMatrix[2] + pMatrix[8]) / scale;
        w = (pMatrix[9] - pMatrix[6]) / scale
    } else if (pMatrix[5] > pMatrix[10]) {
        scale = Math.sqrt(1 + pMatrix[5] - pMatrix[0] - pMatrix[10]) * 2;
        x = (pMatrix[4] + pMatrix[1]) / scale;
        y = 0.25 * scale;
        z = (pMatrix[9] + pMatrix[6]) / scale;
        w = (pMatrix[2] - pMatrix[8]) / scale
    } else {
        scale = Math.sqrt(1 + pMatrix[10] - pMatrix[0] - pMatrix[5]) * 2;
        x = (pMatrix[2] +
            pMatrix[8]) / scale;
        y = (pMatrix[9] + pMatrix[6]) / scale;
        z = 0.25 * scale;
        w = (pMatrix[4] - pMatrix[1]) / scale
    }
    pOut.x = x;
    pOut.y = y;
    pOut.z = z;
    pOut.w = w;
    return pOut
};
cc.kmQuaternionRotationYawPitchRoll = function (pOut, yaw, pitch, roll) {
    var ex, ey, ez;
    var cr, cp, cy, sr, sp, sy, cpcy, spsy;
    ex = cc.kmDegreesToRadians(pitch) / 2;
    ey = cc.kmDegreesToRadians(yaw) / 2;
    ez = cc.kmDegreesToRadians(roll) / 2;
    cr = Math.cos(ex);
    cp = Math.cos(ey);
    cy = Math.cos(ez);
    sr = Math.sin(ex);
    sp = Math.sin(ey);
    sy = Math.sin(ez);
    cpcy = cp * cy;
    spsy = sp * sy;
    pOut.w = cr * cpcy + sr * spsy;
    pOut.x = sr * cpcy - cr * spsy;
    pOut.y = cr * sp * cy + sr * cp * sy;
    pOut.z = cr * cp * sy - sr * sp * cy;
    cc.kmQuaternionNormalize(pOut, pOut);
    return pOut
};
cc.kmQuaternionSlerp = function (pOut, q1, q2, t) {
    if (q1.x == q2.x && q1.y == q2.y && q1.z == q2.z && q1.w == q2.w) {
        pOut.x = q1.x;
        pOut.y = q1.y;
        pOut.z = q1.z;
        pOut.w = q1.w;
        return pOut
    }
    var ct = cc.kmQuaternionDot(q1, q2);
    var theta = Math.acos(ct);
    var st = Math.sqrt(1 - cc.kmSQR(ct));
    var stt = Math.sin(t * theta) / st;
    var somt = Math.sin((1 - t) * theta) / st;
    var temp = new cc.kmQuaternion, temp2 = new cc.kmQuaternion;
    cc.kmQuaternionScale(temp, q1, somt);
    cc.kmQuaternionScale(temp2, q2, stt);
    cc.kmQuaternionAdd(pOut, temp, temp2);
    return pOut
};
cc.kmQuaternionToAxisAngle = function (pIn, pAxis, pAngle) {
    var tempAngle;
    var scale;
    tempAngle = Math.acos(pIn.w);
    scale = Math.sqrt(cc.kmSQR(pIn.x) + cc.kmSQR(pIn.y) + cc.kmSQR(pIn.z));
    if (scale > -cc.kmEpsilon && scale < cc.kmEpsilon || scale < 2 * cc.kmPI + cc.kmEpsilon && scale > 2 * cc.kmPI - cc.kmEpsilon) {
        pAngle = 0;
        pAxis.x = 0;
        pAxis.y = 0;
        pAxis.z = 1
    } else {
        pAngle = tempAngle * 2;
        pAxis.x = pIn.x / scale;
        pAxis.y = pIn.y / scale;
        pAxis.z = pIn.z / scale;
        cc.kmVec3Normalize(pAxis, pAxis)
    }
};
cc.kmQuaternionScale = function (pOut, pIn, s) {
    pOut.x = pIn.x * s;
    pOut.y = pIn.y * s;
    pOut.z = pIn.z * s;
    pOut.w = pIn.w * s;
    return pOut
};
cc.kmQuaternionAssign = function (pOut, pIn) {
    pOut.x = pIn.x;
    pOut.y = pIn.y;
    pOut.z = pIn.z;
    pOut.w = pIn.w;
    return pOut
};
cc.kmQuaternionAdd = function (pOut, pQ1, pQ2) {
    pOut.x = pQ1.x + pQ2.x;
    pOut.y = pQ1.y + pQ2.y;
    pOut.z = pQ1.z + pQ2.z;
    pOut.w = pQ1.w + pQ2.w;
    return pOut
};
cc.kmQuaternionRotationBetweenVec3 = function (pOut, vec1, vec2, fallback) {
    var v1 = new cc.kmVec3, v2 = new cc.kmVec3;
    var a;
    cc.kmVec3Assign(v1, vec1);
    cc.kmVec3Assign(v2, vec2);
    cc.kmVec3Normalize(v1, v1);
    cc.kmVec3Normalize(v2, v2);
    a = cc.kmVec3Dot(v1, v2);
    if (a >= 1) {
        cc.kmQuaternionIdentity(pOut);
        return pOut
    }
    if (a < 1E-6 - 1)if (Math.abs(cc.kmVec3LengthSq(fallback)) < cc.kmEpsilon)cc.kmQuaternionRotationAxis(pOut, fallback, cc.kmPI); else {
        var axis = new cc.kmVec3;
        var X = new cc.kmVec3;
        X.x = 1;
        X.y = 0;
        X.z = 0;
        cc.kmVec3Cross(axis, X, vec1);
        if (Math.abs(cc.kmVec3LengthSq(axis)) <
            cc.kmEpsilon) {
            var Y = new cc.kmVec3;
            Y.x = 0;
            Y.y = 1;
            Y.z = 0;
            cc.kmVec3Cross(axis, Y, vec1)
        }
        cc.kmVec3Normalize(axis, axis);
        cc.kmQuaternionRotationAxis(pOut, axis, cc.kmPI)
    } else {
        var s = Math.sqrt((1 + a) * 2);
        var invs = 1 / s;
        var c = new cc.kmVec3;
        cc.kmVec3Cross(c, v1, v2);
        pOut.x = c.x * invs;
        pOut.y = c.y * invs;
        pOut.z = c.z * invs;
        pOut.w = s * 0.5;
        cc.kmQuaternionNormalize(pOut, pOut)
    }
    return pOut
};
cc.kmQuaternionMultiplyVec3 = function (pOut, q, v) {
    var uv = new cc.kmVec3, uuv = new cc.kmVec3, qvec = new cc.kmVec3;
    qvec.x = q.x;
    qvec.y = q.y;
    qvec.z = q.z;
    cc.kmVec3Cross(uv, qvec, v);
    cc.kmVec3Cross(uuv, qvec, uv);
    cc.kmVec3Scale(uv, uv, 2 * q.w);
    cc.kmVec3Scale(uuv, uuv, 2);
    cc.kmVec3Add(pOut, v, uv);
    cc.kmVec3Add(pOut, pOut, uuv);
    return pOut
};
cc.kmAABB = function (min, max) {
    this.min = min || new cc.kmVec3;
    this.max = max || new cc.kmVec3
};
cc.kmAABBContainsPoint = function (pPoint, pBox) {
    if (pPoint.x >= pBox.min.x && pPoint.x <= pBox.max.x && pPoint.y >= pBox.min.y && pPoint.y <= pBox.max.y && pPoint.z >= pBox.min.z && pPoint.z <= pBox.max.z)return cc.KM_TRUE;
    return cc.KM_FALSE
};
cc.kmAABBAssign = function (pOut, pIn) {
    cc.kmVec3Assign(pOut.min, pIn.min);
    cc.kmVec3Assign(pOut.max, pIn.max);
    return pOut
};
cc.kmAABBScale = function (pOut, pIn, s) {
    cc.log("cc.kmAABBScale hasn't been supported.")
};
cc.km_mat4_stack = function (capacity, item_count, top, stack) {
    this.top = top;
    this.stack = stack
};
cc.km_mat4_stack.INITIAL_SIZE = 30;
cc.km_mat4_stack_initialize = function (stack) {
    stack.stack = [];
    stack.top = null
};
cc.km_mat4_stack_push = function (stack, item) {
    stack.stack.push(stack.top);
    stack.top = new cc.kmMat4;
    cc.kmMat4Assign(stack.top, item)
};
cc.km_mat4_stack_pop = function (stack, pOut) {
    stack.top = stack.stack.pop()
};
cc.km_mat4_stack_release = function (stack) {
    stack.stack = null;
    stack.top = null;
    stack = null
};
cc.KM_GL_MODELVIEW = 5888;
cc.KM_GL_PROJECTION = 5889;
cc.KM_GL_TEXTURE = 5890;
cc.modelview_matrix_stack = new cc.km_mat4_stack;
cc.projection_matrix_stack = new cc.km_mat4_stack;
cc.texture_matrix_stack = new cc.km_mat4_stack;
cc.current_stack = null;
cc.initialized = false;
cc.lazyInitialize = function () {
    if (!cc.initialized) {
        var identity = new cc.kmMat4;
        cc.km_mat4_stack_initialize(cc.modelview_matrix_stack);
        cc.km_mat4_stack_initialize(cc.projection_matrix_stack);
        cc.km_mat4_stack_initialize(cc.texture_matrix_stack);
        cc.current_stack = cc.modelview_matrix_stack;
        cc.initialized = true;
        cc.kmMat4Identity(identity);
        cc.km_mat4_stack_push(cc.modelview_matrix_stack, identity);
        cc.km_mat4_stack_push(cc.projection_matrix_stack, identity);
        cc.km_mat4_stack_push(cc.texture_matrix_stack, identity)
    }
};
cc.lazyInitialize();
cc.kmGLFreeAll = function () {
    cc.km_mat4_stack_release(cc.modelview_matrix_stack);
    cc.km_mat4_stack_release(cc.projection_matrix_stack);
    cc.km_mat4_stack_release(cc.texture_matrix_stack);
    cc.initialized = false;
    cc.current_stack = null
};
cc.kmGLPushMatrix = function () {
    cc.km_mat4_stack_push(cc.current_stack, cc.current_stack.top)
};
cc.kmGLPushMatrixWitMat4 = function (saveMat) {
    cc.current_stack.stack.push(cc.current_stack.top);
    cc.kmMat4Assign(saveMat, cc.current_stack.top);
    cc.current_stack.top = saveMat
};
cc.kmGLPopMatrix = function () {
    cc.current_stack.top = cc.current_stack.stack.pop()
};
cc.kmGLMatrixMode = function (mode) {
    switch (mode) {
        case cc.KM_GL_MODELVIEW:
            cc.current_stack = cc.modelview_matrix_stack;
            break;
        case cc.KM_GL_PROJECTION:
            cc.current_stack = cc.projection_matrix_stack;
            break;
        case cc.KM_GL_TEXTURE:
            cc.current_stack = cc.texture_matrix_stack;
            break;
        default:
            throw"Invalid matrix mode specified";
            break
    }
};
cc.kmGLLoadIdentity = function () {
    cc.kmMat4Identity(cc.current_stack.top)
};
cc.kmGLLoadMatrix = function (pIn) {
    cc.kmMat4Assign(cc.current_stack.top, pIn)
};
cc.kmGLMultMatrix = function (pIn) {
    cc.kmMat4Multiply(cc.current_stack.top, cc.current_stack.top, pIn)
};
cc.kmGLTranslatef = function (x, y, z) {
    var translation = new cc.kmMat4;
    cc.kmMat4Translation(translation, x, y, z);
    cc.kmMat4Multiply(cc.current_stack.top, cc.current_stack.top, translation)
};
cc.kmGLRotatef = function (angle, x, y, z) {
    var axis = new cc.kmVec3(x, y, z);
    var rotation = new cc.kmMat4;
    cc.kmMat4RotationAxisAngle(rotation, axis, cc.kmDegreesToRadians(angle));
    cc.kmMat4Multiply(cc.current_stack.top, cc.current_stack.top, rotation)
};
cc.kmGLScalef = function (x, y, z) {
    var scaling = new cc.kmMat4;
    cc.kmMat4Scaling(scaling, x, y, z);
    cc.kmMat4Multiply(cc.current_stack.top, cc.current_stack.top, scaling)
};
cc.kmGLGetMatrix = function (mode, pOut) {
    switch (mode) {
        case cc.KM_GL_MODELVIEW:
            cc.kmMat4Assign(pOut, cc.modelview_matrix_stack.top);
            break;
        case cc.KM_GL_PROJECTION:
            cc.kmMat4Assign(pOut, cc.projection_matrix_stack.top);
            break;
        case cc.KM_GL_TEXTURE:
            cc.kmMat4Assign(pOut, cc.texture_matrix_stack.top);
            break;
        default:
            throw"Invalid matrix mode specified";
            break
    }
};cc.SHADER_POSITION_UCOLOR_FRAG = "precision lowp float;\n" + "varying vec4 v_fragmentColor;\n" + "void main()                              \n" + "{ \n" + "    gl_FragColor \x3d v_fragmentColor;      \n" + "}\n";
cc.SHADER_POSITION_UCOLOR_VERT = "attribute vec4 a_position;\n" + "uniform    vec4 u_color;\n" + "uniform float u_pointSize;\n" + "varying lowp vec4 v_fragmentColor; \n" + "void main(void)   \n" + "{\n" + "    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n" + "    gl_PointSize \x3d u_pointSize;          \n" + "    v_fragmentColor \x3d u_color;           \n" + "}";
cc.SHADER_POSITION_COLOR_FRAG = "precision lowp float; \n" + "varying vec4 v_fragmentColor; \n" + "void main() \n" + "{ \n" + "     gl_FragColor \x3d v_fragmentColor; \n" + "} ";
cc.SHADER_POSITION_COLOR_VERT = "attribute vec4 a_position;\n" + "attribute vec4 a_color;\n" + "varying lowp vec4 v_fragmentColor;\n" + "void main()\n" + "{\n" + "    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n" + "    v_fragmentColor \x3d a_color;             \n" + "}";
cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_FRAG = "// #extension GL_OES_standard_derivatives : enable\n" + "varying mediump vec4 v_color;\n" + "varying mediump vec2 v_texcoord;\n" + "void main()\t\n" + "{ \n" + "// #if defined GL_OES_standard_derivatives\t\n" + "// gl_FragColor \x3d v_color*smoothstep(0.0, length(fwidth(v_texcoord)), 1.0 - length(v_texcoord)); \n" + "// #else\t\n" + "gl_FragColor \x3d v_color * step(0.0, 1.0 - length(v_texcoord)); \n" + "// #endif \n" + "}";
cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_VERT = "attribute mediump vec4 a_position; \n" + "attribute mediump vec2 a_texcoord; \n" + "attribute mediump vec4 a_color;\t\n" + "varying mediump vec4 v_color; \n" + "varying mediump vec2 v_texcoord;\t\n" + "void main() \n" + "{ \n" + "     v_color \x3d a_color;//vec4(a_color.rgb * a_color.a, a_color.a); \n" + "     v_texcoord \x3d a_texcoord; \n" + "    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n" + "}";
cc.SHADER_POSITION_TEXTURE_FRAG = "precision lowp float;   \n" + "varying vec2 v_texCoord;  \n" + "uniform sampler2D CC_Texture0; \n" + "void main() \n" + "{  \n" + "    gl_FragColor \x3d  texture2D(CC_Texture0, v_texCoord);   \n" + "}";
cc.SHADER_POSITION_TEXTURE_VERT = "attribute vec4 a_position; \n" + "attribute vec2 a_texCoord; \n" + "varying mediump vec2 v_texCoord; \n" + "void main() \n" + "{ \n" + "    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n" + "    v_texCoord \x3d a_texCoord;               \n" + "}";
cc.SHADER_POSITION_TEXTURE_UCOLOR_FRAG = "precision lowp float;  \n" + "uniform vec4 u_color; \n" + "varying vec2 v_texCoord; \n" + "uniform sampler2D CC_Texture0;  \n" + "void main() \n" + "{  \n" + "    gl_FragColor \x3d  texture2D(CC_Texture0, v_texCoord) * u_color;    \n" + "}";
cc.SHADER_POSITION_TEXTURE_UCOLOR_VERT = "attribute vec4 a_position;\n" + "attribute vec2 a_texCoord; \n" + "varying mediump vec2 v_texCoord; \n" + "void main() \n" + "{ \n" + "    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n" + "    v_texCoord \x3d a_texCoord;                 \n" + "}";
cc.SHADER_POSITION_TEXTURE_A8COLOR_FRAG = "precision lowp float;  \n" + "varying vec4 v_fragmentColor; \n" + "varying vec2 v_texCoord; \n" + "uniform sampler2D CC_Texture0; \n" + "void main() \n" + "{ \n" + "    gl_FragColor \x3d vec4( v_fragmentColor.rgb,         \n" + "        v_fragmentColor.a * texture2D(CC_Texture0, v_texCoord).a   \n" + "    ); \n" + "}";
cc.SHADER_POSITION_TEXTURE_A8COLOR_VERT = "attribute vec4 a_position; \n" + "attribute vec2 a_texCoord; \n" + "attribute vec4 a_color;  \n" + "varying lowp vec4 v_fragmentColor; \n" + "varying mediump vec2 v_texCoord; \n" + "void main() \n" + "{ \n" + "    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n" + "    v_fragmentColor \x3d a_color; \n" + "    v_texCoord \x3d a_texCoord; \n" + "}";
cc.SHADER_POSITION_TEXTURE_COLOR_FRAG = "precision lowp float;\n" + "varying vec4 v_fragmentColor; \n" + "varying vec2 v_texCoord; \n" + "uniform sampler2D CC_Texture0; \n" + "void main() \n" + "{ \n" + "    gl_FragColor \x3d v_fragmentColor * texture2D(CC_Texture0, v_texCoord); \n" + "}";
cc.SHADER_POSITION_TEXTURE_COLOR_VERT = "attribute vec4 a_position; \n" + "attribute vec2 a_texCoord; \n" + "attribute vec4 a_color;  \n" + "varying lowp vec4 v_fragmentColor; \n" + "varying mediump vec2 v_texCoord; \n" + "void main() \n" + "{ \n" + "    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n" + "    v_fragmentColor \x3d a_color; \n" + "    v_texCoord \x3d a_texCoord; \n" + "}";
cc.SHADER_POSITION_TEXTURE_COLOR_ALPHATEST_FRAG = "precision lowp float;   \n" + "varying vec4 v_fragmentColor; \n" + "varying vec2 v_texCoord;   \n" + "uniform sampler2D CC_Texture0; \n" + "uniform float CC_alpha_value; \n" + "void main() \n" + "{  \n" + "    vec4 texColor \x3d texture2D(CC_Texture0, v_texCoord);  \n" + "    // mimic: glAlphaFunc(GL_GREATER)           \n" + "    //pass if ( incoming_pixel \x3e\x3d CC_alpha_value ) \x3d\x3e fail if incoming_pixel \x3c CC_alpha_value   \n" + "    if ( texColor.a \x3c\x3d CC_alpha_value )          \n" +
    "        discard; \n" + "    gl_FragColor \x3d texColor * v_fragmentColor;  \n" + "}";
cc.SHADEREX_SWITCHMASK_FRAG = "precision lowp float; \n" + "varying vec4 v_fragmentColor; \n" + "varying vec2 v_texCoord; \n" + "uniform sampler2D u_texture;  \n" + "uniform sampler2D   u_mask;   \n" + "void main()  \n" + "{  \n" + "    vec4 texColor   \x3d texture2D(u_texture, v_texCoord);  \n" + "    vec4 maskColor  \x3d texture2D(u_mask, v_texCoord); \n" + "    vec4 finalColor \x3d vec4(texColor.r, texColor.g, texColor.b, maskColor.a * texColor.a);        \n" + "    gl_FragColor    \x3d v_fragmentColor * finalColor; \n" +
    "}";
cc.shaderCache = {TYPE_POSITION_TEXTURECOLOR: 0, TYPE_POSITION_TEXTURECOLOR_ALPHATEST: 1, TYPE_POSITION_COLOR: 2, TYPE_POSITION_TEXTURE: 3, TYPE_POSITION_TEXTURE_UCOLOR: 4, TYPE_POSITION_TEXTURE_A8COLOR: 5, TYPE_POSITION_UCOLOR: 6, TYPE_POSITION_LENGTH_TEXTURECOLOR: 7, TYPE_MAX: 8, _programs: {}, _init: function () {
    this.loadDefaultShaders();
    return true
}, _loadDefaultShader: function (program, type) {
    switch (type) {
        case this.TYPE_POSITION_TEXTURECOLOR:
            program.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_COLOR_VERT, cc.SHADER_POSITION_TEXTURE_COLOR_FRAG);
            program.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
            program.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
            program.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
            break;
        case this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST:
            program.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_COLOR_VERT, cc.SHADER_POSITION_TEXTURE_COLOR_ALPHATEST_FRAG);
            program.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
            program.addAttribute(cc.ATTRIBUTE_NAME_COLOR,
                cc.VERTEX_ATTRIB_COLOR);
            program.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
            break;
        case this.TYPE_POSITION_COLOR:
            program.initWithVertexShaderByteArray(cc.SHADER_POSITION_COLOR_VERT, cc.SHADER_POSITION_COLOR_FRAG);
            program.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
            program.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
            break;
        case this.TYPE_POSITION_TEXTURE:
            program.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_VERT, cc.SHADER_POSITION_TEXTURE_FRAG);
            program.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
            program.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
            break;
        case this.TYPE_POSITION_TEXTURE_UCOLOR:
            program.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_UCOLOR_VERT, cc.SHADER_POSITION_TEXTURE_UCOLOR_FRAG);
            program.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
            program.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
            break;
        case this.TYPE_POSITION_TEXTURE_A8COLOR:
            program.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_A8COLOR_VERT,
                cc.SHADER_POSITION_TEXTURE_A8COLOR_FRAG);
            program.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
            program.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
            program.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
            break;
        case this.TYPE_POSITION_UCOLOR:
            program.initWithVertexShaderByteArray(cc.SHADER_POSITION_UCOLOR_VERT, cc.SHADER_POSITION_UCOLOR_FRAG);
            program.addAttribute("aVertex", cc.VERTEX_ATTRIB_POSITION);
            break;
        case this.TYPE_POSITION_LENGTH_TEXTURECOLOR:
            program.initWithVertexShaderByteArray(cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_VERT,
                cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_FRAG);
            program.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
            program.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
            program.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
            break;
        default:
            cc.log("cocos2d: cc.shaderCache._loadDefaultShader, error shader type");
            return
    }
    program.link();
    program.updateUniforms()
}, loadDefaultShaders: function () {
    var program = new cc.GLProgram;
    this._loadDefaultShader(program, this.TYPE_POSITION_TEXTURECOLOR);
    this._programs[cc.SHADER_POSITION_TEXTURECOLOR] = program;
    this._programs["ShaderPositionTextureColor"] = program;
    program = new cc.GLProgram;
    this._loadDefaultShader(program, this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST);
    this._programs[cc.SHADER_POSITION_TEXTURECOLORALPHATEST] = program;
    this._programs["ShaderPositionTextureColorAlphaTest"] = program;
    program = new cc.GLProgram;
    this._loadDefaultShader(program, this.TYPE_POSITION_COLOR);
    this._programs[cc.SHADER_POSITION_COLOR] = program;
    this._programs["ShaderPositionColor"] =
        program;
    program = new cc.GLProgram;
    this._loadDefaultShader(program, this.TYPE_POSITION_TEXTURE);
    this._programs[cc.SHADER_POSITION_TEXTURE] = program;
    this._programs["ShaderPositionTexture"] = program;
    program = new cc.GLProgram;
    this._loadDefaultShader(program, this.TYPE_POSITION_TEXTURE_UCOLOR);
    this._programs[cc.SHADER_POSITION_TEXTURE_UCOLOR] = program;
    this._programs["ShaderPositionTextureUColor"] = program;
    program = new cc.GLProgram;
    this._loadDefaultShader(program, this.TYPE_POSITION_TEXTURE_A8COLOR);
    this._programs[cc.SHADER_POSITION_TEXTUREA8COLOR] =
        program;
    this._programs["ShaderPositionTextureA8Color"] = program;
    program = new cc.GLProgram;
    this._loadDefaultShader(program, this.TYPE_POSITION_UCOLOR);
    this._programs[cc.SHADER_POSITION_UCOLOR] = program;
    this._programs["ShaderPositionUColor"] = program;
    program = new cc.GLProgram;
    this._loadDefaultShader(program, this.TYPE_POSITION_LENGTH_TEXTURECOLOR);
    this._programs[cc.SHADER_POSITION_LENGTHTEXTURECOLOR] = program;
    this._programs["ShaderPositionLengthTextureColor"] = program
}, reloadDefaultShaders: function () {
    var program =
        this.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
    program.reset();
    this._loadDefaultShader(program, this.TYPE_POSITION_TEXTURECOLOR);
    program = this.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST);
    program.reset();
    this._loadDefaultShader(program, this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST);
    program = this.programForKey(cc.SHADER_POSITION_COLOR);
    program.reset();
    this._loadDefaultShader(program, this.TYPE_POSITION_COLOR);
    program = this.programForKey(cc.SHADER_POSITION_TEXTURE);
    program.reset();
    this._loadDefaultShader(program,
        this.TYPE_POSITION_TEXTURE);
    program = this.programForKey(cc.SHADER_POSITION_TEXTURE_UCOLOR);
    program.reset();
    this._loadDefaultShader(program, this.TYPE_POSITION_TEXTURE_UCOLOR);
    program = this.programForKey(cc.SHADER_POSITION_TEXTUREA8COLOR);
    program.reset();
    this._loadDefaultShader(program, this.TYPE_POSITION_TEXTURE_A8COLOR);
    program = this.programForKey(cc.SHADER_POSITION_UCOLOR);
    program.reset();
    this._loadDefaultShader(program, this.TYPE_POSITION_UCOLOR)
}, programForKey: function (key) {
    return this._programs[key]
},
    getProgram: function (shaderName) {
        return this._programs[shaderName]
    }, addProgram: function (program, key) {
        this._programs[key] = program
    }};
cc.HashUniformEntry = function (value, location, hh) {
    this.value = value;
    this.location = location;
    this.hh = hh || {}
};
cc.GLProgram = cc.Class.extend({_glContext: null, _programObj: null, _vertShader: null, _fragShader: null, _uniforms: null, _hashForUniforms: null, _usesTime: false, _updateUniformLocation: function (location, data, bytes) {
    if (location == null)return false;
    var updated = true;
    var element = null;
    for (var i = 0; i < this._hashForUniforms.length; i++)if (this._hashForUniforms[i].location == location)element = this._hashForUniforms[i];
    if (!element) {
        element = new cc.HashUniformEntry;
        element.location = location;
        element.value = data;
        this._hashForUniforms.push(element)
    } else if (element.value ==
        data)updated = false; else element.value = data;
    return updated
}, _description: function () {
    return"\x3cCCGLProgram \x3d " + this.toString() + " | Program \x3d " + this._programObj.toString() + ", VertexShader \x3d " + this._vertShader.toString() + ", FragmentShader \x3d " + this._fragShader.toString() + "\x3e"
}, _compileShader: function (shader, type, source) {
    if (!source || !shader)return false;
    source = "precision highp float;        \n" + "uniform mat4 CC_PMatrix;         \n" + "uniform mat4 CC_MVMatrix;        \n" + "uniform mat4 CC_MVPMatrix;       \n" +
        "uniform vec4 CC_Time;            \n" + "uniform vec4 CC_SinTime;         \n" + "uniform vec4 CC_CosTime;         \n" + "uniform vec4 CC_Random01;        \n" + "//CC INCLUDES END                \n" + source;
    this._glContext.shaderSource(shader, source);
    this._glContext.compileShader(shader);
    var status = this._glContext.getShaderParameter(shader, this._glContext.COMPILE_STATUS);
    if (!status) {
        cc.log("cocos2d: ERROR: Failed to compile shader:\n" + this._glContext.getShaderSource(shader));
        if (type == this._glContext.VERTEX_SHADER)cc.log("cocos2d: \n" +
            this.vertexShaderLog()); else cc.log("cocos2d: \n" + this.fragmentShaderLog())
    }
    return status == 1
}, ctor: function (vShaderFileName, fShaderFileName, glContext) {
    this._uniforms = [];
    this._hashForUniforms = [];
    this._glContext = glContext || cc._renderContext;
    vShaderFileName && fShaderFileName && this.init(vShaderFileName, fShaderFileName)
}, destroyProgram: function () {
    this._vertShader = null;
    this._fragShader = null;
    this._uniforms = null;
    this._hashForUniforms = null;
    this._glContext.deleteProgram(this._programObj)
}, initWithVertexShaderByteArray: function (vertShaderStr, fragShaderStr) {
    var locGL = this._glContext;
    this._programObj = locGL.createProgram();
    this._vertShader = null;
    this._fragShader = null;
    if (vertShaderStr) {
        this._vertShader = locGL.createShader(locGL.VERTEX_SHADER);
        if (!this._compileShader(this._vertShader, locGL.VERTEX_SHADER, vertShaderStr))cc.log("cocos2d: ERROR: Failed to compile vertex shader")
    }
    if (fragShaderStr) {
        this._fragShader = locGL.createShader(locGL.FRAGMENT_SHADER);
        if (!this._compileShader(this._fragShader, locGL.FRAGMENT_SHADER, fragShaderStr))cc.log("cocos2d: ERROR: Failed to compile fragment shader")
    }
    if (this._vertShader)locGL.attachShader(this._programObj,
        this._vertShader);
    cc.checkGLErrorDebug();
    if (this._fragShader)locGL.attachShader(this._programObj, this._fragShader);
    this._hashForUniforms.length = 0;
    cc.checkGLErrorDebug();
    return true
}, initWithString: function (vertShaderStr, fragShaderStr) {
    return this.initWithVertexShaderByteArray(vertShaderStr, fragShaderStr)
}, initWithVertexShaderFilename: function (vShaderFilename, fShaderFileName) {
    var vertexSource = cc.loader.getRes(vShaderFilename);
    if (!vertexSource)throw"Please load the resource firset : " + vShaderFilename;
    var fragmentSource = cc.loader.getRes(fShaderFileName);
    if (!fragmentSource)throw"Please load the resource firset : " + fShaderFileName;
    return this.initWithVertexShaderByteArray(vertexSource, fragmentSource)
}, init: function (vShaderFilename, fShaderFileName) {
    return this.initWithVertexShaderFilename(vShaderFilename, fShaderFileName)
}, addAttribute: function (attributeName, index) {
    this._glContext.bindAttribLocation(this._programObj, index, attributeName)
}, link: function () {
    if (!this._programObj) {
        cc.log("cc.GLProgram.link(): Cannot link invalid program");
        return false
    }
    this._glContext.linkProgram(this._programObj);
    if (this._vertShader)this._glContext.deleteShader(this._vertShader);
    if (this._fragShader)this._glContext.deleteShader(this._fragShader);
    this._vertShader = null;
    this._fragShader = null;
    if (cc.game.config[cc.game.CONFIG_KEY.debugMode]) {
        var status = this._glContext.getProgramParameter(this._programObj, this._glContext.LINK_STATUS);
        if (!status) {
            cc.log("cocos2d: ERROR: Failed to link program: " + this._glContext.getProgramInfoLog(this._programObj));
            cc.glDeleteProgram(this._programObj);
            this._programObj = null;
            return false
        }
    }
    return true
}, use: function () {
    cc.glUseProgram(this._programObj)
}, updateUniforms: function () {
    this._uniforms[cc.UNIFORM_PMATRIX] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_PMATRIX_S);
    this._uniforms[cc.UNIFORM_MVMATRIX] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_MVMATRIX_S);
    this._uniforms[cc.UNIFORM_MVPMATRIX] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_MVPMATRIX_S);
    this._uniforms[cc.UNIFORM_TIME] = this._glContext.getUniformLocation(this._programObj,
        cc.UNIFORM_TIME_S);
    this._uniforms[cc.UNIFORM_SINTIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_SINTIME_S);
    this._uniforms[cc.UNIFORM_COSTIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_COSTIME_S);
    this._usesTime = this._uniforms[cc.UNIFORM_TIME] != null || this._uniforms[cc.UNIFORM_SINTIME] != null || this._uniforms[cc.UNIFORM_COSTIME] != null;
    this._uniforms[cc.UNIFORM_RANDOM01] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_RANDOM01_S);
    this._uniforms[cc.UNIFORM_SAMPLER] =
        this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_SAMPLER_S);
    this.use();
    this.setUniformLocationWith1i(this._uniforms[cc.UNIFORM_SAMPLER], 0)
}, getUniformLocationForName: function (name) {
    if (!name)throw"cc.GLProgram.getUniformLocationForName(): uniform name should be non-null";
    if (!this._programObj)throw"cc.GLProgram.getUniformLocationForName(): Invalid operation. Cannot get uniform location when program is not initialized";
    return this._glContext.getUniformLocation(this._programObj, name)
}, getUniformMVPMatrix: function () {
    return this._uniforms[cc.UNIFORM_MVPMATRIX]
},
    getUniformSampler: function () {
        return this._uniforms[cc.UNIFORM_SAMPLER]
    }, setUniformLocationWith1i: function (location, i1) {
        var updated = this._updateUniformLocation(location, i1);
        if (updated)this._glContext.uniform1i(location, i1)
    }, setUniformLocationWith2i: function (location, i1, i2) {
        var intArray = [i1, i2];
        var updated = this._updateUniformLocation(location, intArray);
        if (updated)this._glContext.uniform2i(location, i1, i2)
    }, setUniformLocationWith3i: function (location, i1, i2, i3) {
        var intArray = [i1, i2, i3];
        var updated = this._updateUniformLocation(location,
            intArray);
        if (updated)this._glContext.uniform3i(location, i1, i2, i3)
    }, setUniformLocationWith4i: function (location, i1, i2, i3, i4) {
        var intArray = [i1, i2, i3, i4];
        var updated = this._updateUniformLocation(location, intArray);
        if (updated)this._glContext.uniform4i(location, i1, i2, i3, i4)
    }, setUniformLocationWith2iv: function (location, intArray, numberOfArrays) {
        var updated = this._updateUniformLocation(location, intArray);
        if (updated)this._glContext.uniform2iv(location, intArray)
    }, setUniformLocationWith3iv: function (location, intArray, numberOfArrays) {
        var updated = this._updateUniformLocation(location, intArray);
        if (updated)this._glContext.uniform3iv(location, intArray)
    }, setUniformLocationWith4iv: function (location, intArray, numberOfArrays) {
        var updated = this._updateUniformLocation(location, intArray);
        if (updated)this._glContext.uniform4iv(location, intArray)
    }, setUniformLocationI32: function (location, i1) {
        this.setUniformLocationWith1i(arguments[0], arguments[1])
    }, setUniformLocationWith1f: function (location, f1) {
        var updated = this._updateUniformLocation(location,
            f1);
        if (updated)this._glContext.uniform1f(location, f1)
    }, setUniformLocationWith2f: function (location, f1, f2) {
        var floats = [f1, f2];
        var updated = this._updateUniformLocation(location, floats);
        if (updated)this._glContext.uniform2f(location, f1, f2)
    }, setUniformLocationWith3f: function (location, f1, f2, f3) {
        var floats = [f1, f2, f3];
        var updated = this._updateUniformLocation(location, floats);
        if (updated)this._glContext.uniform3f(location, f1, f2, f3)
    }, setUniformLocationWith4f: function (location, f1, f2, f3, f4) {
        var floats = [f1, f2, f3,
            f4];
        var updated = this._updateUniformLocation(location, floats);
        if (updated)this._glContext.uniform4f(location, f1, f2, f3, f4)
    }, setUniformLocationWith2fv: function (location, floatArray, numberOfArrays) {
        var updated = this._updateUniformLocation(location, floatArray);
        if (updated)this._glContext.uniform2fv(location, floatArray)
    }, setUniformLocationWith3fv: function (location, floatArray, numberOfArrays) {
        var updated = this._updateUniformLocation(location, floatArray);
        if (updated)this._glContext.uniform3fv(location, floatArray)
    },
    setUniformLocationWith4fv: function (location, floatArray, numberOfArrays) {
        var updated = this._updateUniformLocation(location, floatArray);
        if (updated)this._glContext.uniform4fv(location, floatArray)
    }, setUniformLocationWithMatrix4fv: function (location, matrixArray, numberOfMatrices) {
        var updated = this._updateUniformLocation(location, matrixArray);
        if (updated)this._glContext.uniformMatrix4fv(location, false, matrixArray)
    }, setUniformLocationF32: function () {
        if (arguments.length < 2)return;
        switch (arguments.length) {
            case 2:
                this.setUniformLocationWith1f(arguments[0],
                    arguments[1]);
                break;
            case 3:
                this.setUniformLocationWith2f(arguments[0], arguments[1], arguments[2]);
                break;
            case 4:
                this.setUniformLocationWith3f(arguments[0], arguments[1], arguments[2], arguments[3]);
                break;
            case 5:
                this.setUniformLocationWith4f(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]);
                break
        }
    }, setUniformsForBuiltins: function () {
        var matrixP = new cc.kmMat4;
        var matrixMV = new cc.kmMat4;
        var matrixMVP = new cc.kmMat4;
        cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, matrixP);
        cc.kmGLGetMatrix(cc.KM_GL_MODELVIEW,
            matrixMV);
        cc.kmMat4Multiply(matrixMVP, matrixP, matrixMV);
        this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], matrixP.mat, 1);
        this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], matrixMV.mat, 1);
        this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], matrixMVP.mat, 1);
        if (this._usesTime) {
            var director = cc.director;
            var time = director.getTotalFrames() * director.getAnimationInterval();
            this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_TIME], time /
                10, time, time * 2, time * 4);
            this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_SINTIME], time / 8, time / 4, time / 2, Math.sin(time));
            this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_COSTIME], time / 8, time / 4, time / 2, Math.cos(time))
        }
        if (this._uniforms[cc.UNIFORM_RANDOM01] != -1)this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_RANDOM01], Math.random(), Math.random(), Math.random(), Math.random())
    }, setUniformForModelViewProjectionMatrix: function () {
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX],
            false, cc.getMat4MultiplyValue(cc.projection_matrix_stack.top, cc.modelview_matrix_stack.top))
    }, setUniformForModelViewProjectionMatrixWithMat4: function (swapMat4) {
        cc.kmMat4Multiply(swapMat4, cc.projection_matrix_stack.top, cc.modelview_matrix_stack.top);
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], false, swapMat4.mat)
    }, setUniformForModelViewAndProjectionMatrixWithMat4: function () {
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], false, cc.modelview_matrix_stack.top.mat);
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], false, cc.projection_matrix_stack.top.mat)
    }, vertexShaderLog: function () {
        return this._glContext.getShaderInfoLog(this._vertShader)
    }, getVertexShaderLog: function () {
        return this._glContext.getShaderInfoLog(this._vertShader)
    }, getFragmentShaderLog: function () {
        return this._glContext.getShaderInfoLog(this._vertShader)
    }, fragmentShaderLog: function () {
        return this._glContext.getShaderInfoLog(this._fragShader)
    }, programLog: function () {
        return this._glContext.getProgramInfoLog(this._programObj)
    },
    getProgramLog: function () {
        return this._glContext.getProgramInfoLog(this._programObj)
    }, reset: function () {
        this._vertShader = null;
        this._fragShader = null;
        this._uniforms.length = 0;
        this._glContext.deleteProgram(this._programObj);
        this._programObj = null;
        for (var i = 0; i < this._hashForUniforms.length; i++) {
            this._hashForUniforms[i].value = null;
            this._hashForUniforms[i] = null
        }
        this._hashForUniforms.length = 0
    }, getProgram: function () {
        return this._programObj
    }, retain: function () {
    }, release: function () {
    }});
cc.GLProgram.create = function (vShaderFileName, fShaderFileName) {
    return new cc.GLProgram(vShaderFileName, fShaderFileName)
};
cc._currentProjectionMatrix = -1;
cc._vertexAttribPosition = false;
cc._vertexAttribColor = false;
cc._vertexAttribTexCoords = false;
if (cc.ENABLE_GL_STATE_CACHE) {
    cc.MAX_ACTIVETEXTURE = 16;
    cc._currentShaderProgram = -1;
    cc._currentBoundTexture = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
    cc._blendingSource = -1;
    cc._blendingDest = -1;
    cc._GLServerState = 0;
    if (cc.TEXTURE_ATLAS_USE_VAO)cc._uVAO = 0
}
cc.glInvalidateStateCache = function () {
    cc.kmGLFreeAll();
    cc._currentProjectionMatrix = -1;
    cc._vertexAttribPosition = false;
    cc._vertexAttribColor = false;
    cc._vertexAttribTexCoords = false;
    if (cc.ENABLE_GL_STATE_CACHE) {
        cc._currentShaderProgram = -1;
        for (var i = 0; i < cc.MAX_ACTIVETEXTURE; i++)cc._currentBoundTexture[i] = -1;
        cc._blendingSource = -1;
        cc._blendingDest = -1;
        cc._GLServerState = 0
    }
};
cc.glUseProgram = function (program) {
    if (program !== cc._currentShaderProgram) {
        cc._currentShaderProgram = program;
        cc._renderContext.useProgram(program)
    }
};
if (!cc.ENABLE_GL_STATE_CACHE)cc.glUseProgram = function (program) {
    cc._renderContext.useProgram(program)
};
cc.glDeleteProgram = function (program) {
    if (cc.ENABLE_GL_STATE_CACHE)if (program === cc._currentShaderProgram)cc._currentShaderProgram = -1;
    gl.deleteProgram(program)
};
cc.glBlendFunc = function (sfactor, dfactor) {
    if (sfactor !== cc._blendingSource || dfactor !== cc._blendingDest) {
        cc._blendingSource = sfactor;
        cc._blendingDest = dfactor;
        cc.setBlending(sfactor, dfactor)
    }
};
cc.setBlending = function (sfactor, dfactor) {
    var ctx = cc._renderContext;
    if (sfactor === ctx.ONE && dfactor === ctx.ZERO)ctx.disable(ctx.BLEND); else {
        ctx.enable(ctx.BLEND);
        cc._renderContext.blendFunc(sfactor, dfactor)
    }
};
cc.glBlendFuncForParticle = function (sfactor, dfactor) {
    if (sfactor !== cc._blendingSource || dfactor !== cc._blendingDest) {
        cc._blendingSource = sfactor;
        cc._blendingDest = dfactor;
        var ctx = cc._renderContext;
        if (sfactor === ctx.ONE && dfactor === ctx.ZERO)ctx.disable(ctx.BLEND); else {
            ctx.enable(ctx.BLEND);
            ctx.blendFuncSeparate(ctx.SRC_ALPHA, dfactor, sfactor, dfactor)
        }
    }
};
if (!cc.ENABLE_GL_STATE_CACHE)cc.glBlendFunc = cc.setBlending;
cc.glBlendResetToCache = function () {
    var ctx = cc._renderContext;
    ctx.blendEquation(ctx.FUNC_ADD);
    if (cc.ENABLE_GL_STATE_CACHE)cc.setBlending(cc._blendingSource, cc._blendingDest); else cc.setBlending(ctx.BLEND_SRC, ctx.BLEND_DST)
};
cc.setProjectionMatrixDirty = function () {
    cc._currentProjectionMatrix = -1
};
cc.glEnableVertexAttribs = function (flags) {
    var ctx = cc._renderContext;
    var enablePosition = flags & cc.VERTEX_ATTRIB_FLAG_POSITION;
    if (enablePosition !== cc._vertexAttribPosition) {
        if (enablePosition)ctx.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION); else ctx.disableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION);
        cc._vertexAttribPosition = enablePosition
    }
    var enableColor = flags & cc.VERTEX_ATTRIB_FLAG_COLOR;
    if (enableColor !== cc._vertexAttribColor) {
        if (enableColor)ctx.enableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR); else ctx.disableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR);
        cc._vertexAttribColor = enableColor
    }
    var enableTexCoords = flags & cc.VERTEX_ATTRIB_FLAG_TEX_COORDS;
    if (enableTexCoords !== cc._vertexAttribTexCoords) {
        if (enableTexCoords)ctx.enableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS); else ctx.disableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS);
        cc._vertexAttribTexCoords = enableTexCoords
    }
};
cc.glBindTexture2D = function (textureId) {
    cc.glBindTexture2DN(0, textureId)
};
cc.glBindTexture2DN = function (textureUnit, textureId) {
    if (cc._currentBoundTexture[textureUnit] == textureId)return;
    cc._currentBoundTexture[textureUnit] = textureId;
    var ctx = cc._renderContext;
    ctx.activeTexture(ctx.TEXTURE0 + textureUnit);
    if (textureId)ctx.bindTexture(ctx.TEXTURE_2D, textureId._webTextureObj); else ctx.bindTexture(ctx.TEXTURE_2D, null)
};
if (!cc.ENABLE_GL_STATE_CACHE)cc.glBindTexture2DN = function (textureUnit, textureId) {
    var ctx = cc._renderContext;
    ctx.activeTexture(ctx.TEXTURE0 + textureUnit);
    if (textureId)ctx.bindTexture(ctx.TEXTURE_2D, textureId._webTextureObj); else ctx.bindTexture(ctx.TEXTURE_2D, null)
};
cc.glDeleteTexture = function (textureId) {
    cc.glDeleteTextureN(0, textureId)
};
cc.glDeleteTextureN = function (textureUnit, textureId) {
    if (cc.ENABLE_GL_STATE_CACHE)if (textureId == cc._currentBoundTexture[textureUnit])cc._currentBoundTexture[textureUnit] = -1;
    cc._renderContext.deleteTexture(textureId)
};
cc.glBindVAO = function (vaoId) {
    if (!cc.TEXTURE_ATLAS_USE_VAO)return;
    if (cc.ENABLE_GL_STATE_CACHE) {
        if (cc._uVAO != vaoId)cc._uVAO = vaoId
    } else;
};
cc.glEnable = function (flags) {
    if (cc.ENABLE_GL_STATE_CACHE); else;
};cc.IMAGE_FORMAT_JPEG = 0;
cc.IMAGE_FORMAT_PNG = 1;
cc.IMAGE_FORMAT_RAWDATA = 2;
cc.NextPOT = function (x) {
    x = x - 1;
    x = x | x >> 1;
    x = x | x >> 2;
    x = x | x >> 4;
    x = x | x >> 8;
    x = x | x >> 16;
    return x + 1
};
cc.RenderTexture = cc.Node.extend({sprite: null, clearFlags: 0, clearDepthVal: 0, autoDraw: false, _cacheCanvas: null, _cacheContext: null, _fBO: 0, _depthRenderBuffer: 0, _oldFBO: 0, _texture: null, _textureCopy: null, _uITextureImage: null, _pixelFormat: cc.Texture2D.PIXEL_FORMAT_RGBA8888, _clearColor: null, clearStencilVal: 0, _clearColorStr: null, _className: "RenderTexture", ctor: null, _ctorForCanvas: function (width, height, format, depthStencilFormat) {
    cc.Node.prototype.ctor.call(this);
    this._clearColor = cc.color(255, 255, 255, 255);
    this._clearColorStr =
        "rgba(255,255,255,1)";
    this._cacheCanvas = cc.newElement("canvas");
    this._cacheContext = this._cacheCanvas.getContext("2d");
    this.anchorX = 0;
    this.anchorY = 0;
    if (width !== undefined && height !== undefined) {
        format = format || cc.Texture2D.PIXEL_FORMAT_RGBA8888;
        depthStencilFormat = depthStencilFormat || 0;
        this.initWithWidthAndHeight(width, height, format, depthStencilFormat)
    }
}, _ctorForWebGL: function (width, height, format, depthStencilFormat) {
    cc.Node.prototype.ctor.call(this);
    this._clearColor = cc.color(0, 0, 0, 0);
    if (width !== undefined &&
        height !== undefined) {
        format = format || cc.Texture2D.PIXEL_FORMAT_RGBA8888;
        depthStencilFormat = depthStencilFormat || 0;
        this.initWithWidthAndHeight(width, height, format, depthStencilFormat)
    }
}, cleanup: null, _cleanupForCanvas: function () {
    cc.Node.prototype.onExit.call(this);
    this._cacheContext = null;
    this._cacheCanvas = null
}, _cleanupForWebGL: function () {
    cc.Node.prototype.onExit.call(this);
    this._textureCopy = null;
    var gl = cc._renderContext;
    gl.deleteFramebuffer(this._fBO);
    if (this._depthRenderBuffer)gl.deleteRenderbuffer(this._depthRenderBuffer);
    this._uITextureImage = null
}, getSprite: function () {
    return this.sprite
}, setSprite: function (sprite) {
    this.sprite = sprite
}, initWithWidthAndHeight: null, _initWithWidthAndHeightForCanvas: function (width, height, format, depthStencilFormat) {
    var locCacheCanvas = this._cacheCanvas, locScaleFactor = cc.contentScaleFactor();
    locCacheCanvas.width = 0 | width * locScaleFactor;
    locCacheCanvas.height = 0 | height * locScaleFactor;
    this._cacheContext.translate(0, locCacheCanvas.height);
    var texture = new cc.Texture2D;
    texture.initWithElement(locCacheCanvas);
    texture.handleLoadedTexture();
    this.sprite = cc.Sprite.create(texture);
    return true
}, _initWithWidthAndHeightForWebGL: function (width, height, format, depthStencilFormat) {
    if (format == cc.Texture2D.PIXEL_FORMAT_A8)cc.log("cc.RenderTexture._initWithWidthAndHeightForWebGL() : only RGB and RGBA formats are valid for a render texture;");
    var gl = cc._renderContext, locScaleFactor = cc.contentScaleFactor();
    width = 0 | width * locScaleFactor;
    height = 0 | height * locScaleFactor;
    this._oldFBO = gl.getParameter(gl.FRAMEBUFFER_BINDING);
    var powW,
        powH;
    if (cc.configuration.supportsNPOT()) {
        powW = width;
        powH = height
    } else {
        powW = cc.NextPOT(width);
        powH = cc.NextPOT(height)
    }
    var dataLen = powW * powH * 4;
    var data = new Uint8Array(dataLen);
    for (var i = 0; i < powW * powH * 4; i++)data[i] = 0;
    this._pixelFormat = format;
    this._texture = new cc.Texture2D;
    if (!this._texture)return false;
    var locTexture = this._texture;
    locTexture.initWithData(data, this._pixelFormat, powW, powH, cc.size(width, height));
    var oldRBO = gl.getParameter(gl.RENDERBUFFER_BINDING);
    if (cc.configuration.checkForGLExtension("GL_QCOM")) {
        this._textureCopy =
            new cc.Texture2D;
        if (!this._textureCopy)return false;
        this._textureCopy.initWithData(data, this._pixelFormat, powW, powH, cc.size(width, height))
    }
    this._fBO = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._fBO);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, locTexture._webTextureObj, 0);
    if (depthStencilFormat != 0) {
        this._depthRenderBuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, this._depthRenderBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, depthStencilFormat,
            powW, powH);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this._depthRenderBuffer)
    }
    if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE)cc.log("Could not attach texture to the framebuffer");
    locTexture.setAliasTexParameters();
    this.sprite = cc.Sprite.create(locTexture);
    var locSprite = this.sprite;
    locSprite.scaleY = -1;
    locSprite.setBlendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    gl.bindRenderbuffer(gl.RENDERBUFFER, oldRBO);
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._oldFBO);
    this.autoDraw = false;
    this.addChild(locSprite);
    return true
}, begin: null, _beginForCanvas: function () {
    cc._renderContext = this._cacheContext;
    cc.view._setScaleXYForRenderTexture()
}, _beginForWebGL: function () {
    cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
    cc.kmGLPushMatrix();
    cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
    cc.kmGLPushMatrix();
    var director = cc.director;
    director.setProjection(director.getProjection());
    var texSize = this._texture.getContentSizeInPixels();
    var size = cc.director.getWinSizeInPixels();
    var widthRatio = size.width /
        texSize.width;
    var heightRatio = size.height / texSize.height;
    var gl = cc._renderContext;
    gl.viewport(0, 0, texSize.width, texSize.height);
    var orthoMatrix = new cc.kmMat4;
    cc.kmMat4OrthographicProjection(orthoMatrix, -1 / widthRatio, 1 / widthRatio, -1 / heightRatio, 1 / heightRatio, -1, 1);
    cc.kmGLMultMatrix(orthoMatrix);
    this._oldFBO = gl.getParameter(gl.FRAMEBUFFER_BINDING);
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._fBO);
    if (cc.configuration.checkForGLExtension("GL_QCOM")) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,
            gl.TEXTURE_2D, this._textureCopy._webTextureObj, 0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._texture._webTextureObj, 0)
    }
}, beginWithClear: function (r, g, b, a, depthValue, stencilValue) {
    var gl = cc._renderContext;
    depthValue = depthValue || gl.COLOR_BUFFER_BIT;
    stencilValue = stencilValue || gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT;
    this._beginWithClear(r, g, b, a, depthValue, stencilValue, gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT)
},
    _beginWithClear: null, _beginWithClearForCanvas: function (r, g, b, a, depthValue, stencilValue, flags) {
        this.begin();
        r = r || 0;
        g = g || 0;
        b = b || 0;
        a = isNaN(a) ? 1 : a;
        var context = this._cacheContext;
        var locCanvas = this._cacheCanvas;
        context.save();
        context.fillStyle = "rgba(" + (0 | r) + "," + (0 | g) + "," + (0 | b) + "," + a / 255 + ")";
        context.clearRect(0, 0, locCanvas.width, -locCanvas.height);
        context.fillRect(0, 0, locCanvas.width, -locCanvas.height);
        context.restore()
    }, _beginWithClearForWebGL: function (r, g, b, a, depthValue, stencilValue, flags) {
        this.begin();
        var gl = cc._renderContext;
        var clearColor = [0, 0, 0, 0];
        var depthClearValue = 0;
        var stencilClearValue = 0;
        if (flags & gl.COLOR_BUFFER_BIT) {
            clearColor = gl.getParameter(gl.COLOR_CLEAR_VALUE);
            gl.clearColor(r, g, b, a)
        }
        if (flags & gl.DEPTH_BUFFER_BIT) {
            depthClearValue = gl.getParameter(gl.DEPTH_CLEAR_VALUE);
            gl.clearDepth(depthValue)
        }
        if (flags & gl.STENCIL_BUFFER_BIT) {
            stencilClearValue = gl.getParameter(gl.STENCIL_CLEAR_VALUE);
            gl.clearStencil(stencilValue)
        }
        gl.clear(flags);
        if (flags & gl.COLOR_BUFFER_BIT)gl.clearColor(clearColor[0],
            clearColor[1], clearColor[2], clearColor[3]);
        if (flags & gl.DEPTH_BUFFER_BIT)gl.clearDepth(depthClearValue);
        if (flags & gl.STENCIL_BUFFER_BIT)gl.clearStencil(stencilClearValue)
    }, end: null, _endForCanvas: function () {
        cc._renderContext = cc._mainRenderContextBackup;
        cc.view._resetScale()
    }, _endForWebGL: function () {
        var gl = cc._renderContext;
        var director = cc.director;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._oldFBO);
        director.setViewport();
        cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
        cc.kmGLPopMatrix();
        cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
        cc.kmGLPopMatrix()
    }, clear: function (r, g, b, a) {
        this.beginWithClear(r, g, b, a);
        this.end()
    }, clearRect: null, _clearRectForCanvas: function (x, y, width, height) {
        this._cacheContext.clearRect(x, y, width, -height)
    }, _clearRectForWebGL: function (x, y, width, height) {
    }, clearDepth: null, _clearDepthForCanvas: function (depthValue) {
        cc.log("clearDepth isn't supported on Cocos2d-Html5")
    }, _clearDepthForWebGL: function (depthValue) {
        this.begin();
        var gl = cc._renderContext;
        var depthClearValue = gl.getParameter(gl.DEPTH_CLEAR_VALUE);
        gl.clearDepth(depthValue);
        gl.clear(gl.DEPTH_BUFFER_BIT);
        gl.clearDepth(depthClearValue);
        this.end()
    }, clearStencil: null, _clearStencilForCanvas: function (stencilValue) {
        cc.log("clearDepth isn't supported on Cocos2d-Html5")
    }, _clearStencilForWebGL: function (stencilValue) {
        var gl = cc._renderContext;
        var stencilClearValue = gl.getParameter(gl.STENCIL_CLEAR_VALUE);
        gl.clearStencil(stencilValue);
        gl.clear(gl.STENCIL_BUFFER_BIT);
        gl.clearStencil(stencilClearValue)
    }, visit: null, _visitForCanvas: function (ctx) {
        if (!this._visible)return;
        ctx = ctx || cc._renderContext;
        ctx.save();
        this.draw(ctx);
        this.transform(ctx);
        this.sprite.visit();
        ctx.restore();
        this.arrivalOrder = 0
    }, _visitForWebGL: function (ctx) {
        if (!this._visible)return;
        cc.kmGLPushMatrix();
        var locGrid = this.grid;
        if (locGrid && locGrid.isActive()) {
            locGrid.beforeDraw();
            this.transformAncestors()
        }
        this.transform(ctx);
        this.sprite.visit();
        this.draw(ctx);
        if (locGrid && locGrid.isActive())locGrid.afterDraw(this);
        cc.kmGLPopMatrix();
        this.arrivalOrder = 0
    }, draw: null, _drawForCanvas: function (ctx) {
        ctx = ctx || cc._renderContext;
        if (this.autoDraw) {
            this.begin();
            if (this.clearFlags) {
                var locCanvas = this._cacheCanvas;
                ctx.save();
                ctx.fillStyle = this._clearColorStr;
                ctx.clearRect(0, 0, locCanvas.width, -locCanvas.height);
                ctx.fillRect(0, 0, locCanvas.width, -locCanvas.height);
                ctx.restore()
            }
            this.sortAllChildren();
            var locChildren = this._children;
            var childrenLen = locChildren.length;
            var selfSprite = this.sprite;
            for (var i = 0; i < childrenLen; i++) {
                var getChild = locChildren[i];
                if (getChild != selfSprite)getChild.visit()
            }
            this.end()
        }
    }, _drawForWebGL: function (ctx) {
        var gl = cc._renderContext;
        if (this.autoDraw) {
            this.begin();
            var locClearFlags = this.clearFlags;
            if (locClearFlags) {
                var oldClearColor = [0, 0, 0, 0];
                var oldDepthClearValue = 0;
                var oldStencilClearValue = 0;
                if (locClearFlags & gl.COLOR_BUFFER_BIT) {
                    oldClearColor = gl.getParameter(gl.COLOR_CLEAR_VALUE);
                    gl.clearColor(this._clearColor.r / 255, this._clearColor.g / 255, this._clearColor.b / 255, this._clearColor.a / 255)
                }
                if (locClearFlags & gl.DEPTH_BUFFER_BIT) {
                    oldDepthClearValue = gl.getParameter(gl.DEPTH_CLEAR_VALUE);
                    gl.clearDepth(this.clearDepthVal)
                }
                if (locClearFlags & gl.STENCIL_BUFFER_BIT) {
                    oldStencilClearValue =
                        gl.getParameter(gl.STENCIL_CLEAR_VALUE);
                    gl.clearStencil(this.clearStencilVal)
                }
                gl.clear(locClearFlags);
                if (locClearFlags & gl.COLOR_BUFFER_BIT)gl.clearColor(oldClearColor[0], oldClearColor[1], oldClearColor[2], oldClearColor[3]);
                if (locClearFlags & gl.DEPTH_BUFFER_BIT)gl.clearDepth(oldDepthClearValue);
                if (locClearFlags & gl.STENCIL_BUFFER_BIT)gl.clearStencil(oldStencilClearValue)
            }
            this.sortAllChildren();
            var locChildren = this._children;
            for (var i = 0; i < locChildren.length; i++) {
                var getChild = locChildren[i];
                if (getChild !=
                    this.sprite)getChild.visit()
            }
            this.end()
        }
    }, newCCImage: function (flipImage) {
        cc.log("saveToFile isn't supported on cocos2d-html5");
        return null
    }, _memcpy: function (destArr, destIndex, srcArr, srcIndex, size) {
        for (var i = 0; i < size; i++)destArr[destIndex + i] = srcArr[srcIndex + i]
    }, saveToFile: function (filePath, format) {
        cc.log("saveToFile isn't supported on Cocos2d-Html5")
    }, listenToBackground: function (obj) {
        cc.log("listenToBackground isn't supported on Cocos2d-Html5")
    }, listenToForeground: function (obj) {
        cc.log("listenToForeground isn't supported on Cocos2d-Html5")
    },
    getClearFlags: function () {
        return this.clearFlags
    }, setClearFlags: function (clearFlags) {
        this.clearFlags = clearFlags
    }, getClearColor: function () {
        return this._clearColor
    }, setClearColor: null, _setClearColorForCanvas: function (clearColor) {
        var locClearColor = this._clearColor;
        locClearColor.r = clearColor.r;
        locClearColor.g = clearColor.g;
        locClearColor.b = clearColor.b;
        locClearColor.a = clearColor.a;
        this._clearColorStr = "rgba(" + (0 | clearColor.r) + "," + (0 | clearColor.g) + "," + (0 | clearColor.b) + "," + clearColor.a / 255 + ")"
    }, _setClearColorForWebGL: function (clearColor) {
        var locClearColor =
            this._clearColor;
        locClearColor.r = clearColor.r;
        locClearColor.g = clearColor.g;
        locClearColor.b = clearColor.b;
        locClearColor.a = clearColor.a
    }, getClearDepth: function () {
        return this.clearDepthVal
    }, setClearDepth: function (clearDepth) {
        this.clearDepthVal = clearDepth
    }, getClearStencil: function () {
        return this.clearStencilVal
    }, setClearStencil: function (clearStencil) {
        this.clearStencilVal = clearStencil
    }, isAutoDraw: function () {
        return this.autoDraw
    }, setAutoDraw: function (autoDraw) {
        this.autoDraw = autoDraw
    }});
var _p = cc.RenderTexture.prototype;
if (cc._renderType == cc._RENDER_TYPE_WEBGL) {
    _p.ctor = _p._ctorForWebGL;
    _p.cleanup = _p._cleanupForWebGL;
    _p.initWithWidthAndHeight = _p._initWithWidthAndHeightForWebGL;
    _p.begin = _p._beginForWebGL;
    _p._beginWithClear = _p._beginWithClearForWebGL;
    _p.end = _p._endForWebGL;
    _p.clearRect = _p._clearRectForWebGL;
    _p.clearDepth = _p._clearDepthForWebGL;
    _p.clearStencil = _p._clearStencilForWebGL;
    _p.visit = _p._visitForWebGL;
    _p.draw = _p._drawForWebGL;
    _p.setClearColor = _p._setClearColorForWebGL
} else {
    _p.ctor = _p._ctorForCanvas;
    _p.cleanup =
        _p._cleanupForCanvas;
    _p.initWithWidthAndHeight = _p._initWithWidthAndHeightForCanvas;
    _p.begin = _p._beginForCanvas;
    _p._beginWithClear = _p._beginWithClearForCanvas;
    _p.end = _p._endForCanvas;
    _p.clearRect = _p._clearRectForCanvas;
    _p.clearDepth = _p._clearDepthForCanvas;
    _p.clearStencil = _p._clearStencilForCanvas;
    _p.visit = _p._visitForCanvas;
    _p.draw = _p._drawForCanvas;
    _p.setClearColor = _p._setClearColorForCanvas
}
_p.clearColorVal;
cc.defineGetterSetter(_p, "clearColorVal", _p.getClearColor, _p.setClearColor);
cc.RenderTexture.create = function (width, height, format, depthStencilFormat) {
    return new cc.RenderTexture(width, height, format, depthStencilFormat)
};cc.LabelAtlas = cc.AtlasNode.extend({_string: null, _mapStartChar: null, _textureLoaded: false, _loadedEventListeners: null, _className: "LabelAtlas", ctor: function (strText, charMapFile, itemWidth, itemHeight, startCharMap) {
    cc.AtlasNode.prototype.ctor.call(this);
    charMapFile && cc.LabelAtlas.prototype.initWithString.call(this, strText, charMapFile, itemWidth, itemHeight, startCharMap)
}, textureLoaded: function () {
    return this._textureLoaded
}, addLoadedEventListener: function (callback, target) {
    if (!this._loadedEventListeners)this._loadedEventListeners =
        [];
    this._loadedEventListeners.push({eventCallback: callback, eventTarget: target})
}, _callLoadedEventCallbacks: function () {
    if (!this._loadedEventListeners)return;
    this._textureLoaded = true;
    var locListeners = this._loadedEventListeners;
    for (var i = 0, len = locListeners.length; i < len; i++) {
        var selCallback = locListeners[i];
        selCallback.eventCallback.call(selCallback.eventTarget, this)
    }
    locListeners.length = 0
}, initWithString: function (strText, charMapFile, itemWidth, itemHeight, startCharMap) {
    var label = strText + "", textureFilename,
        width, height, startChar;
    if (itemWidth === undefined) {
        var dict = cc.loader.getRes(charMapFile);
        if (parseInt(dict["version"], 10) !== 1) {
            cc.log("cc.LabelAtlas.initWithString(): Unsupported version. Upgrade cocos2d version");
            return false
        }
        textureFilename = cc.path.changeBasename(charMapFile, dict["textureFilename"]);
        var locScaleFactor = cc.contentScaleFactor();
        width = parseInt(dict["itemWidth"], 10) / locScaleFactor;
        height = parseInt(dict["itemHeight"], 10) / locScaleFactor;
        startChar = String.fromCharCode(parseInt(dict["firstChar"],
            10))
    } else {
        textureFilename = charMapFile;
        width = itemWidth || 0;
        height = itemHeight || 0;
        startChar = startCharMap || " "
    }
    var texture = null;
    if (textureFilename instanceof cc.Texture2D)texture = textureFilename; else texture = cc.textureCache.addImage(textureFilename);
    var locLoaded = texture.isLoaded();
    this._textureLoaded = locLoaded;
    if (!locLoaded)texture.addLoadedEventListener(function (sender) {
        this.initWithTexture(texture, width, height, label.length);
        this.string = label;
        this._callLoadedEventCallbacks()
    }, this);
    if (this.initWithTexture(texture,
        width, height, label.length)) {
        this._mapStartChar = startChar;
        this.string = label;
        return true
    }
    return false
}, setColor: function (color3) {
    cc.AtlasNode.prototype.setColor.call(this, color3);
    this.updateAtlasValues()
}, getString: function () {
    return this._string
}, draw: function (ctx) {
    cc.AtlasNode.prototype.draw.call(this, ctx);
    if (cc.LABELATLAS_DEBUG_DRAW) {
        var s = this.size;
        var vertices = [cc.p(0, 0), cc.p(s.width, 0), cc.p(s.width, s.height), cc.p(0, s.height)];
        cc._drawingUtil.drawPoly(vertices, 4, true)
    }
}, _addChildForCanvas: function (child, zOrder, tag) {
    child._lateChild = true;
    cc.NodeRGBA.prototype.addChild.call(this, child, zOrder, tag)
}, updateAtlasValues: null, _updateAtlasValuesForCanvas: function () {
    var locString = this._string || "";
    var n = locString.length;
    var texture = this.texture;
    var locItemWidth = this._itemWidth, locItemHeight = this._itemHeight;
    for (var i = 0; i < n; i++) {
        var a = locString.charCodeAt(i) - this._mapStartChar.charCodeAt(0);
        var row = parseInt(a % this._itemsPerRow, 10);
        var col = parseInt(a / this._itemsPerRow, 10);
        var rect = cc.rect(row * locItemWidth, col *
            locItemHeight, locItemWidth, locItemHeight);
        var c = locString.charCodeAt(i);
        var fontChar = this.getChildByTag(i);
        if (!fontChar) {
            fontChar = new cc.Sprite;
            if (c == 32) {
                fontChar.init();
                fontChar.setTextureRect(cc.rect(0, 0, 10, 10), false, cc.size(0, 0))
            } else fontChar.initWithTexture(texture, rect);
            cc.NodeRGBA.prototype.addChild.call(this, fontChar, 0, i)
        } else if (c == 32) {
            fontChar.init();
            fontChar.setTextureRect(cc.rect(0, 0, 10, 10), false, cc.size(0, 0))
        } else {
            fontChar.initWithTexture(texture, rect);
            fontChar.visible = true;
            fontChar.opacity =
                this._displayedOpacity
        }
        fontChar.setPosition(i * locItemWidth + locItemWidth / 2, locItemHeight / 2)
    }
}, _updateAtlasValuesForWebGL: function () {
    var locString = this._string;
    var n = locString.length;
    var locTextureAtlas = this.textureAtlas;
    var texture = locTextureAtlas.texture;
    var textureWide = texture.pixelsWidth;
    var textureHigh = texture.pixelsHeight;
    var itemWidthInPixels = this._itemWidth;
    var itemHeightInPixels = this._itemHeight;
    if (!this._ignoreContentScaleFactor) {
        itemWidthInPixels = this._itemWidth * cc.contentScaleFactor();
        itemHeightInPixels =
            this._itemHeight * cc.contentScaleFactor()
    }
    if (n > locTextureAtlas.getCapacity())cc.log("cc.LabelAtlas._updateAtlasValues(): Invalid String length");
    var quads = locTextureAtlas.quads;
    var locDisplayedColor = this._displayedColor;
    var curColor = {r: locDisplayedColor.r, g: locDisplayedColor.g, b: locDisplayedColor.b, a: this._displayedOpacity};
    var locItemWidth = this._itemWidth;
    for (var i = 0; i < n; i++) {
        var a = locString.charCodeAt(i) - this._mapStartChar.charCodeAt(0);
        var row = a % this._itemsPerRow;
        var col = 0 | a / this._itemsPerRow;
        var left,
            right, top, bottom;
        if (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL) {
            left = (2 * row * itemWidthInPixels + 1) / (2 * textureWide);
            right = left + (itemWidthInPixels * 2 - 2) / (2 * textureWide);
            top = (2 * col * itemHeightInPixels + 1) / (2 * textureHigh);
            bottom = top + (itemHeightInPixels * 2 - 2) / (2 * textureHigh)
        } else {
            left = row * itemWidthInPixels / textureWide;
            right = left + itemWidthInPixels / textureWide;
            top = col * itemHeightInPixels / textureHigh;
            bottom = top + itemHeightInPixels / textureHigh
        }
        var quad = quads[i];
        var locQuadTL = quad.tl, locQuadTR = quad.tr, locQuadBL = quad.bl, locQuadBR =
            quad.br;
        locQuadTL.texCoords.u = left;
        locQuadTL.texCoords.v = top;
        locQuadTR.texCoords.u = right;
        locQuadTR.texCoords.v = top;
        locQuadBL.texCoords.u = left;
        locQuadBL.texCoords.v = bottom;
        locQuadBR.texCoords.u = right;
        locQuadBR.texCoords.v = bottom;
        locQuadBL.vertices.x = i * locItemWidth;
        locQuadBL.vertices.y = 0;
        locQuadBL.vertices.z = 0;
        locQuadBR.vertices.x = i * locItemWidth + locItemWidth;
        locQuadBR.vertices.y = 0;
        locQuadBR.vertices.z = 0;
        locQuadTL.vertices.x = i * locItemWidth;
        locQuadTL.vertices.y = this._itemHeight;
        locQuadTL.vertices.z = 0;
        locQuadTR.vertices.x = i * locItemWidth + locItemWidth;
        locQuadTR.vertices.y = this._itemHeight;
        locQuadTR.vertices.z = 0;
        locQuadTL.colors = curColor;
        locQuadTR.colors = curColor;
        locQuadBL.colors = curColor;
        locQuadBR.colors = curColor
    }
    if (n > 0) {
        locTextureAtlas.dirty = true;
        var totalQuads = locTextureAtlas.totalQuads;
        if (n > totalQuads)locTextureAtlas.increaseTotalQuadsWith(n - totalQuads)
    }
}, setString: null, _setStringForCanvas: function (label) {
    label = String(label);
    var len = label.length;
    this._string = label;
    this.width = len * this._itemWidth;
    this.height = this._itemHeight;
    if (this._children) {
        var locChildren = this._children;
        len = locChildren.length;
        for (var i = 0; i < len; i++) {
            var node = locChildren[i];
            if (node && !node._lateChild)node.visible = false
        }
    }
    this.updateAtlasValues();
    this.quadsToDraw = len
}, _setStringForWebGL: function (label) {
    label = String(label);
    var len = label.length;
    if (len > this.textureAtlas.totalQuads)this.textureAtlas.resizeCapacity(len);
    this._string = label;
    this.width = len * this._itemWidth;
    this.height = this._itemHeight;
    this.updateAtlasValues();
    this.quadsToDraw =
        len
}, setOpacity: null, _setOpacityForCanvas: function (opacity) {
    if (this._displayedOpacity !== opacity) {
        cc.AtlasNode.prototype.setOpacity.call(this, opacity);
        var locChildren = this._children;
        for (var i = 0, len = locChildren.length; i < len; i++)if (locChildren[i])locChildren[i].opacity = opacity
    }
}, _setOpacityForWebGL: function (opacity) {
    if (this._opacity !== opacity)cc.AtlasNode.prototype.setOpacity.call(this, opacity)
}});
var _p = cc.LabelAtlas.prototype;
if (cc._renderType === cc._RENDER_TYPE_WEBGL) {
    _p.updateAtlasValues = _p._updateAtlasValuesForWebGL;
    _p.setString = _p._setStringForWebGL;
    _p.setOpacity = _p._setOpacityForWebGL
} else {
    _p.updateAtlasValues = _p._updateAtlasValuesForCanvas;
    _p.setString = _p._setStringForCanvas;
    _p.setOpacity = _p._setOpacityForCanvas;
    _p.addChild = _p._addChildForCanvas
}
cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
_p.string;
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
cc.LabelAtlas.create = function (strText, charMapFile, itemWidth, itemHeight, startCharMap) {
    return new cc.LabelAtlas(strText, charMapFile, itemWidth, itemHeight, startCharMap)
};
cc.LABEL_AUTOMATIC_WIDTH = -1;
cc.LabelBMFont = cc.SpriteBatchNode.extend({RGBAProtocol: true, _opacityModifyRGB: false, _string: "", _config: null, _fntFile: "", _initialString: "", _alignment: cc.TEXT_ALIGNMENT_CENTER, _width: -1, _lineBreakWithoutSpaces: false, _imageOffset: null, _reusedChar: null, _displayedOpacity: 255, _realOpacity: 255, _displayedColor: null, _realColor: null, _cascadeColorEnabled: true, _cascadeOpacityEnabled: true, _textureLoaded: false, _loadedEventListeners: null, _className: "LabelBMFont", _setString: function (newString, needUpdateLabel) {
    if (!needUpdateLabel)this._string =
        newString; else this._initialString = newString;
    var locChildren = this._children;
    if (locChildren)for (var i = 0; i < locChildren.length; i++) {
        var selNode = locChildren[i];
        if (selNode)selNode.setVisible(false)
    }
    if (this._textureLoaded) {
        this.createFontChars();
        if (needUpdateLabel)this.updateLabel()
    }
}, ctor: function (str, fntFile, width, alignment, imageOffset) {
    var self = this;
    cc.SpriteBatchNode.prototype.ctor.call(self);
    self._imageOffset = cc.p(0, 0);
    self._displayedColor = cc.color(255, 255, 255, 255);
    self._realColor = cc.color(255, 255,
        255, 255);
    self._reusedChar = [];
    this.initWithString(str, fntFile, width, alignment, imageOffset)
}, textureLoaded: function () {
    return this._textureLoaded
}, addLoadedEventListener: function (callback, target) {
    if (!this._loadedEventListeners)this._loadedEventListeners = [];
    this._loadedEventListeners.push({eventCallback: callback, eventTarget: target})
}, _callLoadedEventCallbacks: function () {
    if (!this._loadedEventListeners)return;
    var locListeners = this._loadedEventListeners;
    for (var i = 0, len = locListeners.length; i < len; i++) {
        var selCallback =
            locListeners[i];
        selCallback.eventCallback.call(selCallback.eventTarget, this)
    }
    locListeners.length = 0
}, draw: function (ctx) {
    cc.SpriteBatchNode.prototype.draw.call(this, ctx);
    if (cc.LABELBMFONT_DEBUG_DRAW) {
        var size = this.getContentSize();
        var pos = cc.p(0 | -this._anchorPointInPoints.x, 0 | -this._anchorPointInPoints.y);
        var vertices = [cc.p(pos.x, pos.y), cc.p(pos.x + size.width, pos.y), cc.p(pos.x + size.width, pos.y + size.height), cc.p(pos.x, pos.y + size.height)];
        cc._drawingUtil.setDrawColor(0, 255, 0, 255);
        cc._drawingUtil.drawPoly(vertices,
            4, true)
    }
}, setColor: function (color) {
    var locDisplayed = this._displayedColor, locRealColor = this._realColor;
    if (locRealColor.r == color.r && locRealColor.g == color.g && locRealColor.b == color.b && locRealColor.a == color.a)return;
    locDisplayed.r = locRealColor.r = color.r;
    locDisplayed.g = locRealColor.g = color.g;
    locDisplayed.b = locRealColor.b = color.b;
    if (this._textureLoaded)if (this._cascadeColorEnabled) {
        var parentColor = cc.color.WHITE;
        var locParent = this._parent;
        if (locParent && locParent.RGBAProtocol && locParent.cascadeColor)parentColor =
            locParent.getDisplayedColor();
        this.updateDisplayedColor(parentColor)
    }
    if (color.a !== undefined && !color.a_undefined)this.setOpacity(color.a)
}, isOpacityModifyRGB: function () {
    return this._opacityModifyRGB
}, setOpacityModifyRGB: function (opacityModifyRGB) {
    this._opacityModifyRGB = opacityModifyRGB;
    var locChildren = this._children;
    if (locChildren)for (var i = 0; i < locChildren.length; i++) {
        var node = locChildren[i];
        if (node && node.RGBAProtocol)node.opacityModifyRGB = this._opacityModifyRGB
    }
}, getOpacity: function () {
    return this._realOpacity
},
    getDisplayedOpacity: function () {
        return this._displayedOpacity
    }, setOpacity: function (opacity) {
        this._displayedOpacity = this._realOpacity = opacity;
        if (this._cascadeOpacityEnabled) {
            var parentOpacity = 255;
            var locParent = this._parent;
            if (locParent && locParent.RGBAProtocol && locParent.cascadeOpacity)parentOpacity = locParent.getDisplayedOpacity();
            this.updateDisplayedOpacity(parentOpacity)
        }
        this._displayedColor.a = this._realColor.a = opacity
    }, updateDisplayedOpacity: function (parentOpacity) {
        this._displayedOpacity = this._realOpacity *
            parentOpacity / 255;
        var locChildren = this._children;
        for (var i = 0; i < locChildren.length; i++) {
            var locChild = locChildren[i];
            if (cc._renderType == cc._RENDER_TYPE_WEBGL)locChild.updateDisplayedOpacity(this._displayedOpacity); else {
                cc.NodeRGBA.prototype.updateDisplayedOpacity.call(locChild, this._displayedOpacity);
                locChild.setNodeDirty()
            }
        }
        this._changeTextureColor()
    }, isCascadeOpacityEnabled: function () {
        return false
    }, setCascadeOpacityEnabled: function (cascadeOpacityEnabled) {
        this._cascadeOpacityEnabled = cascadeOpacityEnabled
    },
    getColor: function () {
        var locRealColor = this._realColor;
        return cc.color(locRealColor.r, locRealColor.g, locRealColor.b, locRealColor.a)
    }, getDisplayedColor: function () {
        return this._displayedColor
    }, updateDisplayedColor: function (parentColor) {
        var locDispColor = this._displayedColor;
        var locRealColor = this._realColor;
        locDispColor.r = locRealColor.r * parentColor.r / 255;
        locDispColor.g = locRealColor.g * parentColor.g / 255;
        locDispColor.b = locRealColor.b * parentColor.b / 255;
        var locChildren = this._children;
        for (var i = 0; i < locChildren.length; i++) {
            var locChild =
                locChildren[i];
            if (cc._renderType == cc._RENDER_TYPE_WEBGL)locChild.updateDisplayedColor(this._displayedColor); else {
                cc.NodeRGBA.prototype.updateDisplayedColor.call(locChild, this._displayedColor);
                locChild.setNodeDirty()
            }
        }
        this._changeTextureColor()
    }, _changeTextureColor: function () {
        if (cc._renderType == cc._RENDER_TYPE_WEBGL)return;
        var locElement, locTexture = this.texture;
        if (locTexture && locTexture.width > 0) {
            locElement = locTexture.getHtmlElementObj();
            if (!locElement)return;
            var cacheTextureForColor = cc.textureCache.getTextureColors(this._originalTexture.getHtmlElementObj());
            if (cacheTextureForColor)if (locElement instanceof HTMLCanvasElement && !this._rectRotated)cc.generateTintImage(locElement, cacheTextureForColor, this._displayedColor, null, locElement); else {
                locElement = cc.generateTintImage(locElement, cacheTextureForColor, this._displayedColor);
                locTexture = new cc.Texture2D;
                locTexture.initWithElement(locElement);
                locTexture.handleLoadedTexture();
                this.texture = locTexture
            }
        }
    }, isCascadeColorEnabled: function () {
        return false
    }, setCascadeColorEnabled: function (cascadeColorEnabled) {
        this._cascadeColorEnabled =
            cascadeColorEnabled
    }, init: function () {
        return this.initWithString(null, null, null, null, null)
    }, initWithString: function (str, fntFile, width, alignment, imageOffset) {
        var self = this, theString = str || "";
        if (self._config)cc.log("cc.LabelBMFont.initWithString(): re-init is no longer supported");
        var texture;
        if (fntFile) {
            var newConf = cc.loader.getRes(fntFile);
            if (!newConf) {
                cc.log("cc.LabelBMFont.initWithString(): Impossible to create font. Please check file");
                return false
            }
            self._config = newConf;
            self._fntFile = fntFile;
            texture =
                cc.textureCache.addImage(newConf.atlasName);
            var locIsLoaded = texture.isLoaded();
            self._textureLoaded = locIsLoaded;
            if (!locIsLoaded)texture.addLoadedEventListener(function (sender) {
                var self1 = this;
                self1._textureLoaded = true;
                self1.initWithTexture(sender, self1._initialString.length);
                self1.setString(self1._initialString, true);
                self1._callLoadedEventCallbacks()
            }, self)
        } else {
            texture = new cc.Texture2D;
            var image = new Image;
            texture.initWithElement(image);
            self._textureLoaded = false
        }
        if (self.initWithTexture(texture, theString.length)) {
            self._alignment =
                alignment || cc.TEXT_ALIGNMENT_LEFT;
            self._imageOffset = imageOffset || cc.p(0, 0);
            self._width = width == null ? -1 : width;
            self._displayedOpacity = self._realOpacity = 255;
            self._displayedColor = cc.color(255, 255, 255, 255);
            self._realColor = cc.color(255, 255, 255, 255);
            self._cascadeOpacityEnabled = true;
            self._cascadeColorEnabled = true;
            self._contentSize.width = 0;
            self._contentSize.height = 0;
            self.setAnchorPoint(0.5, 0.5);
            if (cc._renderType === cc._RENDER_TYPE_WEBGL) {
                var locTexture = self.textureAtlas.texture;
                self._opacityModifyRGB = locTexture.hasPremultipliedAlpha();
                var reusedChar = self._reusedChar = new cc.Sprite;
                reusedChar.initWithTexture(locTexture, cc.rect(0, 0, 0, 0), false);
                reusedChar.batchNode = self
            }
            self.setString(theString, true);
            return true
        }
        return false
    }, createFontChars: function () {
        var self = this;
        var locContextType = cc._renderType;
        var locTexture = locContextType === cc._RENDER_TYPE_CANVAS ? self.texture : self.textureAtlas.texture;
        var nextFontPositionX = 0;
        var tmpSize = cc.size(0, 0);
        var longestLine = 0;
        var quantityOfLines = 1;
        var locStr = self._string;
        var stringLen = locStr ? locStr.length :
            0;
        if (stringLen === 0)return;
        var i, locCfg = self._config, locKerningDict = locCfg.kerningDict, locCommonH = locCfg.commonHeight, locFontDict = locCfg.fontDefDictionary;
        for (i = 0; i < stringLen - 1; i++)if (locStr.charCodeAt(i) == 10)quantityOfLines++;
        var totalHeight = locCommonH * quantityOfLines;
        var nextFontPositionY = -(locCommonH - locCommonH * quantityOfLines);
        var prev = -1;
        for (i = 0; i < stringLen; i++) {
            var key = locStr.charCodeAt(i);
            if (key == 0)continue;
            if (key === 10) {
                nextFontPositionX = 0;
                nextFontPositionY -= locCfg.commonHeight;
                continue
            }
            var kerningAmount =
                locKerningDict[prev << 16 | key & 65535] || 0;
            var fontDef = locFontDict[key];
            if (!fontDef) {
                cc.log("cocos2d: LabelBMFont: character not found " + locStr[i]);
                continue
            }
            var rect = cc.rect(fontDef.rect.x, fontDef.rect.y, fontDef.rect.width, fontDef.rect.height);
            rect = cc.rectPixelsToPoints(rect);
            rect.x += self._imageOffset.x;
            rect.y += self._imageOffset.y;
            var fontChar = self.getChildByTag(i);
            if (!fontChar) {
                fontChar = new cc.Sprite;
                if (key === 32 && locContextType === cc._RENDER_TYPE_CANVAS)rect = cc.rect(0, 0, 0, 0);
                fontChar.initWithTexture(locTexture,
                    rect, false);
                fontChar._newTextureWhenChangeColor = true;
                self.addChild(fontChar, 0, i)
            } else if (key === 32 && locContextType === cc._RENDER_TYPE_CANVAS)fontChar.setTextureRect(rect, false, cc.size(0, 0)); else {
                fontChar.setTextureRect(rect, false);
                fontChar.visible = true
            }
            fontChar.opacityModifyRGB = self._opacityModifyRGB;
            if (cc._renderType == cc._RENDER_TYPE_WEBGL) {
                fontChar.updateDisplayedColor(self._displayedColor);
                fontChar.updateDisplayedOpacity(self._displayedOpacity)
            } else {
                cc.NodeRGBA.prototype.updateDisplayedColor.call(fontChar,
                    self._displayedColor);
                cc.NodeRGBA.prototype.updateDisplayedOpacity.call(fontChar, self._displayedOpacity);
                fontChar.setNodeDirty()
            }
            var yOffset = locCfg.commonHeight - fontDef.yOffset;
            var fontPos = cc.p(nextFontPositionX + fontDef.xOffset + fontDef.rect.width * 0.5 + kerningAmount, nextFontPositionY + yOffset - rect.height * 0.5 * cc.contentScaleFactor());
            fontChar.setPosition(cc.pointPixelsToPoints(fontPos));
            nextFontPositionX += fontDef.xAdvance + kerningAmount;
            prev = key;
            if (longestLine < nextFontPositionX)longestLine = nextFontPositionX
        }
        tmpSize.width =
            longestLine;
        tmpSize.height = totalHeight;
        self.setContentSize(cc.sizePixelsToPoints(tmpSize))
    }, updateString: function (fromUpdate) {
        var self = this;
        var locChildren = self._children;
        if (locChildren)for (var i = 0, li = locChildren.length; i < li; i++) {
            var node = locChildren[i];
            if (node)node.visible = false
        }
        if (self._config)self.createFontChars();
        if (!fromUpdate)self.updateLabel()
    }, getString: function () {
        return this._initialString
    }, setString: function (newString, needUpdateLabel) {
        newString = String(newString);
        if (needUpdateLabel == null)needUpdateLabel =
            true;
        if (newString == null || typeof newString != "string")newString = newString + "";
        this._initialString = newString;
        this._setString(newString, needUpdateLabel)
    }, _setStringForSetter: function (newString) {
        this.setString(newString, false)
    }, setCString: function (label) {
        this.setString(label, true)
    }, updateLabel: function () {
        var self = this;
        self.string = self._initialString;
        if (self._width > 0) {
            var stringLength = self._string.length;
            var multiline_string = [];
            var last_word = [];
            var line = 1, i = 0, start_line = false, start_word = false, startOfLine =
                -1, startOfWord = -1, skip = 0;
            var characterSprite;
            for (var j = 0, lj = self._children.length; j < lj; j++) {
                var justSkipped = 0;
                while (!(characterSprite = self.getChildByTag(j + skip + justSkipped)))justSkipped++;
                skip += justSkipped;
                if (i >= stringLength)break;
                var character = self._string[i];
                if (!start_word) {
                    startOfWord = self._getLetterPosXLeft(characterSprite);
                    start_word = true
                }
                if (!start_line) {
                    startOfLine = startOfWord;
                    start_line = true
                }
                if (character.charCodeAt(0) == 10) {
                    last_word.push("\n");
                    multiline_string = multiline_string.concat(last_word);
                    last_word.length = 0;
                    start_word = false;
                    start_line = false;
                    startOfWord = -1;
                    startOfLine = -1;
                    j--;
                    skip -= justSkipped;
                    line++;
                    if (i >= stringLength)break;
                    character = self._string[i];
                    if (!startOfWord) {
                        startOfWord = self._getLetterPosXLeft(characterSprite);
                        start_word = true
                    }
                    if (!startOfLine) {
                        startOfLine = startOfWord;
                        start_line = true
                    }
                    i++;
                    continue
                }
                if (cc.isspace_unicode(character)) {
                    last_word.push(character);
                    multiline_string = multiline_string.concat(last_word);
                    last_word.length = 0;
                    start_word = false;
                    startOfWord = -1;
                    i++;
                    continue
                }
                if (self._getLetterPosXRight(characterSprite) -
                    startOfLine > self._width)if (!self._lineBreakWithoutSpaces) {
                    last_word.push(character);
                    var found = multiline_string.lastIndexOf(" ");
                    if (found != -1)cc.utf8_trim_ws(multiline_string); else multiline_string = [];
                    if (multiline_string.length > 0)multiline_string.push("\n");
                    line++;
                    start_line = false;
                    startOfLine = -1;
                    i++
                } else {
                    cc.utf8_trim_ws(last_word);
                    last_word.push("\n");
                    multiline_string = multiline_string.concat(last_word);
                    last_word.length = 0;
                    start_word = false;
                    start_line = false;
                    startOfWord = -1;
                    startOfLine = -1;
                    line++;
                    if (i >=
                        stringLength)break;
                    if (!startOfWord) {
                        startOfWord = self._getLetterPosXLeft(characterSprite);
                        start_word = true
                    }
                    if (!startOfLine) {
                        startOfLine = startOfWord;
                        start_line = true
                    }
                    j--
                } else {
                    last_word.push(character);
                    i++
                }
            }
            multiline_string = multiline_string.concat(last_word);
            var len = multiline_string.length;
            var str_new = "";
            for (i = 0; i < len; ++i)str_new += multiline_string[i];
            str_new = str_new + String.fromCharCode(0);
            self._setString(str_new, false)
        }
        if (self._alignment != cc.TEXT_ALIGNMENT_LEFT) {
            i = 0;
            var lineNumber = 0;
            var strlen = self._string.length;
            var last_line = [];
            for (var ctr = 0; ctr < strlen; ctr++) {
                if (self._string[ctr].charCodeAt(0) == 10 || self._string[ctr].charCodeAt(0) == 0) {
                    var lineWidth = 0;
                    var line_length = last_line.length;
                    if (line_length == 0) {
                        lineNumber++;
                        continue
                    }
                    var index = i + line_length - 1 + lineNumber;
                    if (index < 0)continue;
                    var lastChar = self.getChildByTag(index);
                    if (lastChar == null)continue;
                    lineWidth = lastChar.getPositionX() + lastChar._getWidth() / 2;
                    var shift = 0;
                    switch (self._alignment) {
                        case cc.TEXT_ALIGNMENT_CENTER:
                            shift = self.width / 2 - lineWidth / 2;
                            break;
                        case cc.TEXT_ALIGNMENT_RIGHT:
                            shift =
                                self.width - lineWidth;
                            break;
                        default:
                            break
                    }
                    if (shift != 0)for (j = 0; j < line_length; j++) {
                        index = i + j + lineNumber;
                        if (index < 0)continue;
                        characterSprite = self.getChildByTag(index);
                        if (characterSprite)characterSprite.x += shift
                    }
                    i += line_length;
                    lineNumber++;
                    last_line.length = 0;
                    continue
                }
                last_line.push(self._string[i])
            }
        }
    }, setAlignment: function (alignment) {
        this._alignment = alignment;
        this.updateLabel()
    }, _getAlignment: function () {
        return this._alignment
    }, setBoundingWidth: function (width) {
        this._width = width;
        this.updateLabel()
    }, _getBoundingWidth: function () {
        return this._width
    },
    setLineBreakWithoutSpace: function (breakWithoutSpace) {
        this._lineBreakWithoutSpaces = breakWithoutSpace;
        this.updateLabel()
    }, setScale: function (scale, scaleY) {
        cc.Node.prototype.setScale.call(this, scale, scaleY);
        this.updateLabel()
    }, setScaleX: function (scaleX) {
        cc.Node.prototype.setScaleX.call(this, scaleX);
        this.updateLabel()
    }, setScaleY: function (scaleY) {
        cc.Node.prototype.setScaleY.call(this, scaleY);
        this.updateLabel()
    }, setFntFile: function (fntFile) {
        var self = this;
        if (fntFile != null && fntFile != self._fntFile) {
            var newConf =
                cc.loader.getRes(fntFile);
            if (!newConf) {
                cc.log("cc.LabelBMFont.setFntFile() : Impossible to create font. Please check file");
                return
            }
            self._fntFile = fntFile;
            self._config = newConf;
            var texture = cc.textureCache.addImage(newConf.atlasName);
            var locIsLoaded = texture.isLoaded();
            self._textureLoaded = locIsLoaded;
            self.texture = texture;
            if (cc._renderType === cc._RENDER_TYPE_CANVAS)self._originalTexture = self.texture;
            if (!locIsLoaded)texture.addLoadedEventListener(function (sender) {
                var self1 = this;
                self1._textureLoaded = true;
                self1.texture = sender;
                self1.createFontChars();
                self1._changeTextureColor();
                self1.updateLabel();
                self1._callLoadedEventCallbacks()
            }, self); else self.createFontChars()
        }
    }, getFntFile: function () {
        return this._fntFile
    }, setAnchorPoint: function (point, y) {
        cc.Node.prototype.setAnchorPoint.call(this, point, y);
        this.updateLabel()
    }, _setAnchor: function (p) {
        cc.Node.prototype._setAnchor.call(this, p);
        this.updateLabel()
    }, _setAnchorX: function (x) {
        cc.Node.prototype._setAnchorX.call(this, x);
        this.updateLabel()
    }, _setAnchorY: function (y) {
        cc.Node.prototype._setAnchorY.call(this,
            y);
        this.updateLabel()
    }, _atlasNameFromFntFile: function (fntFile) {
    }, _kerningAmountForFirst: function (first, second) {
        var ret = 0;
        var key = first << 16 | second & 65535;
        if (this._configuration.kerningDictionary) {
            var element = this._configuration.kerningDictionary[key.toString()];
            if (element)ret = element.amount
        }
        return ret
    }, _getLetterPosXLeft: function (sp) {
        return sp.getPositionX() * this._scaleX - sp._getWidth() * this._scaleX * sp._getAnchorX()
    }, _getLetterPosXRight: function (sp) {
        return sp.getPositionX() * this._scaleX + sp._getWidth() *
            this._scaleX * sp._getAnchorX()
    }});
var _p = cc.LabelBMFont.prototype;
_p.opacityModifyRGB;
cc.defineGetterSetter(_p, "opacityModifyRGB", _p.isOpacityModifyRGB, _p.setOpacityModifyRGB);
_p.opacity;
cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
_p.cascadeOpacity;
cc.defineGetterSetter(_p, "cascadeOpacity", _p.isCascadeOpacityEnabled, _p.setCascadeOpacityEnabled);
_p.color;
cc.defineGetterSetter(_p, "color", _p.getColor, _p.setColor);
_p.cascadeColor;
cc.defineGetterSetter(_p, "cascadeColor", _p.isCascadeColorEnabled, _p.setCascadeColorEnabled);
_p.string;
cc.defineGetterSetter(_p, "string", _p.getString, _p._setStringForSetter);
_p.boundingWidth;
cc.defineGetterSetter(_p, "boundingWidth", _p._getBoundingWidth, _p.setBoundingWidth);
_p.textAlign;
cc.defineGetterSetter(_p, "textAlign", _p._getAlignment, _p.setAlignment);
cc.LabelBMFont.create = function (str, fntFile, width, alignment, imageOffset) {
    return new cc.LabelBMFont(str, fntFile, width, alignment, imageOffset)
};
cc.isspace_unicode = function (ch) {
    ch = ch.charCodeAt(0);
    return ch >= 9 && ch <= 13 || ch == 32 || ch == 133 || ch == 160 || ch == 5760 || ch >= 8192 && ch <= 8202 || ch == 8232 || ch == 8233 || ch == 8239 || ch == 8287 || ch == 12288
};
cc.utf8_trim_ws = function (str) {
    var len = str.length;
    if (len <= 0)return;
    var last_index = len - 1;
    if (cc.isspace_unicode(str[last_index])) {
        for (var i = last_index - 1; i >= 0; --i)if (cc.isspace_unicode(str[i]))last_index = i; else break;
        cc.utf8_trim_from(str, last_index)
    }
};
cc.utf8_trim_from = function (str, index) {
    var len = str.length;
    if (index >= len || index < 0)return;
    str.splice(index, len)
};
cc._fntLoader = {INFO_EXP: /info [^\n]*(\n|$)/gi, COMMON_EXP: /common [^\n]*(\n|$)/gi, PAGE_EXP: /page [^\n]*(\n|$)/gi, CHAR_EXP: /char [^\n]*(\n|$)/gi, KERNING_EXP: /kerning [^\n]*(\n|$)/gi, ITEM_EXP: /\w+=[^ \r\n]+/gi, INT_EXP: /^[\-]?\d+$/, _parseStrToObj: function (str) {
    var arr = str.match(this.ITEM_EXP);
    var obj = {};
    if (arr)for (var i = 0, li = arr.length; i < li; i++) {
        var tempStr = arr[i];
        var index = tempStr.indexOf("\x3d");
        var key = tempStr.substring(0, index);
        var value = tempStr.substring(index + 1);
        if (value.match(this.INT_EXP))value =
            parseInt(value); else if (value[0] == '"')value = value.substring(1, value.length - 1);
        obj[key] = value
    }
    return obj
}, parseFnt: function (fntStr, url) {
    var self = this, fnt = {};
    var infoObj = self._parseStrToObj(fntStr.match(self.INFO_EXP)[0]);
    var paddingArr = infoObj["padding"].split(",");
    var padding = {left: parseInt(paddingArr[0]), top: parseInt(paddingArr[1]), right: parseInt(paddingArr[2]), bottom: parseInt(paddingArr[3])};
    var commonObj = self._parseStrToObj(fntStr.match(self.COMMON_EXP)[0]);
    fnt.commonHeight = commonObj["lineHeight"];
    if (cc._renderType === cc._RENDER_TYPE_WEBGL) {
        var texSize = cc.configuration.getMaxTextureSize();
        if (commonObj["scaleW"] > texSize.width || commonObj["scaleH"] > texSize.height)cc.log("cc.LabelBMFont._parseCommonArguments(): page can't be larger than supported")
    }
    if (commonObj["pages"] !== 1)cc.log("cc.LabelBMFont._parseCommonArguments(): only supports 1 page");
    var pageObj = self._parseStrToObj(fntStr.match(self.PAGE_EXP)[0]);
    if (pageObj["id"] !== 0)cc.log("cc.LabelBMFont._parseImageFileName() : file could not be found");
    fnt.atlasName = cc.path.changeBasename(url, pageObj["file"]);
    var charLines = fntStr.match(self.CHAR_EXP);
    var fontDefDictionary = fnt.fontDefDictionary = {};
    for (var i = 0, li = charLines.length; i < li; i++) {
        var charObj = self._parseStrToObj(charLines[i]);
        var charId = charObj["id"];
        fontDefDictionary[charId] = {rect: {x: charObj["x"], y: charObj["y"], width: charObj["width"], height: charObj["height"]}, xOffset: charObj["xoffset"], yOffset: charObj["yoffset"], xAdvance: charObj["xadvance"]}
    }
    var kerningDict = fnt.kerningDict = {};
    var kerningLines =
        fntStr.match(self.KERNING_EXP);
    if (kerningLines)for (var i = 0, li = kerningLines.length; i < li; i++) {
        var kerningObj = self._parseStrToObj(kerningLines[i]);
        kerningDict[kerningObj["first"] << 16 | kerningObj["second"] & 65535] = kerningObj["amount"]
    }
    return fnt
}, load: function (realUrl, url, res, cb) {
    var self = this;
    cc.loader.loadTxt(realUrl, function (err, txt) {
        if (err)return cb(err);
        cb(null, self.parseFnt(txt, url))
    })
}};
cc.loader.register(["fnt"], cc._fntLoader);cc.MotionStreak = cc.NodeRGBA.extend({texture: null, fastMode: false, startingPositionInitialized: false, _blendFunc: null, _stroke: 0, _fadeDelta: 0, _minSeg: 0, _maxPoints: 0, _nuPoints: 0, _previousNuPoints: 0, _pointVertexes: null, _pointState: null, _vertices: null, _colorPointer: null, _texCoords: null, _verticesBuffer: null, _colorPointerBuffer: null, _texCoordsBuffer: null, _className: "MotionStreak", ctor: function (fade, minSeg, stroke, color, texture) {
    cc.NodeRGBA.prototype.ctor.call(this);
    this._positionR = cc.p(0, 0);
    this._blendFunc =
        new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA);
    this._vertexWebGLBuffer = cc._renderContext.createBuffer();
    this.fastMode = false;
    this.startingPositionInitialized = false;
    this.texture = null;
    this._stroke = 0;
    this._fadeDelta = 0;
    this._minSeg = 0;
    this._maxPoints = 0;
    this._nuPoints = 0;
    this._previousNuPoints = 0;
    this._pointVertexes = null;
    this._pointState = null;
    this._vertices = null;
    this._colorPointer = null;
    this._texCoords = null;
    this._verticesBuffer = null;
    this._colorPointerBuffer = null;
    this._texCoordsBuffer = null;
    if (texture !==
        undefined)this.initWithFade(fade, minSeg, stroke, color, texture)
}, getTexture: function () {
    return this.texture
}, setTexture: function (texture) {
    if (this.texture != texture)this.texture = texture
}, getBlendFunc: function () {
    return this._blendFunc
}, setBlendFunc: function (src, dst) {
    if (dst === undefined)this._blendFunc = src; else {
        this._blendFunc.src = src;
        this._blendFunc.dst = dst
    }
}, getOpacity: function () {
    cc.log("cc.MotionStreak.getOpacity has not been supported.");
    return 0
}, setOpacity: function (opacity) {
    cc.log("cc.MotionStreak.setOpacity has not been supported.")
},
    setOpacityModifyRGB: function (value) {
    }, isOpacityModifyRGB: function () {
        return false
    }, onExit: function () {
        cc.Node.prototype.onExit.call(this);
        if (this._verticesBuffer)cc._renderContext.deleteBuffer(this._verticesBuffer);
        if (this._texCoordsBuffer)cc._renderContext.deleteBuffer(this._texCoordsBuffer);
        if (this._colorPointerBuffer)cc._renderContext.deleteBuffer(this._colorPointerBuffer)
    }, isFastMode: function () {
        return this.fastMode
    }, setFastMode: function (fastMode) {
        this.fastMode = fastMode
    }, isStartingPositionInitialized: function () {
        return this.startingPositionInitialized
    },
    setStartingPositionInitialized: function (startingPositionInitialized) {
        this.startingPositionInitialized = startingPositionInitialized
    }, initWithFade: function (fade, minSeg, stroke, color, texture) {
        if (!texture)throw"cc.MotionStreak.initWithFade(): Invalid filename or texture";
        if (typeof texture === "string")texture = cc.textureCache.addImage(texture);
        cc.Node.prototype.setPosition.call(this, cc.p(0, 0));
        this.anchorX = 0;
        this.anchorY = 0;
        this.ignoreAnchor = true;
        this.startingPositionInitialized = false;
        this.fastMode = true;
        this._minSeg =
                minSeg == -1 ? stroke / 5 : minSeg;
        this._minSeg *= this._minSeg;
        this._stroke = stroke;
        this._fadeDelta = 1 / fade;
        var locMaxPoints = (0 | fade * 60) + 2;
        this._nuPoints = 0;
        this._pointState = new Float32Array(locMaxPoints);
        this._pointVertexes = new Float32Array(locMaxPoints * 2);
        this._vertices = new Float32Array(locMaxPoints * 4);
        this._texCoords = new Float32Array(locMaxPoints * 4);
        this._colorPointer = new Uint8Array(locMaxPoints * 8);
        this._maxPoints = locMaxPoints;
        var gl = cc._renderContext;
        this._verticesBuffer = gl.createBuffer();
        this._texCoordsBuffer =
            gl.createBuffer();
        this._colorPointerBuffer = gl.createBuffer();
        this._blendFunc.src = gl.SRC_ALPHA;
        this._blendFunc.dst = gl.ONE_MINUS_SRC_ALPHA;
        this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
        this.texture = texture;
        this.color = color;
        this.scheduleUpdate();
        gl.bindBuffer(gl.ARRAY_BUFFER, this._verticesBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this._vertices, gl.DYNAMIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._texCoordsBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this._texCoords, gl.DYNAMIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._colorPointerBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this._colorPointer, gl.DYNAMIC_DRAW);
        return true
    }, tintWithColor: function (color) {
        this.color = color;
        var locColorPointer = this._colorPointer;
        for (var i = 0, len = this._nuPoints * 2; i < len; i++) {
            locColorPointer[i * 4] = color.r;
            locColorPointer[i * 4 + 1] = color.g;
            locColorPointer[i * 4 + 2] = color.b
        }
    }, reset: function () {
        this._nuPoints = 0
    }, setPosition: function (position, yValue) {
        this.startingPositionInitialized = true;
        if (yValue === undefined) {
            this._positionR.x =
                position.x;
            this._positionR.y = position.y
        } else {
            this._positionR.x = position;
            this._positionR.y = yValue
        }
    }, getPositionX: function () {
        return this._positionR.x
    }, setPositionX: function (x) {
        this._positionR.x = x;
        if (!this.startingPositionInitialized)this.startingPositionInitialized = true
    }, getPositionY: function () {
        return this._positionR.y
    }, setPositionY: function (y) {
        this._positionR.y = y;
        if (!this.startingPositionInitialized)this.startingPositionInitialized = true
    }, draw: function (ctx) {
        if (this._nuPoints <= 1)return;
        if (this.texture &&
            this.texture.isLoaded()) {
            ctx = ctx || cc._renderContext;
            cc.nodeDrawSetup(this);
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
            cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst);
            cc.glBindTexture2D(this.texture);
            ctx.bindBuffer(ctx.ARRAY_BUFFER, this._verticesBuffer);
            ctx.bufferData(ctx.ARRAY_BUFFER, this._vertices, ctx.DYNAMIC_DRAW);
            ctx.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, ctx.FLOAT, false, 0, 0);
            ctx.bindBuffer(ctx.ARRAY_BUFFER, this._texCoordsBuffer);
            ctx.bufferData(ctx.ARRAY_BUFFER,
                this._texCoords, ctx.DYNAMIC_DRAW);
            ctx.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, ctx.FLOAT, false, 0, 0);
            ctx.bindBuffer(ctx.ARRAY_BUFFER, this._colorPointerBuffer);
            ctx.bufferData(ctx.ARRAY_BUFFER, this._colorPointer, ctx.DYNAMIC_DRAW);
            ctx.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, ctx.UNSIGNED_BYTE, true, 0, 0);
            ctx.drawArrays(ctx.TRIANGLE_STRIP, 0, this._nuPoints * 2);
            cc.g_NumberOfDraws++
        }
    }, update: function (delta) {
        if (!this.startingPositionInitialized)return;
        delta *= this._fadeDelta;
        var newIdx, newIdx2, i,
            i2;
        var mov = 0;
        var locNuPoints = this._nuPoints;
        var locPointState = this._pointState, locPointVertexes = this._pointVertexes, locVertices = this._vertices;
        var locColorPointer = this._colorPointer;
        for (i = 0; i < locNuPoints; i++) {
            locPointState[i] -= delta;
            if (locPointState[i] <= 0)mov++; else {
                newIdx = i - mov;
                if (mov > 0) {
                    locPointState[newIdx] = locPointState[i];
                    locPointVertexes[newIdx * 2] = locPointVertexes[i * 2];
                    locPointVertexes[newIdx * 2 + 1] = locPointVertexes[i * 2 + 1];
                    i2 = i * 2;
                    newIdx2 = newIdx * 2;
                    locVertices[newIdx2 * 2] = locVertices[i2 * 2];
                    locVertices[newIdx2 *
                        2 + 1] = locVertices[i2 * 2 + 1];
                    locVertices[(newIdx2 + 1) * 2] = locVertices[(i2 + 1) * 2];
                    locVertices[(newIdx2 + 1) * 2 + 1] = locVertices[(i2 + 1) * 2 + 1];
                    i2 *= 4;
                    newIdx2 *= 4;
                    locColorPointer[newIdx2 + 0] = locColorPointer[i2 + 0];
                    locColorPointer[newIdx2 + 1] = locColorPointer[i2 + 1];
                    locColorPointer[newIdx2 + 2] = locColorPointer[i2 + 2];
                    locColorPointer[newIdx2 + 4] = locColorPointer[i2 + 4];
                    locColorPointer[newIdx2 + 5] = locColorPointer[i2 + 5];
                    locColorPointer[newIdx2 + 6] = locColorPointer[i2 + 6]
                } else newIdx2 = newIdx * 8;
                var op = locPointState[newIdx] * 255;
                locColorPointer[newIdx2 +
                    3] = op;
                locColorPointer[newIdx2 + 7] = op
            }
        }
        locNuPoints -= mov;
        var appendNewPoint = true;
        if (locNuPoints >= this._maxPoints)appendNewPoint = false; else if (locNuPoints > 0) {
            var a1 = cc.pDistanceSQ(cc.p(locPointVertexes[(locNuPoints - 1) * 2], locPointVertexes[(locNuPoints - 1) * 2 + 1]), this._positionR) < this._minSeg;
            var a2 = locNuPoints == 1 ? false : cc.pDistanceSQ(cc.p(locPointVertexes[(locNuPoints - 2) * 2], locPointVertexes[(locNuPoints - 2) * 2 + 1]), this._positionR) < this._minSeg * 2;
            if (a1 || a2)appendNewPoint = false
        }
        if (appendNewPoint) {
            locPointVertexes[locNuPoints *
                2] = this._positionR.x;
            locPointVertexes[locNuPoints * 2 + 1] = this._positionR.y;
            locPointState[locNuPoints] = 1;
            var offset = locNuPoints * 8;
            var locDisplayedColor = this._displayedColor;
            locColorPointer[offset] = locDisplayedColor.r;
            locColorPointer[offset + 1] = locDisplayedColor.g;
            locColorPointer[offset + 2] = locDisplayedColor.b;
            locColorPointer[offset + 4] = locDisplayedColor.r;
            locColorPointer[offset + 5] = locDisplayedColor.g;
            locColorPointer[offset + 6] = locDisplayedColor.b;
            locColorPointer[offset + 3] = 255;
            locColorPointer[offset + 7] = 255;
            if (locNuPoints > 0 && this.fastMode)if (locNuPoints > 1)cc.vertexLineToPolygon(locPointVertexes, this._stroke, this._vertices, locNuPoints, 1); else cc.vertexLineToPolygon(locPointVertexes, this._stroke, this._vertices, 0, 2);
            locNuPoints++
        }
        if (!this.fastMode)cc.vertexLineToPolygon(locPointVertexes, this._stroke, this._vertices, 0, locNuPoints);
        if (locNuPoints && this._previousNuPoints != locNuPoints) {
            var texDelta = 1 / locNuPoints;
            var locTexCoords = this._texCoords;
            for (i = 0; i < locNuPoints; i++) {
                locTexCoords[i * 4] = 0;
                locTexCoords[i * 4 +
                    1] = texDelta * i;
                locTexCoords[(i * 2 + 1) * 2] = 1;
                locTexCoords[(i * 2 + 1) * 2 + 1] = texDelta * i
            }
            this._previousNuPoints = locNuPoints
        }
        this._nuPoints = locNuPoints
    }});
cc.MotionStreak.create = function (fade, minSeg, stroke, color, texture) {
    return new cc.MotionStreak(fade, minSeg, stroke, color, texture)
};cc.NodeGrid = cc.Node.extend({grid: null, _target: null, getGrid: function () {
    return this.grid
}, setGrid: function (grid) {
    this.grid = grid
}, setTarget: function (target) {
    this._target = target
}, addChild: function (child, zOrder, tag) {
    cc.Node.prototype.addChild.call(this, child, zOrder, tag);
    if (child && !this._target)this._target = child
}, visit: function () {
    var self = this;
    if (!self._visible)return;
    var isWebGL = cc._renderType == cc._RENDER_TYPE_WEBGL;
    var locGrid = self.grid;
    if (isWebGL && locGrid && locGrid._active)locGrid.beforeDraw();
    self.transform();
    var locChildren = this._children;
    if (locChildren && locChildren.length > 0) {
        var childLen = locChildren.length;
        this.sortAllChildren();
        for (i = 0; i < childLen; i++) {
            var child = locChildren[i];
            child && child.visit()
        }
    }
    if (isWebGL && locGrid && locGrid._active)locGrid.afterDraw(self._target)
}, _transformForWebGL: function () {
    var t4x4 = this._transform4x4, topMat4 = cc.current_stack.top;
    var trans = this.nodeToParentTransform();
    var t4x4Mat = t4x4.mat;
    t4x4Mat[0] = trans.a;
    t4x4Mat[4] = trans.c;
    t4x4Mat[12] = trans.tx;
    t4x4Mat[1] = trans.b;
    t4x4Mat[5] =
        trans.d;
    t4x4Mat[13] = trans.ty;
    t4x4Mat[14] = this._vertexZ;
    cc.kmMat4Multiply(topMat4, topMat4, t4x4);
    if (this._camera != null && !(this.grid && this.grid.isActive())) {
        var apx = this._anchorPointInPoints.x, apy = this._anchorPointInPoints.y;
        var translate = apx !== 0 || apy !== 0;
        if (translate) {
            if (!cc.SPRITEBATCHNODE_RENDER_SUBPIXEL) {
                apx = 0 | apx;
                apy = 0 | apy
            }
            cc.kmGLTranslatef(apx, apy, 0);
            this._camera.locate();
            cc.kmGLTranslatef(-apx, -apy, 0)
        } else this._camera.locate()
    }
}});
var _p = cc.NodeGrid.prototype;
if (cc._renderType === cc._RENDER_TYPE_WEBGL)_p.transform = _p._transformForWebGL;
_p.grid;
_p.target;
cc.defineGetterSetter(_p, "target", null, _p.setTarget);
cc.NodeGrid.create = function () {
    return new cc.NodeGrid
};cc.v2fzero = function () {
    return{x: 0, y: 0}
};
cc.v2f = function (x, y) {
    return{x: x, y: y}
};
cc.v2fadd = function (v0, v1) {
    return cc.v2f(v0.x + v1.x, v0.y + v1.y)
};
cc.v2fsub = function (v0, v1) {
    return cc.v2f(v0.x - v1.x, v0.y - v1.y)
};
cc.v2fmult = function (v, s) {
    return cc.v2f(v.x * s, v.y * s)
};
cc.v2fperp = function (p0) {
    return cc.v2f(-p0.y, p0.x)
};
cc.v2fneg = function (p0) {
    return cc.v2f(-p0.x, -p0.y)
};
cc.v2fdot = function (p0, p1) {
    return p0.x * p1.x + p0.y * p1.y
};
cc.v2fforangle = function (_a_) {
    return cc.v2f(Math.cos(_a_), Math.sin(_a_))
};
cc.v2fnormalize = function (p) {
    var r = cc.pNormalize(cc.p(p.x, p.y));
    return cc.v2f(r.x, r.y)
};
cc.__v2f = function (v) {
    return cc.v2f(v.x, v.y)
};
cc.__t = function (v) {
    return{u: v.x, v: v.y}
};
cc.DrawNodeCanvas = cc.Node.extend({_buffer: null, _blendFunc: null, _lineWidth: 1, _drawColor: null, _className: "DrawNodeCanvas", ctor: function () {
    cc.Node.prototype.ctor.call(this);
    this._buffer = [];
    this._drawColor = cc.color(255, 255, 255, 255);
    this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
    this.init()
}, getBlendFunc: function () {
    return this._blendFunc
}, setBlendFunc: function (blendFunc, dst) {
    if (dst === undefined) {
        this._blendFunc.src = blendFunc.src;
        this._blendFunc.dst = blendFunc.dst
    } else {
        this._blendFunc.src = blendFunc;
        this._blendFunc.dst = dst
    }
}, setLineWidth: function (width) {
    this._lineWidth = width
}, getLineWidth: function () {
    return this._lineWidth
}, setDrawColor: function (color) {
    var locDrawColor = this._drawColor;
    locDrawColor.r = color.r;
    locDrawColor.g = color.g;
    locDrawColor.b = color.b;
    locDrawColor.a = color.a == null ? 255 : color.a
}, getDrawColor: function () {
    return cc.color(this._drawColor.r, this._drawColor.g, this._drawColor.b, this._drawColor.a)
}, drawRect: function (origin, destination, fillColor, lineWidth, lineColor) {
    lineWidth = lineWidth ||
        this._lineWidth;
    lineColor = lineColor || this.getDrawColor();
    if (lineColor.a == null)lineColor.a = 255;
    var vertices = [origin, cc.p(destination.x, origin.y), destination, cc.p(origin.x, destination.y)];
    var element = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
    element.verts = vertices;
    element.lineWidth = lineWidth;
    element.lineColor = lineColor;
    element.isClosePolygon = true;
    element.isStroke = true;
    element.lineCap = "butt";
    element.fillColor = fillColor;
    if (fillColor) {
        if (fillColor.a == null)fillColor.a = 255;
        element.isFill = true
    }
    this._buffer.push(element)
},
    drawCircle: function (center, radius, angle, segments, drawLineToCenter, lineWidth, color) {
        lineWidth = lineWidth || this._lineWidth;
        color = color || this.getDrawColor();
        if (color.a == null)color.a = 255;
        var coef = 2 * Math.PI / segments;
        var vertices = [];
        for (var i = 0; i <= segments; i++) {
            var rads = i * coef;
            var j = radius * Math.cos(rads + angle) + center.x;
            var k = radius * Math.sin(rads + angle) + center.y;
            vertices.push(cc.p(j, k))
        }
        if (drawLineToCenter)vertices.push(cc.p(center.x, center.y));
        var element = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
        element.verts =
            vertices;
        element.lineWidth = lineWidth;
        element.lineColor = color;
        element.isClosePolygon = true;
        element.isStroke = true;
        this._buffer.push(element)
    }, drawQuadBezier: function (origin, control, destination, segments, lineWidth, color) {
        lineWidth = lineWidth || this._lineWidth;
        color = color || this.getDrawColor();
        if (color.a == null)color.a = 255;
        var vertices = [], t = 0;
        for (var i = 0; i < segments; i++) {
            var x = Math.pow(1 - t, 2) * origin.x + 2 * (1 - t) * t * control.x + t * t * destination.x;
            var y = Math.pow(1 - t, 2) * origin.y + 2 * (1 - t) * t * control.y + t * t * destination.y;
            vertices.push(cc.p(x, y));
            t += 1 / segments
        }
        vertices.push(cc.p(destination.x, destination.y));
        var element = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
        element.verts = vertices;
        element.lineWidth = lineWidth;
        element.lineColor = color;
        element.isStroke = true;
        element.lineCap = "round";
        this._buffer.push(element)
    }, drawCubicBezier: function (origin, control1, control2, destination, segments, lineWidth, color) {
        lineWidth = lineWidth || this._lineWidth;
        color = color || this.getDrawColor();
        if (color.a == null)color.a = 255;
        var vertices = [], t =
            0;
        for (var i = 0; i < segments; i++) {
            var x = Math.pow(1 - t, 3) * origin.x + 3 * Math.pow(1 - t, 2) * t * control1.x + 3 * (1 - t) * t * t * control2.x + t * t * t * destination.x;
            var y = Math.pow(1 - t, 3) * origin.y + 3 * Math.pow(1 - t, 2) * t * control1.y + 3 * (1 - t) * t * t * control2.y + t * t * t * destination.y;
            vertices.push(cc.p(x, y));
            t += 1 / segments
        }
        vertices.push(cc.p(destination.x, destination.y));
        var element = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
        element.verts = vertices;
        element.lineWidth = lineWidth;
        element.lineColor = color;
        element.isStroke = true;
        element.lineCap = "round";
        this._buffer.push(element)
    }, drawCatmullRom: function (points, segments, lineWidth, color) {
        this.drawCardinalSpline(points, 0.5, segments, lineWidth, color)
    }, drawCardinalSpline: function (config, tension, segments, lineWidth, color) {
        lineWidth = lineWidth || this._lineWidth;
        color = color || this.getDrawColor();
        if (color.a == null)color.a = 255;
        var vertices = [], p, lt, deltaT = 1 / config.length;
        for (var i = 0; i < segments + 1; i++) {
            var dt = i / segments;
            if (dt == 1) {
                p = config.length - 1;
                lt = 1
            } else {
                p = 0 | dt / deltaT;
                lt = (dt - deltaT * p) / deltaT
            }
            var newPos = cc.cardinalSplineAt(cc.getControlPointAt(config,
                    p - 1), cc.getControlPointAt(config, p - 0), cc.getControlPointAt(config, p + 1), cc.getControlPointAt(config, p + 2), tension, lt);
            vertices.push(newPos)
        }
        var element = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
        element.verts = vertices;
        element.lineWidth = lineWidth;
        element.lineColor = color;
        element.isStroke = true;
        element.lineCap = "round";
        this._buffer.push(element)
    }, drawDot: function (pos, radius, color) {
        color = color || this.getDrawColor();
        if (color.a == null)color.a = 255;
        var element = new cc._DrawNodeElement(cc.DrawNode.TYPE_DOT);
        element.verts = [pos];
        element.lineWidth = radius;
        element.fillColor = color;
        this._buffer.push(element)
    }, drawDots: function (points, radius, color) {
        if (!points || points.length == 0)return;
        color = color || this.getDrawColor();
        if (color.a == null)color.a = 255;
        for (var i = 0, len = points.length; i < len; i++)this.drawDot(points[i], radius, color)
    }, drawSegment: function (from, to, lineWidth, color) {
        lineWidth = lineWidth || this._lineWidth;
        color = color || this.getDrawColor();
        if (color.a == null)color.a = 255;
        var element = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
        element.verts = [from, to];
        element.lineWidth = lineWidth * 2;
        element.lineColor = color;
        element.isStroke = true;
        element.lineCap = "round";
        this._buffer.push(element)
    }, drawPoly_: function (verts, fillColor, lineWidth, color) {
        lineWidth = lineWidth || this._lineWidth;
        color = color || this.getDrawColor();
        if (color.a == null)color.a = 255;
        var element = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
        element.verts = verts;
        element.fillColor = fillColor;
        element.lineWidth = lineWidth;
        element.lineColor = color;
        element.isClosePolygon = true;
        element.isStroke =
            true;
        element.lineCap = "round";
        if (fillColor)element.isFill = true;
        this._buffer.push(element)
    }, drawPoly: function (verts, fillColor, lineWidth, color) {
        var vertsCopy = [];
        for (var i = 0; i < verts.length; i++)vertsCopy.push(cc.p(verts[i].x, verts[i].y));
        return this.drawPoly_(vertsCopy, fillColor, lineWidth, color)
    }, draw: function (ctx) {
        var context = ctx || cc._renderContext, _t = this;
        if (_t._blendFunc && _t._blendFunc.src == cc.SRC_ALPHA && _t._blendFunc.dst == cc.ONE)context.globalCompositeOperation = "lighter";
        for (var i = 0; i < _t._buffer.length; i++) {
            var element =
                _t._buffer[i];
            switch (element.type) {
                case cc.DrawNode.TYPE_DOT:
                    _t._drawDot(context, element);
                    break;
                case cc.DrawNode.TYPE_SEGMENT:
                    _t._drawSegment(context, element);
                    break;
                case cc.DrawNode.TYPE_POLY:
                    _t._drawPoly(context, element);
                    break
            }
        }
    }, _drawDot: function (ctx, element) {
        var locColor = element.fillColor, locPos = element.verts[0], locRadius = element.lineWidth;
        var locScaleX = cc.view.getScaleX(), locScaleY = cc.view.getScaleY();
        ctx.fillStyle = "rgba(" + (0 | locColor.r) + "," + (0 | locColor.g) + "," + (0 | locColor.b) + "," + locColor.a / 255 +
            ")";
        ctx.beginPath();
        ctx.arc(locPos.x * locScaleX, -locPos.y * locScaleY, locRadius * locScaleX, 0, Math.PI * 2, false);
        ctx.closePath();
        ctx.fill()
    }, _drawSegment: function (ctx, element) {
        var locColor = element.lineColor;
        var locFrom = element.verts[0];
        var locTo = element.verts[1];
        var locLineWidth = element.lineWidth;
        var locLineCap = element.lineCap;
        var locScaleX = cc.view.getScaleX(), locScaleY = cc.view.getScaleY();
        ctx.strokeStyle = "rgba(" + (0 | locColor.r) + "," + (0 | locColor.g) + "," + (0 | locColor.b) + "," + locColor.a / 255 + ")";
        ctx.lineWidth = locLineWidth *
            locScaleX;
        ctx.beginPath();
        ctx.lineCap = locLineCap;
        ctx.moveTo(locFrom.x * locScaleX, -locFrom.y * locScaleY);
        ctx.lineTo(locTo.x * locScaleX, -locTo.y * locScaleY);
        ctx.stroke()
    }, _drawPoly: function (ctx, element) {
        var locVertices = element.verts;
        var locLineCap = element.lineCap;
        var locFillColor = element.fillColor;
        var locLineWidth = element.lineWidth;
        var locLineColor = element.lineColor;
        var locIsClosePolygon = element.isClosePolygon;
        var locIsFill = element.isFill;
        var locIsStroke = element.isStroke;
        if (locVertices == null)return;
        var firstPoint =
            locVertices[0];
        var locScaleX = cc.view.getScaleX(), locScaleY = cc.view.getScaleY();
        ctx.lineCap = locLineCap;
        if (locFillColor)ctx.fillStyle = "rgba(" + (0 | locFillColor.r) + "," + (0 | locFillColor.g) + "," + (0 | locFillColor.b) + "," + locFillColor.a / 255 + ")";
        if (locLineWidth)ctx.lineWidth = locLineWidth * locScaleX;
        if (locLineColor)ctx.strokeStyle = "rgba(" + (0 | locLineColor.r) + "," + (0 | locLineColor.g) + "," + (0 | locLineColor.b) + "," + locLineColor.a / 255 + ")";
        ctx.beginPath();
        ctx.moveTo(firstPoint.x * locScaleX, -firstPoint.y * locScaleY);
        for (var i =
            1, len = locVertices.length; i < len; i++)ctx.lineTo(locVertices[i].x * locScaleX, -locVertices[i].y * locScaleY);
        if (locIsClosePolygon)ctx.closePath();
        if (locIsFill)ctx.fill();
        if (locIsStroke)ctx.stroke()
    }, clear: function () {
        this._buffer.length = 0
    }});
cc.DrawNodeWebGL = cc.Node.extend({_bufferCapacity: 0, _buffer: null, _trianglesArrayBuffer: null, _trianglesWebBuffer: null, _trianglesReader: null, _lineWidth: 1, _drawColor: null, _blendFunc: null, _dirty: false, _className: "DrawNodeWebGL", getBlendFunc: function () {
    return this._blendFunc
}, setBlendFunc: function (blendFunc, dst) {
    if (dst === undefined) {
        this._blendFunc.src = blendFunc.src;
        this._blendFunc.dst = blendFunc.dst
    } else {
        this._blendFunc.src = blendFunc;
        this._blendFunc.dst = dst
    }
}, ctor: function () {
    cc.Node.prototype.ctor.call(this);
    this._buffer = [];
    this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
    this._drawColor = cc.color(255, 255, 255, 255);
    this.init()
}, init: function () {
    if (cc.Node.prototype.init.call(this)) {
        this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_LENGTHTEXTURECOLOR);
        this._ensureCapacity(64);
        this._trianglesWebBuffer = cc._renderContext.createBuffer();
        this._dirty = true;
        return true
    }
    return false
}, setLineWidth: function (width) {
    this._lineWidth = width
}, getLineWidth: function () {
    return this._lineWidth
}, setDrawColor: function (color) {
    var locDrawColor =
        this._drawColor;
    locDrawColor.r = color.r;
    locDrawColor.g = color.g;
    locDrawColor.b = color.b;
    locDrawColor.a = color.a
}, getDrawColor: function () {
    return cc.color(this._drawColor.r, this._drawColor.g, this._drawColor.b, this._drawColor.a)
}, drawRect: function (origin, destination, fillColor, lineWidth, lineColor) {
    lineWidth = lineWidth || this._lineWidth;
    lineColor = lineColor || this.getDrawColor();
    if (lineColor.a == null)lineColor.a = 255;
    var vertices = [origin, cc.p(destination.x, origin.y), destination, cc.p(origin.x, destination.y)];
    if (fillColor ==
        null)this._drawSegments(vertices, lineWidth, lineColor, true); else this.drawPoly(vertices, fillColor, lineWidth, lineColor)
}, drawCircle: function (center, radius, angle, segments, drawLineToCenter, lineWidth, color) {
    lineWidth = lineWidth || this._lineWidth;
    color = color || this.getDrawColor();
    if (color.a == null)color.a = 255;
    var coef = 2 * Math.PI / segments, vertices = [], i, len;
    for (i = 0; i <= segments; i++) {
        var rads = i * coef;
        var j = radius * Math.cos(rads + angle) + center.x;
        var k = radius * Math.sin(rads + angle) + center.y;
        vertices.push(cc.p(j, k))
    }
    if (drawLineToCenter)vertices.push(cc.p(center.x,
        center.y));
    lineWidth *= 0.5;
    for (i = 0, len = vertices.length; i < len - 1; i++)this.drawSegment(vertices[i], vertices[i + 1], lineWidth, color)
}, drawQuadBezier: function (origin, control, destination, segments, lineWidth, color) {
    lineWidth = lineWidth || this._lineWidth;
    color = color || this.getDrawColor();
    if (color.a == null)color.a = 255;
    var vertices = [], t = 0;
    for (var i = 0; i < segments; i++) {
        var x = Math.pow(1 - t, 2) * origin.x + 2 * (1 - t) * t * control.x + t * t * destination.x;
        var y = Math.pow(1 - t, 2) * origin.y + 2 * (1 - t) * t * control.y + t * t * destination.y;
        vertices.push(cc.p(x,
            y));
        t += 1 / segments
    }
    vertices.push(cc.p(destination.x, destination.y));
    this._drawSegments(vertices, lineWidth, color, false)
}, drawCubicBezier: function (origin, control1, control2, destination, segments, lineWidth, color) {
    lineWidth = lineWidth || this._lineWidth;
    color = color || this.getDrawColor();
    if (color.a == null)color.a = 255;
    var vertices = [], t = 0;
    for (var i = 0; i < segments; i++) {
        var x = Math.pow(1 - t, 3) * origin.x + 3 * Math.pow(1 - t, 2) * t * control1.x + 3 * (1 - t) * t * t * control2.x + t * t * t * destination.x;
        var y = Math.pow(1 - t, 3) * origin.y + 3 * Math.pow(1 -
            t, 2) * t * control1.y + 3 * (1 - t) * t * t * control2.y + t * t * t * destination.y;
        vertices.push(cc.p(x, y));
        t += 1 / segments
    }
    vertices.push(cc.p(destination.x, destination.y));
    this._drawSegments(vertices, lineWidth, color, false)
}, drawCatmullRom: function (points, segments, lineWidth, color) {
    this.drawCardinalSpline(points, 0.5, segments, lineWidth, color)
}, drawCardinalSpline: function (config, tension, segments, lineWidth, color) {
    lineWidth = lineWidth || this._lineWidth;
    color = color || this.getDrawColor();
    if (color.a == null)color.a = 255;
    var vertices =
        [], p, lt, deltaT = 1 / config.length;
    for (var i = 0; i < segments + 1; i++) {
        var dt = i / segments;
        if (dt == 1) {
            p = config.length - 1;
            lt = 1
        } else {
            p = 0 | dt / deltaT;
            lt = (dt - deltaT * p) / deltaT
        }
        var newPos = cc.cardinalSplineAt(cc.getControlPointAt(config, p - 1), cc.getControlPointAt(config, p - 0), cc.getControlPointAt(config, p + 1), cc.getControlPointAt(config, p + 2), tension, lt);
        vertices.push(newPos)
    }
    lineWidth *= 0.5;
    for (var j = 0, len = vertices.length; j < len - 1; j++)this.drawSegment(vertices[j], vertices[j + 1], lineWidth, color)
}, _render: function () {
    var gl = cc._renderContext;
    cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
    gl.bindBuffer(gl.ARRAY_BUFFER, this._trianglesWebBuffer);
    if (this._dirty) {
        gl.bufferData(gl.ARRAY_BUFFER, this._trianglesArrayBuffer, gl.STREAM_DRAW);
        this._dirty = false
    }
    var triangleSize = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
    gl.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, gl.FLOAT, false, triangleSize, 0);
    gl.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, gl.UNSIGNED_BYTE, true, triangleSize, 8);
    gl.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, gl.FLOAT,
        false, triangleSize, 12);
    gl.drawArrays(gl.TRIANGLES, 0, this._buffer.length * 3);
    cc.incrementGLDraws(1)
}, _ensureCapacity: function (count) {
    var _t = this;
    var locBuffer = _t._buffer;
    if (locBuffer.length + count > _t._bufferCapacity) {
        var TriangleLength = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT;
        _t._bufferCapacity += Math.max(_t._bufferCapacity, count);
        if (locBuffer == null || locBuffer.length === 0) {
            _t._buffer = [];
            _t._trianglesArrayBuffer = new ArrayBuffer(TriangleLength * _t._bufferCapacity);
            _t._trianglesReader = new Uint8Array(_t._trianglesArrayBuffer)
        } else {
            var newTriangles =
                [];
            var newArrayBuffer = new ArrayBuffer(TriangleLength * _t._bufferCapacity);
            for (var i = 0; i < locBuffer.length; i++)newTriangles[i] = new cc.V2F_C4B_T2F_Triangle(locBuffer[i].a, locBuffer[i].b, locBuffer[i].c, newArrayBuffer, i * TriangleLength);
            _t._trianglesReader = new Uint8Array(newArrayBuffer);
            _t._trianglesArrayBuffer = newArrayBuffer;
            _t._buffer = newTriangles
        }
    }
}, draw: function () {
    cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst);
    this._shaderProgram.use();
    this._shaderProgram.setUniformsForBuiltins();
    this._render()
},
    drawDot: function (pos, radius, color) {
        color = color || this.getDrawColor();
        if (color.a == null)color.a = 255;
        var c4bColor = {r: 0 | color.r, g: 0 | color.g, b: 0 | color.b, a: 0 | color.a};
        var a = {vertices: {x: pos.x - radius, y: pos.y - radius}, colors: c4bColor, texCoords: {u: -1, v: -1}};
        var b = {vertices: {x: pos.x - radius, y: pos.y + radius}, colors: c4bColor, texCoords: {u: -1, v: 1}};
        var c = {vertices: {x: pos.x + radius, y: pos.y + radius}, colors: c4bColor, texCoords: {u: 1, v: 1}};
        var d = {vertices: {x: pos.x + radius, y: pos.y - radius}, colors: c4bColor, texCoords: {u: 1, v: -1}};
        this._ensureCapacity(2 * 3);
        this._buffer.push(new cc.V2F_C4B_T2F_Triangle(a, b, c, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT));
        this._buffer.push(new cc.V2F_C4B_T2F_Triangle(a, c, d, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT));
        this._dirty = true
    }, drawDots: function (points, radius, color) {
        if (!points || points.length == 0)return;
        color = color || this.getDrawColor();
        if (color.a == null)color.a = 255;
        for (var i = 0, len = points.length; i < len; i++)this.drawDot(points[i],
            radius, color)
    }, drawSegment: function (from, to, radius, color) {
        color = color || this.getDrawColor();
        if (color.a == null)color.a = 255;
        radius = radius || this._lineWidth * 0.5;
        var vertexCount = 6 * 3;
        this._ensureCapacity(vertexCount);
        var c4bColor = {r: 0 | color.r, g: 0 | color.g, b: 0 | color.b, a: 0 | color.a};
        var a = cc.__v2f(from), b = cc.__v2f(to);
        var n = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(b, a))), t = cc.v2fperp(n);
        var nw = cc.v2fmult(n, radius), tw = cc.v2fmult(t, radius);
        var v0 = cc.v2fsub(b, cc.v2fadd(nw, tw));
        var v1 = cc.v2fadd(b, cc.v2fsub(nw, tw));
        var v2 =
            cc.v2fsub(b, nw);
        var v3 = cc.v2fadd(b, nw);
        var v4 = cc.v2fsub(a, nw);
        var v5 = cc.v2fadd(a, nw);
        var v6 = cc.v2fsub(a, cc.v2fsub(nw, tw));
        var v7 = cc.v2fadd(a, cc.v2fadd(nw, tw));
        var TriangleLength = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT, triangleBuffer = this._trianglesArrayBuffer, locBuffer = this._buffer;
        locBuffer.push(new cc.V2F_C4B_T2F_Triangle({vertices: v0, colors: c4bColor, texCoords: cc.__t(cc.v2fneg(cc.v2fadd(n, t)))}, {vertices: v1, colors: c4bColor, texCoords: cc.__t(cc.v2fsub(n, t))}, {vertices: v2, colors: c4bColor, texCoords: cc.__t(cc.v2fneg(n))},
            triangleBuffer, locBuffer.length * TriangleLength));
        locBuffer.push(new cc.V2F_C4B_T2F_Triangle({vertices: v3, colors: c4bColor, texCoords: cc.__t(n)}, {vertices: v1, colors: c4bColor, texCoords: cc.__t(cc.v2fsub(n, t))}, {vertices: v2, colors: c4bColor, texCoords: cc.__t(cc.v2fneg(n))}, triangleBuffer, locBuffer.length * TriangleLength));
        locBuffer.push(new cc.V2F_C4B_T2F_Triangle({vertices: v3, colors: c4bColor, texCoords: cc.__t(n)}, {vertices: v4, colors: c4bColor, texCoords: cc.__t(cc.v2fneg(n))}, {vertices: v2, colors: c4bColor, texCoords: cc.__t(cc.v2fneg(n))},
            triangleBuffer, locBuffer.length * TriangleLength));
        locBuffer.push(new cc.V2F_C4B_T2F_Triangle({vertices: v3, colors: c4bColor, texCoords: cc.__t(n)}, {vertices: v4, colors: c4bColor, texCoords: cc.__t(cc.v2fneg(n))}, {vertices: v5, colors: c4bColor, texCoords: cc.__t(n)}, triangleBuffer, locBuffer.length * TriangleLength));
        locBuffer.push(new cc.V2F_C4B_T2F_Triangle({vertices: v6, colors: c4bColor, texCoords: cc.__t(cc.v2fsub(t, n))}, {vertices: v4, colors: c4bColor, texCoords: cc.__t(cc.v2fneg(n))}, {vertices: v5, colors: c4bColor, texCoords: cc.__t(n)},
            triangleBuffer, locBuffer.length * TriangleLength));
        locBuffer.push(new cc.V2F_C4B_T2F_Triangle({vertices: v6, colors: c4bColor, texCoords: cc.__t(cc.v2fsub(t, n))}, {vertices: v7, colors: c4bColor, texCoords: cc.__t(cc.v2fadd(n, t))}, {vertices: v5, colors: c4bColor, texCoords: cc.__t(n)}, triangleBuffer, locBuffer.length * TriangleLength));
        this._dirty = true
    }, drawPoly: function (verts, fillColor, borderWidth, borderColor) {
        if (fillColor == null) {
            this._drawSegments(verts, borderWidth, borderColor, true);
            return
        }
        if (fillColor.a == null)fillColor.a =
            255;
        if (borderColor.a == null)borderColor.a = 255;
        borderWidth = borderWidth || this._lineWidth;
        borderWidth *= 0.5;
        var c4bFillColor = {r: 0 | fillColor.r, g: 0 | fillColor.g, b: 0 | fillColor.b, a: 0 | fillColor.a};
        var c4bBorderColor = {r: 0 | borderColor.r, g: 0 | borderColor.g, b: 0 | borderColor.b, a: 0 | borderColor.a};
        var extrude = [], i, v0, v1, v2, count = verts.length;
        for (i = 0; i < count; i++) {
            v0 = cc.__v2f(verts[(i - 1 + count) % count]);
            v1 = cc.__v2f(verts[i]);
            v2 = cc.__v2f(verts[(i + 1) % count]);
            var n1 = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(v1, v0)));
            var n2 = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(v2,
                v1)));
            var offset = cc.v2fmult(cc.v2fadd(n1, n2), 1 / (cc.v2fdot(n1, n2) + 1));
            extrude[i] = {offset: offset, n: n2}
        }
        var outline = borderWidth > 0, triangleCount = 3 * count - 2, vertexCount = 3 * triangleCount;
        this._ensureCapacity(vertexCount);
        var triangleBytesLen = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT, trianglesBuffer = this._trianglesArrayBuffer;
        var locBuffer = this._buffer;
        var inset = outline == false ? 0.5 : 0;
        for (i = 0; i < count - 2; i++) {
            v0 = cc.v2fsub(cc.__v2f(verts[0]), cc.v2fmult(extrude[0].offset, inset));
            v1 = cc.v2fsub(cc.__v2f(verts[i + 1]),
                cc.v2fmult(extrude[i + 1].offset, inset));
            v2 = cc.v2fsub(cc.__v2f(verts[i + 2]), cc.v2fmult(extrude[i + 2].offset, inset));
            locBuffer.push(new cc.V2F_C4B_T2F_Triangle({vertices: v0, colors: c4bFillColor, texCoords: cc.__t(cc.v2fzero())}, {vertices: v1, colors: c4bFillColor, texCoords: cc.__t(cc.v2fzero())}, {vertices: v2, colors: c4bFillColor, texCoords: cc.__t(cc.v2fzero())}, trianglesBuffer, locBuffer.length * triangleBytesLen))
        }
        for (i = 0; i < count; i++) {
            var j = (i + 1) % count;
            v0 = cc.__v2f(verts[i]);
            v1 = cc.__v2f(verts[j]);
            var n0 = extrude[i].n;
            var offset0 = extrude[i].offset;
            var offset1 = extrude[j].offset;
            var inner0 = outline ? cc.v2fsub(v0, cc.v2fmult(offset0, borderWidth)) : cc.v2fsub(v0, cc.v2fmult(offset0, 0.5));
            var inner1 = outline ? cc.v2fsub(v1, cc.v2fmult(offset1, borderWidth)) : cc.v2fsub(v1, cc.v2fmult(offset1, 0.5));
            var outer0 = outline ? cc.v2fadd(v0, cc.v2fmult(offset0, borderWidth)) : cc.v2fadd(v0, cc.v2fmult(offset0, 0.5));
            var outer1 = outline ? cc.v2fadd(v1, cc.v2fmult(offset1, borderWidth)) : cc.v2fadd(v1, cc.v2fmult(offset1, 0.5));
            if (outline) {
                locBuffer.push(new cc.V2F_C4B_T2F_Triangle({vertices: inner0,
                    colors: c4bBorderColor, texCoords: cc.__t(cc.v2fneg(n0))}, {vertices: inner1, colors: c4bBorderColor, texCoords: cc.__t(cc.v2fneg(n0))}, {vertices: outer1, colors: c4bBorderColor, texCoords: cc.__t(n0)}, trianglesBuffer, locBuffer.length * triangleBytesLen));
                locBuffer.push(new cc.V2F_C4B_T2F_Triangle({vertices: inner0, colors: c4bBorderColor, texCoords: cc.__t(cc.v2fneg(n0))}, {vertices: outer0, colors: c4bBorderColor, texCoords: cc.__t(n0)}, {vertices: outer1, colors: c4bBorderColor, texCoords: cc.__t(n0)}, trianglesBuffer, locBuffer.length *
                    triangleBytesLen))
            } else {
                locBuffer.push(new cc.V2F_C4B_T2F_Triangle({vertices: inner0, colors: c4bFillColor, texCoords: cc.__t(cc.v2fzero())}, {vertices: inner1, colors: c4bFillColor, texCoords: cc.__t(cc.v2fzero())}, {vertices: outer1, colors: c4bFillColor, texCoords: cc.__t(n0)}, trianglesBuffer, locBuffer.length * triangleBytesLen));
                locBuffer.push(new cc.V2F_C4B_T2F_Triangle({vertices: inner0, colors: c4bFillColor, texCoords: cc.__t(cc.v2fzero())}, {vertices: outer0, colors: c4bFillColor, texCoords: cc.__t(n0)}, {vertices: outer1,
                    colors: c4bFillColor, texCoords: cc.__t(n0)}, trianglesBuffer, locBuffer.length * triangleBytesLen))
            }
        }
        extrude = null;
        this._dirty = true
    }, _drawSegments: function (verts, borderWidth, borderColor, closePoly) {
        borderWidth = borderWidth || this._lineWidth;
        borderColor = borderColor || this._drawColor;
        if (borderColor.a == null)borderColor.a = 255;
        borderWidth *= 0.5;
        if (borderWidth <= 0)return;
        var c4bBorderColor = {r: 0 | borderColor.r, g: 0 | borderColor.g, b: 0 | borderColor.b, a: 0 | borderColor.a};
        var extrude = [], i, v0, v1, v2, count = verts.length;
        for (i = 0; i <
            count; i++) {
            v0 = cc.__v2f(verts[(i - 1 + count) % count]);
            v1 = cc.__v2f(verts[i]);
            v2 = cc.__v2f(verts[(i + 1) % count]);
            var n1 = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(v1, v0)));
            var n2 = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(v2, v1)));
            var offset = cc.v2fmult(cc.v2fadd(n1, n2), 1 / (cc.v2fdot(n1, n2) + 1));
            extrude[i] = {offset: offset, n: n2}
        }
        var triangleCount = 3 * count - 2, vertexCount = 3 * triangleCount;
        this._ensureCapacity(vertexCount);
        var triangleBytesLen = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT, trianglesBuffer = this._trianglesArrayBuffer;
        var locBuffer =
            this._buffer;
        var len = closePoly ? count : count - 1;
        for (i = 0; i < len; i++) {
            var j = (i + 1) % count;
            v0 = cc.__v2f(verts[i]);
            v1 = cc.__v2f(verts[j]);
            var n0 = extrude[i].n;
            var offset0 = extrude[i].offset;
            var offset1 = extrude[j].offset;
            var inner0 = cc.v2fsub(v0, cc.v2fmult(offset0, borderWidth));
            var inner1 = cc.v2fsub(v1, cc.v2fmult(offset1, borderWidth));
            var outer0 = cc.v2fadd(v0, cc.v2fmult(offset0, borderWidth));
            var outer1 = cc.v2fadd(v1, cc.v2fmult(offset1, borderWidth));
            locBuffer.push(new cc.V2F_C4B_T2F_Triangle({vertices: inner0, colors: c4bBorderColor,
                texCoords: cc.__t(cc.v2fneg(n0))}, {vertices: inner1, colors: c4bBorderColor, texCoords: cc.__t(cc.v2fneg(n0))}, {vertices: outer1, colors: c4bBorderColor, texCoords: cc.__t(n0)}, trianglesBuffer, locBuffer.length * triangleBytesLen));
            locBuffer.push(new cc.V2F_C4B_T2F_Triangle({vertices: inner0, colors: c4bBorderColor, texCoords: cc.__t(cc.v2fneg(n0))}, {vertices: outer0, colors: c4bBorderColor, texCoords: cc.__t(n0)}, {vertices: outer1, colors: c4bBorderColor, texCoords: cc.__t(n0)}, trianglesBuffer, locBuffer.length * triangleBytesLen))
        }
        extrude =
            null;
        this._dirty = true
    }, clear: function () {
        this._buffer.length = 0;
        this._dirty = true
    }});
cc.DrawNode = cc._renderType == cc._RENDER_TYPE_WEBGL ? cc.DrawNodeWebGL : cc.DrawNodeCanvas;
cc.DrawNode.create = function () {
    return new cc.DrawNode
};
cc._DrawNodeElement = function (type, verts, fillColor, lineWidth, lineColor, lineCap, isClosePolygon, isFill, isStroke) {
    var _t = this;
    _t.type = type;
    _t.verts = verts || null;
    _t.fillColor = fillColor || null;
    _t.lineWidth = lineWidth || 0;
    _t.lineColor = lineColor || null;
    _t.lineCap = lineCap || "butt";
    _t.isClosePolygon = isClosePolygon || false;
    _t.isFill = isFill || false;
    _t.isStroke = isStroke || false
};
cc.DrawNode.TYPE_DOT = 0;
cc.DrawNode.TYPE_SEGMENT = 1;
cc.DrawNode.TYPE_POLY = 2;cc.stencilBits = -1;
cc.setProgram = function (node, program) {
    node.shaderProgram = program;
    var children = node.children;
    if (!children)return;
    for (var i = 0; i < children.length; i++)cc.setProgram(children[i], program)
};
cc.ClippingNode = cc.Node.extend({alphaThreshold: 0, inverted: false, _stencil: null, _godhelpme: false, ctor: function (stencil) {
    cc.Node.prototype.ctor.call(this);
    this._stencil = null;
    this.alphaThreshold = 0;
    this.inverted = false;
    stencil = stencil || null;
    cc.ClippingNode.prototype.init.call(this, stencil)
}, init: null, _className: "ClippingNode", _initForWebGL: function (stencil) {
    this._stencil = stencil;
    this.alphaThreshold = 1;
    this.inverted = false;
    cc.ClippingNode._init_once = true;
    if (cc.ClippingNode._init_once) {
        cc.stencilBits = cc._renderContext.getParameter(cc._renderContext.STENCIL_BITS);
        if (cc.stencilBits <= 0)cc.log("Stencil buffer is not enabled.");
        cc.ClippingNode._init_once = false
    }
    return true
}, _initForCanvas: function (stencil) {
    this._stencil = stencil;
    this.alphaThreshold = 1;
    this.inverted = false
}, onEnter: function () {
    cc.Node.prototype.onEnter.call(this);
    this._stencil.onEnter()
}, onEnterTransitionDidFinish: function () {
    cc.Node.prototype.onEnterTransitionDidFinish.call(this);
    this._stencil.onEnterTransitionDidFinish()
}, onExitTransitionDidStart: function () {
    this._stencil.onExitTransitionDidStart();
    cc.Node.prototype.onExitTransitionDidStart.call(this)
}, onExit: function () {
    this._stencil.onExit();
    cc.Node.prototype.onExit.call(this)
}, visit: null, _visitForWebGL: function (ctx) {
    var gl = ctx || cc._renderContext;
    if (cc.stencilBits < 1) {
        cc.Node.prototype.visit.call(this, ctx);
        return
    }
    if (!this._stencil || !this._stencil.visible) {
        if (this.inverted)cc.Node.prototype.visit.call(this, ctx);
        return
    }
    cc.ClippingNode._layer = -1;
    if (cc.ClippingNode._layer + 1 == cc.stencilBits) {
        cc.ClippingNode._visit_once = true;
        if (cc.ClippingNode._visit_once) {
            cc.log("Nesting more than " +
                cc.stencilBits + "stencils is not supported. Everything will be drawn without stencil for this node and its childs.");
            cc.ClippingNode._visit_once = false
        }
        cc.Node.prototype.visit.call(this, ctx);
        return
    }
    cc.ClippingNode._layer++;
    var mask_layer = 1 << cc.ClippingNode._layer;
    var mask_layer_l = mask_layer - 1;
    var mask_layer_le = mask_layer | mask_layer_l;
    var currentStencilEnabled = gl.isEnabled(gl.STENCIL_TEST);
    var currentStencilWriteMask = gl.getParameter(gl.STENCIL_WRITEMASK);
    var currentStencilFunc = gl.getParameter(gl.STENCIL_FUNC);
    var currentStencilRef = gl.getParameter(gl.STENCIL_REF);
    var currentStencilValueMask = gl.getParameter(gl.STENCIL_VALUE_MASK);
    var currentStencilFail = gl.getParameter(gl.STENCIL_FAIL);
    var currentStencilPassDepthFail = gl.getParameter(gl.STENCIL_PASS_DEPTH_FAIL);
    var currentStencilPassDepthPass = gl.getParameter(gl.STENCIL_PASS_DEPTH_PASS);
    gl.enable(gl.STENCIL_TEST);
    gl.stencilMask(mask_layer);
    var currentDepthWriteMask = gl.getParameter(gl.DEPTH_WRITEMASK);
    gl.depthMask(false);
    gl.stencilFunc(gl.NEVER, mask_layer, mask_layer);
    gl.stencilOp(!this.inverted ? gl.ZERO : gl.REPLACE, gl.KEEP, gl.KEEP);
    cc._drawingUtil.drawSolidRect(cc.p(0, 0), cc.pFromSize(cc.director.getWinSize()), cc.color(255, 255, 255, 255));
    gl.stencilFunc(gl.NEVER, mask_layer, mask_layer);
    gl.stencilOp(!this.inverted ? gl.REPLACE : gl.ZERO, gl.KEEP, gl.KEEP);
    if (this.alphaThreshold < 1) {
        var program = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST);
        var alphaValueLocation = gl.getUniformLocation(program.getProgram(), cc.UNIFORM_ALPHA_TEST_VALUE_S);
        cc.glUseProgram(program.getProgram());
        program.setUniformLocationWith1f(alphaValueLocation, this.alphaThreshold);
        cc.setProgram(this._stencil, program)
    }
    cc.kmGLPushMatrix();
    this.transform();
    this._stencil.visit();
    cc.kmGLPopMatrix();
    gl.depthMask(currentDepthWriteMask);
    gl.stencilFunc(gl.EQUAL, mask_layer_le, mask_layer_le);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
    cc.Node.prototype.visit.call(this, ctx);
    gl.stencilFunc(currentStencilFunc, currentStencilRef, currentStencilValueMask);
    gl.stencilOp(currentStencilFail, currentStencilPassDepthFail, currentStencilPassDepthPass);
    gl.stencilMask(currentStencilWriteMask);
    if (!currentStencilEnabled)gl.disable(gl.STENCIL_TEST);
    cc.ClippingNode._layer--
}, _visitForCanvas: function (ctx) {
    if (!this._stencil || !this._stencil.visible) {
        if (this.inverted)cc.Node.prototype.visit.call(this, ctx);
        return
    }
    var context = ctx || cc._renderContext;
    var canvas = context.canvas;
    if (this._cangodhelpme() || this._stencil instanceof cc.Sprite) {
        var locCache = cc.ClippingNode._getSharedCache();
        locCache.width = canvas.width;
        locCache.height = canvas.height;
        var locCacheCtx = locCache.getContext("2d");
        locCacheCtx.drawImage(canvas, 0, 0);
        context.save();
        cc.Node.prototype.visit.call(this, context);
        context.globalCompositeOperation = this.inverted ? "destination-out" : "destination-in";
        this.transform(context);
        this._stencil.visit();
        context.restore();
        context.save();
        context.setTransform(1, 0, 0, 1, 0, 0);
        context.globalCompositeOperation = "destination-over";
        context.drawImage(locCache, 0, 0);
        context.restore()
    } else {
        var i, children = this._children, locChild;
        context.save();
        this.transform(context);
        this._stencil.visit(context);
        if (this.inverted) {
            context.save();
            context.setTransform(1, 0, 0, 1, 0, 0);
            context.moveTo(0, 0);
            context.lineTo(0, canvas.height);
            context.lineTo(canvas.width, canvas.height);
            context.lineTo(canvas.width, 0);
            context.lineTo(0, 0);
            context.restore()
        }
        context.clip();
        this._cangodhelpme(true);
        var len = children.length;
        if (len > 0) {
            this.sortAllChildren();
            for (i = 0; i < len; i++) {
                locChild = children[i];
                if (locChild._localZOrder < 0)locChild.visit(context); else break
            }
            this.draw(context);
            for (; i < len; i++)children[i].visit(context)
        } else this.draw(context);
        this._cangodhelpme(false);
        context.restore()
    }
}, getStencil: function () {
    return this._stencil
}, setStencil: null, _setStencilForWebGL: function (stencil) {
    this._stencil = stencil
}, _setStencilForCanvas: function (stencil) {
    this._stencil = stencil;
    var locContext = cc._renderContext;
    if (stencil instanceof cc.Sprite)return; else if (stencil instanceof cc.DrawNode)stencil.draw = function () {
        var locEGL_ScaleX = cc.view.getScaleX(), locEGL_ScaleY = cc.view.getScaleY();
        locContext.beginPath();
        for (var i = 0; i < stencil._buffer.length; i++) {
            var element =
                stencil._buffer[i];
            var vertices = element.verts;
            var firstPoint = vertices[0];
            locContext.moveTo(firstPoint.x * locEGL_ScaleX, -firstPoint.y * locEGL_ScaleY);
            for (var j = 1, len = vertices.length; j < len; j++)locContext.lineTo(vertices[j].x * locEGL_ScaleX, -vertices[j].y * locEGL_ScaleY)
        }
    }
}, getAlphaThreshold: function () {
    return this.alphaThreshold
}, setAlphaThreshold: function (alphaThreshold) {
    this.alphaThreshold = alphaThreshold
}, isInverted: function () {
    return this.inverted
}, setInverted: function (inverted) {
    this.inverted = inverted
},
    _cangodhelpme: function (godhelpme) {
        if (godhelpme === true || godhelpme === false)cc.ClippingNode.prototype._godhelpme = godhelpme;
        return cc.ClippingNode.prototype._godhelpme
    }});
var _p = cc.ClippingNode.prototype;
if (cc._renderType === cc._RENDER_TYPE_WEBGL) {
    _p.init = _p._initForWebGL;
    _p.visit = _p._visitForWebGL;
    _p.setStencil = _p._setStencilForWebGL
} else {
    _p.init = _p._initForCanvas;
    _p.visit = _p._visitForCanvas;
    _p.setStencil = _p._setStencilForCanvas
}
cc.defineGetterSetter(_p, "stencil", _p.getStencil, _p.setStencil);
_p.stencil;
cc.ClippingNode._init_once = null;
cc.ClippingNode._visit_once = null;
cc.ClippingNode._layer = null;
cc.ClippingNode._sharedCache = null;
cc.ClippingNode._getSharedCache = function () {
    return cc.ClippingNode._sharedCache || (cc.ClippingNode._sharedCache = document.createElement("canvas"))
};
cc.ClippingNode.create = function (stencil) {
    return new cc.ClippingNode(stencil)
};cc.GridBase = cc.Class.extend({_active: false, _reuseGrid: 0, _gridSize: null, _texture: null, _step: null, _grabber: null, _isTextureFlipped: false, _shaderProgram: null, _directorProjection: 0, _dirty: false, ctor: function (gridSize, texture, flipped) {
    cc._checkWebGLRenderMode();
    this._active = false;
    this._reuseGrid = 0;
    this._gridSize = null;
    this._texture = null;
    this._step = cc.p(0, 0);
    this._grabber = null;
    this._isTextureFlipped = false;
    this._shaderProgram = null;
    this._directorProjection = 0;
    this._dirty = false;
    if (gridSize !== undefined)this.initWithSize(gridSize,
        texture, flipped)
}, isActive: function () {
    return this._active
}, setActive: function (active) {
    this._active = active;
    if (!active) {
        var director = cc.director;
        var proj = director.getProjection();
        director.setProjection(proj)
    }
}, getReuseGrid: function () {
    return this._reuseGrid
}, setReuseGrid: function (reuseGrid) {
    this._reuseGrid = reuseGrid
}, getGridSize: function () {
    return cc.size(this._gridSize.width, this._gridSize.height)
}, setGridSize: function (gridSize) {
    this._gridSize.width = parseInt(gridSize.width);
    this._gridSize.height = parseInt(gridSize.height)
},
    getStep: function () {
        return cc.p(this._step.x, this._step.y)
    }, setStep: function (step) {
        this._step.x = step.x;
        this._step.y = step.y
    }, isTextureFlipped: function () {
        return this._isTextureFlipped
    }, setTextureFlipped: function (flipped) {
        if (this._isTextureFlipped != flipped) {
            this._isTextureFlipped = flipped;
            this.calculateVertexPoints()
        }
    }, initWithSize: function (gridSize, texture, flipped) {
        if (!texture) {
            var director = cc.director;
            var winSize = director.getWinSizeInPixels();
            var POTWide = cc.NextPOT(winSize.width);
            var POTHigh = cc.NextPOT(winSize.height);
            var data = new Uint8Array(POTWide * POTHigh * 4);
            if (!data) {
                cc.log("cocos2d: CCGrid: not enough memory.");
                return false
            }
            texture = new cc.Texture2D;
            texture.initWithData(data, cc.Texture2D.PIXEL_FORMAT_RGBA8888, POTWide, POTHigh, winSize);
            if (!texture) {
                cc.log("cocos2d: CCGrid: error creating texture");
                return false
            }
        }
        flipped = flipped || false;
        this._active = false;
        this._reuseGrid = 0;
        this._gridSize = gridSize;
        this._texture = texture;
        this._isTextureFlipped = flipped;
        this._step.x = this._texture.width / gridSize.width;
        this._step.y = this._texture.height /
            gridSize.height;
        this._grabber = new cc.Grabber;
        if (!this._grabber)return false;
        this._grabber.grab(this._texture);
        this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE);
        this.calculateVertexPoints();
        return true
    }, beforeDraw: function () {
        this._directorProjection = cc.director.getProjection();
        this.set2DProjection();
        this._grabber.beforeRender(this._texture)
    }, afterDraw: function (target) {
        this._grabber.afterRender(this._texture);
        cc.director.setProjection(this._directorProjection);
        if (target.getCamera().isDirty()) {
            var offset =
                target.getAnchorPointInPoints();
            cc.kmGLTranslatef(offset.x, offset.y, 0);
            target.getCamera().locate();
            cc.kmGLTranslatef(-offset.x, -offset.y, 0)
        }
        cc.glBindTexture2D(this._texture);
        this.blit()
    }, blit: function () {
        cc.log("cc.GridBase.blit(): Shall be overridden in subclass.")
    }, reuse: function () {
        cc.log("cc.GridBase.reuse(): Shall be overridden in subclass.")
    }, calculateVertexPoints: function () {
        cc.log("cc.GridBase.calculateVertexPoints(): Shall be overridden in subclass.")
    }, set2DProjection: function () {
        var winSize =
            cc.director.getWinSizeInPixels();
        var gl = cc._renderContext;
        gl.viewport(0, 0, winSize.width, winSize.height);
        cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
        cc.kmGLLoadIdentity();
        var orthoMatrix = new cc.kmMat4;
        cc.kmMat4OrthographicProjection(orthoMatrix, 0, winSize.width, 0, winSize.height, -1, 1);
        cc.kmGLMultMatrix(orthoMatrix);
        cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
        cc.kmGLLoadIdentity();
        cc.setProjectionMatrixDirty()
    }});
cc.GridBase.create = function (gridSize, texture, flipped) {
    return new cc.GridBase(gridSize, texture, flipped)
};
cc.Grid3D = cc.GridBase.extend({_texCoordinates: null, _vertices: null, _originalVertices: null, _indices: null, _texCoordinateBuffer: null, _verticesBuffer: null, _indicesBuffer: null, ctor: function (gridSize, texture, flipped) {
    cc.GridBase.prototype.ctor.call(this);
    this._texCoordinates = null;
    this._vertices = null;
    this._originalVertices = null;
    this._indices = null;
    this._texCoordinateBuffer = null;
    this._verticesBuffer = null;
    this._indicesBuffer = null;
    if (gridSize !== undefined)this.initWithSize(gridSize, texture, flipped)
}, vertex: function (pos) {
    if (pos.x !==
        (0 | pos.x) || pos.y !== (0 | pos.y))cc.log("cc.Grid3D.vertex() : Numbers must be integers");
    var index = 0 | (pos.x * (this._gridSize.height + 1) + pos.y) * 3;
    var locVertices = this._vertices;
    return new cc.Vertex3F(locVertices[index], locVertices[index + 1], locVertices[index + 2])
}, originalVertex: function (pos) {
    if (pos.x !== (0 | pos.x) || pos.y !== (0 | pos.y))cc.log("cc.Grid3D.originalVertex() : Numbers must be integers");
    var index = 0 | (pos.x * (this._gridSize.height + 1) + pos.y) * 3;
    var locOriginalVertices = this._originalVertices;
    return new cc.Vertex3F(locOriginalVertices[index],
        locOriginalVertices[index + 1], locOriginalVertices[index + 2])
}, setVertex: function (pos, vertex) {
    if (pos.x !== (0 | pos.x) || pos.y !== (0 | pos.y))cc.log("cc.Grid3D.setVertex() : Numbers must be integers");
    var index = 0 | (pos.x * (this._gridSize.height + 1) + pos.y) * 3;
    var vertArray = this._vertices;
    vertArray[index] = vertex.x;
    vertArray[index + 1] = vertex.y;
    vertArray[index + 2] = vertex.z;
    this._dirty = true
}, blit: function () {
    var n = this._gridSize.width * this._gridSize.height;
    cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS);
    this._shaderProgram.use();
    this._shaderProgram.setUniformsForBuiltins();
    var gl = cc._renderContext, locDirty = this._dirty;
    gl.bindBuffer(gl.ARRAY_BUFFER, this._verticesBuffer);
    if (locDirty)gl.bufferData(gl.ARRAY_BUFFER, this._vertices, gl.DYNAMIC_DRAW);
    gl.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ARRAY_BUFFER, this._texCoordinateBuffer);
    if (locDirty)gl.bufferData(gl.ARRAY_BUFFER, this._texCoordinates, gl.DYNAMIC_DRAW);
    gl.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS,
        2, gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
    if (locDirty)gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._indices, gl.STATIC_DRAW);
    gl.drawElements(gl.TRIANGLES, n * 6, gl.UNSIGNED_SHORT, 0);
    if (locDirty)this._dirty = false;
    cc.incrementGLDraws(1)
}, reuse: function () {
    if (this._reuseGrid > 0) {
        var locOriginalVertices = this._originalVertices, locVertices = this._vertices;
        for (var i = 0, len = this._vertices.length; i < len; i++)locOriginalVertices[i] = locVertices[i];
        --this._reuseGrid
    }
}, calculateVertexPoints: function () {
    var gl =
        cc._renderContext;
    var width = this._texture.pixelsWidth;
    var height = this._texture.pixelsHeight;
    var imageH = this._texture.getContentSizeInPixels().height;
    var locGridSize = this._gridSize;
    var numOfPoints = (locGridSize.width + 1) * (locGridSize.height + 1);
    this._vertices = new Float32Array(numOfPoints * 3);
    this._texCoordinates = new Float32Array(numOfPoints * 2);
    this._indices = new Uint16Array(locGridSize.width * locGridSize.height * 6);
    if (this._verticesBuffer)gl.deleteBuffer(this._verticesBuffer);
    this._verticesBuffer = gl.createBuffer();
    if (this._texCoordinateBuffer)gl.deleteBuffer(this._texCoordinateBuffer);
    this._texCoordinateBuffer = gl.createBuffer();
    if (this._indicesBuffer)gl.deleteBuffer(this._indicesBuffer);
    this._indicesBuffer = gl.createBuffer();
    var x, y, i, locIndices = this._indices, locTexCoordinates = this._texCoordinates;
    var locIsTextureFlipped = this._isTextureFlipped, locVertices = this._vertices;
    for (x = 0; x < locGridSize.width; ++x)for (y = 0; y < locGridSize.height; ++y) {
        var idx = y * locGridSize.width + x;
        var x1 = x * this._step.x;
        var x2 = x1 + this._step.x;
        var y1 = y * this._step.y;
        var y2 = y1 + this._step.y;
        var a = x * (locGridSize.height + 1) + y;
        var b = (x + 1) * (locGridSize.height + 1) + y;
        var c = (x + 1) * (locGridSize.height + 1) + (y + 1);
        var d = x * (locGridSize.height + 1) + (y + 1);
        locIndices[idx * 6] = a;
        locIndices[idx * 6 + 1] = b;
        locIndices[idx * 6 + 2] = d;
        locIndices[idx * 6 + 3] = b;
        locIndices[idx * 6 + 4] = c;
        locIndices[idx * 6 + 5] = d;
        var l1 = [a * 3, b * 3, c * 3, d * 3];
        var e = {x: x1, y: y1, z: 0};
        var f = {x: x2, y: y1, z: 0};
        var g = {x: x2, y: y2, z: 0};
        var h = {x: x1, y: y2, z: 0};
        var l2 = [e, f, g, h];
        var tex1 = [a * 2, b * 2, c * 2, d * 2];
        var tex2 = [cc.p(x1, y1),
            cc.p(x2, y1), cc.p(x2, y2), cc.p(x1, y2)];
        for (i = 0; i < 4; ++i) {
            locVertices[l1[i]] = l2[i].x;
            locVertices[l1[i] + 1] = l2[i].y;
            locVertices[l1[i] + 2] = l2[i].z;
            locTexCoordinates[tex1[i]] = tex2[i].x / width;
            if (locIsTextureFlipped)locTexCoordinates[tex1[i] + 1] = (imageH - tex2[i].y) / height; else locTexCoordinates[tex1[i] + 1] = tex2[i].y / height
        }
    }
    this._originalVertices = new Float32Array(this._vertices);
    gl.bindBuffer(gl.ARRAY_BUFFER, this._verticesBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this._vertices, gl.DYNAMIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER,
        this._texCoordinateBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this._texCoordinates, gl.DYNAMIC_DRAW);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._indices, gl.STATIC_DRAW);
    this._dirty = true
}});
cc.Grid3D.create = function (gridSize, texture, flipped) {
    return new cc.Grid3D(gridSize, texture, flipped)
};
cc.TiledGrid3D = cc.GridBase.extend({_texCoordinates: null, _vertices: null, _originalVertices: null, _indices: null, _texCoordinateBuffer: null, _verticesBuffer: null, _indicesBuffer: null, ctor: function (gridSize, texture, flipped) {
    cc.GridBase.prototype.ctor.call(this);
    this._texCoordinates = null;
    this._vertices = null;
    this._originalVertices = null;
    this._indices = null;
    this._texCoordinateBuffer = null;
    this._verticesBuffer = null;
    this._indicesBuffer = null;
    if (gridSize !== undefined)this.initWithSize(gridSize, texture, flipped)
}, tile: function (pos) {
    if (pos.x !==
        (0 | pos.x) || pos.y !== (0 | pos.y))cc.log("cc.TiledGrid3D.tile() : Numbers must be integers");
    var idx = (this._gridSize.height * pos.x + pos.y) * 4 * 3;
    var locVertices = this._vertices;
    return new cc.Quad3(new cc.Vertex3F(locVertices[idx], locVertices[idx + 1], locVertices[idx + 2]), new cc.Vertex3F(locVertices[idx + 3], locVertices[idx + 4], locVertices[idx + 5]), new cc.Vertex3F(locVertices[idx + 6], locVertices[idx + 7], locVertices[idx + 8]), new cc.Vertex3F(locVertices[idx + 9], locVertices[idx + 10], locVertices[idx + 11]))
}, originalTile: function (pos) {
    if (pos.x !==
        (0 | pos.x) || pos.y !== (0 | pos.y))cc.log("cc.TiledGrid3D.originalTile() : Numbers must be integers");
    var idx = (this._gridSize.height * pos.x + pos.y) * 4 * 3;
    var locOriginalVertices = this._originalVertices;
    return new cc.Quad3(new cc.Vertex3F(locOriginalVertices[idx], locOriginalVertices[idx + 1], locOriginalVertices[idx + 2]), new cc.Vertex3F(locOriginalVertices[idx + 3], locOriginalVertices[idx + 4], locOriginalVertices[idx + 5]), new cc.Vertex3F(locOriginalVertices[idx + 6], locOriginalVertices[idx + 7], locOriginalVertices[idx + 8]),
        new cc.Vertex3F(locOriginalVertices[idx + 9], locOriginalVertices[idx + 10], locOriginalVertices[idx + 11]))
}, setTile: function (pos, coords) {
    if (pos.x !== (0 | pos.x) || pos.y !== (0 | pos.y))cc.log("cc.TiledGrid3D.setTile() : Numbers must be integers");
    var idx = (this._gridSize.height * pos.x + pos.y) * 12;
    var locVertices = this._vertices;
    locVertices[idx] = coords.bl.x;
    locVertices[idx + 1] = coords.bl.y;
    locVertices[idx + 2] = coords.bl.z;
    locVertices[idx + 3] = coords.br.x;
    locVertices[idx + 4] = coords.br.y;
    locVertices[idx + 5] = coords.br.z;
    locVertices[idx +
        6] = coords.tl.x;
    locVertices[idx + 7] = coords.tl.y;
    locVertices[idx + 8] = coords.tl.z;
    locVertices[idx + 9] = coords.tr.x;
    locVertices[idx + 10] = coords.tr.y;
    locVertices[idx + 11] = coords.tr.z;
    this._dirty = true
}, blit: function () {
    var n = this._gridSize.width * this._gridSize.height;
    this._shaderProgram.use();
    this._shaderProgram.setUniformsForBuiltins();
    var gl = cc._renderContext, locDirty = this._dirty;
    cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS);
    gl.bindBuffer(gl.ARRAY_BUFFER, this._verticesBuffer);
    if (locDirty)gl.bufferData(gl.ARRAY_BUFFER, this._vertices, gl.DYNAMIC_DRAW);
    gl.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, gl.FLOAT, false, 0, this._vertices);
    gl.bindBuffer(gl.ARRAY_BUFFER, this._texCoordinateBuffer);
    if (locDirty)gl.bufferData(gl.ARRAY_BUFFER, this._texCoordinates, gl.DYNAMIC_DRAW);
    gl.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, gl.FLOAT, false, 0, this._texCoordinates);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
    if (locDirty)gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._indices,
        gl.STATIC_DRAW);
    gl.drawElements(gl.TRIANGLES, n * 6, gl.UNSIGNED_SHORT, 0);
    if (locDirty)this._dirty = false;
    cc.incrementGLDraws(1)
}, reuse: function () {
    if (this._reuseGrid > 0) {
        var locVertices = this._vertices, locOriginalVertices = this._originalVertices;
        for (var i = 0; i < locVertices.length; i++)locOriginalVertices[i] = locVertices[i];
        --this._reuseGrid
    }
}, calculateVertexPoints: function () {
    var width = this._texture.pixelsWidth;
    var height = this._texture.pixelsHeight;
    var imageH = this._texture.getContentSizeInPixels().height;
    var locGridSize =
        this._gridSize;
    var numQuads = locGridSize.width * locGridSize.height;
    this._vertices = new Float32Array(numQuads * 12);
    this._texCoordinates = new Float32Array(numQuads * 8);
    this._indices = new Uint16Array(numQuads * 6);
    var gl = cc._renderContext;
    if (this._verticesBuffer)gl.deleteBuffer(this._verticesBuffer);
    this._verticesBuffer = gl.createBuffer();
    if (this._texCoordinateBuffer)gl.deleteBuffer(this._texCoordinateBuffer);
    this._texCoordinateBuffer = gl.createBuffer();
    if (this._indicesBuffer)gl.deleteBuffer(this._indicesBuffer);
    this._indicesBuffer = gl.createBuffer();
    var x, y, i = 0;
    var locStep = this._step, locVertices = this._vertices, locTexCoords = this._texCoordinates, locIsTextureFlipped = this._isTextureFlipped;
    for (x = 0; x < locGridSize.width; x++)for (y = 0; y < locGridSize.height; y++) {
        var x1 = x * locStep.x;
        var x2 = x1 + locStep.x;
        var y1 = y * locStep.y;
        var y2 = y1 + locStep.y;
        locVertices[i * 12] = x1;
        locVertices[i * 12 + 1] = y1;
        locVertices[i * 12 + 2] = 0;
        locVertices[i * 12 + 3] = x2;
        locVertices[i * 12 + 4] = y1;
        locVertices[i * 12 + 5] = 0;
        locVertices[i * 12 + 6] = x1;
        locVertices[i * 12 + 7] = y2;
        locVertices[i * 12 + 8] = 0;
        locVertices[i * 12 + 9] = x2;
        locVertices[i * 12 + 10] = y2;
        locVertices[i * 12 + 11] = 0;
        var newY1 = y1;
        var newY2 = y2;
        if (locIsTextureFlipped) {
            newY1 = imageH - y1;
            newY2 = imageH - y2
        }
        locTexCoords[i * 8] = x1 / width;
        locTexCoords[i * 8 + 1] = newY1 / height;
        locTexCoords[i * 8 + 2] = x2 / width;
        locTexCoords[i * 8 + 3] = newY1 / height;
        locTexCoords[i * 8 + 4] = x1 / width;
        locTexCoords[i * 8 + 5] = newY2 / height;
        locTexCoords[i * 8 + 6] = x2 / width;
        locTexCoords[i * 8 + 7] = newY2 / height;
        i++
    }
    var locIndices = this._indices;
    for (x = 0; x < numQuads; x++) {
        locIndices[x * 6 + 0] = x * 4 + 0;
        locIndices[x * 6 + 1] = x * 4 + 1;
        locIndices[x * 6 + 2] = x * 4 + 2;
        locIndices[x * 6 + 3] = x * 4 + 1;
        locIndices[x * 6 + 4] = x * 4 + 2;
        locIndices[x * 6 + 5] = x * 4 + 3
    }
    this._originalVertices = new Float32Array(this._vertices);
    gl.bindBuffer(gl.ARRAY_BUFFER, this._verticesBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this._vertices, gl.DYNAMIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, this._texCoordinateBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this._texCoordinates, gl.DYNAMIC_DRAW);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,
        this._indices, gl.DYNAMIC_DRAW);
    this._dirty = true
}});
cc.TiledGrid3D.create = function (gridSize, texture, flipped) {
    return new cc.TiledGrid3D(gridSize, texture, flipped)
};
cc.Grabber = cc.Class.extend({_FBO: null, _oldFBO: null, _oldClearColor: null, _gl: null, ctor: function () {
    cc._checkWebGLRenderMode();
    this._gl = cc._renderContext;
    this._oldClearColor = [0, 0, 0, 0];
    this._oldFBO = null;
    this._FBO = this._gl.createFramebuffer()
}, grab: function (texture) {
    var locGL = this._gl;
    this._oldFBO = locGL.getParameter(locGL.FRAMEBUFFER_BINDING);
    locGL.bindFramebuffer(locGL.FRAMEBUFFER, this._FBO);
    locGL.framebufferTexture2D(locGL.FRAMEBUFFER, locGL.COLOR_ATTACHMENT0, locGL.TEXTURE_2D, texture._webTextureObj, 0);
    var status = locGL.checkFramebufferStatus(locGL.FRAMEBUFFER);
    if (status != locGL.FRAMEBUFFER_COMPLETE)cc.log("Frame Grabber: could not attach texture to frmaebuffer");
    locGL.bindFramebuffer(locGL.FRAMEBUFFER, this._oldFBO)
}, beforeRender: function (texture) {
    var locGL = this._gl;
    this._oldFBO = locGL.getParameter(locGL.FRAMEBUFFER_BINDING);
    locGL.bindFramebuffer(locGL.FRAMEBUFFER, this._FBO);
    this._oldClearColor = locGL.getParameter(locGL.COLOR_CLEAR_VALUE);
    locGL.clearColor(0, 0, 0, 0);
    locGL.clear(locGL.COLOR_BUFFER_BIT |
        locGL.DEPTH_BUFFER_BIT)
}, afterRender: function (texture) {
    var locGL = this._gl;
    locGL.bindFramebuffer(locGL.FRAMEBUFFER, this._oldFBO);
    locGL.colorMask(true, true, true, true)
}, destroy: function () {
    this._gl.deleteFramebuffer(this._FBO)
}});cc.GridAction = cc.ActionInterval.extend({_gridSize: null, ctor: function (duration, gridSize) {
    cc._checkWebGLRenderMode();
    cc.ActionInterval.prototype.ctor.call(this);
    this._gridSize = cc.size(0, 0);
    gridSize && this.initWithDuration(duration, gridSize)
}, clone: function () {
    var action = new cc.GridAction;
    var locGridSize = this._gridSize;
    action.initWithDuration(this._duration, cc.size(locGridSize.width, locGridSize.height));
    return action
}, startWithTarget: function (target) {
    cc.ActionInterval.prototype.startWithTarget.call(this,
        target);
    var newGrid = this.getGrid();
    var t = this.target;
    var targetGrid = t.grid;
    if (targetGrid && targetGrid.getReuseGrid() > 0) {
        var locGridSize = targetGrid.getGridSize();
        if (targetGrid.isActive() && locGridSize.width == this._gridSize.width && locGridSize.height == this._gridSize.height)targetGrid.reuse()
    } else {
        if (targetGrid && targetGrid.isActive())targetGrid.setActive(false);
        t.grid = newGrid;
        t.grid.setActive(true)
    }
}, reverse: function () {
    return cc.ReverseTime.create(this)
}, initWithDuration: function (duration, gridSize) {
    if (cc.ActionInterval.prototype.initWithDuration.call(this,
        duration)) {
        this._gridSize.width = gridSize.width;
        this._gridSize.height = gridSize.height;
        return true
    }
    return false
}, getGrid: function () {
    cc.log("cc.GridAction.getGrid(): it should be overridden in subclass.")
}});
cc.GridAction.create = function (duration, gridSize) {
    return new cc.GridAction(duration, gridSize)
};
cc.Grid3DAction = cc.GridAction.extend({getGrid: function () {
    return cc.Grid3D.create(this._gridSize)
}, vertex: function (position) {
    return this.target.grid.vertex(position)
}, originalVertex: function (position) {
    return this.target.grid.originalVertex(position)
}, setVertex: function (position, vertex) {
    this.target.grid.setVertex(position, vertex)
}});
cc.Grid3DAction.create = function (duration, gridSize) {
    return new cc.Grid3DAction(duration, gridSize)
};
cc.TiledGrid3DAction = cc.GridAction.extend({tile: function (position) {
    return this.target.grid.tile(position)
}, originalTile: function (position) {
    return this.target.grid.originalTile(position)
}, setTile: function (position, coords) {
    this.target.grid.setTile(position, coords)
}, getGrid: function () {
    return cc.TiledGrid3D.create(this._gridSize)
}});
cc.TiledGrid3DAction.create = function (duration, gridSize) {
    return new cc.TiledGrid3DAction(duration, gridSize)
};
cc.StopGrid = cc.ActionInstant.extend({startWithTarget: function (target) {
    cc.ActionInstant.prototype.startWithTarget.call(this, target);
    var grid = this.target.grid;
    if (grid && grid.isActive())grid.setActive(false)
}});
cc.StopGrid.create = function () {
    return new cc.StopGrid
};
cc.ReuseGrid = cc.ActionInstant.extend({_times: null, ctor: function (times) {
    cc.ActionInstant.prototype.ctor.call(this);
    times !== undefined && this.initWithTimes(times)
}, initWithTimes: function (times) {
    this._times = times;
    return true
}, startWithTarget: function (target) {
    cc.ActionInstant.prototype.startWithTarget.call(this, target);
    if (this.target.grid && this.target.grid.isActive())this.target.grid.setReuseGrid(this.target.grid.getReuseGrid() + this._times)
}});
cc.ReuseGrid.create = function (times) {
    return new cc.ReuseGrid(times)
};
cc.Waves3D = cc.Grid3DAction.extend({_waves: 0, _amplitude: 0, _amplitudeRate: 0, ctor: function (duration, gridSize, waves, amplitude) {
    cc.GridAction.prototype.ctor.call(this);
    amplitude !== undefined && this.initWithDuration(duration, gridSize, waves, amplitude)
}, getAmplitude: function () {
    return this._amplitude
}, setAmplitude: function (amplitude) {
    this._amplitude = amplitude
}, getAmplitudeRate: function () {
    return this._amplitudeRate
}, setAmplitudeRate: function (amplitudeRate) {
    this._amplitudeRate = amplitudeRate
}, initWithDuration: function (duration, gridSize, waves, amplitude) {
    if (cc.Grid3DAction.prototype.initWithDuration.call(this, duration, gridSize)) {
        this._waves = waves;
        this._amplitude = amplitude;
        this._amplitudeRate = 1;
        return true
    }
    return false
}, update: function (time) {
    var locGridSize = this._gridSize;
    var locAmplitude = this._amplitude, locPos = cc.p(0, 0);
    var locAmplitudeRate = this._amplitudeRate, locWaves = this._waves;
    for (var i = 0; i < locGridSize.width + 1; ++i)for (var j = 0; j < locGridSize.height + 1; ++j) {
        locPos.x = i;
        locPos.y = j;
        var v = this.originalVertex(locPos);
        v.z += Math.sin(Math.PI *
            time * locWaves * 2 + (v.y + v.x) * 0.01) * locAmplitude * locAmplitudeRate;
        this.setVertex(locPos, v)
    }
}});
cc.Waves3D.create = function (duration, gridSize, waves, amplitude) {
    return new cc.Waves3D(duration, gridSize, waves, amplitude)
};
cc.FlipX3D = cc.Grid3DAction.extend({ctor: function (duration) {
    if (duration !== undefined)cc.GridAction.prototype.ctor.call(this, duration, cc.size(1, 1)); else cc.GridAction.prototype.ctor.call(this)
}, initWithDuration: function (duration) {
    return cc.Grid3DAction.prototype.initWithDuration.call(this, duration, cc.size(1, 1))
}, initWithSize: function (gridSize, duration) {
    if (gridSize.width != 1 || gridSize.height != 1) {
        cc.log("Grid size must be (1,1)");
        return false
    }
    return cc.Grid3DAction.prototype.initWithDuration.call(this,
        duration, gridSize)
}, update: function (time) {
    var angle = Math.PI * time;
    var mz = Math.sin(angle);
    angle = angle / 2;
    var mx = Math.cos(angle);
    var diff = new cc.Vertex3F;
    var tempVer = cc.p(0, 0);
    tempVer.x = tempVer.y = 1;
    var v0 = this.originalVertex(tempVer);
    tempVer.x = tempVer.y = 0;
    var v1 = this.originalVertex(tempVer);
    var x0 = v0.x;
    var x1 = v1.x;
    var x;
    var a, b, c, d;
    if (x0 > x1) {
        a = cc.p(0, 0);
        b = cc.p(0, 1);
        c = cc.p(1, 0);
        d = cc.p(1, 1);
        x = x0
    } else {
        c = cc.p(0, 0);
        d = cc.p(0, 1);
        a = cc.p(1, 0);
        b = cc.p(1, 1);
        x = x1
    }
    diff.x = x - x * mx;
    diff.z = Math.abs(parseFloat(x * mz / 4));
    var v = this.originalVertex(a);
    v.x = diff.x;
    v.z += diff.z;
    this.setVertex(a, v);
    v = this.originalVertex(b);
    v.x = diff.x;
    v.z += diff.z;
    this.setVertex(b, v);
    v = this.originalVertex(c);
    v.x -= diff.x;
    v.z -= diff.z;
    this.setVertex(c, v);
    v = this.originalVertex(d);
    v.x -= diff.x;
    v.z -= diff.z;
    this.setVertex(d, v)
}});
cc.FlipX3D.create = function (duration) {
    return new cc.FlipX3D(duration)
};
cc.FlipY3D = cc.FlipX3D.extend({ctor: function (duration) {
    if (duration !== undefined)cc.GridAction.prototype.ctor.call(this, duration, cc.size(1, 1)); else cc.GridAction.prototype.ctor.call(this)
}, update: function (time) {
    var angle = Math.PI * time;
    var mz = Math.sin(angle);
    angle = angle / 2;
    var my = Math.cos(angle);
    var diff = new cc.Vertex3F;
    var tempP = cc.p(0, 0);
    tempP.x = tempP.y = 1;
    var v0 = this.originalVertex(tempP);
    tempP.x = tempP.y = 0;
    var v1 = this.originalVertex(tempP);
    var y0 = v0.y;
    var y1 = v1.y;
    var y;
    var a, b, c, d;
    if (y0 > y1) {
        a = cc.p(0,
            0);
        b = cc.p(0, 1);
        c = cc.p(1, 0);
        d = cc.p(1, 1);
        y = y0
    } else {
        b = cc.p(0, 0);
        a = cc.p(0, 1);
        d = cc.p(1, 0);
        c = cc.p(1, 1);
        y = y1
    }
    diff.y = y - y * my;
    diff.z = Math.abs(parseFloat(y * mz) / 4);
    var v = this.originalVertex(a);
    v.y = diff.y;
    v.z += diff.z;
    this.setVertex(a, v);
    v = this.originalVertex(b);
    v.y -= diff.y;
    v.z -= diff.z;
    this.setVertex(b, v);
    v = this.originalVertex(c);
    v.y = diff.y;
    v.z += diff.z;
    this.setVertex(c, v);
    v = this.originalVertex(d);
    v.y -= diff.y;
    v.z -= diff.z;
    this.setVertex(d, v)
}});
cc.FlipY3D.create = function (duration) {
    return new cc.FlipY3D(duration)
};
cc.Lens3D = cc.Grid3DAction.extend({_position: null, _radius: 0, _lensEffect: 0, _concave: false, _dirty: false, ctor: function (duration, gridSize, position, radius) {
    cc.GridAction.prototype.ctor.call(this);
    this._position = cc.p(0, 0);
    radius !== undefined && this.initWithDuration(duration, gridSize, position, radius)
}, getLensEffect: function () {
    return this._lensEffect
}, setLensEffect: function (lensEffect) {
    this._lensEffect = lensEffect
}, setConcave: function (concave) {
    this._concave = concave
}, getPosition: function () {
    return this._position
},
    setPosition: function (position) {
        if (!cc.pointEqualToPoint(position, this._position)) {
            this._position.x = position.x;
            this._position.y = position.y;
            this._dirty = true
        }
    }, initWithDuration: function (duration, gridSize, position, radius) {
        if (cc.Grid3DAction.prototype.initWithDuration.call(this, duration, gridSize)) {
            this.setPosition(position);
            this._radius = radius;
            this._lensEffect = 0.7;
            this._dirty = true;
            return true
        }
        return false
    }, update: function (time) {
        if (this._dirty) {
            var locGridSizeWidth = this._gridSize.width, locGridSizeHeight =
                this._gridSize.height;
            var locRadius = this._radius, locLensEffect = this._lensEffect;
            var locPos = cc.p(0, 0);
            var vect = cc.p(0, 0);
            var v, r, l, new_r, pre_log;
            for (var i = 0; i < locGridSizeWidth + 1; ++i)for (var j = 0; j < locGridSizeHeight + 1; ++j) {
                locPos.x = i;
                locPos.y = j;
                v = this.originalVertex(locPos);
                vect.x = this._position.x - v.x;
                vect.y = this._position.y - v.y;
                r = cc.pLength(vect);
                if (r < locRadius) {
                    r = locRadius - r;
                    pre_log = r / locRadius;
                    if (pre_log == 0)pre_log = 0.001;
                    l = Math.log(pre_log) * locLensEffect;
                    new_r = Math.exp(l) * locRadius;
                    r = cc.pLength(vect);
                    if (r > 0) {
                        vect.x = vect.x / r;
                        vect.y = vect.y / r;
                        vect.x = vect.x * new_r;
                        vect.y = vect.y * new_r;
                        v.z += cc.pLength(vect) * locLensEffect
                    }
                }
                this.setVertex(locPos, v)
            }
            this._dirty = false
        }
    }});
cc.Lens3D.create = function (duration, gridSize, position, radius) {
    return new cc.Lens3D(duration, gridSize, position, radius)
};
cc.Ripple3D = cc.Grid3DAction.extend({_position: null, _radius: 0, _waves: 0, _amplitude: 0, _amplitudeRate: 0, ctor: function (duration, gridSize, position, radius, waves, amplitude) {
    cc.GridAction.prototype.ctor.call(this);
    this._position = cc.p(0, 0);
    amplitude !== undefined && this.initWithDuration(duration, gridSize, position, radius, waves, amplitude)
}, getPosition: function () {
    return this._position
}, setPosition: function (position) {
    this._position.x = position.x;
    this._position.y = position.y
}, getAmplitude: function () {
    return this._amplitude
},
    setAmplitude: function (amplitude) {
        this._amplitude = amplitude
    }, getAmplitudeRate: function () {
        return this._amplitudeRate
    }, setAmplitudeRate: function (amplitudeRate) {
        this._amplitudeRate = amplitudeRate
    }, initWithDuration: function (duration, gridSize, position, radius, waves, amplitude) {
        if (cc.Grid3DAction.prototype.initWithDuration.call(this, duration, gridSize)) {
            this.setPosition(position);
            this._radius = radius;
            this._waves = waves;
            this._amplitude = amplitude;
            this._amplitudeRate = 1;
            return true
        }
        return false
    }, update: function (time) {
        var locGridSizeWidth =
            this._gridSize.width, locGridSizeHeight = this._gridSize.height;
        var locPos = cc.p(0, 0), locRadius = this._radius;
        var locWaves = this._waves, locAmplitude = this._amplitude, locAmplitudeRate = this._amplitudeRate;
        var v, r, tempPos = cc.p(0, 0);
        for (var i = 0; i < locGridSizeWidth + 1; ++i)for (var j = 0; j < locGridSizeHeight + 1; ++j) {
            locPos.x = i;
            locPos.y = j;
            v = this.originalVertex(locPos);
            tempPos.x = this._position.x - v.x;
            tempPos.y = this._position.y - v.y;
            r = cc.pLength(tempPos);
            if (r < locRadius) {
                r = locRadius - r;
                var rate = Math.pow(r / locRadius, 2);
                v.z +=
                    Math.sin(time * Math.PI * locWaves * 2 + r * 0.1) * locAmplitude * locAmplitudeRate * rate
            }
            this.setVertex(locPos, v)
        }
    }});
cc.Ripple3D.create = function (duration, gridSize, position, radius, waves, amplitude) {
    return new cc.Ripple3D(duration, gridSize, position, radius, waves, amplitude)
};
cc.Shaky3D = cc.Grid3DAction.extend({_randRange: 0, _shakeZ: false, ctor: function (duration, gridSize, range, shakeZ) {
    cc.GridAction.prototype.ctor.call(this);
    shakeZ !== undefined && this.initWithDuration(duration, gridSize, range, shakeZ)
}, initWithDuration: function (duration, gridSize, range, shakeZ) {
    if (cc.Grid3DAction.prototype.initWithDuration.call(this, duration, gridSize)) {
        this._randRange = range;
        this._shakeZ = shakeZ;
        return true
    }
    return false
}, update: function (time) {
    var locGridSizeWidth = this._gridSize.width, locGridSizeHeight =
        this._gridSize.height;
    var locRandRange = this._randRange, locShakeZ = this._shakeZ, locP = cc.p(0, 0);
    var v;
    for (var i = 0; i < locGridSizeWidth + 1; ++i)for (var j = 0; j < locGridSizeHeight + 1; ++j) {
        locP.x = i;
        locP.y = j;
        v = this.originalVertex(locP);
        v.x += cc.rand() % (locRandRange * 2) - locRandRange;
        v.y += cc.rand() % (locRandRange * 2) - locRandRange;
        if (locShakeZ)v.z += cc.rand() % (locRandRange * 2) - locRandRange;
        this.setVertex(locP, v)
    }
}});
cc.Shaky3D.create = function (duration, gridSize, range, shakeZ) {
    return new cc.Shaky3D(duration, gridSize, range, shakeZ)
};
cc.Liquid = cc.Grid3DAction.extend({_waves: 0, _amplitude: 0, _amplitudeRate: 0, ctor: function (duration, gridSize, waves, amplitude) {
    cc.GridAction.prototype.ctor.call(this);
    amplitude !== undefined && this.initWithDuration(duration, gridSize, waves, amplitude)
}, getAmplitude: function () {
    return this._amplitude
}, setAmplitude: function (amplitude) {
    this._amplitude = amplitude
}, getAmplitudeRate: function () {
    return this._amplitudeRate
}, setAmplitudeRate: function (amplitudeRate) {
    this._amplitudeRate = amplitudeRate
}, initWithDuration: function (duration, gridSize, waves, amplitude) {
    if (cc.Grid3DAction.prototype.initWithDuration.call(this, duration, gridSize)) {
        this._waves = waves;
        this._amplitude = amplitude;
        this._amplitudeRate = 1;
        return true
    }
    return false
}, update: function (time) {
    var locSizeWidth = this._gridSize.width, locSizeHeight = this._gridSize.height, locPos = cc.p(0, 0);
    var locWaves = this._waves, locAmplitude = this._amplitude, locAmplitudeRate = this._amplitudeRate;
    var v;
    for (var i = 1; i < locSizeWidth; ++i)for (var j = 1; j < locSizeHeight; ++j) {
        locPos.x = i;
        locPos.y = j;
        v = this.originalVertex(locPos);
        v.x = v.x + Math.sin(time * Math.PI * locWaves * 2 + v.x * 0.01) * locAmplitude * locAmplitudeRate;
        v.y = v.y + Math.sin(time * Math.PI * locWaves * 2 + v.y * 0.01) * locAmplitude * locAmplitudeRate;
        this.setVertex(locPos, v)
    }
}});
cc.Liquid.create = function (duration, gridSize, waves, amplitude) {
    return new cc.Liquid(duration, gridSize, waves, amplitude)
};
cc.Waves = cc.Grid3DAction.extend({_waves: 0, _amplitude: 0, _amplitudeRate: 0, _vertical: false, _horizontal: false, ctor: function (duration, gridSize, waves, amplitude, horizontal, vertical) {
    cc.GridAction.prototype.ctor.call(this);
    vertical !== undefined && this.initWithDuration(duration, gridSize, waves, amplitude, horizontal, vertical)
}, getAmplitude: function () {
    return this._amplitude
}, setAmplitude: function (amplitude) {
    this._amplitude = amplitude
}, getAmplitudeRate: function () {
    return this._amplitudeRate
}, setAmplitudeRate: function (amplitudeRate) {
    this._amplitudeRate =
        amplitudeRate
}, initWithDuration: function (duration, gridSize, waves, amplitude, horizontal, vertical) {
    if (cc.Grid3DAction.prototype.initWithDuration.call(this, duration, gridSize)) {
        this._waves = waves;
        this._amplitude = amplitude;
        this._amplitudeRate = 1;
        this._horizontal = horizontal;
        this._vertical = vertical;
        return true
    }
    return false
}, update: function (time) {
    var locSizeWidth = this._gridSize.width, locSizeHeight = this._gridSize.height, locPos = cc.p(0, 0);
    var locVertical = this._vertical, locHorizontal = this._horizontal;
    var locWaves =
        this._waves, locAmplitude = this._amplitude, locAmplitudeRate = this._amplitudeRate;
    var v;
    for (var i = 0; i < locSizeWidth + 1; ++i)for (var j = 0; j < locSizeHeight + 1; ++j) {
        locPos.x = i;
        locPos.y = j;
        v = this.originalVertex(locPos);
        if (locVertical)v.x = v.x + Math.sin(time * Math.PI * locWaves * 2 + v.y * 0.01) * locAmplitude * locAmplitudeRate;
        if (locHorizontal)v.y = v.y + Math.sin(time * Math.PI * locWaves * 2 + v.x * 0.01) * locAmplitude * locAmplitudeRate;
        this.setVertex(locPos, v)
    }
}});
cc.Waves.create = function (duration, gridSize, waves, amplitude, horizontal, vertical) {
    return new cc.Waves(duration, gridSize, waves, amplitude, horizontal, vertical)
};
cc.Twirl = cc.Grid3DAction.extend({_position: null, _twirls: 0, _amplitude: 0, _amplitudeRate: 0, ctor: function (duration, gridSize, position, twirls, amplitude) {
    cc.GridAction.prototype.ctor.call(this);
    this._position = cc.p(0, 0);
    amplitude !== undefined && this.initWithDuration(duration, gridSize, position, twirls, amplitude)
}, getPosition: function () {
    return this._position
}, setPosition: function (position) {
    this._position.x = position.x;
    this._position.y = position.y
}, getAmplitude: function () {
    return this._amplitude
}, setAmplitude: function (amplitude) {
    this._amplitude =
        amplitude
}, getAmplitudeRate: function () {
    return this._amplitudeRate
}, setAmplitudeRate: function (amplitudeRate) {
    this._amplitudeRate = amplitudeRate
}, initWithDuration: function (duration, gridSize, position, twirls, amplitude) {
    if (cc.Grid3DAction.prototype.initWithDuration.call(this, duration, gridSize)) {
        this.setPosition(position);
        this._twirls = twirls;
        this._amplitude = amplitude;
        this._amplitudeRate = 1;
        return true
    }
    return false
}, update: function (time) {
    var c = this._position;
    var locSizeWidth = this._gridSize.width, locSizeHeight =
        this._gridSize.height, locPos = cc.p(0, 0);
    var amp = 0.1 * this._amplitude * this._amplitudeRate;
    var locTwirls = this._twirls;
    var v, a, dX, dY, avg = cc.p(0, 0);
    for (var i = 0; i < locSizeWidth + 1; ++i)for (var j = 0; j < locSizeHeight + 1; ++j) {
        locPos.x = i;
        locPos.y = j;
        v = this.originalVertex(locPos);
        avg.x = i - locSizeWidth / 2;
        avg.y = j - locSizeHeight / 2;
        a = cc.pLength(avg) * Math.cos(Math.PI / 2 + time * Math.PI * locTwirls * 2) * amp;
        dX = Math.sin(a) * (v.y - c.y) + Math.cos(a) * (v.x - c.x);
        dY = Math.cos(a) * (v.y - c.y) - Math.sin(a) * (v.x - c.x);
        v.x = c.x + dX;
        v.y = c.y + dY;
        this.setVertex(locPos,
            v)
    }
}});
cc.Twirl.create = function (duration, gridSize, position, twirls, amplitude) {
    return new cc.Twirl(duration, gridSize, position, twirls, amplitude)
};
cc.ShakyTiles3D = cc.TiledGrid3DAction.extend({_randRange: 0, _shakeZ: false, ctor: function (duration, gridSize, range, shakeZ) {
    cc.GridAction.prototype.ctor.call(this);
    shakeZ !== undefined && this.initWithDuration(duration, gridSize, range, shakeZ)
}, initWithDuration: function (duration, gridSize, range, shakeZ) {
    if (cc.TiledGrid3DAction.prototype.initWithDuration.call(this, duration, gridSize)) {
        this._randRange = range;
        this._shakeZ = shakeZ;
        return true
    }
    return false
}, update: function (time) {
    var locGridSize = this._gridSize, locRandRange =
        this._randRange;
    var locPos = cc.p(0, 0);
    for (var i = 0; i < locGridSize.width; ++i)for (var j = 0; j < locGridSize.height; ++j) {
        locPos.x = i;
        locPos.y = j;
        var coords = this.originalTile(locPos);
        coords.bl.x += cc.rand() % (locRandRange * 2) - locRandRange;
        coords.br.x += cc.rand() % (locRandRange * 2) - locRandRange;
        coords.tl.x += cc.rand() % (locRandRange * 2) - locRandRange;
        coords.tr.x += cc.rand() % (locRandRange * 2) - locRandRange;
        coords.bl.y += cc.rand() % (locRandRange * 2) - locRandRange;
        coords.br.y += cc.rand() % (locRandRange * 2) - locRandRange;
        coords.tl.y +=
            cc.rand() % (locRandRange * 2) - locRandRange;
        coords.tr.y += cc.rand() % (locRandRange * 2) - locRandRange;
        if (this._shakeZ) {
            coords.bl.z += cc.rand() % (locRandRange * 2) - locRandRange;
            coords.br.z += cc.rand() % (locRandRange * 2) - locRandRange;
            coords.tl.z += cc.rand() % (locRandRange * 2) - locRandRange;
            coords.tr.z += cc.rand() % (locRandRange * 2) - locRandRange
        }
        this.setTile(locPos, coords)
    }
}});
cc.ShakyTiles3D.create = function (duration, gridSize, range, shakeZ) {
    return new cc.ShakyTiles3D(duration, gridSize, range, shakeZ)
};
cc.ShatteredTiles3D = cc.TiledGrid3DAction.extend({_randRange: 0, _once: false, _shatterZ: false, ctor: function (duration, gridSize, range, shatterZ) {
    cc.GridAction.prototype.ctor.call(this);
    shatterZ !== undefined && this.initWithDuration(duration, gridSize, range, shatterZ)
}, initWithDuration: function (duration, gridSize, range, shatterZ) {
    if (cc.TiledGrid3DAction.prototype.initWithDuration.call(this, duration, gridSize)) {
        this._once = false;
        this._randRange = range;
        this._shatterZ = shatterZ;
        return true
    }
    return false
}, update: function (time) {
    if (this._once ===
        false) {
        var locGridSize = this._gridSize, locRandRange = this._randRange;
        var coords, locPos = cc.p(0, 0);
        for (var i = 0; i < locGridSize.width; ++i)for (var j = 0; j < locGridSize.height; ++j) {
            locPos.x = i;
            locPos.y = j;
            coords = this.originalTile(locPos);
            coords.bl.x += cc.rand() % (locRandRange * 2) - locRandRange;
            coords.br.x += cc.rand() % (locRandRange * 2) - locRandRange;
            coords.tl.x += cc.rand() % (locRandRange * 2) - locRandRange;
            coords.tr.x += cc.rand() % (locRandRange * 2) - locRandRange;
            coords.bl.y += cc.rand() % (locRandRange * 2) - locRandRange;
            coords.br.y +=
                cc.rand() % (locRandRange * 2) - locRandRange;
            coords.tl.y += cc.rand() % (locRandRange * 2) - locRandRange;
            coords.tr.y += cc.rand() % (locRandRange * 2) - locRandRange;
            if (this._shatterZ) {
                coords.bl.z += cc.rand() % (locRandRange * 2) - locRandRange;
                coords.br.z += cc.rand() % (locRandRange * 2) - locRandRange;
                coords.tl.z += cc.rand() % (locRandRange * 2) - locRandRange;
                coords.tr.z += cc.rand() % (locRandRange * 2) - locRandRange
            }
            this.setTile(locPos, coords)
        }
        this._once = true
    }
}});
cc.ShatteredTiles3D.create = function (duration, gridSize, range, shatterZ) {
    return new cc.ShatteredTiles3D(duration, gridSize, range, shatterZ)
};
cc.Tile = function (position, startPosition, delta) {
    this.position = position || cc.p(0, 0);
    this.startPosition = startPosition || cc.p(0, 0);
    this.delta = delta || cc.p(0, 0)
};
cc.ShuffleTiles = cc.TiledGrid3DAction.extend({_seed: 0, _tilesCount: 0, _tilesOrder: null, _tiles: null, ctor: function (duration, gridSize, seed) {
    cc.GridAction.prototype.ctor.call(this);
    this._tilesOrder = [];
    this._tiles = [];
    seed !== undefined && this.initWithDuration(duration, gridSize, seed)
}, initWithDuration: function (duration, gridSize, seed) {
    if (cc.TiledGrid3DAction.prototype.initWithDuration.call(this, duration, gridSize)) {
        this._seed = seed;
        this._tilesOrder.length = 0;
        this._tiles.length = 0;
        return true
    }
    return false
}, shuffle: function (array, len) {
    for (var i = len - 1; i >= 0; i--) {
        var j = 0 | cc.rand() % (i + 1);
        var v = array[i];
        array[i] = array[j];
        array[j] = v
    }
}, getDelta: function (pos) {
    var locGridSize = this._gridSize;
    var idx = pos.width * locGridSize.height + pos.height;
    return cc.size(this._tilesOrder[idx] / locGridSize.height - pos.width, this._tilesOrder[idx] % locGridSize.height - pos.height)
}, placeTile: function (pos, tile) {
    var coords = this.originalTile(pos);
    var step = this.target.grid.getStep();
    var locPosition = tile.position;
    coords.bl.x += locPosition.x * step.x;
    coords.bl.y += locPosition.y *
        step.y;
    coords.br.x += locPosition.x * step.x;
    coords.br.y += locPosition.y * step.y;
    coords.tl.x += locPosition.x * step.x;
    coords.tl.y += locPosition.y * step.y;
    coords.tr.x += locPosition.x * step.x;
    coords.tr.y += locPosition.y * step.y;
    this.setTile(pos, coords)
}, startWithTarget: function (target) {
    cc.TiledGrid3DAction.prototype.startWithTarget.call(this, target);
    var locGridSize = this._gridSize;
    this._tilesCount = locGridSize.width * locGridSize.height;
    var locTilesOrder = this._tilesOrder;
    locTilesOrder.length = 0;
    for (var k = 0; k < this._tilesCount; ++k)locTilesOrder[k] =
        k;
    this.shuffle(locTilesOrder, this._tilesCount);
    var locTiles = this._tiles;
    locTiles.length = 0;
    var tileIndex = 0, tempSize = cc.size(0, 0);
    for (var i = 0; i < locGridSize.width; ++i)for (var j = 0; j < locGridSize.height; ++j) {
        locTiles[tileIndex] = new cc.Tile;
        locTiles[tileIndex].position = cc.p(i, j);
        locTiles[tileIndex].startPosition = cc.p(i, j);
        tempSize.width = i;
        tempSize.height = j;
        locTiles[tileIndex].delta = this.getDelta(tempSize);
        ++tileIndex
    }
}, update: function (time) {
    var tileIndex = 0, locGridSize = this._gridSize, locTiles = this._tiles;
    var selTile, locPos = cc.p(0, 0);
    for (var i = 0; i < locGridSize.width; ++i)for (var j = 0; j < locGridSize.height; ++j) {
        locPos.x = i;
        locPos.y = j;
        selTile = locTiles[tileIndex];
        selTile.position.x = selTile.delta.width * time;
        selTile.position.y = selTile.delta.height * time;
        this.placeTile(locPos, selTile);
        ++tileIndex
    }
}});
cc.ShuffleTiles.create = function (duration, gridSize, seed) {
    return new cc.ShuffleTiles(duration, gridSize, seed)
};
cc.FadeOutTRTiles = cc.TiledGrid3DAction.extend({testFunc: function (pos, time) {
    var locX = this._gridSize.width * time;
    var locY = this._gridSize.height * time;
    if (locX + locY == 0)return 1;
    return Math.pow((pos.width + pos.height) / (locX + locY), 6)
}, turnOnTile: function (pos) {
    this.setTile(pos, this.originalTile(pos))
}, turnOffTile: function (pos) {
    this.setTile(pos, new cc.Quad3)
}, transformTile: function (pos, distance) {
    var coords = this.originalTile(pos);
    var step = this.target.grid.getStep();
    coords.bl.x += step.x / 2 * (1 - distance);
    coords.bl.y +=
        step.y / 2 * (1 - distance);
    coords.br.x -= step.x / 2 * (1 - distance);
    coords.br.y += step.y / 2 * (1 - distance);
    coords.tl.x += step.x / 2 * (1 - distance);
    coords.tl.y -= step.y / 2 * (1 - distance);
    coords.tr.x -= step.x / 2 * (1 - distance);
    coords.tr.y -= step.y / 2 * (1 - distance);
    this.setTile(pos, coords)
}, update: function (time) {
    var locGridSize = this._gridSize;
    var locPos = cc.p(0, 0), locSize = cc.size(0, 0), distance;
    for (var i = 0; i < locGridSize.width; ++i)for (var j = 0; j < locGridSize.height; ++j) {
        locPos.x = i;
        locPos.y = j;
        locSize.width = i;
        locSize.height = j;
        distance = this.testFunc(locSize,
            time);
        if (distance == 0)this.turnOffTile(locPos); else if (distance < 1)this.transformTile(locPos, distance); else this.turnOnTile(locPos)
    }
}});
cc.FadeOutTRTiles.create = function (duration, gridSize) {
    return new cc.FadeOutTRTiles(duration, gridSize)
};
cc.FadeOutBLTiles = cc.FadeOutTRTiles.extend({testFunc: function (pos, time) {
    var locX = this._gridSize.width * (1 - time);
    var locY = this._gridSize.height * (1 - time);
    if (pos.width + pos.height == 0)return 1;
    return Math.pow((locX + locY) / (pos.width + pos.height), 6)
}});
cc.FadeOutBLTiles.create = function (duration, gridSize) {
    return new cc.FadeOutBLTiles(duration, gridSize)
};
cc.FadeOutUpTiles = cc.FadeOutTRTiles.extend({testFunc: function (pos, time) {
    var locY = this._gridSize.height * time;
    if (locY == 0)return 1;
    return Math.pow(pos.height / locY, 6)
}, transformTile: function (pos, distance) {
    var coords = this.originalTile(pos);
    var step = this.target.grid.getStep();
    coords.bl.y += step.y / 2 * (1 - distance);
    coords.br.y += step.y / 2 * (1 - distance);
    coords.tl.y -= step.y / 2 * (1 - distance);
    coords.tr.y -= step.y / 2 * (1 - distance);
    this.setTile(pos, coords)
}});
cc.FadeOutUpTiles.create = function (duration, gridSize) {
    return new cc.FadeOutUpTiles(duration, gridSize)
};
cc.FadeOutDownTiles = cc.FadeOutUpTiles.extend({testFunc: function (pos, time) {
    var locY = this._gridSize.height * (1 - time);
    if (pos.height == 0)return 1;
    return Math.pow(locY / pos.height, 6)
}});
cc.FadeOutDownTiles.create = function (duration, gridSize) {
    return new cc.FadeOutDownTiles(duration, gridSize)
};
cc.TurnOffTiles = cc.TiledGrid3DAction.extend({_seed: null, _tilesCount: 0, _tilesOrder: null, ctor: function (duration, gridSize, seed) {
    cc.GridAction.prototype.ctor.call(this);
    this._tilesOrder = [];
    gridSize !== undefined && this.initWithDuration(duration, gridSize, seed)
}, initWithDuration: function (duration, gridSize, seed) {
    if (cc.TiledGrid3DAction.prototype.initWithDuration.call(this, duration, gridSize)) {
        this._seed = seed || 0;
        this._tilesOrder.length = 0;
        return true
    }
    return false
}, shuffle: function (array, len) {
    for (var i = len - 1; i >=
        0; i--) {
        var j = 0 | cc.rand() % (i + 1);
        var v = array[i];
        array[i] = array[j];
        array[j] = v
    }
}, turnOnTile: function (pos) {
    this.setTile(pos, this.originalTile(pos))
}, turnOffTile: function (pos) {
    this.setTile(pos, new cc.Quad3)
}, startWithTarget: function (target) {
    cc.TiledGrid3DAction.prototype.startWithTarget.call(this, target);
    this._tilesCount = this._gridSize.width * this._gridSize.height;
    var locTilesOrder = this._tilesOrder;
    locTilesOrder.length = 0;
    for (var i = 0; i < this._tilesCount; ++i)locTilesOrder[i] = i;
    this.shuffle(locTilesOrder, this._tilesCount)
},
    update: function (time) {
        var l = 0 | time * this._tilesCount, locGridSize = this._gridSize;
        var t, tilePos = cc.p(0, 0), locTilesOrder = this._tilesOrder;
        for (var i = 0; i < this._tilesCount; i++) {
            t = locTilesOrder[i];
            tilePos.x = 0 | t / locGridSize.height;
            tilePos.y = t % (0 | locGridSize.height);
            if (i < l)this.turnOffTile(tilePos); else this.turnOnTile(tilePos)
        }
    }});
cc.TurnOffTiles.create = function (duration, gridSize, seed) {
    return new cc.TurnOffTiles(duration, gridSize, seed)
};
cc.WavesTiles3D = cc.TiledGrid3DAction.extend({_waves: 0, _amplitude: 0, _amplitudeRate: 0, ctor: function (duration, gridSize, waves, amplitude) {
    cc.GridAction.prototype.ctor.call(this);
    amplitude !== undefined && this.initWithDuration(duration, gridSize, waves, amplitude)
}, getAmplitude: function () {
    return this._amplitude
}, setAmplitude: function (amplitude) {
    this._amplitude = amplitude
}, getAmplitudeRate: function () {
    return this._amplitudeRate
}, setAmplitudeRate: function (amplitudeRate) {
    this._amplitudeRate = amplitudeRate
}, initWithDuration: function (duration, gridSize, waves, amplitude) {
    if (cc.TiledGrid3DAction.prototype.initWithDuration.call(this, duration, gridSize)) {
        this._waves = waves;
        this._amplitude = amplitude;
        this._amplitudeRate = 1;
        return true
    }
    return false
}, update: function (time) {
    var locGridSize = this._gridSize, locWaves = this._waves, locAmplitude = this._amplitude, locAmplitudeRate = this._amplitudeRate;
    var locPos = cc.p(0, 0), coords;
    for (var i = 0; i < locGridSize.width; i++)for (var j = 0; j < locGridSize.height; j++) {
        locPos.x = i;
        locPos.y = j;
        coords = this.originalTile(locPos);
        coords.bl.z =
            Math.sin(time * Math.PI * locWaves * 2 + (coords.bl.y + coords.bl.x) * 0.01) * locAmplitude * locAmplitudeRate;
        coords.br.z = coords.bl.z;
        coords.tl.z = coords.bl.z;
        coords.tr.z = coords.bl.z;
        this.setTile(locPos, coords)
    }
}});
cc.WavesTiles3D.create = function (duration, gridSize, waves, amplitude) {
    return new cc.WavesTiles3D(duration, gridSize, waves, amplitude)
};
cc.JumpTiles3D = cc.TiledGrid3DAction.extend({_jumps: 0, _amplitude: 0, _amplitudeRate: 0, ctor: function (duration, gridSize, numberOfJumps, amplitude) {
    cc.GridAction.prototype.ctor.call(this);
    amplitude !== undefined && this.initWithDuration(duration, gridSize, numberOfJumps, amplitude)
}, getAmplitude: function () {
    return this._amplitude
}, setAmplitude: function (amplitude) {
    this._amplitude = amplitude
}, getAmplitudeRate: function () {
    return this._amplitudeRate
}, setAmplitudeRate: function (amplitudeRate) {
    this._amplitudeRate = amplitudeRate
},
    initWithDuration: function (duration, gridSize, numberOfJumps, amplitude) {
        if (cc.TiledGrid3DAction.prototype.initWithDuration.call(this, duration, gridSize)) {
            this._jumps = numberOfJumps;
            this._amplitude = amplitude;
            this._amplitudeRate = 1;
            return true
        }
        return false
    }, update: function (time) {
        var sinz = Math.sin(Math.PI * time * this._jumps * 2) * this._amplitude * this._amplitudeRate;
        var sinz2 = Math.sin(Math.PI * (time * this._jumps * 2 + 1)) * this._amplitude * this._amplitudeRate;
        var locGridSize = this._gridSize;
        var locGrid = this.target.grid;
        var coords, locPos = cc.p(0, 0);
        for (var i = 0; i < locGridSize.width; i++)for (var j = 0; j < locGridSize.height; j++) {
            locPos.x = i;
            locPos.y = j;
            coords = locGrid.originalTile(locPos);
            if ((i + j) % 2 == 0) {
                coords.bl.z += sinz;
                coords.br.z += sinz;
                coords.tl.z += sinz;
                coords.tr.z += sinz
            } else {
                coords.bl.z += sinz2;
                coords.br.z += sinz2;
                coords.tl.z += sinz2;
                coords.tr.z += sinz2
            }
            locGrid.setTile(locPos, coords)
        }
    }});
cc.JumpTiles3D.create = function (duration, gridSize, numberOfJumps, amplitude) {
    return new cc.JumpTiles3D(duration, gridSize, numberOfJumps, amplitude)
};
cc.SplitRows = cc.TiledGrid3DAction.extend({_rows: 0, _winSize: null, ctor: function (duration, rows) {
    cc.GridAction.prototype.ctor.call(this);
    rows !== undefined && this.initWithDuration(duration, rows)
}, initWithDuration: function (duration, rows) {
    this._rows = rows;
    return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, duration, cc.size(1, rows))
}, update: function (time) {
    var locGridSize = this._gridSize, locWinSizeWidth = this._winSize.width;
    var coords, direction, locPos = cc.p(0, 0);
    for (var j = 0; j < locGridSize.height; ++j) {
        locPos.y =
            j;
        coords = this.originalTile(locPos);
        direction = 1;
        if (j % 2 == 0)direction = -1;
        coords.bl.x += direction * locWinSizeWidth * time;
        coords.br.x += direction * locWinSizeWidth * time;
        coords.tl.x += direction * locWinSizeWidth * time;
        coords.tr.x += direction * locWinSizeWidth * time;
        this.setTile(locPos, coords)
    }
}, startWithTarget: function (target) {
    cc.TiledGrid3DAction.prototype.startWithTarget.call(this, target);
    this._winSize = cc.director.getWinSizeInPixels()
}});
cc.SplitRows.create = function (duration, rows) {
    return new cc.SplitRows(duration, rows)
};
cc.SplitCols = cc.TiledGrid3DAction.extend({_cols: 0, _winSize: null, ctor: function (duration, cols) {
    cc.GridAction.prototype.ctor.call(this);
    cols !== undefined && this.initWithDuration(duration, cols)
}, initWithDuration: function (duration, cols) {
    this._cols = cols;
    return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, duration, cc.size(cols, 1))
}, update: function (time) {
    var locGridSizeWidth = this._gridSize.width, locWinSizeHeight = this._winSize.height;
    var coords, direction, locPos = cc.p(0, 0);
    for (var i = 0; i < locGridSizeWidth; ++i) {
        locPos.x =
            i;
        coords = this.originalTile(locPos);
        direction = 1;
        if (i % 2 == 0)direction = -1;
        coords.bl.y += direction * locWinSizeHeight * time;
        coords.br.y += direction * locWinSizeHeight * time;
        coords.tl.y += direction * locWinSizeHeight * time;
        coords.tr.y += direction * locWinSizeHeight * time;
        this.setTile(locPos, coords)
    }
}, startWithTarget: function (target) {
    cc.TiledGrid3DAction.prototype.startWithTarget.call(this, target);
    this._winSize = cc.director.getWinSizeInPixels()
}});
cc.SplitCols.create = function (duration, cols) {
    return new cc.SplitCols(duration, cols)
};
cc.PageTurn3D = cc.Grid3DAction.extend({update: function (time) {
    var tt = Math.max(0, time - 0.25);
    var deltaAy = tt * tt * 500;
    var ay = -100 - deltaAy;
    var deltaTheta = -Math.PI / 2 * Math.sqrt(time);
    var theta = +Math.PI / 2 + deltaTheta;
    var sinTheta = Math.sin(theta);
    var cosTheta = Math.cos(theta);
    var locGridSize = this._gridSize;
    var locVer = cc.p(0, 0);
    for (var i = 0; i <= locGridSize.width; ++i)for (var j = 0; j <= locGridSize.height; ++j) {
        locVer.x = i;
        locVer.y = j;
        var p = this.originalVertex(locVer);
        var R = Math.sqrt(p.x * p.x + (p.y - ay) * (p.y - ay));
        var r = R * sinTheta;
        var alpha = Math.asin(p.x / R);
        var beta = alpha / sinTheta;
        var cosBeta = Math.cos(beta);
        if (beta <= Math.PI)p.x = r * Math.sin(beta); else p.x = 0;
        p.y = R + ay - r * (1 - cosBeta) * sinTheta;
        p.z = r * (1 - cosBeta) * cosTheta / 7;
        if (p.z < 0.5)p.z = 0.5;
        this.setVertex(locVer, p)
    }
}});
cc.PageTurn3D.create = function (duration, gridSize) {
    return new cc.PageTurn3D(duration, gridSize)
};cc.ProgressTimer = cc.NodeRGBA.extend({_type: null, _percentage: 0, _sprite: null, _midPoint: null, _barChangeRate: null, _reverseDirection: false, _className: "ProgressTimer", getMidpoint: function () {
    return cc.p(this._midPoint.x, this._midPoint.y)
}, setMidpoint: function (mpoint) {
    this._midPoint = cc.pClamp(mpoint, cc.p(0, 0), cc.p(1, 1))
}, getBarChangeRate: function () {
    return cc.p(this._barChangeRate.x, this._barChangeRate.y)
}, setBarChangeRate: function (barChangeRate) {
    this._barChangeRate = cc.pClamp(barChangeRate, cc.p(0, 0), cc.p(1,
        1))
}, getType: function () {
    return this._type
}, getPercentage: function () {
    return this._percentage
}, getSprite: function () {
    return this._sprite
}, setPercentage: function (percentage) {
    if (this._percentage != percentage) {
        this._percentage = cc.clampf(percentage, 0, 100);
        this._updateProgress()
    }
}, setOpacityModifyRGB: function (bValue) {
}, isOpacityModifyRGB: function () {
    return false
}, isReverseDirection: function () {
    return this._reverseDirection
}, _boundaryTexCoord: function (index) {
    if (index < cc.ProgressTimer.TEXTURE_COORDS_COUNT) {
        var locProTextCoords =
            cc.ProgressTimer.TEXTURE_COORDS;
        if (this._reverseDirection)return cc.p(locProTextCoords >> 7 - (index << 1) & 1, locProTextCoords >> 7 - ((index << 1) + 1) & 1); else return cc.p(locProTextCoords >> (index << 1) + 1 & 1, locProTextCoords >> (index << 1) & 1)
    }
    return cc.p(0, 0)
}, _origin: null, _startAngle: 270, _endAngle: 270, _radius: 0, _counterClockWise: false, _barRect: null, _vertexDataCount: 0, _vertexData: null, _vertexArrayBuffer: null, _vertexWebGLBuffer: null, _vertexDataDirty: false, ctor: null, _ctorForCanvas: function () {
    cc.NodeRGBA.prototype.ctor.call(this);
    this._type = cc.ProgressTimer.TYPE_RADIAL;
    this._percentage = 0;
    this._midPoint = cc.p(0, 0);
    this._barChangeRate = cc.p(0, 0);
    this._reverseDirection = false;
    this._sprite = null;
    this._origin = cc.p(0, 0);
    this._startAngle = 270;
    this._endAngle = 270;
    this._radius = 0;
    this._counterClockWise = false;
    this._barRect = cc.rect(0, 0, 0, 0)
}, _ctorForWebGL: function () {
    cc.NodeRGBA.prototype.ctor.call(this);
    this._type = cc.ProgressTimer.TYPE_RADIAL;
    this._percentage = 0;
    this._midPoint = cc.p(0, 0);
    this._barChangeRate = cc.p(0, 0);
    this._reverseDirection = false;
    this._sprite = null;
    this._vertexWebGLBuffer = cc._renderContext.createBuffer();
    this._vertexDataCount = 0;
    this._vertexData = null;
    this._vertexArrayBuffer = null;
    this._vertexDataDirty = false
}, setColor: function (color) {
    this._sprite.color = color;
    this._updateColor()
}, setOpacity: function (opacity) {
    this._sprite.opacity = opacity;
    this._updateColor()
}, getColor: function () {
    return this._sprite.color
}, getOpacity: function () {
    return this._sprite.opacity
}, setReverseProgress: null, _setReverseProgressForCanvas: function (reverse) {
    if (this._reverseDirection !==
        reverse)this._reverseDirection = reverse
}, _setReverseProgressForWebGL: function (reverse) {
    if (this._reverseDirection !== reverse) {
        this._reverseDirection = reverse;
        this._vertexData = null;
        this._vertexArrayBuffer = null;
        this._vertexDataCount = 0
    }
}, setSprite: null, _setSpriteForCanvas: function (sprite) {
    if (this._sprite != sprite) {
        this._sprite = sprite;
        this.width = this._sprite.width;
        this.height = this._sprite.height
    }
}, _setSpriteForWebGL: function (sprite) {
    if (sprite && this._sprite != sprite) {
        this._sprite = sprite;
        this.width = sprite.width;
        this.height = sprite.height;
        if (this._vertexData) {
            this._vertexData = null;
            this._vertexArrayBuffer = null;
            this._vertexDataCount = 0
        }
    }
}, setType: null, _setTypeForCanvas: function (type) {
    if (type !== this._type)this._type = type
}, _setTypeForWebGL: function (type) {
    if (type !== this._type) {
        if (this._vertexData) {
            this._vertexData = null;
            this._vertexArrayBuffer = null;
            this._vertexDataCount = 0
        }
        this._type = type
    }
}, setReverseDirection: null, _setReverseDirectionForCanvas: function (reverse) {
    if (this._reverseDirection !== reverse)this._reverseDirection =
        reverse
}, _setReverseDirectionForWebGL: function (reverse) {
    if (this._reverseDirection !== reverse) {
        this._reverseDirection = reverse;
        this._vertexData = null;
        this._vertexArrayBuffer = null;
        this._vertexDataCount = 0
    }
}, _textureCoordFromAlphaPoint: function (alpha) {
    var locSprite = this._sprite;
    if (!locSprite)return{u: 0, v: 0};
    var quad = locSprite.quad;
    var min = cc.p(quad.bl.texCoords.u, quad.bl.texCoords.v);
    var max = cc.p(quad.tr.texCoords.u, quad.tr.texCoords.v);
    if (locSprite.textureRectRotated) {
        var temp = alpha.x;
        alpha.x = alpha.y;
        alpha.y =
            temp
    }
    return{u: min.x * (1 - alpha.x) + max.x * alpha.x, v: min.y * (1 - alpha.y) + max.y * alpha.y}
}, _vertexFromAlphaPoint: function (alpha) {
    if (!this._sprite)return{x: 0, y: 0};
    var quad = this._sprite.quad;
    var min = cc.p(quad.bl.vertices.x, quad.bl.vertices.y);
    var max = cc.p(quad.tr.vertices.x, quad.tr.vertices.y);
    return{x: min.x * (1 - alpha.x) + max.x * alpha.x, y: min.y * (1 - alpha.y) + max.y * alpha.y}
}, initWithSprite: null, _initWithSpriteForCanvas: function (sprite) {
    this.percentage = 0;
    this.anchorX = 0.5;
    this.anchorY = 0.5;
    this._type = cc.ProgressTimer.TYPE_RADIAL;
    this._reverseDirection = false;
    this.midPoint = cc.p(0.5, 0.5);
    this.barChangeRate = cc.p(1, 1);
    this.sprite = sprite;
    return true
}, _initWithSpriteForWebGL: function (sprite) {
    this.percentage = 0;
    this._vertexData = null;
    this._vertexArrayBuffer = null;
    this._vertexDataCount = 0;
    this.anchorX = 0.5;
    this.anchorY = 0.5;
    this._type = cc.ProgressTimer.TYPE_RADIAL;
    this._reverseDirection = false;
    this.midPoint = cc.p(0.5, 0.5);
    this.barChangeRate = cc.p(1, 1);
    this.sprite = sprite;
    this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
    return true
}, draw: null, _drawForCanvas: function (ctx) {
    var context = ctx || cc._renderContext;
    var locSprite = this._sprite;
    if (locSprite._isLighterMode)context.globalCompositeOperation = "lighter";
    var locEGL_ScaleX = cc.view.getScaleX(), locEGL_ScaleY = cc.view.getScaleY();
    context.globalAlpha = locSprite._displayedOpacity / 255;
    var locRect = locSprite._rect, locContentSize = locSprite._contentSize, locOffsetPosition = locSprite._offsetPosition, locDrawSizeCanvas = locSprite._drawSize_Canvas;
    var flipXOffset = 0 | locOffsetPosition.x,
        flipYOffset = -locOffsetPosition.y - locRect.height, locTextureCoord = locSprite._textureRect_Canvas;
    locDrawSizeCanvas.width = locRect.width * locEGL_ScaleX;
    locDrawSizeCanvas.height = locRect.height * locEGL_ScaleY;
    context.save();
    if (locSprite._flippedX) {
        flipXOffset = -locOffsetPosition.x - locRect.width;
        context.scale(-1, 1)
    }
    if (locSprite._flippedY) {
        flipYOffset = locOffsetPosition.y;
        context.scale(1, -1)
    }
    flipXOffset *= locEGL_ScaleX;
    flipYOffset *= locEGL_ScaleY;
    if (this._type == cc.ProgressTimer.TYPE_BAR) {
        var locBarRect = this._barRect;
        context.beginPath();
        context.rect(locBarRect.x * locEGL_ScaleX, locBarRect.y * locEGL_ScaleY, locBarRect.width * locEGL_ScaleX, locBarRect.height * locEGL_ScaleY);
        context.clip();
        context.closePath()
    } else if (this._type == cc.ProgressTimer.TYPE_RADIAL) {
        var locOriginX = this._origin.x * locEGL_ScaleX;
        var locOriginY = this._origin.y * locEGL_ScaleY;
        context.beginPath();
        context.arc(locOriginX, locOriginY, this._radius * locEGL_ScaleY, Math.PI / 180 * this._startAngle, Math.PI / 180 * this._endAngle, this._counterClockWise);
        context.lineTo(locOriginX,
            locOriginY);
        context.clip();
        context.closePath()
    }
    if (locSprite._texture && locTextureCoord.validRect) {
        var image = locSprite._texture.getHtmlElementObj();
        if (this._colorized)context.drawImage(image, 0, 0, locTextureCoord.width, locTextureCoord.height, flipXOffset, flipYOffset, locDrawSizeCanvas.width, locDrawSizeCanvas.height); else context.drawImage(image, locTextureCoord.x, locTextureCoord.y, locTextureCoord.width, locTextureCoord.height, flipXOffset, flipYOffset, locDrawSizeCanvas.width, locDrawSizeCanvas.height)
    } else if (locContentSize.width !==
        0) {
        var curColor = this.color;
        context.fillStyle = "rgba(" + curColor.r + "," + curColor.g + "," + curColor.b + ",1)";
        context.fillRect(flipXOffset, flipYOffset, locContentSize.width * locEGL_ScaleX, locContentSize.height * locEGL_ScaleY)
    }
    context.restore();
    cc.incrementGLDraws(1)
}, _drawForWebGL: function (ctx) {
    var context = ctx || cc._renderContext;
    if (!this._vertexData || !this._sprite)return;
    cc.nodeDrawSetup(this);
    var blendFunc = this._sprite.getBlendFunc();
    cc.glBlendFunc(blendFunc.src, blendFunc.dst);
    cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
    cc.glBindTexture2D(this._sprite.texture);
    context.bindBuffer(context.ARRAY_BUFFER, this._vertexWebGLBuffer);
    if (this._vertexDataDirty) {
        context.bufferData(context.ARRAY_BUFFER, this._vertexArrayBuffer, context.DYNAMIC_DRAW);
        this._vertexDataDirty = false
    }
    var locVertexDataLen = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
    context.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, context.FLOAT, false, locVertexDataLen, 0);
    context.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, context.UNSIGNED_BYTE, true, locVertexDataLen, 8);
    context.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS,
        2, context.FLOAT, false, locVertexDataLen, 12);
    if (this._type === cc.ProgressTimer.TYPE_RADIAL)context.drawArrays(context.TRIANGLE_FAN, 0, this._vertexDataCount); else if (this._type == cc.ProgressTimer.TYPE_BAR)if (!this._reverseDirection)context.drawArrays(context.TRIANGLE_STRIP, 0, this._vertexDataCount); else {
        context.drawArrays(context.TRIANGLE_STRIP, 0, this._vertexDataCount / 2);
        context.drawArrays(context.TRIANGLE_STRIP, 4, this._vertexDataCount / 2);
        cc.g_NumberOfDraws++
    }
    cc.g_NumberOfDraws++
}, _updateRadial: function () {
    if (!this._sprite)return;
    var i, locMidPoint = this._midPoint;
    var alpha = this._percentage / 100;
    var angle = 2 * cc.PI * (this._reverseDirection ? alpha : 1 - alpha);
    var topMid = cc.p(locMidPoint.x, 1);
    var percentagePt = cc.pRotateByAngle(topMid, locMidPoint, angle);
    var index = 0;
    var hit;
    if (alpha == 0) {
        hit = topMid;
        index = 0
    } else if (alpha == 1) {
        hit = topMid;
        index = 4
    } else {
        var min_t = cc.FLT_MAX;
        var locProTextCoordsCount = cc.ProgressTimer.TEXTURE_COORDS_COUNT;
        for (i = 0; i <= locProTextCoordsCount; ++i) {
            var pIndex = (i + (locProTextCoordsCount - 1)) % locProTextCoordsCount;
            var edgePtA =
                this._boundaryTexCoord(i % locProTextCoordsCount);
            var edgePtB = this._boundaryTexCoord(pIndex);
            if (i == 0)edgePtB = cc.pLerp(edgePtA, edgePtB, 1 - locMidPoint.x); else if (i == 4)edgePtA = cc.pLerp(edgePtA, edgePtB, 1 - locMidPoint.x);
            var retPoint = cc.p(0, 0);
            if (cc.pLineIntersect(edgePtA, edgePtB, locMidPoint, percentagePt, retPoint)) {
                if (i == 0 || i == 4)if (!(0 <= retPoint.x && retPoint.x <= 1))continue;
                if (retPoint.y >= 0)if (retPoint.y < min_t) {
                    min_t = retPoint.y;
                    index = i
                }
            }
        }
        hit = cc.pAdd(locMidPoint, cc.pMult(cc.pSub(percentagePt, locMidPoint), min_t))
    }
    var sameIndexCount =
        true;
    if (this._vertexDataCount != index + 3) {
        sameIndexCount = false;
        this._vertexData = null;
        this._vertexArrayBuffer = null;
        this._vertexDataCount = 0
    }
    if (!this._vertexData) {
        this._vertexDataCount = index + 3;
        var locCount = this._vertexDataCount, vertexDataLen = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
        this._vertexArrayBuffer = new ArrayBuffer(locCount * vertexDataLen);
        var locData = [];
        for (i = 0; i < locCount; i++)locData[i] = new cc.V2F_C4B_T2F(null, null, null, this._vertexArrayBuffer, i * vertexDataLen);
        this._vertexData = locData;
        if (!this._vertexData) {
            cc.log("cc.ProgressTimer._updateRadial() : Not enough memory");
            return
        }
    }
    this._updateColor();
    var locVertexData = this._vertexData;
    if (!sameIndexCount) {
        locVertexData[0].texCoords = this._textureCoordFromAlphaPoint(locMidPoint);
        locVertexData[0].vertices = this._vertexFromAlphaPoint(locMidPoint);
        locVertexData[1].texCoords = this._textureCoordFromAlphaPoint(topMid);
        locVertexData[1].vertices = this._vertexFromAlphaPoint(topMid);
        for (i = 0; i < index; i++) {
            var alphaPoint = this._boundaryTexCoord(i);
            locVertexData[i + 2].texCoords = this._textureCoordFromAlphaPoint(alphaPoint);
            locVertexData[i +
                2].vertices = this._vertexFromAlphaPoint(alphaPoint)
        }
    }
    locVertexData[this._vertexDataCount - 1].texCoords = this._textureCoordFromAlphaPoint(hit);
    locVertexData[this._vertexDataCount - 1].vertices = this._vertexFromAlphaPoint(hit)
}, _updateBar: function () {
    if (!this._sprite)return;
    var i;
    var alpha = this._percentage / 100;
    var locBarChangeRate = this._barChangeRate;
    var alphaOffset = cc.pMult(cc.p(1 - locBarChangeRate.x + alpha * locBarChangeRate.x, 1 - locBarChangeRate.y + alpha * locBarChangeRate.y), 0.5);
    var min = cc.pSub(this._midPoint,
        alphaOffset);
    var max = cc.pAdd(this._midPoint, alphaOffset);
    if (min.x < 0) {
        max.x += -min.x;
        min.x = 0
    }
    if (max.x > 1) {
        min.x -= max.x - 1;
        max.x = 1
    }
    if (min.y < 0) {
        max.y += -min.y;
        min.y = 0
    }
    if (max.y > 1) {
        min.y -= max.y - 1;
        max.y = 1
    }
    var locVertexData;
    if (!this._reverseDirection) {
        if (!this._vertexData) {
            this._vertexDataCount = 4;
            var vertexDataLen = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT, locCount = 4;
            this._vertexArrayBuffer = new ArrayBuffer(locCount * vertexDataLen);
            this._vertexData = [];
            for (i = 0; i < locCount; i++)this._vertexData[i] = new cc.V2F_C4B_T2F(null, null,
                null, this._vertexArrayBuffer, i * vertexDataLen)
        }
        locVertexData = this._vertexData;
        locVertexData[0].texCoords = this._textureCoordFromAlphaPoint(cc.p(min.x, max.y));
        locVertexData[0].vertices = this._vertexFromAlphaPoint(cc.p(min.x, max.y));
        locVertexData[1].texCoords = this._textureCoordFromAlphaPoint(cc.p(min.x, min.y));
        locVertexData[1].vertices = this._vertexFromAlphaPoint(cc.p(min.x, min.y));
        locVertexData[2].texCoords = this._textureCoordFromAlphaPoint(cc.p(max.x, max.y));
        locVertexData[2].vertices = this._vertexFromAlphaPoint(cc.p(max.x,
            max.y));
        locVertexData[3].texCoords = this._textureCoordFromAlphaPoint(cc.p(max.x, min.y));
        locVertexData[3].vertices = this._vertexFromAlphaPoint(cc.p(max.x, min.y))
    } else {
        if (!this._vertexData) {
            this._vertexDataCount = 8;
            var rVertexDataLen = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT, rLocCount = 8;
            this._vertexArrayBuffer = new ArrayBuffer(rLocCount * rVertexDataLen);
            var rTempData = [];
            for (i = 0; i < rLocCount; i++)rTempData[i] = new cc.V2F_C4B_T2F(null, null, null, this._vertexArrayBuffer, i * rVertexDataLen);
            rTempData[0].texCoords = this._textureCoordFromAlphaPoint(cc.p(0,
                1));
            rTempData[0].vertices = this._vertexFromAlphaPoint(cc.p(0, 1));
            rTempData[1].texCoords = this._textureCoordFromAlphaPoint(cc.p(0, 0));
            rTempData[1].vertices = this._vertexFromAlphaPoint(cc.p(0, 0));
            rTempData[6].texCoords = this._textureCoordFromAlphaPoint(cc.p(1, 1));
            rTempData[6].vertices = this._vertexFromAlphaPoint(cc.p(1, 1));
            rTempData[7].texCoords = this._textureCoordFromAlphaPoint(cc.p(1, 0));
            rTempData[7].vertices = this._vertexFromAlphaPoint(cc.p(1, 0));
            this._vertexData = rTempData
        }
        locVertexData = this._vertexData;
        locVertexData[2].texCoords = this._textureCoordFromAlphaPoint(cc.p(min.x, max.y));
        locVertexData[2].vertices = this._vertexFromAlphaPoint(cc.p(min.x, max.y));
        locVertexData[3].texCoords = this._textureCoordFromAlphaPoint(cc.p(min.x, min.y));
        locVertexData[3].vertices = this._vertexFromAlphaPoint(cc.p(min.x, min.y));
        locVertexData[4].texCoords = this._textureCoordFromAlphaPoint(cc.p(max.x, max.y));
        locVertexData[4].vertices = this._vertexFromAlphaPoint(cc.p(max.x, max.y));
        locVertexData[5].texCoords = this._textureCoordFromAlphaPoint(cc.p(max.x,
            min.y));
        locVertexData[5].vertices = this._vertexFromAlphaPoint(cc.p(max.x, min.y))
    }
    this._updateColor()
}, _updateColor: function () {
    if (!this._sprite || !this._vertexData)return;
    var sc = this._sprite.quad.tl.colors;
    var locVertexData = this._vertexData;
    for (var i = 0, len = this._vertexDataCount; i < len; ++i)locVertexData[i].colors = sc;
    this._vertexDataDirty = true
}, _updateProgress: null, _updateProgressForCanvas: function () {
    var locSprite = this._sprite;
    var sw = locSprite.width, sh = locSprite.height;
    var locMidPoint = this._midPoint;
    if (this._type ==
        cc.ProgressTimer.TYPE_RADIAL) {
        this._radius = Math.round(Math.sqrt(sw * sw + sh * sh));
        var locStartAngle, locEndAngle, locCounterClockWise = false, locOrigin = this._origin;
        locOrigin.x = sw * locMidPoint.x;
        locOrigin.y = -sh * locMidPoint.y;
        if (this._reverseDirection) {
            locEndAngle = 270;
            locStartAngle = 270 - 3.6 * this._percentage
        } else {
            locStartAngle = -90;
            locEndAngle = -90 + 3.6 * this._percentage
        }
        if (locSprite._flippedX) {
            locOrigin.x -= sw * this._midPoint.x * 2;
            locStartAngle = -locStartAngle;
            locEndAngle = -locEndAngle;
            locStartAngle -= 180;
            locEndAngle -=
                180;
            locCounterClockWise = !locCounterClockWise
        }
        if (locSprite._flippedY) {
            locOrigin.y += sh * this._midPoint.y * 2;
            locCounterClockWise = !locCounterClockWise;
            locStartAngle = -locStartAngle;
            locEndAngle = -locEndAngle
        }
        this._startAngle = locStartAngle;
        this._endAngle = locEndAngle;
        this._counterClockWise = locCounterClockWise
    } else {
        var locBarChangeRate = this._barChangeRate;
        var percentageF = this._percentage / 100;
        var locBarRect = this._barRect;
        var drawedSize = cc.size(sw * (1 - locBarChangeRate.x), sh * (1 - locBarChangeRate.y));
        var drawingSize =
            cc.size((sw - drawedSize.width) * percentageF, (sh - drawedSize.height) * percentageF);
        var currentDrawSize = cc.size(drawedSize.width + drawingSize.width, drawedSize.height + drawingSize.height);
        var startPoint = cc.p(sw * locMidPoint.x, sh * locMidPoint.y);
        var needToLeft = startPoint.x - currentDrawSize.width / 2;
        if (locMidPoint.x > 0.5)if (currentDrawSize.width / 2 >= sw - startPoint.x)needToLeft = sw - currentDrawSize.width;
        var needToTop = startPoint.y - currentDrawSize.height / 2;
        if (locMidPoint.y > 0.5)if (currentDrawSize.height / 2 >= sh - startPoint.y)needToTop =
            sh - currentDrawSize.height;
        locBarRect.x = 0;
        var flipXNeed = 1;
        if (locSprite._flippedX) {
            locBarRect.x -= currentDrawSize.width;
            flipXNeed = -1
        }
        if (needToLeft > 0)locBarRect.x += needToLeft * flipXNeed;
        locBarRect.y = 0;
        var flipYNeed = 1;
        if (locSprite._flippedY) {
            locBarRect.y += currentDrawSize.height;
            flipYNeed = -1
        }
        if (needToTop > 0)locBarRect.y -= needToTop * flipYNeed;
        locBarRect.width = currentDrawSize.width;
        locBarRect.height = -currentDrawSize.height
    }
}, _updateProgressForWebGL: function () {
    var locType = this._type;
    if (locType === cc.ProgressTimer.TYPE_RADIAL)this._updateRadial();
    else if (locType === cc.ProgressTimer.TYPE_BAR)this._updateBar();
    this._vertexDataDirty = true
}});
var _p = cc.ProgressTimer.prototype;
if (cc._renderType == cc._RENDER_TYPE_WEBGL) {
    _p.ctor = _p._ctorForWebGL;
    _p.setReverseProgress = _p._setReverseProgressForWebGL;
    _p.setSprite = _p._setSpriteForWebGL;
    _p.setType = _p._setTypeForWebGL;
    _p.setReverseDirection = _p._setReverseDirectionForWebGL;
    _p.initWithSprite = _p._initWithSpriteForWebGL;
    _p.draw = _p._drawForWebGL;
    _p._updateProgress = _p._updateProgressForWebGL
} else {
    _p.ctor = _p._ctorForCanvas;
    _p.setReverseProgress = _p._setReverseProgressForCanvas;
    _p.setSprite = _p._setSpriteForCanvas;
    _p.setType = _p._setTypeForCanvas;
    _p.setReverseDirection = _p._setReverseDirectionForCanvas;
    _p.initWithSprite = _p._initWithSpriteForCanvas;
    _p.draw = _p._drawForCanvas;
    _p._updateProgress = cc.ProgressTimer.prototype._updateProgressForCanvas
}
_p.midPoint;
cc.defineGetterSetter(_p, "midPoint", _p.getMidpoint, _p.setMidpoint);
_p.barChangeRate;
cc.defineGetterSetter(_p, "barChangeRate", _p.getBarChangeRate, _p.setBarChangeRate);
_p.type;
cc.defineGetterSetter(_p, "type", _p.getType, _p.setType);
_p.percentage;
cc.defineGetterSetter(_p, "percentage", _p.getPercentage, _p.setPercentage);
_p.sprite;
cc.defineGetterSetter(_p, "sprite", _p.getSprite, _p.setSprite);
_p.reverseDir;
cc.defineGetterSetter(_p, "reverseDir", _p.isReverseDirection, _p.setReverseDirection);
cc.ProgressTimer.create = function (sprite) {
    var progressTimer = new cc.ProgressTimer;
    if (progressTimer.initWithSprite(sprite))return progressTimer;
    return null
};
cc.ProgressTimer.TEXTURE_COORDS_COUNT = 4;
cc.ProgressTimer.TEXTURE_COORDS = 75;
cc.ProgressTimer.TYPE_RADIAL = 0;
cc.ProgressTimer.TYPE_BAR = 1;
cc.ProgressTo = cc.ActionInterval.extend({_to: 0, _from: 0, ctor: function (duration, percent) {
    cc.ActionInterval.prototype.ctor.call(this);
    this._to = 0;
    this._from = 0;
    percent !== undefined && this.initWithDuration(duration, percent)
}, initWithDuration: function (duration, percent) {
    if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
        this._to = percent;
        return true
    }
    return false
}, clone: function () {
    var action = new cc.ProgressTo;
    action.initWithDuration(this._duration, this._to);
    return action
}, reverse: function () {
    cc.log("cc.ProgressTo.reverse(): reverse hasn't been supported.");
    return null
}, startWithTarget: function (target) {
    cc.ActionInterval.prototype.startWithTarget.call(this, target);
    this._from = target.percentage;
    if (this._from == 100)this._from = 0
}, update: function (time) {
    if (this.target instanceof cc.ProgressTimer)this.target.percentage = this._from + (this._to - this._from) * time
}});
cc.ProgressTo.create = function (duration, percent) {
    return new cc.ProgressTo(duration, percent)
};
cc.ProgressFromTo = cc.ActionInterval.extend({_to: 0, _from: 0, ctor: function (duration, fromPercentage, toPercentage) {
    cc.ActionInterval.prototype.ctor.call(this);
    this._to = 0;
    this._from = 0;
    toPercentage !== undefined && this.initWithDuration(duration, fromPercentage, toPercentage)
}, initWithDuration: function (duration, fromPercentage, toPercentage) {
    if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
        this._to = toPercentage;
        this._from = fromPercentage;
        return true
    }
    return false
}, clone: function () {
    var action = new cc.ProgressFromTo;
    action.initWithDuration(this._duration, this._from, this._to);
    return action
}, reverse: function () {
    return cc.ProgressFromTo.create(this._duration, this._to, this._from)
}, startWithTarget: function (target) {
    cc.ActionInterval.prototype.startWithTarget.call(this, target)
}, update: function (time) {
    if (this.target instanceof cc.ProgressTimer)this.target.percentage = this._from + (this._to - this._from) * time
}});
cc.ProgressFromTo.create = function (duration, fromPercentage, toPercentage) {
    return new cc.ProgressFromTo(duration, fromPercentage, toPercentage)
};cc.SCENE_FADE = 4208917214;
cc.TransitionEaseScene = cc.Class.extend({easeActionWithAction: function () {
}});
cc.TRANSITION_ORIENTATION_LEFT_OVER = 0;
cc.TRANSITION_ORIENTATION_RIGHT_OVER = 1;
cc.TRANSITION_ORIENTATION_UP_OVER = 0;
cc.TRANSITION_ORIENTATION_DOWN_OVER = 1;
cc.TransitionScene = cc.Scene.extend({_inScene: null, _outScene: null, _duration: null, _isInSceneOnTop: false, _isSendCleanupToScene: false, _className: "TransitionScene", ctor: function (t, scene) {
    cc.Scene.prototype.ctor.call(this);
    if (t !== undefined && scene !== undefined)this.initWithDuration(t, scene)
}, _setNewScene: function (dt) {
    this.unschedule(this._setNewScene);
    var director = cc.director;
    this._isSendCleanupToScene = director.isSendCleanupToScene();
    director.runScene(this._inScene);
    cc.eventManager.setEnabled(true);
    this._outScene.visible =
        true
}, _sceneOrder: function () {
    this._isInSceneOnTop = true
}, draw: function () {
    if (this._isInSceneOnTop) {
        this._outScene.visit();
        this._inScene.visit()
    } else {
        this._inScene.visit();
        this._outScene.visit()
    }
}, onEnter: function () {
    cc.Node.prototype.onEnter.call(this);
    cc.eventManager.setEnabled(false);
    this._outScene.onExitTransitionDidStart();
    this._inScene.onEnter()
}, onExit: function () {
    cc.Node.prototype.onExit.call(this);
    cc.eventManager.setEnabled(true);
    this._outScene.onExit();
    this._inScene.onEnterTransitionDidFinish()
},
    cleanup: function () {
        cc.Node.prototype.cleanup.call(this);
        if (this._isSendCleanupToScene)this._outScene.cleanup()
    }, initWithDuration: function (t, scene) {
        if (!scene)throw"cc.TransitionScene.initWithDuration(): Argument scene must be non-nil";
        if (this.init()) {
            this._duration = t;
            this.attr({x: 0, y: 0, anchorX: 0, anchorY: 0});
            this._inScene = scene;
            this._outScene = cc.director.getRunningScene();
            if (!this._outScene) {
                this._outScene = cc.Scene.create();
                this._outScene.init()
            }
            if (this._inScene == this._outScene)throw"cc.TransitionScene.initWithDuration(): Incoming scene must be different from the outgoing scene";
            this._sceneOrder();
            return true
        } else return false
    }, finish: function () {
        this._inScene.attr({visible: true, x: 0, y: 0, scale: 1, rotation: 0});
        if (cc._renderType === cc._RENDER_TYPE_WEBGL)this._inScene.getCamera().restore();
        this._outScene.attr({visible: false, x: 0, y: 0, scale: 1, rotation: 0});
        if (cc._renderType === cc._RENDER_TYPE_WEBGL)this._outScene.getCamera().restore();
        this.schedule(this._setNewScene, 0)
    }, hideOutShowIn: function () {
        this._inScene.visible = true;
        this._outScene.visible = false
    }});
cc.TransitionScene.create = function (t, scene) {
    return new cc.TransitionScene(t, scene)
};
cc.TransitionSceneOriented = cc.TransitionScene.extend({_orientation: 0, initWithDuration: function (t, scene, orientation) {
    if (cc.TransitionScene.prototype.initWithDuration.call(this, t, scene))this._orientation = orientation;
    return true
}});
cc.TransitionSceneOriented.create = function (t, scene, orientation) {
    var tempScene = new cc.TransitionSceneOriented;
    tempScene.initWithDuration(t, scene, orientation);
    return tempScene
};
cc.TransitionRotoZoom = cc.TransitionScene.extend({onEnter: function () {
    cc.TransitionScene.prototype.onEnter.call(this);
    this._inScene.attr({scale: 0.001, anchorX: 0.5, anchorY: 0.5});
    this._outScene.attr({scale: 1, anchorX: 0.5, anchorY: 0.5});
    var rotoZoom = cc.Sequence.create(cc.Spawn.create(cc.ScaleBy.create(this._duration / 2, 0.001), cc.RotateBy.create(this._duration / 2, 360 * 2)), cc.DelayTime.create(this._duration / 2));
    this._outScene.runAction(rotoZoom);
    this._inScene.runAction(cc.Sequence.create(rotoZoom.reverse(), cc.CallFunc.create(this.finish,
        this)))
}});
cc.TransitionRotoZoom.create = function (t, scene) {
    var tempScene = new cc.TransitionRotoZoom;
    if (tempScene != null && tempScene.initWithDuration(t, scene))return tempScene;
    return null
};
cc.TransitionJumpZoom = cc.TransitionScene.extend({onEnter: function () {
    cc.TransitionScene.prototype.onEnter.call(this);
    var winSize = cc.director.getWinSize();
    this._inScene.attr({scale: 0.5, x: winSize.width, y: 0, anchorX: 0.5, anchorY: 0.5});
    this._outScene.anchorX = 0.5;
    this._outScene.anchorY = 0.5;
    var jump = cc.JumpBy.create(this._duration / 4, cc.p(-winSize.width, 0), winSize.width / 4, 2);
    var scaleIn = cc.ScaleTo.create(this._duration / 4, 1);
    var scaleOut = cc.ScaleTo.create(this._duration / 4, 0.5);
    var jumpZoomOut = cc.Sequence.create(scaleOut,
        jump);
    var jumpZoomIn = cc.Sequence.create(jump, scaleIn);
    var delay = cc.DelayTime.create(this._duration / 2);
    this._outScene.runAction(jumpZoomOut);
    this._inScene.runAction(cc.Sequence.create(delay, jumpZoomIn, cc.CallFunc.create(this.finish, this)))
}});
cc.TransitionJumpZoom.create = function (t, scene) {
    var tempScene = new cc.TransitionJumpZoom;
    if (tempScene != null && tempScene.initWithDuration(t, scene))return tempScene;
    return null
};
cc.TransitionMoveInL = cc.TransitionScene.extend({onEnter: function () {
    cc.TransitionScene.prototype.onEnter.call(this);
    this.initScenes();
    var action = this.action();
    this._inScene.runAction(cc.Sequence.create(this.easeActionWithAction(action), cc.CallFunc.create(this.finish, this)))
}, initScenes: function () {
    this._inScene.setPosition(-cc.director.getWinSize().width, 0)
}, action: function () {
    return cc.MoveTo.create(this._duration, cc.p(0, 0))
}, easeActionWithAction: function (action) {
    return cc.EaseOut.create(action, 2)
}});
cc.TransitionMoveInL.create = function (t, scene) {
    var tempScene = new cc.TransitionMoveInL;
    if (tempScene != null && tempScene.initWithDuration(t, scene))return tempScene;
    return null
};
cc.TransitionMoveInR = cc.TransitionMoveInL.extend({initScenes: function () {
    this._inScene.setPosition(cc.director.getWinSize().width, 0)
}});
cc.TransitionMoveInR.create = function (t, scene) {
    var tempScene = new cc.TransitionMoveInR;
    if (tempScene != null && tempScene.initWithDuration(t, scene))return tempScene;
    return null
};
cc.TransitionMoveInT = cc.TransitionMoveInL.extend({initScenes: function () {
    this._inScene.setPosition(0, cc.director.getWinSize().height)
}});
cc.TransitionMoveInT.create = function (t, scene) {
    var tempScene = new cc.TransitionMoveInT;
    if (tempScene != null && tempScene.initWithDuration(t, scene))return tempScene;
    return null
};
cc.TransitionMoveInB = cc.TransitionMoveInL.extend({initScenes: function () {
    this._inScene.setPosition(0, -cc.director.getWinSize().height)
}});
cc.TransitionMoveInB.create = function (t, scene) {
    var tempScene = new cc.TransitionMoveInB;
    if (tempScene != null && tempScene.initWithDuration(t, scene))return tempScene;
    return null
};
cc.ADJUST_FACTOR = 0.5;
cc.TransitionSlideInL = cc.TransitionScene.extend({_sceneOrder: function () {
    this._isInSceneOnTop = false
}, onEnter: function () {
    cc.TransitionScene.prototype.onEnter.call(this);
    this.initScenes();
    var inA = this.action();
    var outA = this.action();
    var inAction = this.easeActionWithAction(inA);
    var outAction = cc.Sequence.create(this.easeActionWithAction(outA), cc.CallFunc.create(this.finish, this));
    this._inScene.runAction(inAction);
    this._outScene.runAction(outAction)
}, initScenes: function () {
    this._inScene.setPosition(-cc.director.getWinSize().width +
        cc.ADJUST_FACTOR, 0)
}, action: function () {
    return cc.MoveBy.create(this._duration, cc.p(cc.director.getWinSize().width - cc.ADJUST_FACTOR, 0))
}, easeActionWithAction: function (action) {
    return cc.EaseOut.create(action, 2)
}});
cc.TransitionSlideInL.create = function (t, scene) {
    var tempScene = new cc.TransitionSlideInL;
    if (tempScene != null && tempScene.initWithDuration(t, scene))return tempScene;
    return null
};
cc.TransitionSlideInR = cc.TransitionSlideInL.extend({_sceneOrder: function () {
    this._isInSceneOnTop = true
}, initScenes: function () {
    this._inScene.setPosition(cc.director.getWinSize().width - cc.ADJUST_FACTOR, 0)
}, action: function () {
    return cc.MoveBy.create(this._duration, cc.p(-(cc.director.getWinSize().width - cc.ADJUST_FACTOR), 0))
}});
cc.TransitionSlideInR.create = function (t, scene) {
    var tempScene = new cc.TransitionSlideInR;
    if (tempScene != null && tempScene.initWithDuration(t, scene))return tempScene;
    return null
};
cc.TransitionSlideInB = cc.TransitionSlideInL.extend({_sceneOrder: function () {
    this._isInSceneOnTop = false
}, initScenes: function () {
    this._inScene.setPosition(0, cc.director.getWinSize().height - cc.ADJUST_FACTOR)
}, action: function () {
    return cc.MoveBy.create(this._duration, cc.p(0, -(cc.director.getWinSize().height - cc.ADJUST_FACTOR)))
}});
cc.TransitionSlideInB.create = function (t, scene) {
    var tempScene = new cc.TransitionSlideInB;
    if (tempScene != null && tempScene.initWithDuration(t, scene))return tempScene;
    return null
};
cc.TransitionSlideInT = cc.TransitionSlideInL.extend({_sceneOrder: function () {
    this._isInSceneOnTop = true
}, initScenes: function () {
    this._inScene.setPosition(0, -(cc.director.getWinSize().height - cc.ADJUST_FACTOR))
}, action: function () {
    return cc.MoveBy.create(this._duration, cc.p(0, cc.director.getWinSize().height - cc.ADJUST_FACTOR))
}});
cc.TransitionSlideInT.create = function (t, scene) {
    var tempScene = new cc.TransitionSlideInT;
    if (tempScene != null && tempScene.initWithDuration(t, scene))return tempScene;
    return null
};
cc.TransitionShrinkGrow = cc.TransitionScene.extend({onEnter: function () {
    cc.TransitionScene.prototype.onEnter.call(this);
    this._inScene.attr({scale: 0.001, anchorX: 2 / 3, anchorY: 0.5});
    this._outScene.attr({scale: 1, anchorX: 1 / 3, anchorY: 0.5});
    var scaleOut = cc.ScaleTo.create(this._duration, 0.01);
    var scaleIn = cc.ScaleTo.create(this._duration, 1);
    this._inScene.runAction(this.easeActionWithAction(scaleIn));
    this._outScene.runAction(cc.Sequence.create(this.easeActionWithAction(scaleOut), cc.CallFunc.create(this.finish,
        this)))
}, easeActionWithAction: function (action) {
    return cc.EaseOut.create(action, 2)
}});
cc.TransitionShrinkGrow.create = function (t, scene) {
    var tempScene = new cc.TransitionShrinkGrow;
    if (tempScene != null && tempScene.initWithDuration(t, scene))return tempScene;
    return null
};
cc.TransitionFlipX = cc.TransitionSceneOriented.extend({onEnter: function () {
    cc.TransitionScene.prototype.onEnter.call(this);
    var inA, outA;
    this._inScene.visible = false;
    var inDeltaZ, inAngleZ, outDeltaZ, outAngleZ;
    if (this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER) {
        inDeltaZ = 90;
        inAngleZ = 270;
        outDeltaZ = 90;
        outAngleZ = 0
    } else {
        inDeltaZ = -90;
        inAngleZ = 90;
        outDeltaZ = -90;
        outAngleZ = 0
    }
    inA = cc.Sequence.create(cc.DelayTime.create(this._duration / 2), cc.Show.create(), cc.OrbitCamera.create(this._duration / 2, 1, 0, inAngleZ,
        inDeltaZ, 0, 0), cc.CallFunc.create(this.finish, this));
    outA = cc.Sequence.create(cc.OrbitCamera.create(this._duration / 2, 1, 0, outAngleZ, outDeltaZ, 0, 0), cc.Hide.create(), cc.DelayTime.create(this._duration / 2));
    this._inScene.runAction(inA);
    this._outScene.runAction(outA)
}});
cc.TransitionFlipX.create = function (t, scene, o) {
    if (o == null)o = cc.TRANSITION_ORIENTATION_RIGHT_OVER;
    var tempScene = new cc.TransitionFlipX;
    tempScene.initWithDuration(t, scene, o);
    return tempScene
};
cc.TransitionFlipY = cc.TransitionSceneOriented.extend({onEnter: function () {
    cc.TransitionScene.prototype.onEnter.call(this);
    var inA, outA;
    this._inScene.visible = false;
    var inDeltaZ, inAngleZ, outDeltaZ, outAngleZ;
    if (this._orientation == cc.TRANSITION_ORIENTATION_UP_OVER) {
        inDeltaZ = 90;
        inAngleZ = 270;
        outDeltaZ = 90;
        outAngleZ = 0
    } else {
        inDeltaZ = -90;
        inAngleZ = 90;
        outDeltaZ = -90;
        outAngleZ = 0
    }
    inA = cc.Sequence.create(cc.DelayTime.create(this._duration / 2), cc.Show.create(), cc.OrbitCamera.create(this._duration / 2, 1, 0, inAngleZ, inDeltaZ,
        90, 0), cc.CallFunc.create(this.finish, this));
    outA = cc.Sequence.create(cc.OrbitCamera.create(this._duration / 2, 1, 0, outAngleZ, outDeltaZ, 90, 0), cc.Hide.create(), cc.DelayTime.create(this._duration / 2));
    this._inScene.runAction(inA);
    this._outScene.runAction(outA)
}});
cc.TransitionFlipY.create = function (t, scene, o) {
    if (o == null)o = cc.TRANSITION_ORIENTATION_UP_OVER;
    var tempScene = new cc.TransitionFlipY;
    tempScene.initWithDuration(t, scene, o);
    return tempScene
};
cc.TransitionFlipAngular = cc.TransitionSceneOriented.extend({onEnter: function () {
    cc.TransitionScene.prototype.onEnter.call(this);
    var inA, outA;
    this._inScene.visible = false;
    var inDeltaZ, inAngleZ, outDeltaZ, outAngleZ;
    if (this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER) {
        inDeltaZ = 90;
        inAngleZ = 270;
        outDeltaZ = 90;
        outAngleZ = 0
    } else {
        inDeltaZ = -90;
        inAngleZ = 90;
        outDeltaZ = -90;
        outAngleZ = 0
    }
    inA = cc.Sequence.create(cc.DelayTime.create(this._duration / 2), cc.Show.create(), cc.OrbitCamera.create(this._duration / 2, 1, 0, inAngleZ,
        inDeltaZ, -45, 0), cc.CallFunc.create(this.finish, this));
    outA = cc.Sequence.create(cc.OrbitCamera.create(this._duration / 2, 1, 0, outAngleZ, outDeltaZ, 45, 0), cc.Hide.create(), cc.DelayTime.create(this._duration / 2));
    this._inScene.runAction(inA);
    this._outScene.runAction(outA)
}});
cc.TransitionFlipAngular.create = function (t, scene, o) {
    if (o == null)o = cc.TRANSITION_ORIENTATION_RIGHT_OVER;
    var tempScene = new cc.TransitionFlipAngular;
    tempScene.initWithDuration(t, scene, o);
    return tempScene
};
cc.TransitionZoomFlipX = cc.TransitionSceneOriented.extend({onEnter: function () {
    cc.TransitionScene.prototype.onEnter.call(this);
    var inA, outA;
    this._inScene.visible = false;
    var inDeltaZ, inAngleZ, outDeltaZ, outAngleZ;
    if (this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER) {
        inDeltaZ = 90;
        inAngleZ = 270;
        outDeltaZ = 90;
        outAngleZ = 0
    } else {
        inDeltaZ = -90;
        inAngleZ = 90;
        outDeltaZ = -90;
        outAngleZ = 0
    }
    inA = cc.Sequence.create(cc.DelayTime.create(this._duration / 2), cc.Spawn.create(cc.OrbitCamera.create(this._duration / 2, 1, 0, inAngleZ,
        inDeltaZ, 0, 0), cc.ScaleTo.create(this._duration / 2, 1), cc.Show.create()), cc.CallFunc.create(this.finish, this));
    outA = cc.Sequence.create(cc.Spawn.create(cc.OrbitCamera.create(this._duration / 2, 1, 0, outAngleZ, outDeltaZ, 0, 0), cc.ScaleTo.create(this._duration / 2, 0.5)), cc.Hide.create(), cc.DelayTime.create(this._duration / 2));
    this._inScene.scale = 0.5;
    this._inScene.runAction(inA);
    this._outScene.runAction(outA)
}});
cc.TransitionZoomFlipX.create = function (t, scene, o) {
    if (o == null)o = cc.TRANSITION_ORIENTATION_RIGHT_OVER;
    var tempScene = new cc.TransitionZoomFlipX;
    tempScene.initWithDuration(t, scene, o);
    return tempScene
};
cc.TransitionZoomFlipY = cc.TransitionSceneOriented.extend({onEnter: function () {
    cc.TransitionScene.prototype.onEnter.call(this);
    var inA, outA;
    this._inScene.visible = false;
    var inDeltaZ, inAngleZ, outDeltaZ, outAngleZ;
    if (this._orientation === cc.TRANSITION_ORIENTATION_UP_OVER) {
        inDeltaZ = 90;
        inAngleZ = 270;
        outDeltaZ = 90;
        outAngleZ = 0
    } else {
        inDeltaZ = -90;
        inAngleZ = 90;
        outDeltaZ = -90;
        outAngleZ = 0
    }
    inA = cc.Sequence.create(cc.DelayTime.create(this._duration / 2), cc.Spawn.create(cc.OrbitCamera.create(this._duration / 2, 1, 0, inAngleZ,
        inDeltaZ, 90, 0), cc.ScaleTo.create(this._duration / 2, 1), cc.Show.create()), cc.CallFunc.create(this.finish, this));
    outA = cc.Sequence.create(cc.Spawn.create(cc.OrbitCamera.create(this._duration / 2, 1, 0, outAngleZ, outDeltaZ, 90, 0), cc.ScaleTo.create(this._duration / 2, 0.5)), cc.Hide.create(), cc.DelayTime.create(this._duration / 2));
    this._inScene.scale = 0.5;
    this._inScene.runAction(inA);
    this._outScene.runAction(outA)
}});
cc.TransitionZoomFlipY.create = function (t, scene, o) {
    if (o == null)o = cc.TRANSITION_ORIENTATION_UP_OVER;
    var tempScene = new cc.TransitionZoomFlipY;
    tempScene.initWithDuration(t, scene, o);
    return tempScene
};
cc.TransitionZoomFlipAngular = cc.TransitionSceneOriented.extend({onEnter: function () {
    cc.TransitionScene.prototype.onEnter.call(this);
    var inA, outA;
    this._inScene.visible = false;
    var inDeltaZ, inAngleZ, outDeltaZ, outAngleZ;
    if (this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER) {
        inDeltaZ = 90;
        inAngleZ = 270;
        outDeltaZ = 90;
        outAngleZ = 0
    } else {
        inDeltaZ = -90;
        inAngleZ = 90;
        outDeltaZ = -90;
        outAngleZ = 0
    }
    inA = cc.Sequence.create(cc.DelayTime.create(this._duration / 2), cc.Spawn.create(cc.OrbitCamera.create(this._duration / 2, 1, 0,
        inAngleZ, inDeltaZ, -45, 0), cc.ScaleTo.create(this._duration / 2, 1), cc.Show.create()), cc.Show.create(), cc.CallFunc.create(this.finish, this));
    outA = cc.Sequence.create(cc.Spawn.create(cc.OrbitCamera.create(this._duration / 2, 1, 0, outAngleZ, outDeltaZ, 45, 0), cc.ScaleTo.create(this._duration / 2, 0.5)), cc.Hide.create(), cc.DelayTime.create(this._duration / 2));
    this._inScene.scale = 0.5;
    this._inScene.runAction(inA);
    this._outScene.runAction(outA)
}});
cc.TransitionZoomFlipAngular.create = function (t, scene, o) {
    if (o == null)o = cc.TRANSITION_ORIENTATION_RIGHT_OVER;
    var tempScene = new cc.TransitionZoomFlipAngular;
    tempScene.initWithDuration(t, scene, o);
    return tempScene
};
cc.TransitionFade = cc.TransitionScene.extend({_color: null, ctor: function () {
    cc.TransitionScene.prototype.ctor.call(this);
    this._color = cc.color()
}, onEnter: function () {
    cc.TransitionScene.prototype.onEnter.call(this);
    var l = cc.LayerColor.create(this._color);
    this._inScene.visible = false;
    this.addChild(l, 2, cc.SCENE_FADE);
    var f = this.getChildByTag(cc.SCENE_FADE);
    var a = cc.Sequence.create(cc.FadeIn.create(this._duration / 2), cc.CallFunc.create(this.hideOutShowIn, this), cc.FadeOut.create(this._duration / 2), cc.CallFunc.create(this.finish,
        this));
    f.runAction(a)
}, onExit: function () {
    cc.TransitionScene.prototype.onExit.call(this);
    this.removeChildByTag(cc.SCENE_FADE, false)
}, initWithDuration: function (t, scene, color) {
    color = color || cc.color.BLACK;
    if (cc.TransitionScene.prototype.initWithDuration.call(this, t, scene)) {
        this._color.r = color.r;
        this._color.g = color.g;
        this._color.b = color.b;
        this._color.a = 0
    }
    return true
}});
cc.TransitionFade.create = function (t, scene, color) {
    var transition = new cc.TransitionFade;
    transition.initWithDuration(t, scene, color);
    return transition
};
cc.TransitionCrossFade = cc.TransitionScene.extend({onEnter: function () {
    cc.TransitionScene.prototype.onEnter.call(this);
    var color = cc.color(0, 0, 0, 0);
    var winSize = cc.director.getWinSize();
    var layer = cc.LayerColor.create(color);
    var inTexture = cc.RenderTexture.create(winSize.width, winSize.height);
    if (null == inTexture)return;
    inTexture.sprite.anchorX = 0.5;
    inTexture.sprite.anchorY = 0.5;
    inTexture.attr({x: winSize.width / 2, y: winSize.height / 2, anchorX: 0.5, anchorY: 0.5});
    inTexture.begin();
    this._inScene.visit();
    inTexture.end();
    var outTexture = cc.RenderTexture.create(winSize.width, winSize.height);
    outTexture.setPosition(winSize.width / 2, winSize.height / 2);
    outTexture.sprite.anchorX = outTexture.anchorX = 0.5;
    outTexture.sprite.anchorY = outTexture.anchorY = 0.5;
    outTexture.begin();
    this._outScene.visit();
    outTexture.end();
    inTexture.sprite.setBlendFunc(cc.ONE, cc.ONE);
    outTexture.sprite.setBlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA);
    layer.addChild(inTexture);
    layer.addChild(outTexture);
    inTexture.sprite.opacity = 255;
    outTexture.sprite.opacity =
        255;
    var layerAction = cc.Sequence.create(cc.FadeTo.create(this._duration, 0), cc.CallFunc.create(this.hideOutShowIn, this), cc.CallFunc.create(this.finish, this));
    outTexture.sprite.runAction(layerAction);
    this.addChild(layer, 2, cc.SCENE_FADE)
}, onExit: function () {
    this.removeChildByTag(cc.SCENE_FADE, false);
    cc.TransitionScene.prototype.onExit.call(this)
}, draw: function () {
}});
cc.TransitionCrossFade.create = function (t, scene) {
    var Transition = new cc.TransitionCrossFade;
    Transition.initWithDuration(t, scene);
    return Transition
};
cc.TransitionTurnOffTiles = cc.TransitionScene.extend({_sceneOrder: function () {
    this._isInSceneOnTop = false
}, onEnter: function () {
    cc.TransitionScene.prototype.onEnter.call(this);
    var winSize = cc.director.getWinSize();
    var aspect = winSize.width / winSize.height;
    var x = 0 | 12 * aspect;
    var y = 12;
    var toff = cc.TurnOffTiles.create(this._duration, cc.size(x, y));
    var action = this.easeActionWithAction(toff);
    this._outScene.runAction(cc.Sequence.create(action, cc.CallFunc.create(this.finish, this), cc.StopGrid.create()))
}, easeActionWithAction: function (action) {
    return action
}});
cc.TransitionTurnOffTiles.create = function (t, scene) {
    var tempScene = new cc.TransitionTurnOffTiles;
    if (tempScene != null && tempScene.initWithDuration(t, scene))return tempScene;
    return null
};
cc.TransitionSplitCols = cc.TransitionScene.extend({onEnter: function () {
    cc.TransitionScene.prototype.onEnter.call(this);
    this._inScene.visible = false;
    var split = this.action();
    var seq = cc.Sequence.create(split, cc.CallFunc.create(this.hideOutShowIn, this), split.reverse());
    this.runAction(cc.Sequence.create(this.easeActionWithAction(seq), cc.CallFunc.create(this.finish, this), cc.StopGrid.create()))
}, easeActionWithAction: function (action) {
    return cc.EaseInOut.create(action, 3)
}, action: function () {
    return cc.SplitCols.create(this._duration /
        2, 3)
}});
cc.TransitionSplitCols.create = function (t, scene) {
    var tempScene = new cc.TransitionSplitCols;
    if (tempScene != null && tempScene.initWithDuration(t, scene))return tempScene;
    return null
};
cc.TransitionSplitRows = cc.TransitionSplitCols.extend({action: function () {
    return cc.SplitRows.create(this._duration / 2, 3)
}});
cc.TransitionSplitRows.create = function (t, scene) {
    var tempScene = new cc.TransitionSplitRows;
    if (tempScene != null && tempScene.initWithDuration(t, scene))return tempScene;
    return null
};
cc.TransitionFadeTR = cc.TransitionScene.extend({_sceneOrder: function () {
    this._isInSceneOnTop = false
}, onEnter: function () {
    cc.TransitionScene.prototype.onEnter.call(this);
    var winSize = cc.director.getWinSize();
    var aspect = winSize.width / winSize.height;
    var x = 0 | 12 * aspect;
    var y = 12;
    var action = this.actionWithSize(cc.size(x, y));
    this._outScene.runAction(cc.Sequence.create(this.easeActionWithAction(action), cc.CallFunc.create(this.finish, this), cc.StopGrid.create()))
}, easeActionWithAction: function (action) {
    return action
},
    actionWithSize: function (size) {
        return cc.FadeOutTRTiles.create(this._duration, size)
    }});
cc.TransitionFadeTR.create = function (t, scene) {
    var tempScene = new cc.TransitionFadeTR;
    if (tempScene != null && tempScene.initWithDuration(t, scene))return tempScene;
    return null
};
cc.TransitionFadeBL = cc.TransitionFadeTR.extend({actionWithSize: function (size) {
    return cc.FadeOutBLTiles.create(this._duration, size)
}});
cc.TransitionFadeBL.create = function (t, scene) {
    var tempScene = new cc.TransitionFadeBL;
    if (tempScene != null && tempScene.initWithDuration(t, scene))return tempScene;
    return null
};
cc.TransitionFadeUp = cc.TransitionFadeTR.extend({actionWithSize: function (size) {
    return cc.FadeOutUpTiles.create(this._duration, size)
}});
cc.TransitionFadeUp.create = function (t, scene) {
    var tempScene = new cc.TransitionFadeUp;
    if (tempScene != null && tempScene.initWithDuration(t, scene))return tempScene;
    return null
};
cc.TransitionFadeDown = cc.TransitionFadeTR.extend({actionWithSize: function (size) {
    return cc.FadeOutDownTiles.create(this._duration, size)
}});
cc.TransitionFadeDown.create = function (t, scene) {
    var tempScene = new cc.TransitionFadeDown;
    if (tempScene != null && tempScene.initWithDuration(t, scene))return tempScene;
    return null
};
cc.SCENE_RADIAL = 49153;
cc.TransitionProgress = cc.TransitionScene.extend({_to: 0, _from: 0, _sceneToBeModified: null, _className: "TransitionProgress", _setAttrs: function (node, x, y) {
    node.attr({x: x, y: y, anchorX: 0.5, anchorY: 0.5})
}, onEnter: function () {
    cc.TransitionScene.prototype.onEnter.call(this);
    this._setupTransition();
    var winSize = cc.director.getWinSize();
    var texture = cc.RenderTexture.create(winSize.width, winSize.height);
    texture.sprite.anchorX = 0.5;
    texture.sprite.anchorY = 0.5;
    this._setAttrs(texture, winSize.width / 2, winSize.height / 2);
    texture.clear(0,
        0, 0, 1);
    texture.begin();
    this._sceneToBeModified.visit();
    texture.end();
    if (this._sceneToBeModified == this._outScene)this.hideOutShowIn();
    var pNode = this._progressTimerNodeWithRenderTexture(texture);
    var layerAction = cc.Sequence.create(cc.ProgressFromTo.create(this._duration, this._from, this._to), cc.CallFunc.create(this.finish, this));
    pNode.runAction(layerAction);
    this.addChild(pNode, 2, cc.SCENE_RADIAL)
}, onExit: function () {
    this.removeChildByTag(cc.SCENE_RADIAL, true);
    cc.TransitionScene.prototype.onExit.call(this)
},
    _setupTransition: function () {
        this._sceneToBeModified = this._outScene;
        this._from = 100;
        this._to = 0
    }, _progressTimerNodeWithRenderTexture: function (texture) {
        cc.log("cc.TransitionProgress._progressTimerNodeWithRenderTexture(): should be overridden in subclass");
        return null
    }, _sceneOrder: function () {
        this._isInSceneOnTop = false
    }});
cc.TransitionProgress.create = function (t, scene) {
    var tempScene = new cc.TransitionProgress;
    if (tempScene != null && tempScene.initWithDuration(t, scene))return tempScene;
    return null
};
cc.TransitionProgressRadialCCW = cc.TransitionProgress.extend({_progressTimerNodeWithRenderTexture: function (texture) {
    var size = cc.director.getWinSize();
    var pNode = cc.ProgressTimer.create(texture.sprite);
    if (cc._renderType === cc._RENDER_TYPE_WEBGL)pNode.sprite.flippedY = true;
    pNode.type = cc.ProgressTimer.TYPE_RADIAL;
    pNode.reverseDir = false;
    pNode.percentage = 100;
    this._setAttrs(pNode, size.width / 2, size.height / 2);
    return pNode
}});
cc.TransitionProgressRadialCCW.create = function (t, scene) {
    var tempScene = new cc.TransitionProgressRadialCCW;
    if (tempScene != null && tempScene.initWithDuration(t, scene))return tempScene;
    return null
};
cc.TransitionProgressRadialCW = cc.TransitionProgress.extend({_progressTimerNodeWithRenderTexture: function (texture) {
    var size = cc.director.getWinSize();
    var pNode = cc.ProgressTimer.create(texture.sprite);
    if (cc._renderType === cc._RENDER_TYPE_WEBGL)pNode.sprite.flippedY = true;
    pNode.type = cc.ProgressTimer.TYPE_RADIAL;
    pNode.reverseDir = true;
    pNode.percentage = 100;
    this._setAttrs(pNode, size.width / 2, size.height / 2);
    return pNode
}});
cc.TransitionProgressRadialCW.create = function (t, scene) {
    var tempScene = new cc.TransitionProgressRadialCW;
    if (tempScene != null && tempScene.initWithDuration(t, scene))return tempScene;
    return null
};
cc.TransitionProgressHorizontal = cc.TransitionProgress.extend({_progressTimerNodeWithRenderTexture: function (texture) {
    var size = cc.director.getWinSize();
    var pNode = cc.ProgressTimer.create(texture.sprite);
    if (cc._renderType === cc._RENDER_TYPE_WEBGL)pNode.sprite.flippedY = true;
    pNode.type = cc.ProgressTimer.TYPE_BAR;
    pNode.midPoint = cc.p(1, 0);
    pNode.barChangeRate = cc.p(1, 0);
    pNode.percentage = 100;
    this._setAttrs(pNode, size.width / 2, size.height / 2);
    return pNode
}});
cc.TransitionProgressHorizontal.create = function (t, scene) {
    var tempScene = new cc.TransitionProgressHorizontal;
    if (tempScene != null && tempScene.initWithDuration(t, scene))return tempScene;
    return null
};
cc.TransitionProgressVertical = cc.TransitionProgress.extend({_progressTimerNodeWithRenderTexture: function (texture) {
    var size = cc.director.getWinSize();
    var pNode = cc.ProgressTimer.create(texture.sprite);
    if (cc._renderType === cc._RENDER_TYPE_WEBGL)pNode.sprite.flippedY = true;
    pNode.type = cc.ProgressTimer.TYPE_BAR;
    pNode.midPoint = cc.p(0, 0);
    pNode.barChangeRate = cc.p(0, 1);
    pNode.percentage = 100;
    this._setAttrs(pNode, size.width / 2, size.height / 2);
    return pNode
}});
cc.TransitionProgressVertical.create = function (t, scene) {
    var tempScene = new cc.TransitionProgressVertical;
    if (tempScene != null && tempScene.initWithDuration(t, scene))return tempScene;
    return null
};
cc.TransitionProgressInOut = cc.TransitionProgress.extend({_progressTimerNodeWithRenderTexture: function (texture) {
    var size = cc.director.getWinSize();
    var pNode = cc.ProgressTimer.create(texture.sprite);
    if (cc._renderType === cc._RENDER_TYPE_WEBGL)pNode.sprite.flippedY = true;
    pNode.type = cc.ProgressTimer.TYPE_BAR;
    pNode.midPoint = cc.p(0.5, 0.5);
    pNode.barChangeRate = cc.p(1, 1);
    pNode.percentage = 0;
    this._setAttrs(pNode, size.width / 2, size.height / 2);
    return pNode
}, _sceneOrder: function () {
    this._isInSceneOnTop = false
}, _setupTransition: function () {
    this._sceneToBeModified =
        this._inScene;
    this._from = 0;
    this._to = 100
}});
cc.TransitionProgressInOut.create = function (t, scene) {
    var tempScene = new cc.TransitionProgressInOut;
    if (tempScene != null && tempScene.initWithDuration(t, scene))return tempScene;
    return null
};
cc.TransitionProgressOutIn = cc.TransitionProgress.extend({_progressTimerNodeWithRenderTexture: function (texture) {
    var size = cc.director.getWinSize();
    var pNode = cc.ProgressTimer.create(texture.sprite);
    if (cc._renderType === cc._RENDER_TYPE_WEBGL)pNode.sprite.flippedY = true;
    pNode.type = cc.ProgressTimer.TYPE_BAR;
    pNode.midPoint = cc.p(0.5, 0.5);
    pNode.barChangeRate = cc.p(1, 1);
    pNode.percentage = 100;
    this._setAttrs(pNode, size.width / 2, size.height / 2);
    return pNode
}});
cc.TransitionProgressOutIn.create = function (t, scene) {
    var tempScene = new cc.TransitionProgressOutIn;
    if (tempScene != null && tempScene.initWithDuration(t, scene))return tempScene;
    return null
};
cc.TransitionPageTurn = cc.TransitionScene.extend({_back: true, _className: "TransitionPageTurn", initWithDuration: function (t, scene, backwards) {
    this._back = backwards;
    if (cc.TransitionScene.prototype.initWithDuration.call(this, t, scene));
    return true
}, actionWithSize: function (vector) {
    if (this._back)return cc.ReverseTime.create(cc.PageTurn3D.create(this._duration, vector)); else return cc.PageTurn3D.create(this._duration, vector)
}, onEnter: function () {
    cc.TransitionScene.prototype.onEnter.call(this);
    var winSize = cc.director.getWinSize();
    var x, y;
    if (winSize.width > winSize.height) {
        x = 16;
        y = 12
    } else {
        x = 12;
        y = 16
    }
    var action = this.actionWithSize(cc.size(x, y));
    if (!this._back)this._outScene.runAction(cc.Sequence.create(action, cc.CallFunc.create(this.finish, this), cc.StopGrid.create())); else {
        this._inScene.visible = false;
        this._inScene.runAction(cc.Sequence.create(cc.Show.create(), action, cc.CallFunc.create(this.finish, this), cc.StopGrid.create()))
    }
}, _sceneOrder: function () {
    this._isInSceneOnTop = this._back
}});
cc.TransitionPageTurn.create = function (t, scene, backwards) {
    var transition = new cc.TransitionPageTurn;
    transition.initWithDuration(t, scene, backwards);
    return transition
};cc.Codec = {name: "Jacob__Codec"};
cc.unzip = function () {
    return cc.Codec.GZip.gunzip.apply(cc.Codec.GZip, arguments)
};
cc.unzipBase64 = function () {
    var tmpInput = cc.Codec.Base64.decode.apply(cc.Codec.Base64, arguments);
    return cc.Codec.GZip.gunzip.apply(cc.Codec.GZip, [tmpInput])
};
cc.unzipBase64AsArray = function (input, bytes) {
    bytes = bytes || 1;
    var dec = this.unzipBase64(input), ar = [], i, j, len;
    for (i = 0, len = dec.length / bytes; i < len; i++) {
        ar[i] = 0;
        for (j = bytes - 1; j >= 0; --j)ar[i] += dec.charCodeAt(i * bytes + j) << j * 8
    }
    return ar
};
cc.unzipAsArray = function (input, bytes) {
    bytes = bytes || 1;
    var dec = this.unzip(input), ar = [], i, j, len;
    for (i = 0, len = dec.length / bytes; i < len; i++) {
        ar[i] = 0;
        for (j = bytes - 1; j >= 0; --j)ar[i] += dec.charCodeAt(i * bytes + j) << j * 8
    }
    return ar
};
cc.StringToArray = function (input) {
    var tmp = input.split(","), ar = [], i;
    for (i = 0; i < tmp.length; i++)ar.push(parseInt(tmp[i]));
    return ar
};
cc.Codec.Base64 = {name: "Jacob__Codec__Base64"};
cc.Codec.Base64._keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\x3d";
cc.Codec.Base64.decode = function Jacob__Codec__Base64__decode(input) {
    var output = [], chr1, chr2, chr3, enc1, enc2, enc3, enc4, i = 0;
    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
    while (i < input.length) {
        enc1 = this._keyStr.indexOf(input.charAt(i++));
        enc2 = this._keyStr.indexOf(input.charAt(i++));
        enc3 = this._keyStr.indexOf(input.charAt(i++));
        enc4 = this._keyStr.indexOf(input.charAt(i++));
        chr1 = enc1 << 2 | enc2 >> 4;
        chr2 = (enc2 & 15) << 4 | enc3 >> 2;
        chr3 = (enc3 & 3) << 6 | enc4;
        output.push(String.fromCharCode(chr1));
        if (enc3 != 64)output.push(String.fromCharCode(chr2));
        if (enc4 != 64)output.push(String.fromCharCode(chr3))
    }
    output = output.join("");
    return output
};
cc.Codec.Base64.decodeAsArray = function Jacob__Codec__Base64___decodeAsArray(input, bytes) {
    var dec = this.decode(input), ar = [], i, j, len;
    for (i = 0, len = dec.length / bytes; i < len; i++) {
        ar[i] = 0;
        for (j = bytes - 1; j >= 0; --j)ar[i] += dec.charCodeAt(i * bytes + j) << j * 8
    }
    return ar
};
cc.uint8ArrayToUint32Array = function (uint8Arr) {
    if (uint8Arr.length % 4 != 0)return null;
    var arrLen = uint8Arr.length / 4;
    var retArr = window.Uint32Array ? new Uint32Array(arrLen) : [];
    for (var i = 0; i < arrLen; i++) {
        var offset = i * 4;
        retArr[i] = uint8Arr[offset] + uint8Arr[offset + 1] * (1 << 8) + uint8Arr[offset + 2] * (1 << 16) + uint8Arr[offset + 3] * (1 << 24)
    }
    return retArr
};
cc.Codec.GZip = function Jacob__GZip(data) {
    this.data = data;
    this.debug = false;
    this.gpflags = undefined;
    this.files = 0;
    this.unzipped = [];
    this.buf32k = new Array(32768);
    this.bIdx = 0;
    this.modeZIP = false;
    this.bytepos = 0;
    this.bb = 1;
    this.bits = 0;
    this.nameBuf = [];
    this.fileout = undefined;
    this.literalTree = new Array(cc.Codec.GZip.LITERALS);
    this.distanceTree = new Array(32);
    this.treepos = 0;
    this.Places = null;
    this.len = 0;
    this.fpos = new Array(17);
    this.fpos[0] = 0;
    this.flens = undefined;
    this.fmax = undefined
};
cc.Codec.GZip.gunzip = function (string) {
    if (string.constructor === Array); else if (string.constructor === String);
    var gzip = new cc.Codec.GZip(string);
    return gzip.gunzip()[0][0]
};
cc.Codec.GZip.HufNode = function () {
    this.b0 = 0;
    this.b1 = 0;
    this.jump = null;
    this.jumppos = -1
};
cc.Codec.GZip.LITERALS = 288;
cc.Codec.GZip.NAMEMAX = 256;
cc.Codec.GZip.bitReverse = [0, 128, 64, 192, 32, 160, 96, 224, 16, 144, 80, 208, 48, 176, 112, 240, 8, 136, 72, 200, 40, 168, 104, 232, 24, 152, 88, 216, 56, 184, 120, 248, 4, 132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52, 180, 116, 244, 12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, 226, 18, 146, 82, 210, 50, 178, 114, 242, 10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250, 6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246, 14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254, 1, 129, 65, 193, 33, 161,
    97, 225, 17, 145, 81, 209, 49, 177, 113, 241, 9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249, 5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245, 13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253, 3, 131, 67, 195, 35, 163, 99, 227, 19, 147, 83, 211, 51, 179, 115, 243, 11, 139, 75, 203, 43, 171, 107, 235, 27, 155, 91, 219, 59, 187, 123, 251, 7, 135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247, 15, 143, 79, 207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127, 255];
cc.Codec.GZip.cplens = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];
cc.Codec.GZip.cplext = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99];
cc.Codec.GZip.cpdist = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
cc.Codec.GZip.cpdext = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
cc.Codec.GZip.border = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
cc.Codec.GZip.prototype.gunzip = function () {
    this.outputArr = [];
    this.nextFile();
    return this.unzipped
};
cc.Codec.GZip.prototype.readByte = function () {
    this.bits += 8;
    if (this.bytepos < this.data.length)return this.data.charCodeAt(this.bytepos++); else return-1
};
cc.Codec.GZip.prototype.byteAlign = function () {
    this.bb = 1
};
cc.Codec.GZip.prototype.readBit = function () {
    var carry;
    this.bits++;
    carry = this.bb & 1;
    this.bb >>= 1;
    if (this.bb == 0) {
        this.bb = this.readByte();
        carry = this.bb & 1;
        this.bb = this.bb >> 1 | 128
    }
    return carry
};
cc.Codec.GZip.prototype.readBits = function (a) {
    var res = 0, i = a;
    while (i--)res = res << 1 | this.readBit();
    if (a)res = cc.Codec.GZip.bitReverse[res] >> 8 - a;
    return res
};
cc.Codec.GZip.prototype.flushBuffer = function () {
    this.bIdx = 0
};
cc.Codec.GZip.prototype.addBuffer = function (a) {
    this.buf32k[this.bIdx++] = a;
    this.outputArr.push(String.fromCharCode(a));
    if (this.bIdx == 32768)this.bIdx = 0
};
cc.Codec.GZip.prototype.IsPat = function () {
    while (1) {
        if (this.fpos[this.len] >= this.fmax)return-1;
        if (this.flens[this.fpos[this.len]] == this.len)return this.fpos[this.len]++;
        this.fpos[this.len]++
    }
};
cc.Codec.GZip.prototype.Rec = function () {
    var curplace = this.Places[this.treepos];
    var tmp;
    if (this.len == 17)return-1;
    this.treepos++;
    this.len++;
    tmp = this.IsPat();
    if (tmp >= 0)curplace.b0 = tmp; else {
        curplace.b0 = 32768;
        if (this.Rec())return-1
    }
    tmp = this.IsPat();
    if (tmp >= 0) {
        curplace.b1 = tmp;
        curplace.jump = null
    } else {
        curplace.b1 = 32768;
        curplace.jump = this.Places[this.treepos];
        curplace.jumppos = this.treepos;
        if (this.Rec())return-1
    }
    this.len--;
    return 0
};
cc.Codec.GZip.prototype.CreateTree = function (currentTree, numval, lengths, show) {
    var i;
    this.Places = currentTree;
    this.treepos = 0;
    this.flens = lengths;
    this.fmax = numval;
    for (i = 0; i < 17; i++)this.fpos[i] = 0;
    this.len = 0;
    if (this.Rec())return-1;
    return 0
};
cc.Codec.GZip.prototype.DecodeValue = function (currentTree) {
    var len, i, xtreepos = 0, X = currentTree[xtreepos], b;
    while (1) {
        b = this.readBit();
        if (b) {
            if (!(X.b1 & 32768))return X.b1;
            X = X.jump;
            len = currentTree.length;
            for (i = 0; i < len; i++)if (currentTree[i] === X) {
                xtreepos = i;
                break
            }
        } else {
            if (!(X.b0 & 32768))return X.b0;
            xtreepos++;
            X = currentTree[xtreepos]
        }
    }
    return-1
};
cc.Codec.GZip.prototype.DeflateLoop = function () {
    var last, c, type, i, len;
    do {
        last = this.readBit();
        type = this.readBits(2);
        if (type == 0) {
            var blockLen, cSum;
            this.byteAlign();
            blockLen = this.readByte();
            blockLen |= this.readByte() << 8;
            cSum = this.readByte();
            cSum |= this.readByte() << 8;
            if ((blockLen ^ ~cSum) & 65535)document.write("BlockLen checksum mismatch\n");
            while (blockLen--) {
                c = this.readByte();
                this.addBuffer(c)
            }
        } else if (type == 1) {
            var j;
            while (1) {
                j = cc.Codec.GZip.bitReverse[this.readBits(7)] >> 1;
                if (j > 23) {
                    j = j << 1 | this.readBit();
                    if (j >
                        199) {
                        j -= 128;
                        j = j << 1 | this.readBit()
                    } else {
                        j -= 48;
                        if (j > 143)j = j + 136
                    }
                } else j += 256;
                if (j < 256)this.addBuffer(j); else if (j == 256)break; else {
                    var len, dist;
                    j -= 256 + 1;
                    len = this.readBits(cc.Codec.GZip.cplext[j]) + cc.Codec.GZip.cplens[j];
                    j = cc.Codec.GZip.bitReverse[this.readBits(5)] >> 3;
                    if (cc.Codec.GZip.cpdext[j] > 8) {
                        dist = this.readBits(8);
                        dist |= this.readBits(cc.Codec.GZip.cpdext[j] - 8) << 8
                    } else dist = this.readBits(cc.Codec.GZip.cpdext[j]);
                    dist += cc.Codec.GZip.cpdist[j];
                    for (j = 0; j < len; j++) {
                        var c = this.buf32k[this.bIdx - dist & 32767];
                        this.addBuffer(c)
                    }
                }
            }
        } else if (type == 2) {
            var j, n, literalCodes, distCodes, lenCodes;
            var ll = new Array(288 + 32);
            literalCodes = 257 + this.readBits(5);
            distCodes = 1 + this.readBits(5);
            lenCodes = 4 + this.readBits(4);
            for (j = 0; j < 19; j++)ll[j] = 0;
            for (j = 0; j < lenCodes; j++)ll[cc.Codec.GZip.border[j]] = this.readBits(3);
            len = this.distanceTree.length;
            for (i = 0; i < len; i++)this.distanceTree[i] = new cc.Codec.GZip.HufNode;
            if (this.CreateTree(this.distanceTree, 19, ll, 0)) {
                this.flushBuffer();
                return 1
            }
            n = literalCodes + distCodes;
            i = 0;
            var z = -1;
            while (i <
                n) {
                z++;
                j = this.DecodeValue(this.distanceTree);
                if (j < 16)ll[i++] = j; else if (j == 16) {
                    var l;
                    j = 3 + this.readBits(2);
                    if (i + j > n) {
                        this.flushBuffer();
                        return 1
                    }
                    l = i ? ll[i - 1] : 0;
                    while (j--)ll[i++] = l
                } else {
                    if (j == 17)j = 3 + this.readBits(3); else j = 11 + this.readBits(7);
                    if (i + j > n) {
                        this.flushBuffer();
                        return 1
                    }
                    while (j--)ll[i++] = 0
                }
            }
            len = this.literalTree.length;
            for (i = 0; i < len; i++)this.literalTree[i] = new cc.Codec.GZip.HufNode;
            if (this.CreateTree(this.literalTree, literalCodes, ll, 0)) {
                this.flushBuffer();
                return 1
            }
            len = this.literalTree.length;
            for (i = 0; i < len; i++)this.distanceTree[i] = new cc.Codec.GZip.HufNode;
            var ll2 = new Array;
            for (i = literalCodes; i < ll.length; i++)ll2[i - literalCodes] = ll[i];
            if (this.CreateTree(this.distanceTree, distCodes, ll2, 0)) {
                this.flushBuffer();
                return 1
            }
            while (1) {
                j = this.DecodeValue(this.literalTree);
                if (j >= 256) {
                    var len, dist;
                    j -= 256;
                    if (j == 0)break;
                    j--;
                    len = this.readBits(cc.Codec.GZip.cplext[j]) + cc.Codec.GZip.cplens[j];
                    j = this.DecodeValue(this.distanceTree);
                    if (cc.Codec.GZip.cpdext[j] > 8) {
                        dist = this.readBits(8);
                        dist |= this.readBits(cc.Codec.GZip.cpdext[j] -
                            8) << 8
                    } else dist = this.readBits(cc.Codec.GZip.cpdext[j]);
                    dist += cc.Codec.GZip.cpdist[j];
                    while (len--) {
                        var c = this.buf32k[this.bIdx - dist & 32767];
                        this.addBuffer(c)
                    }
                } else this.addBuffer(j)
            }
        }
    } while (!last);
    this.flushBuffer();
    this.byteAlign();
    return 0
};
cc.Codec.GZip.prototype.unzipFile = function (name) {
    var i;
    this.gunzip();
    for (i = 0; i < this.unzipped.length; i++)if (this.unzipped[i][1] == name)return this.unzipped[i][0]
};
cc.Codec.GZip.prototype.nextFile = function () {
    this.outputArr = [];
    this.modeZIP = false;
    var tmp = [];
    tmp[0] = this.readByte();
    tmp[1] = this.readByte();
    if (tmp[0] == 120 && tmp[1] == 218) {
        this.DeflateLoop();
        this.unzipped[this.files] = [this.outputArr.join(""), "geonext.gxt"];
        this.files++
    }
    if (tmp[0] == 31 && tmp[1] == 139) {
        this.skipdir();
        this.unzipped[this.files] = [this.outputArr.join(""), "file"];
        this.files++
    }
    if (tmp[0] == 80 && tmp[1] == 75) {
        this.modeZIP = true;
        tmp[2] = this.readByte();
        tmp[3] = this.readByte();
        if (tmp[2] == 3 && tmp[3] == 4) {
            tmp[0] =
                this.readByte();
            tmp[1] = this.readByte();
            this.gpflags = this.readByte();
            this.gpflags |= this.readByte() << 8;
            var method = this.readByte();
            method |= this.readByte() << 8;
            this.readByte();
            this.readByte();
            this.readByte();
            this.readByte();
            var compSize = this.readByte();
            compSize |= this.readByte() << 8;
            compSize |= this.readByte() << 16;
            compSize |= this.readByte() << 24;
            var size = this.readByte();
            size |= this.readByte() << 8;
            size |= this.readByte() << 16;
            size |= this.readByte() << 24;
            var filelen = this.readByte();
            filelen |= this.readByte() << 8;
            var extralen =
                this.readByte();
            extralen |= this.readByte() << 8;
            i = 0;
            this.nameBuf = [];
            while (filelen--) {
                var c = this.readByte();
                if (c == "/" | c == ":")i = 0; else if (i < cc.Codec.GZip.NAMEMAX - 1)this.nameBuf[i++] = String.fromCharCode(c)
            }
            if (!this.fileout)this.fileout = this.nameBuf;
            var i = 0;
            while (i < extralen) {
                c = this.readByte();
                i++
            }
            if (method == 8) {
                this.DeflateLoop();
                this.unzipped[this.files] = [this.outputArr.join(""), this.nameBuf.join("")];
                this.files++
            }
            this.skipdir()
        }
    }
};
cc.Codec.GZip.prototype.skipdir = function () {
    var tmp = [];
    var compSize, size, os, i, c;
    if (this.gpflags & 8) {
        tmp[0] = this.readByte();
        tmp[1] = this.readByte();
        tmp[2] = this.readByte();
        tmp[3] = this.readByte();
        compSize = this.readByte();
        compSize |= this.readByte() << 8;
        compSize |= this.readByte() << 16;
        compSize |= this.readByte() << 24;
        size = this.readByte();
        size |= this.readByte() << 8;
        size |= this.readByte() << 16;
        size |= this.readByte() << 24
    }
    if (this.modeZIP)this.nextFile();
    tmp[0] = this.readByte();
    if (tmp[0] != 8)return 0;
    this.gpflags = this.readByte();
    this.readByte();
    this.readByte();
    this.readByte();
    this.readByte();
    this.readByte();
    os = this.readByte();
    if (this.gpflags & 4) {
        tmp[0] = this.readByte();
        tmp[2] = this.readByte();
        this.len = tmp[0] + 256 * tmp[1];
        for (i = 0; i < this.len; i++)this.readByte()
    }
    if (this.gpflags & 8) {
        i = 0;
        this.nameBuf = [];
        while (c = this.readByte()) {
            if (c == "7" || c == ":")i = 0;
            if (i < cc.Codec.GZip.NAMEMAX - 1)this.nameBuf[i++] = c
        }
    }
    if (this.gpflags & 16)while (c = this.readByte());
    if (this.gpflags & 2) {
        this.readByte();
        this.readByte()
    }
    this.DeflateLoop();
    size = this.readByte();
    size |= this.readByte() << 8;
    size |= this.readByte() << 16;
    size |= this.readByte() << 24;
    if (this.modeZIP)this.nextFile()
};
/*
 zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */
(function () {
    function i(a) {
        throw a;
    }

    var r = void 0, v = !0, aa = this;

    function y(a, c) {
        var b = a.split("."), e = aa;
        !(b[0]in e) && e.execScript && e.execScript("var " + b[0]);
        for (var f; b.length && (f = b.shift());)!b.length && c !== r ? e[f] = c : e = e[f] ? e[f] : e[f] = {}
    }

    var H = "undefined" !== typeof Uint8Array && "undefined" !== typeof Uint16Array && "undefined" !== typeof Uint32Array;

    function ba(a) {
        if ("string" === typeof a) {
            var c = a.split(""), b, e;
            b = 0;
            for (e = c.length; b < e; b++)c[b] = (c[b].charCodeAt(0) & 255) >>> 0;
            a = c
        }
        for (var f = 1, d = 0, g = a.length, h, m = 0; 0 < g;) {
            h =
                    1024 < g ? 1024 : g;
            g -= h;
            do f += a[m++], d += f; while (--h);
            f %= 65521;
            d %= 65521
        }
        return(d << 16 | f) >>> 0
    }

    function J(a, c) {
        this.index = "number" === typeof c ? c : 0;
        this.i = 0;
        this.buffer = a instanceof(H ? Uint8Array : Array) ? a : new (H ? Uint8Array : Array)(32768);
        2 * this.buffer.length <= this.index && i(Error("invalid index"));
        this.buffer.length <= this.index && this.f()
    }

    J.prototype.f = function () {
        var a = this.buffer, c, b = a.length, e = new (H ? Uint8Array : Array)(b << 1);
        if (H)e.set(a); else for (c = 0; c < b; ++c)e[c] = a[c];
        return this.buffer = e
    };
    J.prototype.d = function (a, c, b) {
        var e = this.buffer, f = this.index, d = this.i, g = e[f], h;
        b && 1 < c && (a = 8 < c ? (N[a & 255] << 24 | N[a >>> 8 & 255] << 16 | N[a >>> 16 & 255] << 8 | N[a >>> 24 & 255]) >> 32 - c : N[a] >> 8 - c);
        if (8 > c + d)g = g << c | a, d += c; else for (h = 0; h < c; ++h)g = g << 1 | a >> c - h - 1 & 1, 8 === ++d && (d = 0, e[f++] = N[g], g = 0, f === e.length && (e = this.f()));
        e[f] = g;
        this.buffer = e;
        this.i = d;
        this.index = f
    };
    J.prototype.finish = function () {
        var a = this.buffer, c = this.index, b;
        0 < this.i && (a[c] <<= 8 - this.i, a[c] = N[a[c]], c++);
        H ? b = a.subarray(0, c) : (a.length = c, b = a);
        return b
    };
    var ca = new (H ? Uint8Array : Array)(256),
        ha;
    for (ha = 0; 256 > ha; ++ha) {
        for (var R = ha, ia = R, ja = 7, R = R >>> 1; R; R >>>= 1)ia <<= 1, ia |= R & 1, --ja;
        ca[ha] = (ia << ja & 255) >>> 0
    }
    var N = ca;
    var ka = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242,
        1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368,
        4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646,
        62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804,
        3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701,
        2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918E3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117];
    H && new Uint32Array(ka);
    function la(a) {
        this.buffer = new (H ? Uint16Array : Array)(2 * a);
        this.length = 0
    }

    la.prototype.getParent = function (a) {
        return 2 * ((a - 2) / 4 | 0)
    };
    la.prototype.push =
        function (a, c) {
            var b, e, f = this.buffer, d;
            b = this.length;
            f[this.length++] = c;
            for (f[this.length++] = a; 0 < b;)if (e = this.getParent(b), f[b] > f[e])d = f[b], f[b] = f[e], f[e] = d, d = f[b + 1], f[b + 1] = f[e + 1], f[e + 1] = d, b = e; else break;
            return this.length
        };
    la.prototype.pop = function () {
        var a, c, b = this.buffer, e, f, d;
        c = b[0];
        a = b[1];
        this.length -= 2;
        b[0] = b[this.length];
        b[1] = b[this.length + 1];
        for (d = 0; ;) {
            f = 2 * d + 2;
            if (f >= this.length)break;
            f + 2 < this.length && b[f + 2] > b[f] && (f += 2);
            if (b[f] > b[d])e = b[d], b[d] = b[f], b[f] = e, e = b[d + 1], b[d + 1] = b[f + 1], b[f + 1] = e; else break;
            d = f
        }
        return{index: a, value: c, length: this.length}
    };
    function S(a) {
        var c = a.length, b = 0, e = Number.POSITIVE_INFINITY, f, d, g, h, m, j, s, n, l;
        for (n = 0; n < c; ++n)a[n] > b && (b = a[n]), a[n] < e && (e = a[n]);
        f = 1 << b;
        d = new (H ? Uint32Array : Array)(f);
        g = 1;
        h = 0;
        for (m = 2; g <= b;) {
            for (n = 0; n < c; ++n)if (a[n] === g) {
                j = 0;
                s = h;
                for (l = 0; l < g; ++l)j = j << 1 | s & 1, s >>= 1;
                for (l = j; l < f; l += m)d[l] = g << 16 | n;
                ++h
            }
            ++g;
            h <<= 1;
            m <<= 1
        }
        return[d, b, e]
    }

    function ma(a, c) {
        this.h = pa;
        this.w = 0;
        this.input = a;
        this.b = 0;
        c && (c.lazy && (this.w = c.lazy), "number" === typeof c.compressionType && (this.h =
            c.compressionType), c.outputBuffer && (this.a = H && c.outputBuffer instanceof Array ? new Uint8Array(c.outputBuffer) : c.outputBuffer), "number" === typeof c.outputIndex && (this.b = c.outputIndex));
        this.a || (this.a = new (H ? Uint8Array : Array)(32768))
    }

    var pa = 2, qa = {NONE: 0, r: 1, j: pa, N: 3}, ra = [], T;
    for (T = 0; 288 > T; T++)switch (v) {
        case 143 >= T:
            ra.push([T + 48, 8]);
            break;
        case 255 >= T:
            ra.push([T - 144 + 400, 9]);
            break;
        case 279 >= T:
            ra.push([T - 256 + 0, 7]);
            break;
        case 287 >= T:
            ra.push([T - 280 + 192, 8]);
            break;
        default:
            i("invalid literal: " + T)
    }
    ma.prototype.n =
        function () {
            var a, c, b, e, f = this.input;
            switch (this.h) {
                case 0:
                    b = 0;
                    for (e = f.length; b < e;) {
                        c = H ? f.subarray(b, b + 65535) : f.slice(b, b + 65535);
                        b += c.length;
                        var d = c, g = b === e, h = r, m = r, j = r, s = r, n = r, l = this.a, q = this.b;
                        if (H) {
                            for (l = new Uint8Array(this.a.buffer); l.length <= q + d.length + 5;)l = new Uint8Array(l.length << 1);
                            l.set(this.a)
                        }
                        h = g ? 1 : 0;
                        l[q++] = h | 0;
                        m = d.length;
                        j = ~m + 65536 & 65535;
                        l[q++] = m & 255;
                        l[q++] = m >>> 8 & 255;
                        l[q++] = j & 255;
                        l[q++] = j >>> 8 & 255;
                        if (H)l.set(d, q), q += d.length, l = l.subarray(0, q); else {
                            s = 0;
                            for (n = d.length; s < n; ++s)l[q++] = d[s];
                            l.length = q
                        }
                        this.b = q;
                        this.a = l
                    }
                    break;
                case 1:
                    var E = new J(new Uint8Array(this.a.buffer), this.b);
                    E.d(1, 1, v);
                    E.d(1, 2, v);
                    var t = sa(this, f), z, K, A;
                    z = 0;
                    for (K = t.length; z < K; z++)if (A = t[z], J.prototype.d.apply(E, ra[A]), 256 < A)E.d(t[++z], t[++z], v), E.d(t[++z], 5), E.d(t[++z], t[++z], v); else if (256 === A)break;
                    this.a = E.finish();
                    this.b = this.a.length;
                    break;
                case pa:
                    var x = new J(new Uint8Array(this.a), this.b), B, k, p, D, C, da = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], W, Ma, ea, Na, na, va = Array(19), Oa, $, oa, F, Pa;
                    B = pa;
                    x.d(1, 1, v);
                    x.d(B, 2, v);
                    k = sa(this, f);
                    W = ta(this.L, 15);
                    Ma = ua(W);
                    ea = ta(this.K, 7);
                    Na = ua(ea);
                    for (p = 286; 257 < p && 0 === W[p - 1]; p--);
                    for (D = 30; 1 < D && 0 === ea[D - 1]; D--);
                    var Qa = p, Ra = D, M = new (H ? Uint32Array : Array)(Qa + Ra), u, O, w, fa, L = new (H ? Uint32Array : Array)(316), I, G, P = new (H ? Uint8Array : Array)(19);
                    for (u = O = 0; u < Qa; u++)M[O++] = W[u];
                    for (u = 0; u < Ra; u++)M[O++] = ea[u];
                    if (!H) {
                        u = 0;
                        for (fa = P.length; u < fa; ++u)P[u] = 0
                    }
                    u = I = 0;
                    for (fa = M.length; u < fa; u += O) {
                        for (O = 1; u + O < fa && M[u + O] === M[u]; ++O);
                        w = O;
                        if (0 === M[u])if (3 > w)for (; 0 < w--;)L[I++] = 0, P[0]++; else for (; 0 < w;)G =
                                138 > w ? w : 138, G > w - 3 && G < w && (G = w - 3), 10 >= G ? (L[I++] = 17, L[I++] = G - 3, P[17]++) : (L[I++] = 18, L[I++] = G - 11, P[18]++), w -= G; else if (L[I++] = M[u], P[M[u]]++, w--, 3 > w)for (; 0 < w--;)L[I++] = M[u], P[M[u]]++; else for (; 0 < w;)G = 6 > w ? w : 6, G > w - 3 && G < w && (G = w - 3), L[I++] = 16, L[I++] = G - 3, P[16]++, w -= G
                    }
                    a = H ? L.subarray(0, I) : L.slice(0, I);
                    na = ta(P, 7);
                    for (F = 0; 19 > F; F++)va[F] = na[da[F]];
                    for (C = 19; 4 < C && 0 === va[C - 1]; C--);
                    Oa = ua(na);
                    x.d(p - 257, 5, v);
                    x.d(D - 1, 5, v);
                    x.d(C - 4, 4, v);
                    for (F = 0; F < C; F++)x.d(va[F], 3, v);
                    F = 0;
                    for (Pa = a.length; F < Pa; F++)if ($ = a[F], x.d(Oa[$], na[$],
                        v), 16 <= $) {
                        F++;
                        switch ($) {
                            case 16:
                                oa = 2;
                                break;
                            case 17:
                                oa = 3;
                                break;
                            case 18:
                                oa = 7;
                                break;
                            default:
                                i("invalid code: " + $)
                        }
                        x.d(a[F], oa, v)
                    }
                    var Sa = [Ma, W], Ta = [Na, ea], Q, Ua, ga, ya, Va, Wa, Xa, Ya;
                    Va = Sa[0];
                    Wa = Sa[1];
                    Xa = Ta[0];
                    Ya = Ta[1];
                    Q = 0;
                    for (Ua = k.length; Q < Ua; ++Q)if (ga = k[Q], x.d(Va[ga], Wa[ga], v), 256 < ga)x.d(k[++Q], k[++Q], v), ya = k[++Q], x.d(Xa[ya], Ya[ya], v), x.d(k[++Q], k[++Q], v); else if (256 === ga)break;
                    this.a = x.finish();
                    this.b = this.a.length;
                    break;
                default:
                    i("invalid compression type")
            }
            return this.a
        };
    function wa(a, c) {
        this.length =
            a;
        this.G = c
    }

    function xa() {
        var a = za;
        switch (v) {
            case 3 === a:
                return[257, a - 3, 0];
            case 4 === a:
                return[258, a - 4, 0];
            case 5 === a:
                return[259, a - 5, 0];
            case 6 === a:
                return[260, a - 6, 0];
            case 7 === a:
                return[261, a - 7, 0];
            case 8 === a:
                return[262, a - 8, 0];
            case 9 === a:
                return[263, a - 9, 0];
            case 10 === a:
                return[264, a - 10, 0];
            case 12 >= a:
                return[265, a - 11, 1];
            case 14 >= a:
                return[266, a - 13, 1];
            case 16 >= a:
                return[267, a - 15, 1];
            case 18 >= a:
                return[268, a - 17, 1];
            case 22 >= a:
                return[269, a - 19, 2];
            case 26 >= a:
                return[270, a - 23, 2];
            case 30 >= a:
                return[271, a - 27, 2];
            case 34 >= a:
                return[272,
                        a - 31, 2];
            case 42 >= a:
                return[273, a - 35, 3];
            case 50 >= a:
                return[274, a - 43, 3];
            case 58 >= a:
                return[275, a - 51, 3];
            case 66 >= a:
                return[276, a - 59, 3];
            case 82 >= a:
                return[277, a - 67, 4];
            case 98 >= a:
                return[278, a - 83, 4];
            case 114 >= a:
                return[279, a - 99, 4];
            case 130 >= a:
                return[280, a - 115, 4];
            case 162 >= a:
                return[281, a - 131, 5];
            case 194 >= a:
                return[282, a - 163, 5];
            case 226 >= a:
                return[283, a - 195, 5];
            case 257 >= a:
                return[284, a - 227, 5];
            case 258 === a:
                return[285, a - 258, 0];
            default:
                i("invalid length: " + a)
        }
    }

    var Aa = [], za, Ba;
    for (za = 3; 258 >= za; za++)Ba = xa(), Aa[za] = Ba[2] <<
        24 | Ba[1] << 16 | Ba[0];
    var Ca = H ? new Uint32Array(Aa) : Aa;

    function sa(a, c) {
        function b(a, c) {
            var b = a.G, d = [], e = 0, f;
            f = Ca[a.length];
            d[e++] = f & 65535;
            d[e++] = f >> 16 & 255;
            d[e++] = f >> 24;
            var g;
            switch (v) {
                case 1 === b:
                    g = [0, b - 1, 0];
                    break;
                case 2 === b:
                    g = [1, b - 2, 0];
                    break;
                case 3 === b:
                    g = [2, b - 3, 0];
                    break;
                case 4 === b:
                    g = [3, b - 4, 0];
                    break;
                case 6 >= b:
                    g = [4, b - 5, 1];
                    break;
                case 8 >= b:
                    g = [5, b - 7, 1];
                    break;
                case 12 >= b:
                    g = [6, b - 9, 2];
                    break;
                case 16 >= b:
                    g = [7, b - 13, 2];
                    break;
                case 24 >= b:
                    g = [8, b - 17, 3];
                    break;
                case 32 >= b:
                    g = [9, b - 25, 3];
                    break;
                case 48 >= b:
                    g = [10, b - 33, 4];
                    break;
                case 64 >= b:
                    g = [11, b - 49, 4];
                    break;
                case 96 >= b:
                    g = [12, b - 65, 5];
                    break;
                case 128 >= b:
                    g = [13, b - 97, 5];
                    break;
                case 192 >= b:
                    g = [14, b - 129, 6];
                    break;
                case 256 >= b:
                    g = [15, b - 193, 6];
                    break;
                case 384 >= b:
                    g = [16, b - 257, 7];
                    break;
                case 512 >= b:
                    g = [17, b - 385, 7];
                    break;
                case 768 >= b:
                    g = [18, b - 513, 8];
                    break;
                case 1024 >= b:
                    g = [19, b - 769, 8];
                    break;
                case 1536 >= b:
                    g = [20, b - 1025, 9];
                    break;
                case 2048 >= b:
                    g = [21, b - 1537, 9];
                    break;
                case 3072 >= b:
                    g = [22, b - 2049, 10];
                    break;
                case 4096 >= b:
                    g = [23, b - 3073, 10];
                    break;
                case 6144 >= b:
                    g = [24, b - 4097, 11];
                    break;
                case 8192 >= b:
                    g = [25, b - 6145, 11];
                    break;
                case 12288 >= b:
                    g = [26, b - 8193, 12];
                    break;
                case 16384 >= b:
                    g = [27, b - 12289, 12];
                    break;
                case 24576 >= b:
                    g = [28, b - 16385, 13];
                    break;
                case 32768 >= b:
                    g = [29, b - 24577, 13];
                    break;
                default:
                    i("invalid distance")
            }
            f = g;
            d[e++] = f[0];
            d[e++] = f[1];
            d[e++] = f[2];
            var h, j;
            h = 0;
            for (j = d.length; h < j; ++h)l[q++] = d[h];
            t[d[0]]++;
            z[d[3]]++;
            E = a.length + c - 1;
            n = null
        }

        var e, f, d, g, h, m = {}, j, s, n, l = H ? new Uint16Array(2 * c.length) : [], q = 0, E = 0, t = new (H ? Uint32Array : Array)(286), z = new (H ? Uint32Array : Array)(30), K = a.w, A;
        if (!H) {
            for (d = 0; 285 >= d;)t[d++] = 0;
            for (d = 0; 29 >=
                d;)z[d++] = 0
        }
        t[256] = 1;
        e = 0;
        for (f = c.length; e < f; ++e) {
            d = h = 0;
            for (g = 3; d < g && e + d !== f; ++d)h = h << 8 | c[e + d];
            m[h] === r && (m[h] = []);
            j = m[h];
            if (!(0 < E--)) {
                for (; 0 < j.length && 32768 < e - j[0];)j.shift();
                if (e + 3 >= f) {
                    n && b(n, -1);
                    d = 0;
                    for (g = f - e; d < g; ++d)A = c[e + d], l[q++] = A, ++t[A];
                    break
                }
                if (0 < j.length) {
                    var x = r, B = r, k = 0, p = r, D = r, C = r, da = r, W = c.length, D = 0, da = j.length;
                    a:for (; D < da; D++) {
                        x = j[da - D - 1];
                        p = 3;
                        if (3 < k) {
                            for (C = k; 3 < C; C--)if (c[x + C - 1] !== c[e + C - 1])continue a;
                            p = k
                        }
                        for (; 258 > p && e + p < W && c[x + p] === c[e + p];)++p;
                        p > k && (B = x, k = p);
                        if (258 === p)break
                    }
                    s = new wa(k,
                            e - B);
                    n ? n.length < s.length ? (A = c[e - 1], l[q++] = A, ++t[A], b(s, 0)) : b(n, -1) : s.length < K ? n = s : b(s, 0)
                } else n ? b(n, -1) : (A = c[e], l[q++] = A, ++t[A])
            }
            j.push(e)
        }
        l[q++] = 256;
        t[256]++;
        a.L = t;
        a.K = z;
        return H ? l.subarray(0, q) : l
    }

    function ta(a, c) {
        function b(a) {
            var c = z[a][K[a]];
            c === n ? (b(a + 1), b(a + 1)) : --E[c];
            ++K[a]
        }

        var e = a.length, f = new la(572), d = new (H ? Uint8Array : Array)(e), g, h, m, j, s;
        if (!H)for (j = 0; j < e; j++)d[j] = 0;
        for (j = 0; j < e; ++j)0 < a[j] && f.push(j, a[j]);
        g = Array(f.length / 2);
        h = new (H ? Uint32Array : Array)(f.length / 2);
        if (1 === g.length)return d[f.pop().index] =
            1, d;
        j = 0;
        for (s = f.length / 2; j < s; ++j)g[j] = f.pop(), h[j] = g[j].value;
        var n = h.length, l = new (H ? Uint16Array : Array)(c), q = new (H ? Uint8Array : Array)(c), E = new (H ? Uint8Array : Array)(n), t = Array(c), z = Array(c), K = Array(c), A = (1 << c) - n, x = 1 << c - 1, B, k, p, D, C;
        l[c - 1] = n;
        for (k = 0; k < c; ++k)A < x ? q[k] = 0 : (q[k] = 1, A -= x), A <<= 1, l[c - 2 - k] = (l[c - 1 - k] / 2 | 0) + n;
        l[0] = q[0];
        t[0] = Array(l[0]);
        z[0] = Array(l[0]);
        for (k = 1; k < c; ++k)l[k] > 2 * l[k - 1] + q[k] && (l[k] = 2 * l[k - 1] + q[k]), t[k] = Array(l[k]), z[k] = Array(l[k]);
        for (B = 0; B < n; ++B)E[B] = c;
        for (p = 0; p < l[c - 1]; ++p)t[c - 1][p] =
            h[p], z[c - 1][p] = p;
        for (B = 0; B < c; ++B)K[B] = 0;
        1 === q[c - 1] && (--E[0], ++K[c - 1]);
        for (k = c - 2; 0 <= k; --k) {
            D = B = 0;
            C = K[k + 1];
            for (p = 0; p < l[k]; p++)D = t[k + 1][C] + t[k + 1][C + 1], D > h[B] ? (t[k][p] = D, z[k][p] = n, C += 2) : (t[k][p] = h[B], z[k][p] = B, ++B);
            K[k] = 0;
            1 === q[k] && b(k)
        }
        m = E;
        j = 0;
        for (s = g.length; j < s; ++j)d[g[j].index] = m[j];
        return d
    }

    function ua(a) {
        var c = new (H ? Uint16Array : Array)(a.length), b = [], e = [], f = 0, d, g, h, m;
        d = 0;
        for (g = a.length; d < g; d++)b[a[d]] = (b[a[d]] | 0) + 1;
        d = 1;
        for (g = 16; d <= g; d++)e[d] = f, f += b[d] | 0, f > 1 << d && i("overcommitted"), f <<= 1;
        65536 > f &&
        i("undercommitted");
        d = 0;
        for (g = a.length; d < g; d++) {
            f = e[a[d]];
            e[a[d]] += 1;
            h = c[d] = 0;
            for (m = a[d]; h < m; h++)c[d] = c[d] << 1 | f & 1, f >>>= 1
        }
        return c
    }

    function Da(a, c) {
        this.input = a;
        this.a = new (H ? Uint8Array : Array)(32768);
        this.h = U.j;
        var b = {}, e;
        if ((c || !(c = {})) && "number" === typeof c.compressionType)this.h = c.compressionType;
        for (e in c)b[e] = c[e];
        b.outputBuffer = this.a;
        this.z = new ma(this.input, b)
    }

    var U = qa;
    Da.prototype.n = function () {
        var a, c, b, e, f, d, g, h = 0;
        g = this.a;
        a = Ea;
        switch (a) {
            case Ea:
                c = Math.LOG2E * Math.log(32768) - 8;
                break;
            default:
                i(Error("invalid compression method"))
        }
        b =
            c << 4 | a;
        g[h++] = b;
        switch (a) {
            case Ea:
                switch (this.h) {
                    case U.NONE:
                        f = 0;
                        break;
                    case U.r:
                        f = 1;
                        break;
                    case U.j:
                        f = 2;
                        break;
                    default:
                        i(Error("unsupported compression type"))
                }
                break;
            default:
                i(Error("invalid compression method"))
        }
        e = f << 6 | 0;
        g[h++] = e | 31 - (256 * b + e) % 31;
        d = ba(this.input);
        this.z.b = h;
        g = this.z.n();
        h = g.length;
        H && (g = new Uint8Array(g.buffer), g.length <= h + 4 && (this.a = new Uint8Array(g.length + 4), this.a.set(g), g = this.a), g = g.subarray(0, h + 4));
        g[h++] = d >> 24 & 255;
        g[h++] = d >> 16 & 255;
        g[h++] = d >> 8 & 255;
        g[h++] = d & 255;
        return g
    };
    y("Zlib.Deflate",
        Da);
    y("Zlib.Deflate.compress", function (a, c) {
        return(new Da(a, c)).n()
    });
    y("Zlib.Deflate.CompressionType", U);
    y("Zlib.Deflate.CompressionType.NONE", U.NONE);
    y("Zlib.Deflate.CompressionType.FIXED", U.r);
    y("Zlib.Deflate.CompressionType.DYNAMIC", U.j);
    function V(a, c) {
        this.k = [];
        this.l = 32768;
        this.e = this.g = this.c = this.q = 0;
        this.input = H ? new Uint8Array(a) : a;
        this.s = !1;
        this.m = Fa;
        this.B = !1;
        if (c || !(c = {}))c.index && (this.c = c.index), c.bufferSize && (this.l = c.bufferSize), c.bufferType && (this.m = c.bufferType), c.resize && (this.B =
            c.resize);
        switch (this.m) {
            case Ga:
                this.b = 32768;
                this.a = new (H ? Uint8Array : Array)(32768 + this.l + 258);
                break;
            case Fa:
                this.b = 0;
                this.a = new (H ? Uint8Array : Array)(this.l);
                this.f = this.J;
                this.t = this.H;
                this.o = this.I;
                break;
            default:
                i(Error("invalid inflate mode"))
        }
    }

    var Ga = 0, Fa = 1, Ha = {D: Ga, C: Fa};
    V.prototype.p = function () {
        for (; !this.s;) {
            var a = X(this, 3);
            a & 1 && (this.s = v);
            a >>>= 1;
            switch (a) {
                case 0:
                    var c = this.input, b = this.c, e = this.a, f = this.b, d = r, g = r, h = r, m = e.length, j = r;
                    this.e = this.g = 0;
                    d = c[b++];
                    d === r && i(Error("invalid uncompressed block header: LEN (first byte)"));
                    g = d;
                    d = c[b++];
                    d === r && i(Error("invalid uncompressed block header: LEN (second byte)"));
                    g |= d << 8;
                    d = c[b++];
                    d === r && i(Error("invalid uncompressed block header: NLEN (first byte)"));
                    h = d;
                    d = c[b++];
                    d === r && i(Error("invalid uncompressed block header: NLEN (second byte)"));
                    h |= d << 8;
                    g === ~h && i(Error("invalid uncompressed block header: length verify"));
                    b + g > c.length && i(Error("input buffer is broken"));
                    switch (this.m) {
                        case Ga:
                            for (; f + g > e.length;) {
                                j = m - f;
                                g -= j;
                                if (H)e.set(c.subarray(b, b + j), f), f += j, b += j; else for (; j--;)e[f++] =
                                    c[b++];
                                this.b = f;
                                e = this.f();
                                f = this.b
                            }
                            break;
                        case Fa:
                            for (; f + g > e.length;)e = this.f({v: 2});
                            break;
                        default:
                            i(Error("invalid inflate mode"))
                    }
                    if (H)e.set(c.subarray(b, b + g), f), f += g, b += g; else for (; g--;)e[f++] = c[b++];
                    this.c = b;
                    this.b = f;
                    this.a = e;
                    break;
                case 1:
                    this.o(Ia, Ja);
                    break;
                case 2:
                    Ka(this);
                    break;
                default:
                    i(Error("unknown BTYPE: " + a))
            }
        }
        return this.t()
    };
    var La = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], Za = H ? new Uint16Array(La) : La, $a = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163,
        195, 227, 258, 258, 258], ab = H ? new Uint16Array($a) : $a, bb = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0], cb = H ? new Uint8Array(bb) : bb, db = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577], eb = H ? new Uint16Array(db) : db, fb = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], gb = H ? new Uint8Array(fb) : fb, hb = new (H ? Uint8Array : Array)(288), Y, ib;
    Y = 0;
    for (ib = hb.length; Y < ib; ++Y)hb[Y] = 143 >= Y ? 8 : 255 >= Y ? 9 : 279 >= Y ? 7 : 8;
    var Ia = S(hb),
        jb = new (H ? Uint8Array : Array)(30), kb, lb;
    kb = 0;
    for (lb = jb.length; kb < lb; ++kb)jb[kb] = 5;
    var Ja = S(jb);

    function X(a, c) {
        for (var b = a.g, e = a.e, f = a.input, d = a.c, g; e < c;)g = f[d++], g === r && i(Error("input buffer is broken")), b |= g << e, e += 8;
        g = b & (1 << c) - 1;
        a.g = b >>> c;
        a.e = e - c;
        a.c = d;
        return g
    }

    function mb(a, c) {
        for (var b = a.g, e = a.e, f = a.input, d = a.c, g = c[0], h = c[1], m, j, s; e < h;)m = f[d++], m === r && i(Error("input buffer is broken")), b |= m << e, e += 8;
        j = g[b & (1 << h) - 1];
        s = j >>> 16;
        a.g = b >> s;
        a.e = e - s;
        a.c = d;
        return j & 65535
    }

    function Ka(a) {
        function c(a, b, c) {
            var d,
                e, f, g;
            for (g = 0; g < a;)switch (d = mb(this, b), d) {
                case 16:
                    for (f = 3 + X(this, 2); f--;)c[g++] = e;
                    break;
                case 17:
                    for (f = 3 + X(this, 3); f--;)c[g++] = 0;
                    e = 0;
                    break;
                case 18:
                    for (f = 11 + X(this, 7); f--;)c[g++] = 0;
                    e = 0;
                    break;
                default:
                    e = c[g++] = d
            }
            return c
        }

        var b = X(a, 5) + 257, e = X(a, 5) + 1, f = X(a, 4) + 4, d = new (H ? Uint8Array : Array)(Za.length), g, h, m, j;
        for (j = 0; j < f; ++j)d[Za[j]] = X(a, 3);
        g = S(d);
        h = new (H ? Uint8Array : Array)(b);
        m = new (H ? Uint8Array : Array)(e);
        a.o(S(c.call(a, b, g, h)), S(c.call(a, e, g, m)))
    }

    V.prototype.o = function (a, c) {
        var b = this.a, e = this.b;
        this.u =
            a;
        for (var f = b.length - 258, d, g, h, m; 256 !== (d = mb(this, a));)if (256 > d)e >= f && (this.b = e, b = this.f(), e = this.b), b[e++] = d; else {
            g = d - 257;
            m = ab[g];
            0 < cb[g] && (m += X(this, cb[g]));
            d = mb(this, c);
            h = eb[d];
            0 < gb[d] && (h += X(this, gb[d]));
            e >= f && (this.b = e, b = this.f(), e = this.b);
            for (; m--;)b[e] = b[e++ - h]
        }
        for (; 8 <= this.e;)this.e -= 8, this.c--;
        this.b = e
    };
    V.prototype.I = function (a, c) {
        var b = this.a, e = this.b;
        this.u = a;
        for (var f = b.length, d, g, h, m; 256 !== (d = mb(this, a));)if (256 > d)e >= f && (b = this.f(), f = b.length), b[e++] = d; else {
            g = d - 257;
            m = ab[g];
            0 < cb[g] && (m +=
                X(this, cb[g]));
            d = mb(this, c);
            h = eb[d];
            0 < gb[d] && (h += X(this, gb[d]));
            e + m > f && (b = this.f(), f = b.length);
            for (; m--;)b[e] = b[e++ - h]
        }
        for (; 8 <= this.e;)this.e -= 8, this.c--;
        this.b = e
    };
    V.prototype.f = function () {
        var a = new (H ? Uint8Array : Array)(this.b - 32768), c = this.b - 32768, b, e, f = this.a;
        if (H)a.set(f.subarray(32768, a.length)); else {
            b = 0;
            for (e = a.length; b < e; ++b)a[b] = f[b + 32768]
        }
        this.k.push(a);
        this.q += a.length;
        if (H)f.set(f.subarray(c, c + 32768)); else for (b = 0; 32768 > b; ++b)f[b] = f[c + b];
        this.b = 32768;
        return f
    };
    V.prototype.J = function (a) {
        var c,
            b = this.input.length / this.c + 1 | 0, e, f, d, g = this.input, h = this.a;
        a && ("number" === typeof a.v && (b = a.v), "number" === typeof a.F && (b += a.F));
        2 > b ? (e = (g.length - this.c) / this.u[2], d = 258 * (e / 2) | 0, f = d < h.length ? h.length + d : h.length << 1) : f = h.length * b;
        H ? (c = new Uint8Array(f), c.set(h)) : c = h;
        return this.a = c
    };
    V.prototype.t = function () {
        var a = 0, c = this.a, b = this.k, e, f = new (H ? Uint8Array : Array)(this.q + (this.b - 32768)), d, g, h, m;
        if (0 === b.length)return H ? this.a.subarray(32768, this.b) : this.a.slice(32768, this.b);
        d = 0;
        for (g = b.length; d < g; ++d) {
            e =
                b[d];
            h = 0;
            for (m = e.length; h < m; ++h)f[a++] = e[h]
        }
        d = 32768;
        for (g = this.b; d < g; ++d)f[a++] = c[d];
        this.k = [];
        return this.buffer = f
    };
    V.prototype.H = function () {
        var a, c = this.b;
        H ? this.B ? (a = new Uint8Array(c), a.set(this.a.subarray(0, c))) : a = this.a.subarray(0, c) : (this.a.length > c && (this.a.length = c), a = this.a);
        return this.buffer = a
    };
    function nb(a, c) {
        var b, e;
        this.input = a;
        this.c = 0;
        if (c || !(c = {}))c.index && (this.c = c.index), c.verify && (this.M = c.verify);
        b = a[this.c++];
        e = a[this.c++];
        switch (b & 15) {
            case Ea:
                this.method = Ea;
                break;
            default:
                i(Error("unsupported compression method"))
        }
        0 !==
            ((b << 8) + e) % 31 && i(Error("invalid fcheck flag:" + ((b << 8) + e) % 31));
        e & 32 && i(Error("fdict flag is not supported"));
        this.A = new V(a, {index: this.c, bufferSize: c.bufferSize, bufferType: c.bufferType, resize: c.resize})
    }

    nb.prototype.p = function () {
        var a = this.input, c, b;
        c = this.A.p();
        this.c = this.A.c;
        this.M && (b = (a[this.c++] << 24 | a[this.c++] << 16 | a[this.c++] << 8 | a[this.c++]) >>> 0, b !== ba(c) && i(Error("invalid adler-32 checksum")));
        return c
    };
    y("Zlib.Inflate", nb);
    y("Zlib.Inflate.BufferType", Ha);
    Ha.ADAPTIVE = Ha.C;
    Ha.BLOCK = Ha.D;
    y("Zlib.Inflate.prototype.decompress",
        nb.prototype.p);
    var ob = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    H && new Uint16Array(ob);
    var pb = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258];
    H && new Uint16Array(pb);
    var qb = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0];
    H && new Uint8Array(qb);
    var rb = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
    H && new Uint16Array(rb);
    var sb = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7,
        8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
    H && new Uint8Array(sb);
    var tb = new (H ? Uint8Array : Array)(288), Z, ub;
    Z = 0;
    for (ub = tb.length; Z < ub; ++Z)tb[Z] = 143 >= Z ? 8 : 255 >= Z ? 9 : 279 >= Z ? 7 : 8;
    S(tb);
    var vb = new (H ? Uint8Array : Array)(30), wb, xb;
    wb = 0;
    for (xb = vb.length; wb < xb; ++wb)vb[wb] = 5;
    S(vb);
    var Ea = 8
}).call(this);
var _p = window;
_p = _p.Zlib = _p["Zlib"];
_p.Deflate = _p["Deflate"];
_p.Deflate.compress = _p.Deflate["compress"];
_p.Inflate = _p["Inflate"];
_p.Inflate.BufferType = _p.Inflate["BufferType"];
_p.Inflate.prototype.decompress = _p.Inflate.prototype["decompress"];cc.PNGReader = cc.Class.extend({ctor: function (data) {
    var chunkSize, colors, delayDen, delayNum, frame, i, index, key, section, ccshort, text, _i, _j, _ref;
    this.data = data;
    this.pos = 8;
    this.palette = [];
    this.imgData = [];
    this.transparency = {};
    this.animation = null;
    this.text = {};
    frame = null;
    while (true) {
        chunkSize = this.readUInt32();
        section = function () {
            var _i, _results;
            _results = [];
            for (i = _i = 0; _i < 4; i = ++_i)_results.push(String.fromCharCode(this.data[this.pos++]));
            return _results
        }.call(this).join("");
        switch (section) {
            case "IHDR":
                this.width =
                    this.readUInt32();
                this.height = this.readUInt32();
                this.bits = this.data[this.pos++];
                this.colorType = this.data[this.pos++];
                this.compressionMethod = this.data[this.pos++];
                this.filterMethod = this.data[this.pos++];
                this.interlaceMethod = this.data[this.pos++];
                break;
            case "acTL":
                this.animation = {numFrames: this.readUInt32(), numPlays: this.readUInt32() || Infinity, frames: []};
                break;
            case "PLTE":
                this.palette = this.read(chunkSize);
                break;
            case "fcTL":
                if (frame)this.animation.frames.push(frame);
                this.pos += 4;
                frame = {width: this.readUInt32(),
                    height: this.readUInt32(), xOffset: this.readUInt32(), yOffset: this.readUInt32()};
                delayNum = this.readUInt16();
                delayDen = this.readUInt16() || 100;
                frame.delay = 1E3 * delayNum / delayDen;
                frame.disposeOp = this.data[this.pos++];
                frame.blendOp = this.data[this.pos++];
                frame.data = [];
                break;
            case "IDAT":
            case "fdAT":
                if (section === "fdAT") {
                    this.pos += 4;
                    chunkSize -= 4
                }
                data = (frame != null ? frame.data : void 0) || this.imgData;
                for (i = _i = 0; 0 <= chunkSize ? _i < chunkSize : _i > chunkSize; i = 0 <= chunkSize ? ++_i : --_i)data.push(this.data[this.pos++]);
                break;
            case "tRNS":
                this.transparency =
                {};
                switch (this.colorType) {
                    case 3:
                        this.transparency.indexed = this.read(chunkSize);
                        ccshort = 255 - this.transparency.indexed.length;
                        if (ccshort > 0)for (i = _j = 0; 0 <= ccshort ? _j < ccshort : _j > ccshort; i = 0 <= ccshort ? ++_j : --_j)this.transparency.indexed.push(255);
                        break;
                    case 0:
                        this.transparency.grayscale = this.read(chunkSize)[0];
                        break;
                    case 2:
                        this.transparency.rgb = this.read(chunkSize)
                }
                break;
            case "tEXt":
                text = this.read(chunkSize);
                index = text.indexOf(0);
                key = String.fromCharCode.apply(String, text.slice(0, index));
                this.text[key] =
                    String.fromCharCode.apply(String, text.slice(index + 1));
                break;
            case "IEND":
                if (frame)this.animation.frames.push(frame);
                this.colors = function () {
                    switch (this.colorType) {
                        case 0:
                        case 3:
                        case 4:
                            return 1;
                        case 2:
                        case 6:
                            return 3
                    }
                }.call(this);
                this.hasAlphaChannel = (_ref = this.colorType) === 4 || _ref === 6;
                colors = this.colors + (this.hasAlphaChannel ? 1 : 0);
                this.pixelBitlength = this.bits * colors;
                this.colorSpace = function () {
                    switch (this.colors) {
                        case 1:
                            return"DeviceGray";
                        case 3:
                            return"DeviceRGB"
                    }
                }.call(this);
                if (Uint8Array != Array)this.imgData =
                    new Uint8Array(this.imgData);
                return;
            default:
                this.pos += chunkSize
        }
        this.pos += 4;
        if (this.pos > this.data.length)throw new Error("Incomplete or corrupt PNG file");
    }
}, read: function (bytes) {
    var i, _i, _results;
    _results = [];
    for (i = _i = 0; 0 <= bytes ? _i < bytes : _i > bytes; i = 0 <= bytes ? ++_i : --_i)_results.push(this.data[this.pos++]);
    return _results
}, readUInt32: function () {
    var b1, b2, b3, b4;
    b1 = this.data[this.pos++] << 24;
    b2 = this.data[this.pos++] << 16;
    b3 = this.data[this.pos++] << 8;
    b4 = this.data[this.pos++];
    return b1 | b2 | b3 | b4
}, readUInt16: function () {
    var b1,
        b2;
    b1 = this.data[this.pos++] << 8;
    b2 = this.data[this.pos++];
    return b1 | b2
}, decodePixels: function (data) {
    var ccbyte, c, col, i, left, length, p, pa, paeth, pb, pc, pixelBytes, pixels, pos, row, scanlineLength, upper, upperLeft, _i, _j, _k, _l, _m;
    if (data == null)data = this.imgData;
    if (data.length === 0)return new Uint8Array(0);
    var inflate = new Zlib.Inflate(data, {index: 0, verify: false});
    data = inflate.decompress();
    pixelBytes = this.pixelBitlength / 8;
    scanlineLength = pixelBytes * this.width;
    pixels = new Uint8Array(scanlineLength * this.height);
    length =
        data.length;
    row = 0;
    pos = 0;
    c = 0;
    while (pos < length) {
        switch (data[pos++]) {
            case 0:
                for (i = _i = 0; _i < scanlineLength; i = _i += 1)pixels[c++] = data[pos++];
                break;
            case 1:
                for (i = _j = 0; _j < scanlineLength; i = _j += 1) {
                    ccbyte = data[pos++];
                    left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
                    pixels[c++] = (ccbyte + left) % 256
                }
                break;
            case 2:
                for (i = _k = 0; _k < scanlineLength; i = _k += 1) {
                    ccbyte = data[pos++];
                    col = (i - i % pixelBytes) / pixelBytes;
                    upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
                    pixels[c++] = (upper + ccbyte) % 256
                }
                break;
            case 3:
                for (i = _l = 0; _l <
                    scanlineLength; i = _l += 1) {
                    ccbyte = data[pos++];
                    col = (i - i % pixelBytes) / pixelBytes;
                    left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
                    upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
                    pixels[c++] = (ccbyte + Math.floor((left + upper) / 2)) % 256
                }
                break;
            case 4:
                for (i = _m = 0; _m < scanlineLength; i = _m += 1) {
                    ccbyte = data[pos++];
                    col = (i - i % pixelBytes) / pixelBytes;
                    left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
                    if (row === 0)upper = upperLeft = 0; else {
                        upper = pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
                        upperLeft = col && pixels[(row -
                            1) * scanlineLength + (col - 1) * pixelBytes + i % pixelBytes]
                    }
                    p = left + upper - upperLeft;
                    pa = Math.abs(p - left);
                    pb = Math.abs(p - upper);
                    pc = Math.abs(p - upperLeft);
                    if (pa <= pb && pa <= pc)paeth = left; else if (pb <= pc)paeth = upper; else paeth = upperLeft;
                    pixels[c++] = (ccbyte + paeth) % 256
                }
                break;
            default:
                throw new Error("Invalid filter algorithm: " + data[pos - 1]);
        }
        row++
    }
    return pixels
}, copyToImageData: function (imageData, pixels) {
    var alpha, colors, data, i, input, j, k, length, palette, v, _ref;
    colors = this.colors;
    palette = null;
    alpha = this.hasAlphaChannel;
    if (this.palette.length) {
        palette =
                (_ref = this._decodedPalette) != null ? _ref : this._decodedPalette = this.decodePalette();
        colors = 4;
        alpha = true
    }
    data = imageData.data || imageData;
    length = data.length;
    input = palette || pixels;
    i = j = 0;
    if (colors === 1)while (i < length) {
        k = palette ? pixels[i / 4] * 4 : j;
        v = input[k++];
        data[i++] = v;
        data[i++] = v;
        data[i++] = v;
        data[i++] = alpha ? input[k++] : 255;
        j = k
    } else while (i < length) {
        k = palette ? pixels[i / 4] * 4 : j;
        data[i++] = input[k++];
        data[i++] = input[k++];
        data[i++] = input[k++];
        data[i++] = alpha ? input[k++] : 255;
        j = k
    }
}, decodePalette: function () {
    var c, i, palette,
        pos, ret, transparency, _i, _ref, _ref1;
    palette = this.palette;
    transparency = this.transparency.indexed || [];
    ret = new Uint8Array((transparency.length || 0) + palette.length);
    pos = 0;
    c = 0;
    for (i = _i = 0, _ref = palette.length; _i < _ref; i = _i += 3) {
        ret[pos++] = palette[i];
        ret[pos++] = palette[i + 1];
        ret[pos++] = palette[i + 2];
        ret[pos++] = (_ref1 = transparency[c++]) != null ? _ref1 : 255
    }
    return ret
}, render: function (canvas) {
    var ctx, data;
    canvas.width = this.width;
    canvas.height = this.height;
    ctx = canvas.getContext("2d");
    data = ctx.createImageData(this.width,
        this.height);
    this.copyToImageData(data, this.decodePixels());
    return ctx.putImageData(data, 0, 0)
}});
cc.tiffReader = {_littleEndian: false, _tiffData: null, _fileDirectories: [], getUint8: function (offset) {
    return this._tiffData[offset]
}, getUint16: function (offset) {
    if (this._littleEndian)return this._tiffData[offset + 1] << 8 | this._tiffData[offset]; else return this._tiffData[offset] << 8 | this._tiffData[offset + 1]
}, getUint32: function (offset) {
    var a = this._tiffData;
    if (this._littleEndian)return a[offset + 3] << 24 | a[offset + 2] << 16 | a[offset + 1] << 8 | a[offset]; else return a[offset] << 24 | a[offset + 1] << 16 | a[offset + 2] << 8 | a[offset + 3]
},
    checkLittleEndian: function () {
        var BOM = this.getUint16(0);
        if (BOM === 18761)this.littleEndian = true; else if (BOM === 19789)this.littleEndian = false; else {
            console.log(BOM);
            throw TypeError("Invalid byte order value.");
        }
        return this.littleEndian
    }, hasTowel: function () {
        if (this.getUint16(2) !== 42) {
            throw RangeError("You forgot your towel!");
            return false
        }
        return true
    }, getFieldTypeName: function (fieldType) {
        var typeNames = this.fieldTypeNames;
        if (fieldType in typeNames)return typeNames[fieldType];
        return null
    }, getFieldTagName: function (fieldTag) {
        var tagNames =
            this.fieldTagNames;
        if (fieldTag in tagNames)return tagNames[fieldTag]; else {
            console.log("Unknown Field Tag:", fieldTag);
            return"Tag" + fieldTag
        }
    }, getFieldTypeLength: function (fieldTypeName) {
        if (["BYTE", "ASCII", "SBYTE", "UNDEFINED"].indexOf(fieldTypeName) !== -1)return 1; else if (["SHORT", "SSHORT"].indexOf(fieldTypeName) !== -1)return 2; else if (["LONG", "SLONG", "FLOAT"].indexOf(fieldTypeName) !== -1)return 4; else if (["RATIONAL", "SRATIONAL", "DOUBLE"].indexOf(fieldTypeName) !== -1)return 8;
        return null
    }, getFieldValues: function (fieldTagName, fieldTypeName, typeCount, valueOffset) {
        var fieldValues = [];
        var fieldTypeLength = this.getFieldTypeLength(fieldTypeName);
        var fieldValueSize = fieldTypeLength * typeCount;
        if (fieldValueSize <= 4)if (this.littleEndian === false)fieldValues.push(valueOffset >>> (4 - fieldTypeLength) * 8); else fieldValues.push(valueOffset); else for (var i = 0; i < typeCount; i++) {
            var indexOffset = fieldTypeLength * i;
            if (fieldTypeLength >= 8)if (["RATIONAL", "SRATIONAL"].indexOf(fieldTypeName) !== -1) {
                fieldValues.push(this.getUint32(valueOffset + indexOffset));
                fieldValues.push(this.getUint32(valueOffset + indexOffset + 4))
            } else cc.log("Can't handle this field type or size"); else fieldValues.push(this.getBytes(fieldTypeLength, valueOffset + indexOffset))
        }
        if (fieldTypeName === "ASCII")fieldValues.forEach(function (e, i, a) {
            a[i] = String.fromCharCode(e)
        });
        return fieldValues
    }, getBytes: function (numBytes, offset) {
        if (numBytes <= 0)cc.log("No bytes requested"); else if (numBytes <= 1)return this.getUint8(offset); else if (numBytes <= 2)return this.getUint16(offset); else if (numBytes <= 3)return this.getUint32(offset) >>>
            8; else if (numBytes <= 4)return this.getUint32(offset); else cc.log("Too many bytes requested")
    }, getBits: function (numBits, byteOffset, bitOffset) {
        bitOffset = bitOffset || 0;
        var extraBytes = Math.floor(bitOffset / 8);
        var newByteOffset = byteOffset + extraBytes;
        var totalBits = bitOffset + numBits;
        var shiftRight = 32 - numBits;
        var shiftLeft, rawBits;
        if (totalBits <= 0)console.log("No bits requested"); else if (totalBits <= 8) {
            shiftLeft = 24 + bitOffset;
            rawBits = this.getUint8(newByteOffset)
        } else if (totalBits <= 16) {
            shiftLeft = 16 + bitOffset;
            rawBits =
                this.getUint16(newByteOffset)
        } else if (totalBits <= 32) {
            shiftLeft = bitOffset;
            rawBits = this.getUint32(newByteOffset)
        } else console.log("Too many bits requested");
        return{"bits": rawBits << shiftLeft >>> shiftRight, "byteOffset": newByteOffset + Math.floor(totalBits / 8), "bitOffset": totalBits % 8}
    }, parseFileDirectory: function (byteOffset) {
        var numDirEntries = this.getUint16(byteOffset);
        var tiffFields = [];
        for (var i = byteOffset + 2, entryCount = 0; entryCount < numDirEntries; i += 12, entryCount++) {
            var fieldTag = this.getUint16(i);
            var fieldType =
                this.getUint16(i + 2);
            var typeCount = this.getUint32(i + 4);
            var valueOffset = this.getUint32(i + 8);
            var fieldTagName = this.getFieldTagName(fieldTag);
            var fieldTypeName = this.getFieldTypeName(fieldType);
            var fieldValues = this.getFieldValues(fieldTagName, fieldTypeName, typeCount, valueOffset);
            tiffFields[fieldTagName] = {type: fieldTypeName, values: fieldValues}
        }
        this._fileDirectories.push(tiffFields);
        var nextIFDByteOffset = this.getUint32(i);
        if (nextIFDByteOffset !== 0)this.parseFileDirectory(nextIFDByteOffset)
    }, clampColorSample: function (colorSample, bitsPerSample) {
        var multiplier = Math.pow(2, 8 - bitsPerSample);
        return Math.floor(colorSample * multiplier + (multiplier - 1))
    }, parseTIFF: function (tiffData, canvas) {
        canvas = canvas || cc.newElement("canvas");
        this._tiffData = tiffData;
        this.canvas = canvas;
        this.checkLittleEndian();
        if (!this.hasTowel())return;
        var firstIFDByteOffset = this.getUint32(4);
        this._fileDirectories.length = 0;
        this.parseFileDirectory(firstIFDByteOffset);
        var fileDirectory = this._fileDirectories[0];
        var imageWidth = fileDirectory["ImageWidth"].values[0];
        var imageLength =
            fileDirectory["ImageLength"].values[0];
        this.canvas.width = imageWidth;
        this.canvas.height = imageLength;
        var strips = [];
        var compression = fileDirectory["Compression"] ? fileDirectory["Compression"].values[0] : 1;
        var samplesPerPixel = fileDirectory["SamplesPerPixel"].values[0];
        var sampleProperties = [];
        var bitsPerPixel = 0;
        var hasBytesPerPixel = false;
        fileDirectory["BitsPerSample"].values.forEach(function (bitsPerSample, i, bitsPerSampleValues) {
            sampleProperties[i] = {bitsPerSample: bitsPerSample, hasBytesPerSample: false, bytesPerSample: undefined};
            if (bitsPerSample % 8 === 0) {
                sampleProperties[i].hasBytesPerSample = true;
                sampleProperties[i].bytesPerSample = bitsPerSample / 8
            }
            bitsPerPixel += bitsPerSample
        }, this);
        if (bitsPerPixel % 8 === 0) {
            hasBytesPerPixel = true;
            var bytesPerPixel = bitsPerPixel / 8
        }
        var stripOffsetValues = fileDirectory["StripOffsets"].values;
        var numStripOffsetValues = stripOffsetValues.length;
        if (fileDirectory["StripByteCounts"])var stripByteCountValues = fileDirectory["StripByteCounts"].values; else {
            cc.log("Missing StripByteCounts!");
            if (numStripOffsetValues ===
                1)var stripByteCountValues = [Math.ceil(imageWidth * imageLength * bitsPerPixel / 8)]; else throw Error("Cannot recover from missing StripByteCounts");
        }
        for (var i = 0; i < numStripOffsetValues; i++) {
            var stripOffset = stripOffsetValues[i];
            strips[i] = [];
            var stripByteCount = stripByteCountValues[i];
            for (var byteOffset = 0, bitOffset = 0, jIncrement = 1, getHeader = true, pixel = [], numBytes = 0, sample = 0, currentSample = 0; byteOffset < stripByteCount; byteOffset += jIncrement)switch (compression) {
                case 1:
                    for (var m = 0, pixel = []; m < samplesPerPixel; m++)if (sampleProperties[m].hasBytesPerSample) {
                        var sampleOffset =
                            sampleProperties[m].bytesPerSample * m;
                        pixel.push(this.getBytes(sampleProperties[m].bytesPerSample, stripOffset + byteOffset + sampleOffset))
                    } else {
                        var sampleInfo = this.getBits(sampleProperties[m].bitsPerSample, stripOffset + byteOffset, bitOffset);
                        pixel.push(sampleInfo.bits);
                        byteOffset = sampleInfo.byteOffset - stripOffset;
                        bitOffset = sampleInfo.bitOffset;
                        throw RangeError("Cannot handle sub-byte bits per sample");
                    }
                    strips[i].push(pixel);
                    if (hasBytesPerPixel)jIncrement = bytesPerPixel; else {
                        jIncrement = 0;
                        throw RangeError("Cannot handle sub-byte bits per pixel");
                    }
                    break;
                case 2:
                    break;
                case 3:
                    break;
                case 4:
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 32773:
                    if (getHeader) {
                        getHeader = false;
                        var blockLength = 1;
                        var iterations = 1;
                        var header = this.getInt8(stripOffset + byteOffset);
                        if (header >= 0 && header <= 127)blockLength = header + 1; else if (header >= -127 && header <= -1)iterations = -header + 1; else getHeader = true
                    } else {
                        var currentByte = this.getUint8(stripOffset + byteOffset);
                        for (var m = 0; m < iterations; m++) {
                            if (sampleProperties[sample].hasBytesPerSample) {
                                currentSample = currentSample << 8 * numBytes |
                                    currentByte;
                                numBytes++;
                                if (numBytes === sampleProperties[sample].bytesPerSample) {
                                    pixel.push(currentSample);
                                    currentSample = numBytes = 0;
                                    sample++
                                }
                            } else throw RangeError("Cannot handle sub-byte bits per sample");
                            if (sample === samplesPerPixel) {
                                strips[i].push(pixel);
                                pixel = [];
                                sample = 0
                            }
                        }
                        blockLength--;
                        if (blockLength === 0)getHeader = true
                    }
                    jIncrement = 1;
                    break;
                default:
                    break
            }
        }
        if (canvas.getContext) {
            var ctx = this.canvas.getContext("2d");
            ctx.fillStyle = "rgba(255, 255, 255, 0)";
            var rowsPerStrip = fileDirectory["RowsPerStrip"] ? fileDirectory["RowsPerStrip"].values[0] :
                imageLength;
            var numStrips = strips.length;
            var imageLengthModRowsPerStrip = imageLength % rowsPerStrip;
            var rowsInLastStrip = imageLengthModRowsPerStrip === 0 ? rowsPerStrip : imageLengthModRowsPerStrip;
            var numRowsInStrip = rowsPerStrip;
            var numRowsInPreviousStrip = 0;
            var photometricInterpretation = fileDirectory["PhotometricInterpretation"].values[0];
            var extraSamplesValues = [];
            var numExtraSamples = 0;
            if (fileDirectory["ExtraSamples"]) {
                extraSamplesValues = fileDirectory["ExtraSamples"].values;
                numExtraSamples = extraSamplesValues.length
            }
            if (fileDirectory["ColorMap"]) {
                var colorMapValues =
                    fileDirectory["ColorMap"].values;
                var colorMapSampleSize = Math.pow(2, sampleProperties[0].bitsPerSample)
            }
            for (var i = 0; i < numStrips; i++) {
                if (i + 1 === numStrips)numRowsInStrip = rowsInLastStrip;
                var numPixels = strips[i].length;
                var yPadding = numRowsInPreviousStrip * i;
                for (var y = 0, j = 0; y < numRowsInStrip, j < numPixels; y++)for (var x = 0; x < imageWidth; x++, j++) {
                    var pixelSamples = strips[i][j];
                    var red = 0;
                    var green = 0;
                    var blue = 0;
                    var opacity = 1;
                    if (numExtraSamples > 0)for (var k = 0; k < numExtraSamples; k++)if (extraSamplesValues[k] === 1 || extraSamplesValues[k] ===
                        2) {
                        opacity = pixelSamples[3 + k] / 256;
                        break
                    }
                    switch (photometricInterpretation) {
                        case 0:
                            if (sampleProperties[0].hasBytesPerSample)var invertValue = Math.pow(16, sampleProperties[0].bytesPerSample * 2);
                            pixelSamples.forEach(function (sample, index, samples) {
                                samples[index] = invertValue - sample
                            });
                        case 1:
                            red = green = blue = this.clampColorSample(pixelSamples[0], sampleProperties[0].bitsPerSample);
                            break;
                        case 2:
                            red = this.clampColorSample(pixelSamples[0], sampleProperties[0].bitsPerSample);
                            green = this.clampColorSample(pixelSamples[1],
                                sampleProperties[1].bitsPerSample);
                            blue = this.clampColorSample(pixelSamples[2], sampleProperties[2].bitsPerSample);
                            break;
                        case 3:
                            if (colorMapValues === undefined)throw Error("Palette image missing color map");
                            var colorMapIndex = pixelSamples[0];
                            red = this.clampColorSample(colorMapValues[colorMapIndex], 16);
                            green = this.clampColorSample(colorMapValues[colorMapSampleSize + colorMapIndex], 16);
                            blue = this.clampColorSample(colorMapValues[2 * colorMapSampleSize + colorMapIndex], 16);
                            break;
                        default:
                            throw RangeError("Unknown Photometric Interpretation:",
                                photometricInterpretation);
                            break
                    }
                    ctx.fillStyle = "rgba(" + red + ", " + green + ", " + blue + ", " + opacity + ")";
                    ctx.fillRect(x, yPadding + y, 1, 1)
                }
                numRowsInPreviousStrip = numRowsInStrip
            }
        }
        return this.canvas
    }, fieldTagNames: {315: "Artist", 258: "BitsPerSample", 265: "CellLength", 264: "CellWidth", 320: "ColorMap", 259: "Compression", 33432: "Copyright", 306: "DateTime", 338: "ExtraSamples", 266: "FillOrder", 289: "FreeByteCounts", 288: "FreeOffsets", 291: "GrayResponseCurve", 290: "GrayResponseUnit", 316: "HostComputer", 270: "ImageDescription", 257: "ImageLength",
        256: "ImageWidth", 271: "Make", 281: "MaxSampleValue", 280: "MinSampleValue", 272: "Model", 254: "NewSubfileType", 274: "Orientation", 262: "PhotometricInterpretation", 284: "PlanarConfiguration", 296: "ResolutionUnit", 278: "RowsPerStrip", 277: "SamplesPerPixel", 305: "Software", 279: "StripByteCounts", 273: "StripOffsets", 255: "SubfileType", 263: "Threshholding", 282: "XResolution", 283: "YResolution", 326: "BadFaxLines", 327: "CleanFaxData", 343: "ClipPath", 328: "ConsecutiveBadFaxLines", 433: "Decode", 434: "DefaultImageColor", 269: "DocumentName",
        336: "DotRange", 321: "HalftoneHints", 346: "Indexed", 347: "JPEGTables", 285: "PageName", 297: "PageNumber", 317: "Predictor", 319: "PrimaryChromaticities", 532: "ReferenceBlackWhite", 339: "SampleFormat", 559: "StripRowCounts", 330: "SubIFDs", 292: "T4Options", 293: "T6Options", 325: "TileByteCounts", 323: "TileLength", 324: "TileOffsets", 322: "TileWidth", 301: "TransferFunction", 318: "WhitePoint", 344: "XClipPathUnits", 286: "XPosition", 529: "YCbCrCoefficients", 531: "YCbCrPositioning", 530: "YCbCrSubSampling", 345: "YClipPathUnits", 287: "YPosition",
        37378: "ApertureValue", 40961: "ColorSpace", 36868: "DateTimeDigitized", 36867: "DateTimeOriginal", 34665: "Exif IFD", 36864: "ExifVersion", 33434: "ExposureTime", 41728: "FileSource", 37385: "Flash", 40960: "FlashpixVersion", 33437: "FNumber", 42016: "ImageUniqueID", 37384: "LightSource", 37500: "MakerNote", 37377: "ShutterSpeedValue", 37510: "UserComment", 33723: "IPTC", 34675: "ICC Profile", 700: "XMP", 42112: "GDAL_METADATA", 42113: "GDAL_NODATA", 34377: "Photoshop"}, fieldTypeNames: {1: "BYTE", 2: "ASCII", 3: "SHORT", 4: "LONG", 5: "RATIONAL", 6: "SBYTE",
        7: "UNDEFINED", 8: "SSHORT", 9: "SLONG", 10: "SRATIONAL", 11: "FLOAT", 12: "DOUBLE"}};
cc.Particle = function (pos, startPos, color, deltaColor, size, deltaSize, rotation, deltaRotation, timeToLive, atlasIndex, modeA, modeB) {
    this.pos = pos ? pos : cc.p(0, 0);
    this.startPos = startPos ? startPos : cc.p(0, 0);
    this.color = color ? color : {r: 0, g: 0, b: 0, a: 255};
    this.deltaColor = deltaColor ? deltaColor : {r: 0, g: 0, b: 0, a: 255};
    this.size = size || 0;
    this.deltaSize = deltaSize || 0;
    this.rotation = rotation || 0;
    this.deltaRotation = deltaRotation || 0;
    this.timeToLive = timeToLive || 0;
    this.atlasIndex = atlasIndex || 0;
    this.modeA = modeA ? modeA : new cc.Particle.ModeA;
    this.modeB = modeB ? modeB : new cc.Particle.ModeB;
    this.isChangeColor = false;
    this.drawPos = cc.p(0, 0)
};
cc.Particle.ModeA = function (dir, radialAccel, tangentialAccel) {
    this.dir = dir ? dir : cc.p(0, 0);
    this.radialAccel = radialAccel || 0;
    this.tangentialAccel = tangentialAccel || 0
};
cc.Particle.ModeB = function (angle, degreesPerSecond, radius, deltaRadius) {
    this.angle = angle || 0;
    this.degreesPerSecond = degreesPerSecond || 0;
    this.radius = radius || 0;
    this.deltaRadius = deltaRadius || 0
};
cc.Particle.TemporaryPoints = [cc.p(), cc.p(), cc.p(), cc.p()];
cc.ParticleSystem = cc.Node.extend({_plistFile: "", _elapsed: 0, _dontTint: false, modeA: null, modeB: null, _className: "ParticleSystem", _pointZeroForParticle: cc.p(0, 0), _particles: null, _emitCounter: 0, _particleIdx: 0, _batchNode: null, atlasIndex: 0, _transformSystemDirty: false, _allocatedParticles: 0, drawMode: null, shapeType: null, _isActive: false, particleCount: 0, duration: 0, _sourcePosition: null, _posVar: null, life: 0, lifeVar: 0, angle: 0, angleVar: 0, startSize: 0, startSizeVar: 0, endSize: 0, endSizeVar: 0, _startColor: null, _startColorVar: null,
    _endColor: null, _endColorVar: null, startSpin: 0, startSpinVar: 0, endSpin: 0, endSpinVar: 0, emissionRate: 0, _totalParticles: 0, _texture: null, _blendFunc: null, _opacityModifyRGB: false, positionType: null, autoRemoveOnFinish: false, emitterMode: 0, _quads: null, _indices: null, _buffersVBO: null, _pointRect: null, _textureLoaded: null, _quadsArrayBuffer: null, ctor: function (plistFile) {
        cc.Node.prototype.ctor.call(this);
        this.emitterMode = cc.ParticleSystem.MODE_GRAVITY;
        this.modeA = new cc.ParticleSystem.ModeA;
        this.modeB = new cc.ParticleSystem.ModeB;
        this._blendFunc = {src: cc.BLEND_SRC, dst: cc.BLEND_DST};
        this._particles = [];
        this._sourcePosition = cc.p(0, 0);
        this._posVar = cc.p(0, 0);
        this._startColor = cc.color(255, 255, 255, 255);
        this._startColorVar = cc.color(255, 255, 255, 255);
        this._endColor = cc.color(255, 255, 255, 255);
        this._endColorVar = cc.color(255, 255, 255, 255);
        this._plistFile = "";
        this._elapsed = 0;
        this._dontTint = false;
        this._pointZeroForParticle = cc.p(0, 0);
        this._emitCounter = 0;
        this._particleIdx = 0;
        this._batchNode = null;
        this.atlasIndex = 0;
        this._transformSystemDirty = false;
        this._allocatedParticles = 0;
        this.drawMode = cc.ParticleSystem.SHAPE_MODE;
        this.shapeType = cc.ParticleSystem.BALL_SHAPE;
        this._isActive = false;
        this.particleCount = 0;
        this.duration = 0;
        this.life = 0;
        this.lifeVar = 0;
        this.angle = 0;
        this.angleVar = 0;
        this.startSize = 0;
        this.startSizeVar = 0;
        this.endSize = 0;
        this.endSizeVar = 0;
        this.startSpin = 0;
        this.startSpinVar = 0;
        this.endSpin = 0;
        this.endSpinVar = 0;
        this.emissionRate = 0;
        this._totalParticles = 0;
        this._texture = null;
        this._opacityModifyRGB = false;
        this.positionType = cc.ParticleSystem.TYPE_FREE;
        this.autoRemoveOnFinish = false;
        this._buffersVBO = [0, 0];
        this._quads = [];
        this._indices = [];
        this._pointRect = cc.rect(0, 0, 0, 0);
        this._textureLoaded = true;
        if (cc._renderType === cc._RENDER_TYPE_WEBGL)this._quadsArrayBuffer = null;
        if (!plistFile || typeof plistFile === "number") {
            var ton = plistFile || 100;
            this.setDrawMode(cc.ParticleSystem.TEXTURE_MODE);
            this.initWithTotalParticles(ton)
        } else if (plistFile)this.initWithFile(plistFile)
    }, initIndices: function () {
        var locIndices = this._indices;
        for (var i = 0, len = this._totalParticles; i <
            len; ++i) {
            var i6 = i * 6;
            var i4 = i * 4;
            locIndices[i6 + 0] = i4 + 0;
            locIndices[i6 + 1] = i4 + 1;
            locIndices[i6 + 2] = i4 + 2;
            locIndices[i6 + 5] = i4 + 1;
            locIndices[i6 + 4] = i4 + 2;
            locIndices[i6 + 3] = i4 + 3
        }
    }, initTexCoordsWithRect: function (pointRect) {
        var scaleFactor = cc.contentScaleFactor();
        var rect = cc.rect(pointRect.x * scaleFactor, pointRect.y * scaleFactor, pointRect.width * scaleFactor, pointRect.height * scaleFactor);
        var wide = pointRect.width;
        var high = pointRect.height;
        if (this._texture) {
            wide = this._texture.pixelsWidth;
            high = this._texture.pixelsHeight
        }
        if (cc._renderType ===
            cc._RENDER_TYPE_CANVAS)return;
        var left, bottom, right, top;
        if (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL) {
            left = (rect.x * 2 + 1) / (wide * 2);
            bottom = (rect.y * 2 + 1) / (high * 2);
            right = left + (rect.width * 2 - 2) / (wide * 2);
            top = bottom + (rect.height * 2 - 2) / (high * 2)
        } else {
            left = rect.x / wide;
            bottom = rect.y / high;
            right = left + rect.width / wide;
            top = bottom + rect.height / high
        }
        var temp = top;
        top = bottom;
        bottom = temp;
        var quads;
        var start = 0, end = 0;
        if (this._batchNode) {
            quads = this._batchNode.textureAtlas.quads;
            start = this.atlasIndex;
            end = this.atlasIndex + this._totalParticles
        } else {
            quads =
                this._quads;
            start = 0;
            end = this._totalParticles
        }
        for (var i = start; i < end; i++) {
            if (!quads[i])quads[i] = cc.V3F_C4B_T2F_QuadZero();
            var selQuad = quads[i];
            selQuad.bl.texCoords.u = left;
            selQuad.bl.texCoords.v = bottom;
            selQuad.br.texCoords.u = right;
            selQuad.br.texCoords.v = bottom;
            selQuad.tl.texCoords.u = left;
            selQuad.tl.texCoords.v = top;
            selQuad.tr.texCoords.u = right;
            selQuad.tr.texCoords.v = top
        }
    }, getBatchNode: function () {
        return this._batchNode
    }, setBatchNode: function (batchNode) {
        if (this._batchNode != batchNode) {
            var oldBatch = this._batchNode;
            this._batchNode = batchNode;
            if (batchNode) {
                var locParticles = this._particles;
                for (var i = 0; i < this._totalParticles; i++)locParticles[i].atlasIndex = i
            }
            if (!batchNode) {
                this._allocMemory();
                this.initIndices();
                this.setTexture(oldBatch.getTexture());
                this._setupVBO()
            } else if (!oldBatch) {
                this._batchNode.textureAtlas._copyQuadsToTextureAtlas(this._quads, this.atlasIndex);
                cc._renderContext.deleteBuffer(this._buffersVBO[1])
            }
        }
    }, getAtlasIndex: function () {
        return this.atlasIndex
    }, setAtlasIndex: function (atlasIndex) {
        this.atlasIndex =
            atlasIndex
    }, getDrawMode: function () {
        return this.drawMode
    }, setDrawMode: function (drawMode) {
        this.drawMode = drawMode
    }, getShapeType: function () {
        return this.shapeType
    }, setShapeType: function (shapeType) {
        this.shapeType = shapeType
    }, isActive: function () {
        return this._isActive
    }, getParticleCount: function () {
        return this.particleCount
    }, setParticleCount: function (particleCount) {
        this.particleCount = particleCount
    }, getDuration: function () {
        return this.duration
    }, setDuration: function (duration) {
        this.duration = duration
    }, getSourcePosition: function () {
        return{x: this._sourcePosition.x,
            y: this._sourcePosition.y}
    }, setSourcePosition: function (sourcePosition) {
        this._sourcePosition = sourcePosition
    }, getPosVar: function () {
        return{x: this._posVar.x, y: this._posVar.y}
    }, setPosVar: function (posVar) {
        this._posVar = posVar
    }, getLife: function () {
        return this.life
    }, setLife: function (life) {
        this.life = life
    }, getLifeVar: function () {
        return this.lifeVar
    }, setLifeVar: function (lifeVar) {
        this.lifeVar = lifeVar
    }, getAngle: function () {
        return this.angle
    }, setAngle: function (angle) {
        this.angle = angle
    }, getAngleVar: function () {
        return this.angleVar
    },
    setAngleVar: function (angleVar) {
        this.angleVar = angleVar
    }, getGravity: function () {
        if (this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY)cc.log("cc.ParticleBatchNode.getGravity() : Particle Mode should be Gravity");
        var locGravity = this.modeA.gravity;
        return cc.p(locGravity.x, locGravity.y)
    }, setGravity: function (gravity) {
        if (this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY)cc.log("cc.ParticleBatchNode.setGravity() : Particle Mode should be Gravity");
        this.modeA.gravity = gravity
    }, getSpeed: function () {
        if (this.emitterMode !==
            cc.ParticleSystem.MODE_GRAVITY)cc.log("cc.ParticleBatchNode.getSpeed() : Particle Mode should be Gravity");
        return this.modeA.speed
    }, setSpeed: function (speed) {
        if (this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY)cc.log("cc.ParticleBatchNode.setSpeed() : Particle Mode should be Gravity");
        this.modeA.speed = speed
    }, getSpeedVar: function () {
        if (this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY)cc.log("cc.ParticleBatchNode.getSpeedVar() : Particle Mode should be Gravity");
        return this.modeA.speedVar
    }, setSpeedVar: function (speedVar) {
        if (this.emitterMode !==
            cc.ParticleSystem.MODE_GRAVITY)cc.log("cc.ParticleBatchNode.setSpeedVar() : Particle Mode should be Gravity");
        this.modeA.speedVar = speedVar
    }, getTangentialAccel: function () {
        if (this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY)cc.log("cc.ParticleBatchNode.getTangentialAccel() : Particle Mode should be Gravity");
        return this.modeA.tangentialAccel
    }, setTangentialAccel: function (tangentialAccel) {
        if (this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY)cc.log("cc.ParticleBatchNode.setTangentialAccel() : Particle Mode should be Gravity");
        this.modeA.tangentialAccel = tangentialAccel
    }, getTangentialAccelVar: function () {
        if (this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY)cc.log("cc.ParticleBatchNode.getTangentialAccelVar() : Particle Mode should be Gravity");
        return this.modeA.tangentialAccelVar
    }, setTangentialAccelVar: function (tangentialAccelVar) {
        if (this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY)cc.log("cc.ParticleBatchNode.setTangentialAccelVar() : Particle Mode should be Gravity");
        this.modeA.tangentialAccelVar = tangentialAccelVar
    }, getRadialAccel: function () {
        if (this.emitterMode !==
            cc.ParticleSystem.MODE_GRAVITY)cc.log("cc.ParticleBatchNode.getRadialAccel() : Particle Mode should be Gravity");
        return this.modeA.radialAccel
    }, setRadialAccel: function (radialAccel) {
        if (this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY)cc.log("cc.ParticleBatchNode.setRadialAccel() : Particle Mode should be Gravity");
        this.modeA.radialAccel = radialAccel
    }, getRadialAccelVar: function () {
        if (this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY)cc.log("cc.ParticleBatchNode.getRadialAccelVar() : Particle Mode should be Gravity");
        return this.modeA.radialAccelVar
    }, setRadialAccelVar: function (radialAccelVar) {
        if (this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY)cc.log("cc.ParticleBatchNode.setRadialAccelVar() : Particle Mode should be Gravity");
        this.modeA.radialAccelVar = radialAccelVar
    }, getRotationIsDir: function () {
        if (this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY)cc.log("cc.ParticleBatchNode.getRotationIsDir() : Particle Mode should be Gravity");
        return this.modeA.rotationIsDir
    }, setRotationIsDir: function (t) {
        if (this.emitterMode !==
            cc.ParticleSystem.MODE_GRAVITY)cc.log("cc.ParticleBatchNode.setRotationIsDir() : Particle Mode should be Gravity");
        this.modeA.rotationIsDir = t
    }, getStartRadius: function () {
        if (this.emitterMode !== cc.ParticleSystem.MODE_RADIUS)cc.log("cc.ParticleBatchNode.getStartRadius() : Particle Mode should be Radius");
        return this.modeB.startRadius
    }, setStartRadius: function (startRadius) {
        if (this.emitterMode !== cc.ParticleSystem.MODE_RADIUS)cc.log("cc.ParticleBatchNode.setStartRadius() : Particle Mode should be Radius");
        this.modeB.startRadius = startRadius
    }, getStartRadiusVar: function () {
        if (this.emitterMode !== cc.ParticleSystem.MODE_RADIUS)cc.log("cc.ParticleBatchNode.getStartRadiusVar() : Particle Mode should be Radius");
        return this.modeB.startRadiusVar
    }, setStartRadiusVar: function (startRadiusVar) {
        if (this.emitterMode !== cc.ParticleSystem.MODE_RADIUS)cc.log("cc.ParticleBatchNode.setStartRadiusVar() : Particle Mode should be Radius");
        this.modeB.startRadiusVar = startRadiusVar
    }, getEndRadius: function () {
        if (this.emitterMode !==
            cc.ParticleSystem.MODE_RADIUS)cc.log("cc.ParticleBatchNode.getEndRadius() : Particle Mode should be Radius");
        return this.modeB.endRadius
    }, setEndRadius: function (endRadius) {
        if (this.emitterMode !== cc.ParticleSystem.MODE_RADIUS)cc.log("cc.ParticleBatchNode.setEndRadius() : Particle Mode should be Radius");
        this.modeB.endRadius = endRadius
    }, getEndRadiusVar: function () {
        if (this.emitterMode !== cc.ParticleSystem.MODE_RADIUS)cc.log("cc.ParticleBatchNode.getEndRadiusVar() : Particle Mode should be Radius");
        return this.modeB.endRadiusVar
    },
    setEndRadiusVar: function (endRadiusVar) {
        if (this.emitterMode !== cc.ParticleSystem.MODE_RADIUS)cc.log("cc.ParticleBatchNode.setEndRadiusVar() : Particle Mode should be Radius");
        this.modeB.endRadiusVar = endRadiusVar
    }, getRotatePerSecond: function () {
        if (this.emitterMode !== cc.ParticleSystem.MODE_RADIUS)cc.log("cc.ParticleBatchNode.getRotatePerSecond() : Particle Mode should be Radius");
        return this.modeB.rotatePerSecond
    }, setRotatePerSecond: function (degrees) {
        if (this.emitterMode !== cc.ParticleSystem.MODE_RADIUS)cc.log("cc.ParticleBatchNode.setRotatePerSecond() : Particle Mode should be Radius");
        this.modeB.rotatePerSecond = degrees
    }, getRotatePerSecondVar: function () {
        if (this.emitterMode !== cc.ParticleSystem.MODE_RADIUS)cc.log("cc.ParticleBatchNode.getRotatePerSecondVar() : Particle Mode should be Radius");
        return this.modeB.rotatePerSecondVar
    }, setRotatePerSecondVar: function (degrees) {
        if (this.emitterMode !== cc.ParticleSystem.MODE_RADIUS)cc.log("cc.ParticleBatchNode.setRotatePerSecondVar() : Particle Mode should be Radius");
        this.modeB.rotatePerSecondVar = degrees
    }, setScale: function (scale, scaleY) {
        this._transformSystemDirty =
            true;
        cc.Node.prototype.setScale.call(this, scale, scaleY)
    }, setRotation: function (newRotation) {
        this._transformSystemDirty = true;
        cc.Node.prototype.setRotation.call(this, newRotation)
    }, setScaleX: function (newScaleX) {
        this._transformSystemDirty = true;
        cc.Node.prototype.setScaleX.call(this, newScaleX)
    }, setScaleY: function (newScaleY) {
        this._transformSystemDirty = true;
        cc.Node.prototype.setScaleY.call(this, newScaleY)
    }, getStartSize: function () {
        return this.startSize
    }, setStartSize: function (startSize) {
        this.startSize = startSize
    },
    getStartSizeVar: function () {
        return this.startSizeVar
    }, setStartSizeVar: function (startSizeVar) {
        this.startSizeVar = startSizeVar
    }, getEndSize: function () {
        return this.endSize
    }, setEndSize: function (endSize) {
        this.endSize = endSize
    }, getEndSizeVar: function () {
        return this.endSizeVar
    }, setEndSizeVar: function (endSizeVar) {
        this.endSizeVar = endSizeVar
    }, getStartColor: function () {
        return cc.color(this._startColor.r, this._startColor.g, this._startColor.b, this._startColor.a)
    }, setStartColor: function (startColor) {
        this._startColor =
            cc.color(startColor)
    }, getStartColorVar: function () {
        return cc.color(this._startColorVar.r, this._startColorVar.g, this._startColorVar.b, this._startColorVar.a)
    }, setStartColorVar: function (startColorVar) {
        this._startColorVar = cc.color(startColorVar)
    }, getEndColor: function () {
        return cc.color(this._endColor.r, this._endColor.g, this._endColor.b, this._endColor.a)
    }, setEndColor: function (endColor) {
        this._endColor = cc.color(endColor)
    }, getEndColorVar: function () {
        return cc.color(this._endColorVar.r, this._endColorVar.g, this._endColorVar.b,
            this._endColorVar.a)
    }, setEndColorVar: function (endColorVar) {
        this._endColorVar = cc.color(endColorVar)
    }, getStartSpin: function () {
        return this.startSpin
    }, setStartSpin: function (startSpin) {
        this.startSpin = startSpin
    }, getStartSpinVar: function () {
        return this.startSpinVar
    }, setStartSpinVar: function (startSpinVar) {
        this.startSpinVar = startSpinVar
    }, getEndSpin: function () {
        return this.endSpin
    }, setEndSpin: function (endSpin) {
        this.endSpin = endSpin
    }, getEndSpinVar: function () {
        return this.endSpinVar
    }, setEndSpinVar: function (endSpinVar) {
        this.endSpinVar =
            endSpinVar
    }, getEmissionRate: function () {
        return this.emissionRate
    }, setEmissionRate: function (emissionRate) {
        this.emissionRate = emissionRate
    }, getTotalParticles: function () {
        return this._totalParticles
    }, setTotalParticles: function (tp) {
        if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
            this._totalParticles = tp < 200 ? tp : 200;
            return
        }
        if (tp > this._allocatedParticles) {
            var quadSize = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
            this._indices = new Uint16Array(tp * 6);
            var locQuadsArrayBuffer = new ArrayBuffer(tp * quadSize);
            var locParticles = this._particles;
            locParticles.length = 0;
            var locQuads = this._quads;
            locQuads.length = 0;
            for (var j = 0; j < tp; j++) {
                locParticles[j] = new cc.Particle;
                locQuads[j] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, locQuadsArrayBuffer, j * quadSize)
            }
            this._allocatedParticles = tp;
            this._totalParticles = tp;
            if (this._batchNode)for (var i = 0; i < tp; i++)locParticles[i].atlasIndex = i;
            this._quadsArrayBuffer = locQuadsArrayBuffer;
            this.initIndices();
            this._setupVBO();
            if (this._texture)this.initTexCoordsWithRect(cc.rect(0, 0, this._texture.width, this._texture.height))
        } else this._totalParticles =
            tp;
        this.resetSystem()
    }, getTexture: function () {
        return this._texture
    }, setTexture: function (texture) {
        if (texture.isLoaded())this.setTextureWithRect(texture, cc.rect(0, 0, texture.width, texture.height)); else {
            this._textureLoaded = false;
            texture.addLoadedEventListener(function (sender) {
                this._textureLoaded = true;
                this.setTextureWithRect(sender, cc.rect(0, 0, sender.width, sender.height))
            }, this)
        }
    }, getBlendFunc: function () {
        return this._blendFunc
    }, setBlendFunc: function (src, dst) {
        if (dst === undefined) {
            if (this._blendFunc != src) {
                this._blendFunc =
                    src;
                this._updateBlendFunc()
            }
        } else if (this._blendFunc.src != src || this._blendFunc.dst != dst) {
            this._blendFunc = {src: src, dst: dst};
            this._updateBlendFunc()
        }
    }, isOpacityModifyRGB: function () {
        return this._opacityModifyRGB
    }, setOpacityModifyRGB: function (newValue) {
        this._opacityModifyRGB = newValue
    }, isBlendAdditive: function () {
        return this._blendFunc.src == cc.SRC_ALPHA && this._blendFunc.dst == cc.ONE || this._blendFunc.src == cc.ONE && this._blendFunc.dst == cc.ONE
    }, setBlendAdditive: function (isBlendAdditive) {
        var locBlendFunc = this._blendFunc;
        if (isBlendAdditive) {
            locBlendFunc.src = cc.SRC_ALPHA;
            locBlendFunc.dst = cc.ONE
        } else if (cc._renderType === cc._RENDER_TYPE_WEBGL)if (this._texture && !this._texture.hasPremultipliedAlpha()) {
            locBlendFunc.src = cc.SRC_ALPHA;
            locBlendFunc.dst = cc.ONE_MINUS_SRC_ALPHA
        } else {
            locBlendFunc.src = cc.BLEND_SRC;
            locBlendFunc.dst = cc.BLEND_DST
        } else {
            locBlendFunc.src = cc.BLEND_SRC;
            locBlendFunc.dst = cc.BLEND_DST
        }
    }, getPositionType: function () {
        return this.positionType
    }, setPositionType: function (positionType) {
        this.positionType = positionType
    },
    isAutoRemoveOnFinish: function () {
        return this.autoRemoveOnFinish
    }, setAutoRemoveOnFinish: function (isAutoRemoveOnFinish) {
        this.autoRemoveOnFinish = isAutoRemoveOnFinish
    }, getEmitterMode: function () {
        return this.emitterMode
    }, setEmitterMode: function (emitterMode) {
        this.emitterMode = emitterMode
    }, init: function () {
        return this.initWithTotalParticles(150)
    }, initWithFile: function (plistFile) {
        this._plistFile = plistFile;
        var dict = cc.loader.getRes(plistFile);
        if (!dict) {
            cc.log("cc.ParticleSystem.initWithFile(): Particles: file not found");
            return false
        }
        return this.initWithDictionary(dict, "")
    }, getBoundingBoxToWorld: function () {
        return cc.rect(0, 0, cc._canvas.width, cc._canvas.height)
    }, initWithDictionary: function (dictionary, dirname) {
        var ret = false;
        var buffer = null;
        var image = null;
        var locValueForKey = this._valueForKey;
        var maxParticles = parseInt(locValueForKey("maxParticles", dictionary));
        if (this.initWithTotalParticles(maxParticles)) {
            this.angle = parseFloat(locValueForKey("angle", dictionary));
            this.angleVar = parseFloat(locValueForKey("angleVariance",
                dictionary));
            this.duration = parseFloat(locValueForKey("duration", dictionary));
            this._blendFunc.src = parseInt(locValueForKey("blendFuncSource", dictionary));
            this._blendFunc.dst = parseInt(locValueForKey("blendFuncDestination", dictionary));
            var locStartColor = this._startColor;
            locStartColor.r = parseFloat(locValueForKey("startColorRed", dictionary)) * 255;
            locStartColor.g = parseFloat(locValueForKey("startColorGreen", dictionary)) * 255;
            locStartColor.b = parseFloat(locValueForKey("startColorBlue", dictionary)) * 255;
            locStartColor.a =
                parseFloat(locValueForKey("startColorAlpha", dictionary)) * 255;
            var locStartColorVar = this._startColorVar;
            locStartColorVar.r = parseFloat(locValueForKey("startColorVarianceRed", dictionary)) * 255;
            locStartColorVar.g = parseFloat(locValueForKey("startColorVarianceGreen", dictionary)) * 255;
            locStartColorVar.b = parseFloat(locValueForKey("startColorVarianceBlue", dictionary)) * 255;
            locStartColorVar.a = parseFloat(locValueForKey("startColorVarianceAlpha", dictionary)) * 255;
            var locEndColor = this._endColor;
            locEndColor.r = parseFloat(locValueForKey("finishColorRed",
                dictionary)) * 255;
            locEndColor.g = parseFloat(locValueForKey("finishColorGreen", dictionary)) * 255;
            locEndColor.b = parseFloat(locValueForKey("finishColorBlue", dictionary)) * 255;
            locEndColor.a = parseFloat(locValueForKey("finishColorAlpha", dictionary)) * 255;
            var locEndColorVar = this._endColorVar;
            locEndColorVar.r = parseFloat(locValueForKey("finishColorVarianceRed", dictionary)) * 255;
            locEndColorVar.g = parseFloat(locValueForKey("finishColorVarianceGreen", dictionary)) * 255;
            locEndColorVar.b = parseFloat(locValueForKey("finishColorVarianceBlue",
                dictionary)) * 255;
            locEndColorVar.a = parseFloat(locValueForKey("finishColorVarianceAlpha", dictionary)) * 255;
            this.startSize = parseFloat(locValueForKey("startParticleSize", dictionary));
            this.startSizeVar = parseFloat(locValueForKey("startParticleSizeVariance", dictionary));
            this.endSize = parseFloat(locValueForKey("finishParticleSize", dictionary));
            this.endSizeVar = parseFloat(locValueForKey("finishParticleSizeVariance", dictionary));
            this.setPosition(parseFloat(locValueForKey("sourcePositionx", dictionary)), parseFloat(locValueForKey("sourcePositiony",
                dictionary)));
            this._posVar.x = parseFloat(locValueForKey("sourcePositionVariancex", dictionary));
            this._posVar.y = parseFloat(locValueForKey("sourcePositionVariancey", dictionary));
            this.startSpin = parseFloat(locValueForKey("rotationStart", dictionary));
            this.startSpinVar = parseFloat(locValueForKey("rotationStartVariance", dictionary));
            this.endSpin = parseFloat(locValueForKey("rotationEnd", dictionary));
            this.endSpinVar = parseFloat(locValueForKey("rotationEndVariance", dictionary));
            this.emitterMode = parseInt(locValueForKey("emitterType",
                dictionary));
            if (this.emitterMode == cc.ParticleSystem.MODE_GRAVITY) {
                var locModeA = this.modeA;
                locModeA.gravity.x = parseFloat(locValueForKey("gravityx", dictionary));
                locModeA.gravity.y = parseFloat(locValueForKey("gravityy", dictionary));
                locModeA.speed = parseFloat(locValueForKey("speed", dictionary));
                locModeA.speedVar = parseFloat(locValueForKey("speedVariance", dictionary));
                var pszTmp = locValueForKey("radialAcceleration", dictionary);
                locModeA.radialAccel = pszTmp ? parseFloat(pszTmp) : 0;
                pszTmp = locValueForKey("radialAccelVariance",
                    dictionary);
                locModeA.radialAccelVar = pszTmp ? parseFloat(pszTmp) : 0;
                pszTmp = locValueForKey("tangentialAcceleration", dictionary);
                locModeA.tangentialAccel = pszTmp ? parseFloat(pszTmp) : 0;
                pszTmp = locValueForKey("tangentialAccelVariance", dictionary);
                locModeA.tangentialAccelVar = pszTmp ? parseFloat(pszTmp) : 0;
                var locRotationIsDir = locValueForKey("rotationIsDir", dictionary).toLowerCase();
                locModeA.rotationIsDir = locRotationIsDir != null && (locRotationIsDir === "true" || locRotationIsDir === "1")
            } else if (this.emitterMode == cc.ParticleSystem.MODE_RADIUS) {
                var locModeB =
                    this.modeB;
                locModeB.startRadius = parseFloat(locValueForKey("maxRadius", dictionary));
                locModeB.startRadiusVar = parseFloat(locValueForKey("maxRadiusVariance", dictionary));
                locModeB.endRadius = parseFloat(locValueForKey("minRadius", dictionary));
                locModeB.endRadiusVar = 0;
                locModeB.rotatePerSecond = parseFloat(locValueForKey("rotatePerSecond", dictionary));
                locModeB.rotatePerSecondVar = parseFloat(locValueForKey("rotatePerSecondVariance", dictionary))
            } else {
                cc.log("cc.ParticleSystem.initWithDictionary(): Invalid emitterType in config file");
                return false
            }
            this.life = parseFloat(locValueForKey("particleLifespan", dictionary));
            this.lifeVar = parseFloat(locValueForKey("particleLifespanVariance", dictionary));
            this.emissionRate = this._totalParticles / this.life;
            if (!this._batchNode) {
                this._opacityModifyRGB = false;
                var textureName = locValueForKey("textureFileName", dictionary);
                var imgPath = cc.path.changeBasename(this._plistFile, textureName);
                var tex = cc.textureCache.textureForKey(imgPath);
                if (tex)this.setTexture(tex); else {
                    var textureData = locValueForKey("textureImageData",
                        dictionary);
                    if (textureData && textureData.length == 0) {
                        tex = cc.textureCache.addImage(imgPath);
                        if (!tex)return false;
                        this.setTexture(tex)
                    } else {
                        buffer = cc.unzipBase64AsArray(textureData, 1);
                        if (!buffer) {
                            cc.log("cc.ParticleSystem: error decoding or ungzipping textureImageData");
                            return false
                        }
                        var imageFormat = cc.getImageFormatByData(buffer);
                        if (imageFormat !== cc.FMT_TIFF && imageFormat !== cc.FMT_PNG) {
                            cc.log("cc.ParticleSystem: unknown image format with Data");
                            return false
                        }
                        var canvasObj = cc.newElement("canvas");
                        if (imageFormat ===
                            cc.FMT_PNG) {
                            var myPngObj = new cc.PNGReader(buffer);
                            myPngObj.render(canvasObj)
                        } else {
                            var myTIFFObj = cc.tiffReader;
                            myTIFFObj.parseTIFF(buffer, canvasObj)
                        }
                        cc.textureCache.cacheImage(imgPath, canvasObj);
                        var addTexture = cc.textureCache.textureForKey(imgPath);
                        if (!addTexture)cc.log("cc.ParticleSystem.initWithDictionary() : error loading the texture");
                        this.setTexture(addTexture)
                    }
                }
            }
            ret = true
        }
        return ret
    }, initWithTotalParticles: function (numberOfParticles) {
        this._totalParticles = numberOfParticles;
        var i, locParticles = this._particles;
        locParticles.length = 0;
        for (i = 0; i < numberOfParticles; i++)locParticles[i] = new cc.Particle;
        if (!locParticles) {
            cc.log("Particle system: not enough memory");
            return false
        }
        this._allocatedParticles = numberOfParticles;
        if (this._batchNode)for (i = 0; i < this._totalParticles; i++)locParticles[i].atlasIndex = i;
        this._isActive = true;
        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;
        this.positionType = cc.ParticleSystem.TYPE_FREE;
        this.emitterMode = cc.ParticleSystem.MODE_GRAVITY;
        this.autoRemoveOnFinish = false;
        this._transformSystemDirty =
            false;
        this.scheduleUpdateWithPriority(1);
        if (cc._renderType === cc._RENDER_TYPE_WEBGL) {
            if (!this._allocMemory())return false;
            this.initIndices();
            this._setupVBO();
            this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)
        }
        return true
    }, destroyParticleSystem: function () {
        this.unscheduleUpdate()
    }, addParticle: function () {
        if (this.isFull())return false;
        var particle, particles = this._particles;
        if (cc._renderType === cc._RENDER_TYPE_CANVAS)if (this.particleCount < particles.length)particle = particles[this.particleCount];
        else {
            particle = new cc.Particle;
            particles.push(particle)
        } else particle = particles[this.particleCount];
        this.initParticle(particle);
        ++this.particleCount;
        return true
    }, initParticle: function (particle) {
        var locRandomMinus11 = cc.randomMinus1To1;
        particle.timeToLive = this.life + this.lifeVar * locRandomMinus11();
        particle.timeToLive = Math.max(0, particle.timeToLive);
        particle.pos.x = this._sourcePosition.x + this._posVar.x * locRandomMinus11();
        particle.pos.y = this._sourcePosition.y + this._posVar.y * locRandomMinus11();
        var start,
            end;
        var locStartColor = this._startColor, locStartColorVar = this._startColorVar;
        var locEndColor = this._endColor, locEndColorVar = this._endColorVar;
        if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
            start = cc.color(cc.clampf(locStartColor.r + locStartColorVar.r * locRandomMinus11(), 0, 255), cc.clampf(locStartColor.g + locStartColorVar.g * locRandomMinus11(), 0, 255), cc.clampf(locStartColor.b + locStartColorVar.b * locRandomMinus11(), 0, 255), cc.clampf(locStartColor.a + locStartColorVar.a * locRandomMinus11(), 0, 255));
            end = cc.color(cc.clampf(locEndColor.r +
                locEndColorVar.r * locRandomMinus11(), 0, 255), cc.clampf(locEndColor.g + locEndColorVar.g * locRandomMinus11(), 0, 255), cc.clampf(locEndColor.b + locEndColorVar.b * locRandomMinus11(), 0, 255), cc.clampf(locEndColor.a + locEndColorVar.a * locRandomMinus11(), 0, 255))
        } else {
            start = {r: cc.clampf(locStartColor.r + locStartColorVar.r * locRandomMinus11(), 0, 255), g: cc.clampf(locStartColor.g + locStartColorVar.g * locRandomMinus11(), 0, 255), b: cc.clampf(locStartColor.b + locStartColorVar.b * locRandomMinus11(), 0, 255), a: cc.clampf(locStartColor.a +
                locStartColorVar.a * locRandomMinus11(), 0, 255)};
            end = {r: cc.clampf(locEndColor.r + locEndColorVar.r * locRandomMinus11(), 0, 255), g: cc.clampf(locEndColor.g + locEndColorVar.g * locRandomMinus11(), 0, 255), b: cc.clampf(locEndColor.b + locEndColorVar.b * locRandomMinus11(), 0, 255), a: cc.clampf(locEndColor.a + locEndColorVar.a * locRandomMinus11(), 0, 255)}
        }
        particle.color = start;
        var locParticleDeltaColor = particle.deltaColor, locParticleTimeToLive = particle.timeToLive;
        locParticleDeltaColor.r = (end.r - start.r) / locParticleTimeToLive;
        locParticleDeltaColor.g =
            (end.g - start.g) / locParticleTimeToLive;
        locParticleDeltaColor.b = (end.b - start.b) / locParticleTimeToLive;
        locParticleDeltaColor.a = (end.a - start.a) / locParticleTimeToLive;
        var startS = this.startSize + this.startSizeVar * locRandomMinus11();
        startS = Math.max(0, startS);
        particle.size = startS;
        if (this.endSize === cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE)particle.deltaSize = 0; else {
            var endS = this.endSize + this.endSizeVar * locRandomMinus11();
            endS = Math.max(0, endS);
            particle.deltaSize = (endS - startS) / locParticleTimeToLive
        }
        var startA =
            this.startSpin + this.startSpinVar * locRandomMinus11();
        var endA = this.endSpin + this.endSpinVar * locRandomMinus11();
        particle.rotation = startA;
        particle.deltaRotation = (endA - startA) / locParticleTimeToLive;
        if (this.positionType == cc.ParticleSystem.TYPE_FREE)particle.startPos = this.convertToWorldSpace(this._pointZeroForParticle); else if (this.positionType == cc.ParticleSystem.TYPE_RELATIVE) {
            particle.startPos.x = this._position.x;
            particle.startPos.y = this._position.y
        }
        var a = cc.degreesToRadians(this.angle + this.angleVar * locRandomMinus11());
        if (this.emitterMode === cc.ParticleSystem.MODE_GRAVITY) {
            var locModeA = this.modeA, locParticleModeA = particle.modeA;
            var s = locModeA.speed + locModeA.speedVar * locRandomMinus11();
            locParticleModeA.dir.x = Math.cos(a);
            locParticleModeA.dir.y = Math.sin(a);
            cc.pMultIn(locParticleModeA.dir, s);
            locParticleModeA.radialAccel = locModeA.radialAccel + locModeA.radialAccelVar * locRandomMinus11();
            locParticleModeA.tangentialAccel = locModeA.tangentialAccel + locModeA.tangentialAccelVar * locRandomMinus11();
            if (locModeA.rotationIsDir)particle.rotation = -cc.radiansToDegrees(cc.pToAngle(locParticleModeA.dir))
        } else {
            var locModeB = this.modeB, locParitlceModeB = particle.modeB;
            var startRadius = locModeB.startRadius + locModeB.startRadiusVar * locRandomMinus11();
            var endRadius = locModeB.endRadius + locModeB.endRadiusVar * locRandomMinus11();
            locParitlceModeB.radius = startRadius;
            locParitlceModeB.deltaRadius = locModeB.endRadius === cc.ParticleSystem.START_RADIUS_EQUAL_TO_END_RADIUS ? 0 : (endRadius - startRadius) / locParticleTimeToLive;
            locParitlceModeB.angle = a;
            locParitlceModeB.degreesPerSecond =
                cc.degreesToRadians(locModeB.rotatePerSecond + locModeB.rotatePerSecondVar * locRandomMinus11())
        }
    }, stopSystem: function () {
        this._isActive = false;
        this._elapsed = this.duration;
        this._emitCounter = 0
    }, resetSystem: function () {
        this._isActive = true;
        this._elapsed = 0;
        var locParticles = this._particles;
        for (this._particleIdx = 0; this._particleIdx < this.particleCount; ++this._particleIdx)locParticles[this._particleIdx].timeToLive = 0
    }, isFull: function () {
        return this.particleCount >= this._totalParticles
    }, updateQuadWithParticle: function (particle, newPosition) {
        var quad = null;
        if (this._batchNode) {
            var batchQuads = this._batchNode.textureAtlas.quads;
            quad = batchQuads[this.atlasIndex + particle.atlasIndex];
            this._batchNode.textureAtlas.dirty = true
        } else quad = this._quads[this._particleIdx];
        var r, g, b, a;
        if (this._opacityModifyRGB) {
            r = 0 | particle.color.r * particle.color.a / 255;
            g = 0 | particle.color.g * particle.color.a / 255;
            b = 0 | particle.color.b * particle.color.a / 255
        } else {
            r = 0 | particle.color.r;
            g = 0 | particle.color.g;
            b = 0 | particle.color.b
        }
        a = 0 | particle.color.a;
        var locColors = quad.bl.colors;
        locColors.r = r;
        locColors.g = g;
        locColors.b = b;
        locColors.a = a;
        locColors = quad.br.colors;
        locColors.r = r;
        locColors.g = g;
        locColors.b = b;
        locColors.a = a;
        locColors = quad.tl.colors;
        locColors.r = r;
        locColors.g = g;
        locColors.b = b;
        locColors.a = a;
        locColors = quad.tr.colors;
        locColors.r = r;
        locColors.g = g;
        locColors.b = b;
        locColors.a = a;
        var size_2 = particle.size / 2;
        if (particle.rotation) {
            var x1 = -size_2;
            var y1 = -size_2;
            var x2 = size_2;
            var y2 = size_2;
            var x = newPosition.x;
            var y = newPosition.y;
            var rad = -cc.degreesToRadians(particle.rotation);
            var cr =
                Math.cos(rad);
            var sr = Math.sin(rad);
            var ax = x1 * cr - y1 * sr + x;
            var ay = x1 * sr + y1 * cr + y;
            var bx = x2 * cr - y1 * sr + x;
            var by = x2 * sr + y1 * cr + y;
            var cx = x2 * cr - y2 * sr + x;
            var cy = x2 * sr + y2 * cr + y;
            var dx = x1 * cr - y2 * sr + x;
            var dy = x1 * sr + y2 * cr + y;
            quad.bl.vertices.x = ax;
            quad.bl.vertices.y = ay;
            quad.br.vertices.x = bx;
            quad.br.vertices.y = by;
            quad.tl.vertices.x = dx;
            quad.tl.vertices.y = dy;
            quad.tr.vertices.x = cx;
            quad.tr.vertices.y = cy
        } else {
            quad.bl.vertices.x = newPosition.x - size_2;
            quad.bl.vertices.y = newPosition.y - size_2;
            quad.br.vertices.x = newPosition.x + size_2;
            quad.br.vertices.y = newPosition.y - size_2;
            quad.tl.vertices.x = newPosition.x - size_2;
            quad.tl.vertices.y = newPosition.y + size_2;
            quad.tr.vertices.x = newPosition.x + size_2;
            quad.tr.vertices.y = newPosition.y + size_2
        }
    }, postStep: function () {
        if (cc._renderType === cc._RENDER_TYPE_WEBGL) {
            var gl = cc._renderContext;
            gl.bindBuffer(gl.ARRAY_BUFFER, this._buffersVBO[0]);
            gl.bufferData(gl.ARRAY_BUFFER, this._quadsArrayBuffer, gl.DYNAMIC_DRAW)
        }
    }, update: function (dt) {
        if (this._isActive && this.emissionRate) {
            var rate = 1 / this.emissionRate;
            if (this.particleCount <
                this._totalParticles)this._emitCounter += dt;
            while (this.particleCount < this._totalParticles && this._emitCounter > rate) {
                this.addParticle();
                this._emitCounter -= rate
            }
            this._elapsed += dt;
            if (this.duration != -1 && this.duration < this._elapsed)this.stopSystem()
        }
        this._particleIdx = 0;
        var currentPosition = cc.Particle.TemporaryPoints[0];
        if (this.positionType == cc.ParticleSystem.TYPE_FREE)cc.pIn(currentPosition, this.convertToWorldSpace(this._pointZeroForParticle)); else if (this.positionType == cc.ParticleSystem.TYPE_RELATIVE) {
            currentPosition.x =
                this._position.x;
            currentPosition.y = this._position.y
        }
        if (this._visible) {
            var tpa = cc.Particle.TemporaryPoints[1], tpb = cc.Particle.TemporaryPoints[2], tpc = cc.Particle.TemporaryPoints[3];
            var locParticles = this._particles;
            while (this._particleIdx < this.particleCount) {
                cc.pZeroIn(tpa);
                cc.pZeroIn(tpb);
                cc.pZeroIn(tpc);
                var selParticle = locParticles[this._particleIdx];
                selParticle.timeToLive -= dt;
                if (selParticle.timeToLive > 0) {
                    if (this.emitterMode == cc.ParticleSystem.MODE_GRAVITY) {
                        var tmp = tpc, radial = tpa, tangential = tpb;
                        if (selParticle.pos.x ||
                            selParticle.pos.y) {
                            cc.pIn(radial, selParticle.pos);
                            cc.pNormalizeIn(radial)
                        } else cc.pZeroIn(radial);
                        cc.pIn(tangential, radial);
                        cc.pMultIn(radial, selParticle.modeA.radialAccel);
                        var newy = tangential.x;
                        tangential.x = -tangential.y;
                        tangential.y = newy;
                        cc.pMultIn(tangential, selParticle.modeA.tangentialAccel);
                        cc.pIn(tmp, radial);
                        cc.pAddIn(tmp, tangential);
                        cc.pAddIn(tmp, this.modeA.gravity);
                        cc.pMultIn(tmp, dt);
                        cc.pAddIn(selParticle.modeA.dir, tmp);
                        cc.pIn(tmp, selParticle.modeA.dir);
                        cc.pMultIn(tmp, dt);
                        cc.pAddIn(selParticle.pos,
                            tmp)
                    } else {
                        var selModeB = selParticle.modeB;
                        selModeB.angle += selModeB.degreesPerSecond * dt;
                        selModeB.radius += selModeB.deltaRadius * dt;
                        selParticle.pos.x = -Math.cos(selModeB.angle) * selModeB.radius;
                        selParticle.pos.y = -Math.sin(selModeB.angle) * selModeB.radius
                    }
                    if (!this._dontTint || cc._renderType === cc._RENDER_TYPE_CANVAS) {
                        selParticle.color.r += selParticle.deltaColor.r * dt;
                        selParticle.color.g += selParticle.deltaColor.g * dt;
                        selParticle.color.b += selParticle.deltaColor.b * dt;
                        selParticle.color.a += selParticle.deltaColor.a *
                            dt;
                        selParticle.isChangeColor = true
                    }
                    selParticle.size += selParticle.deltaSize * dt;
                    selParticle.size = Math.max(0, selParticle.size);
                    selParticle.rotation += selParticle.deltaRotation * dt;
                    var newPos = tpa;
                    if (this.positionType == cc.ParticleSystem.TYPE_FREE || this.positionType == cc.ParticleSystem.TYPE_RELATIVE) {
                        var diff = tpb;
                        cc.pIn(diff, currentPosition);
                        cc.pSubIn(diff, selParticle.startPos);
                        cc.pIn(newPos, selParticle.pos);
                        cc.pSubIn(newPos, diff)
                    } else cc.pIn(newPos, selParticle.pos);
                    if (this._batchNode) {
                        newPos.x += this._position.x;
                        newPos.y += this._position.y
                    }
                    if (cc._renderType == cc._RENDER_TYPE_WEBGL)this.updateQuadWithParticle(selParticle, newPos); else cc.pIn(selParticle.drawPos, newPos);
                    ++this._particleIdx
                } else {
                    var currentIndex = selParticle.atlasIndex;
                    if (this._particleIdx !== this.particleCount - 1) {
                        var deadParticle = locParticles[this._particleIdx];
                        locParticles[this._particleIdx] = locParticles[this.particleCount - 1];
                        locParticles[this.particleCount - 1] = deadParticle
                    }
                    if (this._batchNode) {
                        this._batchNode.disableParticle(this.atlasIndex + currentIndex);
                        locParticles[this.particleCount - 1].atlasIndex = currentIndex
                    }
                    --this.particleCount;
                    if (this.particleCount == 0 && this.autoRemoveOnFinish) {
                        this.unscheduleUpdate();
                        this._parent.removeChild(this, true);
                        return
                    }
                }
            }
            this._transformSystemDirty = false
        }
        if (!this._batchNode)this.postStep()
    }, updateWithNoTime: function () {
        this.update(0)
    }, _valueForKey: function (key, dict) {
        if (dict) {
            var pString = dict[key];
            return pString != null ? pString : ""
        }
        return""
    }, _updateBlendFunc: function () {
        if (this._batchNode) {
            cc.log("Can't change blending functions when the particle is being batched");
            return
        }
        var locTexture = this._texture;
        if (locTexture && locTexture instanceof cc.Texture2D) {
            this._opacityModifyRGB = false;
            var locBlendFunc = this._blendFunc;
            if (locBlendFunc.src == cc.BLEND_SRC && locBlendFunc.dst == cc.BLEND_DST)if (locTexture.hasPremultipliedAlpha())this._opacityModifyRGB = true; else {
                locBlendFunc.src = cc.SRC_ALPHA;
                locBlendFunc.dst = cc.ONE_MINUS_SRC_ALPHA
            }
        }
    }, clone: function () {
        var retParticle = new cc.ParticleSystem;
        if (retParticle.initWithTotalParticles(this.getTotalParticles())) {
            retParticle.setAngle(this.getAngle());
            retParticle.setAngleVar(this.getAngleVar());
            retParticle.setDuration(this.getDuration());
            var blend = this.getBlendFunc();
            retParticle.setBlendFunc(blend.src, blend.dst);
            retParticle.setStartColor(this.getStartColor());
            retParticle.setStartColorVar(this.getStartColorVar());
            retParticle.setEndColor(this.getEndColor());
            retParticle.setEndColorVar(this.getEndColorVar());
            retParticle.setStartSize(this.getStartSize());
            retParticle.setStartSizeVar(this.getStartSizeVar());
            retParticle.setEndSize(this.getEndSize());
            retParticle.setEndSizeVar(this.getEndSizeVar());
            retParticle.setPosition(cc.p(this.x, this.y));
            retParticle.setPosVar(cc.p(this.getPosVar().x, this.getPosVar().y));
            retParticle.setStartSpin(this.getStartSpin() || 0);
            retParticle.setStartSpinVar(this.getStartSpinVar() || 0);
            retParticle.setEndSpin(this.getEndSpin() || 0);
            retParticle.setEndSpinVar(this.getEndSpinVar() || 0);
            retParticle.setEmitterMode(this.getEmitterMode());
            if (this.getEmitterMode() == cc.ParticleSystem.MODE_GRAVITY) {
                var gra = this.getGravity();
                retParticle.setGravity(cc.p(gra.x, gra.y));
                retParticle.setSpeed(this.getSpeed());
                retParticle.setSpeedVar(this.getSpeedVar());
                retParticle.setRadialAccel(this.getRadialAccel());
                retParticle.setRadialAccelVar(this.getRadialAccelVar());
                retParticle.setTangentialAccel(this.getTangentialAccel());
                retParticle.setTangentialAccelVar(this.getTangentialAccelVar())
            } else if (this.getEmitterMode() == cc.ParticleSystem.MODE_RADIUS) {
                retParticle.setStartRadius(this.getStartRadius());
                retParticle.setStartRadiusVar(this.getStartRadiusVar());
                retParticle.setEndRadius(this.getEndRadius());
                retParticle.setEndRadiusVar(this.getEndRadiusVar());
                retParticle.setRotatePerSecond(this.getRotatePerSecond());
                retParticle.setRotatePerSecondVar(this.getRotatePerSecondVar())
            }
            retParticle.setLife(this.getLife());
            retParticle.setLifeVar(this.getLifeVar());
            retParticle.setEmissionRate(this.getEmissionRate());
            if (!this.getBatchNode()) {
                retParticle.setOpacityModifyRGB(this.isOpacityModifyRGB());
                var texture = this.getTexture();
                if (texture) {
                    var size = texture.getContentSize();
                    retParticle.setTextureWithRect(texture, cc.rect(0, 0, size.width, size.height))
                }
            }
        }
        return retParticle
    },
    setDisplayFrame: function (spriteFrame) {
        var locOffset = spriteFrame.getOffsetInPixels();
        if (locOffset.x != 0 || locOffset.y != 0)cc.log("cc.ParticleSystem.setDisplayFrame(): QuadParticle only supports SpriteFrames with no offsets");
        if (cc._renderType === cc._RENDER_TYPE_WEBGL)if (!this._texture || spriteFrame.getTexture()._webTextureObj != this._texture._webTextureObj)this.setTexture(spriteFrame.getTexture())
    }, setTextureWithRect: function (texture, rect) {
        var locTexture = this._texture;
        if (cc._renderType === cc._RENDER_TYPE_WEBGL) {
            if ((!locTexture ||
                texture._webTextureObj != locTexture._webTextureObj) && locTexture != texture) {
                this._texture = texture;
                this._updateBlendFunc()
            }
        } else if ((!locTexture || texture != locTexture) && locTexture != texture) {
            this._texture = texture;
            this._updateBlendFunc()
        }
        this._pointRect = rect;
        this.initTexCoordsWithRect(rect)
    }, draw: function (ctx) {
        if (!this._textureLoaded || this._batchNode)return;
        if (cc._renderType === cc._RENDER_TYPE_CANVAS)this._drawForCanvas(ctx); else this._drawForWebGL(ctx);
        cc.g_NumberOfDraws++
    }, _drawForCanvas: function (ctx) {
        var context =
            ctx || cc._renderContext;
        context.save();
        if (this.isBlendAdditive())context.globalCompositeOperation = "lighter"; else context.globalCompositeOperation = "source-over";
        for (var i = 0; i < this.particleCount; i++) {
            var particle = this._particles[i];
            var lpx = 0 | particle.size * 0.5;
            if (this.drawMode == cc.ParticleSystem.TEXTURE_MODE) {
                var element = this._texture.getHtmlElementObj();
                if (!element.width || !element.height)continue;
                context.save();
                context.globalAlpha = particle.color.a / 255;
                context.translate(0 | particle.drawPos.x, -(0 | particle.drawPos.y));
                var size = Math.floor(particle.size / 4) * 4;
                var w = this._pointRect.width;
                var h = this._pointRect.height;
                context.scale(Math.max(1 / w * size, 1E-6), Math.max(1 / h * size, 1E-6));
                if (particle.rotation)context.rotate(cc.degreesToRadians(particle.rotation));
                context.translate(-(0 | w / 2), -(0 | h / 2));
                if (particle.isChangeColor) {
                    var cacheTextureForColor = cc.textureCache.getTextureColors(element);
                    if (cacheTextureForColor) {
                        if (!cacheTextureForColor.tintCache) {
                            cacheTextureForColor.tintCache = cc.newElement("canvas");
                            cacheTextureForColor.tintCache.width =
                                element.width;
                            cacheTextureForColor.tintCache.height = element.height
                        }
                        cc.generateTintImage(element, cacheTextureForColor, particle.color, this._pointRect, cacheTextureForColor.tintCache);
                        element = cacheTextureForColor.tintCache
                    }
                }
                context.drawImage(element, 0, 0);
                context.restore()
            } else {
                context.save();
                context.globalAlpha = particle.color.a / 255;
                context.translate(0 | particle.drawPos.x, -(0 | particle.drawPos.y));
                if (this.shapeType == cc.ParticleSystem.STAR_SHAPE) {
                    if (particle.rotation)context.rotate(cc.degreesToRadians(particle.rotation));
                    cc._drawingUtil.drawStar(context, lpx, particle.color)
                } else cc._drawingUtil.drawColorBall(context, lpx, particle.color);
                context.restore()
            }
        }
        context.restore()
    }, _drawForWebGL: function (ctx) {
        if (!this._texture)return;
        var gl = ctx || cc._renderContext;
        this._shaderProgram.use();
        this._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glBindTexture2D(this._texture);
        cc.glBlendFuncForParticle(this._blendFunc.src, this._blendFunc.dst);
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
        gl.bindBuffer(gl.ARRAY_BUFFER,
            this._buffersVBO[0]);
        gl.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, gl.FLOAT, false, 24, 0);
        gl.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, gl.UNSIGNED_BYTE, true, 24, 12);
        gl.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, gl.FLOAT, false, 24, 16);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
        gl.drawElements(gl.TRIANGLES, this._particleIdx * 6, gl.UNSIGNED_SHORT, 0)
    }, listenBackToForeground: function (obj) {
        if (cc.TEXTURE_ATLAS_USE_VAO)this._setupVBOandVAO(); else this._setupVBO()
    }, _setupVBOandVAO: function () {
    },
    _setupVBO: function () {
        if (cc._renderType == cc._RENDER_TYPE_CANVAS)return;
        var gl = cc._renderContext;
        this._buffersVBO[0] = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this._buffersVBO[0]);
        gl.bufferData(gl.ARRAY_BUFFER, this._quadsArrayBuffer, gl.DYNAMIC_DRAW);
        this._buffersVBO[1] = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._indices, gl.STATIC_DRAW)
    }, _allocMemory: function () {
        if (cc._renderType === cc._RENDER_TYPE_CANVAS)return true;
        if (this._batchNode) {
            cc.log("cc.ParticleSystem._allocMemory(): Memory should not be allocated when not using batchNode");
            return false
        }
        var quadSize = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
        var totalParticles = this._totalParticles;
        var locQuads = this._quads;
        locQuads.length = 0;
        this._indices = new Uint16Array(totalParticles * 6);
        var locQuadsArrayBuffer = new ArrayBuffer(quadSize * totalParticles);
        for (var i = 0; i < totalParticles; i++)locQuads[i] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, locQuadsArrayBuffer, i * quadSize);
        if (!locQuads || !this._indices) {
            cc.log("cocos2d: Particle system: not enough memory");
            return false
        }
        this._quadsArrayBuffer =
            locQuadsArrayBuffer;
        return true
    }});
var _p = cc.ParticleSystem.prototype;
_p.opacityModifyRGB;
cc.defineGetterSetter(_p, "opacityModifyRGB", _p.isOpacityModifyRGB, _p.setOpacityModifyRGB);
_p.batchNode;
cc.defineGetterSetter(_p, "batchNode", _p.getBatchNode, _p.setBatchNode);
_p.active;
cc.defineGetterSetter(_p, "active", _p.isActive);
_p.sourcePos;
cc.defineGetterSetter(_p, "sourcePos", _p.getSourcePosition, _p.setSourcePosition);
_p.posVar;
cc.defineGetterSetter(_p, "posVar", _p.getPosVar, _p.setPosVar);
_p.gravity;
cc.defineGetterSetter(_p, "gravity", _p.getGravity, _p.setGravity);
_p.speed;
cc.defineGetterSetter(_p, "speed", _p.getSpeed, _p.setSpeed);
_p.speedVar;
cc.defineGetterSetter(_p, "speedVar", _p.getSpeedVar, _p.setSpeedVar);
_p.tangentialAccel;
cc.defineGetterSetter(_p, "tangentialAccel", _p.getTangentialAccel, _p.setTangentialAccel);
_p.tangentialAccelVar;
cc.defineGetterSetter(_p, "tangentialAccelVar", _p.getTangentialAccelVar, _p.setTangentialAccelVar);
_p.radialAccel;
cc.defineGetterSetter(_p, "radialAccel", _p.getRadialAccel, _p.setRadialAccel);
_p.radialAccelVar;
cc.defineGetterSetter(_p, "radialAccelVar", _p.getRadialAccelVar, _p.setRadialAccelVar);
_p.rotationIsDir;
cc.defineGetterSetter(_p, "rotationIsDir", _p.getRotationIsDir, _p.setRotationIsDir);
_p.startRadius;
cc.defineGetterSetter(_p, "startRadius", _p.getStartRadius, _p.setStartRadius);
_p.startRadiusVar;
cc.defineGetterSetter(_p, "startRadiusVar", _p.getStartRadiusVar, _p.setStartRadiusVar);
_p.endRadius;
cc.defineGetterSetter(_p, "endRadius", _p.getEndRadius, _p.setEndRadius);
_p.endRadiusVar;
cc.defineGetterSetter(_p, "endRadiusVar", _p.getEndRadiusVar, _p.setEndRadiusVar);
_p.rotatePerS;
cc.defineGetterSetter(_p, "rotatePerS", _p.getRotatePerSecond, _p.setRotatePerSecond);
_p.rotatePerSVar;
cc.defineGetterSetter(_p, "rotatePerSVar", _p.getRotatePerSecondVar, _p.setRotatePerSecondVar);
_p.startColor;
cc.defineGetterSetter(_p, "startColor", _p.getStartColor, _p.setStartColor);
_p.startColorVar;
cc.defineGetterSetter(_p, "startColorVar", _p.getStartColorVar, _p.setStartColorVar);
_p.endColor;
cc.defineGetterSetter(_p, "endColor", _p.getEndColor, _p.setEndColor);
_p.endColorVar;
cc.defineGetterSetter(_p, "endColorVar", _p.getEndColorVar, _p.setEndColorVar);
_p.totalParticles;
cc.defineGetterSetter(_p, "totalParticles", _p.getTotalParticles, _p.setTotalParticles);
_p.texture;
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.ParticleSystem.create = function (plistFile) {
    return new cc.ParticleSystem(plistFile)
};
cc.ParticleSystem.ModeA = function (gravity, speed, speedVar, tangentialAccel, tangentialAccelVar, radialAccel, radialAccelVar, rotationIsDir) {
    this.gravity = gravity ? gravity : cc.p(0, 0);
    this.speed = speed || 0;
    this.speedVar = speedVar || 0;
    this.tangentialAccel = tangentialAccel || 0;
    this.tangentialAccelVar = tangentialAccelVar || 0;
    this.radialAccel = radialAccel || 0;
    this.radialAccelVar = radialAccelVar || 0;
    this.rotationIsDir = rotationIsDir || false
};
cc.ParticleSystem.ModeB = function (startRadius, startRadiusVar, endRadius, endRadiusVar, rotatePerSecond, rotatePerSecondVar) {
    this.startRadius = startRadius || 0;
    this.startRadiusVar = startRadiusVar || 0;
    this.endRadius = endRadius || 0;
    this.endRadiusVar = endRadiusVar || 0;
    this.rotatePerSecond = rotatePerSecond || 0;
    this.rotatePerSecondVar = rotatePerSecondVar || 0
};
cc.ParticleSystem.SHAPE_MODE = 0;
cc.ParticleSystem.TEXTURE_MODE = 1;
cc.ParticleSystem.STAR_SHAPE = 0;
cc.ParticleSystem.BALL_SHAPE = 1;
cc.ParticleSystem.DURATION_INFINITY = -1;
cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE = -1;
cc.ParticleSystem.START_RADIUS_EQUAL_TO_END_RADIUS = -1;
cc.ParticleSystem.MODE_GRAVITY = 0;
cc.ParticleSystem.MODE_RADIUS = 1;
cc.ParticleSystem.TYPE_FREE = 0;
cc.ParticleSystem.TYPE_RELATIVE = 1;
cc.ParticleSystem.TYPE_GROUPED = 2;
cc.ParticleFire = cc.ParticleSystem.extend({init: function () {
    return this.initWithTotalParticles(cc._renderType === cc._RENDER_TYPE_WEBGL ? 300 : 150)
}, initWithTotalParticles: function (numberOfParticles) {
    if (cc.ParticleSystem.prototype.initWithTotalParticles.call(this, numberOfParticles)) {
        this.setDuration(cc.ParticleSystem.DURATION_INFINITY);
        this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY);
        this.setGravity(cc.p(0, 0));
        this.setRadialAccel(0);
        this.setRadialAccelVar(0);
        this.setSpeed(60);
        this.setSpeedVar(20);
        this.setAngle(90);
        this.setAngleVar(10);
        var winSize = cc.director.getWinSize();
        this.setPosition(winSize.width / 2, 60);
        this.setPosVar(cc.p(40, 20));
        this.setLife(3);
        this.setLifeVar(0.25);
        this.setStartSize(54);
        this.setStartSizeVar(10);
        this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE);
        this.setEmissionRate(this.getTotalParticles() / this.getLife());
        this.setStartColor(cc.color(194, 64, 31, 255));
        this.setStartColorVar(cc.color(0, 0, 0, 0));
        this.setEndColor(cc.color(0, 0, 0, 255));
        this.setEndColorVar(cc.color(0, 0, 0, 0));
        this.setBlendAdditive(true);
        return true
    }
    return false
}});
cc.ParticleFire.create = function () {
    var ret = new cc.ParticleFire;
    if (ret.init())return ret;
    return null
};
cc.ParticleFireworks = cc.ParticleSystem.extend({init: function () {
    return this.initWithTotalParticles(cc._renderType === cc._RENDER_TYPE_WEBGL ? 1500 : 150)
}, initWithTotalParticles: function (numberOfParticles) {
    if (cc.ParticleSystem.prototype.initWithTotalParticles.call(this, numberOfParticles)) {
        this.setDuration(cc.ParticleSystem.DURATION_INFINITY);
        this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY);
        this.setGravity(cc.p(0, -90));
        this.setRadialAccel(0);
        this.setRadialAccelVar(0);
        this.setSpeed(180);
        this.setSpeedVar(50);
        var winSize = cc.director.getWinSize();
        this.setPosition(winSize.width / 2, winSize.height / 2);
        this.setAngle(90);
        this.setAngleVar(20);
        this.setLife(3.5);
        this.setLifeVar(1);
        this.setEmissionRate(this.getTotalParticles() / this.getLife());
        this.setStartColor(cc.color(128, 128, 128, 255));
        this.setStartColorVar(cc.color(128, 128, 128, 255));
        this.setEndColor(cc.color(26, 26, 26, 51));
        this.setEndColorVar(cc.color(26, 26, 26, 51));
        this.setStartSize(8);
        this.setStartSizeVar(2);
        this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE);
        this.setBlendAdditive(false);
        return true
    }
    return false
}});
cc.ParticleFireworks.create = function () {
    var ret = new cc.ParticleFireworks;
    if (ret.init())return ret;
    return null
};
cc.ParticleSun = cc.ParticleSystem.extend({init: function () {
    return this.initWithTotalParticles(cc._renderType === cc._RENDER_TYPE_WEBGL ? 350 : 150)
}, initWithTotalParticles: function (numberOfParticles) {
    if (cc.ParticleSystem.prototype.initWithTotalParticles.call(this, numberOfParticles)) {
        this.setBlendAdditive(true);
        this.setDuration(cc.ParticleSystem.DURATION_INFINITY);
        this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY);
        this.setGravity(cc.p(0, 0));
        this.setRadialAccel(0);
        this.setRadialAccelVar(0);
        this.setSpeed(20);
        this.setSpeedVar(5);
        this.setAngle(90);
        this.setAngleVar(360);
        var winSize = cc.director.getWinSize();
        this.setPosition(winSize.width / 2, winSize.height / 2);
        this.setPosVar(cc.p(0, 0));
        this.setLife(1);
        this.setLifeVar(0.5);
        this.setStartSize(30);
        this.setStartSizeVar(10);
        this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE);
        this.setEmissionRate(this.getTotalParticles() / this.getLife());
        this.setStartColor(cc.color(194, 64, 31, 255));
        this.setStartColorVar(cc.color(0, 0, 0, 0));
        this.setEndColor(cc.color(0, 0, 0,
            255));
        this.setEndColorVar(cc.color(0, 0, 0, 0));
        return true
    }
    return false
}});
cc.ParticleSun.create = function () {
    var ret = new cc.ParticleSun;
    if (ret.init())return ret;
    return null
};
cc.ParticleGalaxy = cc.ParticleSystem.extend({init: function () {
    return this.initWithTotalParticles(cc._renderType === cc._RENDER_TYPE_WEBGL ? 200 : 100)
}, initWithTotalParticles: function (numberOfParticles) {
    if (cc.ParticleSystem.prototype.initWithTotalParticles.call(this, numberOfParticles)) {
        this.setDuration(cc.ParticleSystem.DURATION_INFINITY);
        this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY);
        this.setGravity(cc.p(0, 0));
        this.setSpeed(60);
        this.setSpeedVar(10);
        this.setRadialAccel(-80);
        this.setRadialAccelVar(0);
        this.setTangentialAccel(80);
        this.setTangentialAccelVar(0);
        this.setAngle(90);
        this.setAngleVar(360);
        var winSize = cc.director.getWinSize();
        this.setPosition(winSize.width / 2, winSize.height / 2);
        this.setPosVar(cc.p(0, 0));
        this.setLife(4);
        this.setLifeVar(1);
        this.setStartSize(37);
        this.setStartSizeVar(10);
        this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE);
        this.setEmissionRate(this.getTotalParticles() / this.getLife());
        this.setStartColor(cc.color(31, 64, 194, 255));
        this.setStartColorVar(cc.color(0, 0, 0,
            0));
        this.setEndColor(cc.color(0, 0, 0, 255));
        this.setEndColorVar(cc.color(0, 0, 0, 0));
        this.setBlendAdditive(true);
        return true
    }
    return false
}});
cc.ParticleGalaxy.create = function () {
    var ret = new cc.ParticleGalaxy;
    if (ret.init())return ret;
    return null
};
cc.ParticleFlower = cc.ParticleSystem.extend({init: function () {
    return this.initWithTotalParticles(cc._renderType === cc._RENDER_TYPE_WEBGL ? 250 : 100)
}, initWithTotalParticles: function (numberOfParticles) {
    if (cc.ParticleSystem.prototype.initWithTotalParticles.call(this, numberOfParticles)) {
        this.setDuration(cc.ParticleSystem.DURATION_INFINITY);
        this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY);
        this.setGravity(cc.p(0, 0));
        this.setSpeed(80);
        this.setSpeedVar(10);
        this.setRadialAccel(-60);
        this.setRadialAccelVar(0);
        this.setTangentialAccel(15);
        this.setTangentialAccelVar(0);
        this.setAngle(90);
        this.setAngleVar(360);
        var winSize = cc.director.getWinSize();
        this.setPosition(winSize.width / 2, winSize.height / 2);
        this.setPosVar(cc.p(0, 0));
        this.setLife(4);
        this.setLifeVar(1);
        this.setStartSize(30);
        this.setStartSizeVar(10);
        this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE);
        this.setEmissionRate(this.getTotalParticles() / this.getLife());
        this.setStartColor(cc.color(128, 128, 128, 255));
        this.setStartColorVar(cc.color(128,
            128, 128, 128));
        this.setEndColor(cc.color(0, 0, 0, 255));
        this.setEndColorVar(cc.color(0, 0, 0, 0));
        this.setBlendAdditive(true);
        return true
    }
    return false
}});
cc.ParticleFlower.create = function () {
    var ret = new cc.ParticleFlower;
    if (ret.init())return ret;
    return null
};
cc.ParticleMeteor = cc.ParticleSystem.extend({init: function () {
    return this.initWithTotalParticles(cc._renderType === cc._RENDER_TYPE_WEBGL ? 150 : 100)
}, initWithTotalParticles: function (numberOfParticles) {
    if (cc.ParticleSystem.prototype.initWithTotalParticles.call(this, numberOfParticles)) {
        this.setDuration(cc.ParticleSystem.DURATION_INFINITY);
        this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY);
        this.setGravity(cc.p(-200, 200));
        this.setSpeed(15);
        this.setSpeedVar(5);
        this.setRadialAccel(0);
        this.setRadialAccelVar(0);
        this.setTangentialAccel(0);
        this.setTangentialAccelVar(0);
        this.setAngle(90);
        this.setAngleVar(360);
        var winSize = cc.director.getWinSize();
        this.setPosition(winSize.width / 2, winSize.height / 2);
        this.setPosVar(cc.p(0, 0));
        this.setLife(2);
        this.setLifeVar(1);
        this.setStartSize(60);
        this.setStartSizeVar(10);
        this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE);
        this.setEmissionRate(this.getTotalParticles() / this.getLife());
        this.setStartColor(cc.color(51, 102, 179));
        this.setStartColorVar(cc.color(0, 0, 51, 26));
        this.setEndColor(cc.color(0, 0, 0, 255));
        this.setEndColorVar(cc.color(0, 0, 0, 0));
        this.setBlendAdditive(true);
        return true
    }
    return false
}});
cc.ParticleMeteor.create = function () {
    var ret = new cc.ParticleMeteor;
    if (ret.init())return ret;
    return null
};
cc.ParticleSpiral = cc.ParticleSystem.extend({init: function () {
    return this.initWithTotalParticles(cc._renderType === cc._RENDER_TYPE_WEBGL ? 500 : 100)
}, initWithTotalParticles: function (numberOfParticles) {
    if (cc.ParticleSystem.prototype.initWithTotalParticles.call(this, numberOfParticles)) {
        this.setDuration(cc.ParticleSystem.DURATION_INFINITY);
        this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY);
        this.setGravity(cc.p(0, 0));
        this.setSpeed(150);
        this.setSpeedVar(0);
        this.setRadialAccel(-380);
        this.setRadialAccelVar(0);
        this.setTangentialAccel(45);
        this.setTangentialAccelVar(0);
        this.setAngle(90);
        this.setAngleVar(0);
        var winSize = cc.director.getWinSize();
        this.setPosition(winSize.width / 2, winSize.height / 2);
        this.setPosVar(cc.p(0, 0));
        this.setLife(12);
        this.setLifeVar(0);
        this.setStartSize(20);
        this.setStartSizeVar(0);
        this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE);
        this.setEmissionRate(this.getTotalParticles() / this.getLife());
        this.setStartColor(cc.color(128, 128, 128, 255));
        this.setStartColorVar(cc.color(128, 128,
            128, 0));
        this.setEndColor(cc.color(128, 128, 128, 255));
        this.setEndColorVar(cc.color(128, 128, 128, 0));
        this.setBlendAdditive(false);
        return true
    }
    return false
}});
cc.ParticleSpiral.create = function () {
    var ret = new cc.ParticleSpiral;
    if (ret.init())return ret;
    return null
};
cc.ParticleExplosion = cc.ParticleSystem.extend({init: function () {
    return this.initWithTotalParticles(cc._renderType === cc._RENDER_TYPE_WEBGL ? 700 : 300)
}, initWithTotalParticles: function (numberOfParticles) {
    if (cc.ParticleSystem.prototype.initWithTotalParticles.call(this, numberOfParticles)) {
        this.setDuration(0.1);
        this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY);
        this.setGravity(cc.p(0, 0));
        this.setSpeed(70);
        this.setSpeedVar(40);
        this.setRadialAccel(0);
        this.setRadialAccelVar(0);
        this.setTangentialAccel(0);
        this.setTangentialAccelVar(0);
        this.setAngle(90);
        this.setAngleVar(360);
        var winSize = cc.director.getWinSize();
        this.setPosition(winSize.width / 2, winSize.height / 2);
        this.setPosVar(cc.p(0, 0));
        this.setLife(5);
        this.setLifeVar(2);
        this.setStartSize(15);
        this.setStartSizeVar(10);
        this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE);
        this.setEmissionRate(this.getTotalParticles() / this.getDuration());
        this.setStartColor(cc.color(179, 26, 51, 255));
        this.setStartColorVar(cc.color(128, 128, 128, 0));
        this.setEndColor(cc.color(128, 128, 128, 0));
        this.setEndColorVar(cc.color(128,
            128, 128, 0));
        this.setBlendAdditive(false);
        return true
    }
    return false
}});
cc.ParticleExplosion.create = function () {
    var ret = new cc.ParticleExplosion;
    if (ret.init())return ret;
    return null
};
cc.ParticleSmoke = cc.ParticleSystem.extend({init: function () {
    return this.initWithTotalParticles(cc._renderType === cc._RENDER_TYPE_WEBGL ? 200 : 100)
}, initWithTotalParticles: function (numberOfParticles) {
    if (cc.ParticleSystem.prototype.initWithTotalParticles.call(this, numberOfParticles)) {
        this.setDuration(cc.ParticleSystem.DURATION_INFINITY);
        this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY);
        this.setGravity(cc.p(0, 0));
        this.setRadialAccel(0);
        this.setRadialAccelVar(0);
        this.setSpeed(25);
        this.setSpeedVar(10);
        this.setAngle(90);
        this.setAngleVar(5);
        var winSize = cc.director.getWinSize();
        this.setPosition(winSize.width / 2, 0);
        this.setPosVar(cc.p(20, 0));
        this.setLife(4);
        this.setLifeVar(1);
        this.setStartSize(60);
        this.setStartSizeVar(10);
        this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE);
        this.setEmissionRate(this.getTotalParticles() / this.getLife());
        this.setStartColor(cc.color(204, 204, 204, 255));
        this.setStartColorVar(cc.color(5, 5, 5, 0));
        this.setEndColor(cc.color(0, 0, 0, 255));
        this.setEndColorVar(cc.color(0, 0, 0, 0));
        this.setBlendAdditive(false);
        return true
    }
    return false
}});
cc.ParticleSmoke.create = function () {
    var ret = new cc.ParticleSmoke;
    if (ret.init())return ret;
    return null
};
cc.ParticleSnow = cc.ParticleSystem.extend({init: function () {
    return this.initWithTotalParticles(cc._renderType === cc._RENDER_TYPE_WEBGL ? 700 : 250)
}, initWithTotalParticles: function (numberOfParticles) {
    if (cc.ParticleSystem.prototype.initWithTotalParticles.call(this, numberOfParticles)) {
        this.setDuration(cc.ParticleSystem.DURATION_INFINITY);
        this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY);
        this.setGravity(cc.p(0, -1));
        this.setSpeed(5);
        this.setSpeedVar(1);
        this.setRadialAccel(0);
        this.setRadialAccelVar(1);
        this.setTangentialAccel(0);
        this.setTangentialAccelVar(1);
        var winSize = cc.director.getWinSize();
        this.setPosition(winSize.width / 2, winSize.height + 10);
        this.setPosVar(cc.p(winSize.width / 2, 0));
        this.setAngle(-90);
        this.setAngleVar(5);
        this.setLife(45);
        this.setLifeVar(15);
        this.setStartSize(10);
        this.setStartSizeVar(5);
        this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE);
        this.setEmissionRate(10);
        this.setStartColor(cc.color(255, 255, 255, 255));
        this.setStartColorVar(cc.color(0, 0, 0, 0));
        this.setEndColor(cc.color(255, 255, 255, 0));
        this.setEndColorVar(cc.color(0,
            0, 0, 0));
        this.setBlendAdditive(false);
        return true
    }
    return false
}});
cc.ParticleSnow.create = function () {
    var ret = new cc.ParticleSnow;
    if (ret.init())return ret;
    return null
};
cc.ParticleRain = cc.ParticleSystem.extend({init: function () {
    return this.initWithTotalParticles(cc._renderType === cc._RENDER_TYPE_WEBGL ? 1E3 : 300)
}, initWithTotalParticles: function (numberOfParticles) {
    if (cc.ParticleSystem.prototype.initWithTotalParticles.call(this, numberOfParticles)) {
        this.setDuration(cc.ParticleSystem.DURATION_INFINITY);
        this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY);
        this.setGravity(cc.p(10, -10));
        this.setRadialAccel(0);
        this.setRadialAccelVar(1);
        this.setTangentialAccel(0);
        this.setTangentialAccelVar(1);
        this.setSpeed(130);
        this.setSpeedVar(30);
        this.setAngle(-90);
        this.setAngleVar(5);
        var winSize = cc.director.getWinSize();
        this.setPosition(winSize.width / 2, winSize.height);
        this.setPosVar(cc.p(winSize.width / 2, 0));
        this.setLife(4.5);
        this.setLifeVar(0);
        this.setStartSize(4);
        this.setStartSizeVar(2);
        this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE);
        this.setEmissionRate(20);
        this.setStartColor(cc.color(179, 204, 255, 255));
        this.setStartColorVar(cc.color(0, 0, 0, 0));
        this.setEndColor(cc.color(179, 204, 255,
            128));
        this.setEndColorVar(cc.color(0, 0, 0, 0));
        this.setBlendAdditive(false);
        return true
    }
    return false
}});
cc.ParticleRain.create = function () {
    var ret = new cc.ParticleRain;
    if (ret.init())return ret;
    return null
};
cc.PARTICLE_DEFAULT_CAPACITY = 500;
cc.ParticleBatchNode = cc.Node.extend({textureAtlas: null, TextureProtocol: true, _blendFunc: null, _className: "ParticleBatchNode", ctor: function (fileImage, capacity) {
    cc.Node.prototype.ctor.call(this);
    this._blendFunc = {src: cc.BLEND_SRC, dst: cc.BLEND_DST};
    if (typeof fileImage == "string")this.init(fileImage, capacity); else if (fileImage instanceof cc.Texture2D)this.initWithTexture(fileImage, capacity)
}, initWithTexture: function (texture, capacity) {
    this.textureAtlas = new cc.TextureAtlas;
    this.textureAtlas.initWithTexture(texture,
        capacity);
    this._children.length = 0;
    if (cc._renderType === cc._RENDER_TYPE_WEBGL)this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
    return true
}, initWithFile: function (fileImage, capacity) {
    var tex = cc.textureCache.addImage(fileImage);
    return this.initWithTexture(tex, capacity)
}, init: function (fileImage, capacity) {
    var tex = cc.TextureCache.getInstance().addImage(fileImage);
    return this.initWithTexture(tex, capacity)
}, addChild: function (child, zOrder, tag) {
    if (!child)throw"cc.ParticleBatchNode.addChild() : child should be non-null";
    if (!(child instanceof cc.ParticleSystem))throw"cc.ParticleBatchNode.addChild() : only supports cc.ParticleSystem as children";
    zOrder = zOrder == null ? child.zIndex : zOrder;
    tag = tag == null ? child.tag : tag;
    if (child.getTexture() != this.textureAtlas.texture)throw"cc.ParticleSystem.addChild() : the child is not using the same texture id";
    var childBlendFunc = child.getBlendFunc();
    if (this._children.length === 0)this.setBlendFunc(childBlendFunc); else if (childBlendFunc.src != this._blendFunc.src || childBlendFunc.dst != this._blendFunc.dst) {
        cc.log("cc.ParticleSystem.addChild() : Can't add a ParticleSystem that uses a different blending function");
        return
    }
    var pos = this._addChildHelper(child, zOrder, tag);
    var atlasIndex = 0;
    if (pos != 0) {
        var p = this._children[pos - 1];
        atlasIndex = p.getAtlasIndex() + p.getTotalParticles()
    } else atlasIndex = 0;
    this.insertChild(child, atlasIndex);
    child.setBatchNode(this)
}, insertChild: function (pSystem, index) {
    var totalParticles = pSystem.getTotalParticles();
    var locTextureAtlas = this.textureAtlas;
    var totalQuads = locTextureAtlas.totalQuads;
    pSystem.setAtlasIndex(index);
    if (totalQuads + totalParticles > locTextureAtlas.getCapacity()) {
        this._increaseAtlasCapacityTo(totalQuads +
            totalParticles);
        locTextureAtlas.fillWithEmptyQuadsFromIndex(locTextureAtlas.getCapacity() - totalParticles, totalParticles)
    }
    if (pSystem.getAtlasIndex() + totalParticles != totalQuads)locTextureAtlas.moveQuadsFromIndex(index, index + totalParticles);
    locTextureAtlas.increaseTotalQuadsWith(totalParticles);
    this._updateAllAtlasIndexes()
}, removeChild: function (child, cleanup) {
    if (child == null)return;
    if (!(child instanceof cc.ParticleSystem))throw"cc.ParticleBatchNode.removeChild(): only supports cc.ParticleSystem as children";
    if (this._children.indexOf(child) == -1) {
        cc.log("cc.ParticleBatchNode.removeChild(): doesn't contain the sprite. Can't remove it");
        return
    }
    cc.Node.prototype.removeChild.call(this, child, cleanup);
    var locTextureAtlas = this.textureAtlas;
    locTextureAtlas.removeQuadsAtIndex(child.getAtlasIndex(), child.getTotalParticles());
    locTextureAtlas.fillWithEmptyQuadsFromIndex(locTextureAtlas.totalQuads, child.getTotalParticles());
    child.setBatchNode(null);
    this._updateAllAtlasIndexes()
}, reorderChild: function (child, zOrder) {
    if (!child)throw"cc.ParticleBatchNode.reorderChild(): child should be non-null";
    if (!(child instanceof cc.ParticleSystem))throw"cc.ParticleBatchNode.reorderChild(): only supports cc.QuadParticleSystems as children";
    if (this._children.indexOf(child) === -1) {
        cc.log("cc.ParticleBatchNode.reorderChild(): Child doesn't belong to batch");
        return
    }
    if (zOrder == child.zIndex)return;
    if (this._children.length > 1) {
        var getIndexes = this._getCurrentIndex(child, zOrder);
        if (getIndexes.oldIndex != getIndexes.newIndex) {
            this._children.splice(getIndexes.oldIndex, 1);
            this._children.splice(getIndexes.newIndex, 0,
                child);
            var oldAtlasIndex = child.getAtlasIndex();
            this._updateAllAtlasIndexes();
            var newAtlasIndex = 0;
            var locChildren = this._children;
            for (var i = 0; i < locChildren.length; i++) {
                var pNode = locChildren[i];
                if (pNode == child) {
                    newAtlasIndex = child.getAtlasIndex();
                    break
                }
            }
            this.textureAtlas.moveQuadsFromIndex(oldAtlasIndex, child.getTotalParticles(), newAtlasIndex);
            child.updateWithNoTime()
        }
    }
    child._setLocalZOrder(zOrder)
}, removeChildAtIndex: function (index, doCleanup) {
    this.removeChild(this._children[i], doCleanup)
}, removeAllChildren: function (doCleanup) {
    var locChildren =
        this._children;
    for (var i = 0; i < locChildren.length; i++)locChildren[i].setBatchNode(null);
    cc.Node.prototype.removeAllChildren.call(this, doCleanup);
    this.textureAtlas.removeAllQuads()
}, disableParticle: function (particleIndex) {
    var quad = this.textureAtlas.quads[particleIndex];
    quad.br.vertices.x = quad.br.vertices.y = quad.tr.vertices.x = quad.tr.vertices.y = quad.tl.vertices.x = quad.tl.vertices.y = quad.bl.vertices.x = quad.bl.vertices.y = 0;
    this.textureAtlas._setDirty(true)
}, draw: function (ctx) {
    if (cc._renderType === cc._RENDER_TYPE_CANVAS)return;
    if (this.textureAtlas.totalQuads == 0)return;
    cc.nodeDrawSetup(this);
    cc.glBlendFuncForParticle(this._blendFunc.src, this._blendFunc.dst);
    this.textureAtlas.drawQuads()
}, getTexture: function () {
    return this.textureAtlas.texture
}, setTexture: function (texture) {
    this.textureAtlas.texture = texture;
    var locBlendFunc = this._blendFunc;
    if (texture && !texture.hasPremultipliedAlpha() && locBlendFunc.src == cc.BLEND_SRC && locBlendFunc.dst == cc.BLEND_DST) {
        locBlendFunc.src = cc.SRC_ALPHA;
        locBlendFunc.dst = cc.ONE_MINUS_SRC_ALPHA
    }
}, setBlendFunc: function (src, dst) {
    if (dst === undefined) {
        this._blendFunc.src = src.src;
        this._blendFunc.dst = src.dst
    } else {
        this._blendFunc.src = src;
        this._blendFunc.src = dst
    }
}, getBlendFunc: function () {
    return{src: this._blendFunc.src, dst: this._blendFunc.dst}
}, visit: function (ctx) {
    if (cc._renderType === cc._RENDER_TYPE_CANVAS)return;
    if (!this._visible)return;
    cc.kmGLPushMatrix();
    if (this.grid && this.grid.isActive()) {
        this.grid.beforeDraw();
        this.transformAncestors()
    }
    this.transform(ctx);
    this.draw(ctx);
    if (this.grid && this.grid.isActive())this.grid.afterDraw(this);
    cc.kmGLPopMatrix()
}, _updateAllAtlasIndexes: function () {
    var index = 0;
    var locChildren = this._children;
    for (var i = 0; i < locChildren.length; i++) {
        var child = locChildren[i];
        child.setAtlasIndex(index);
        index += child.getTotalParticles()
    }
}, _increaseAtlasCapacityTo: function (quantity) {
    cc.log("cocos2d: cc.ParticleBatchNode: resizing TextureAtlas capacity from [" + this.textureAtlas.getCapacity() + "] to [" + quantity + "].");
    if (!this.textureAtlas.resizeCapacity(quantity))cc.log("cc.ParticleBatchNode._increaseAtlasCapacityTo() : WARNING: Not enough memory to resize the atlas")
},
    _searchNewPositionInChildrenForZ: function (z) {
        var locChildren = this._children;
        var count = locChildren.length;
        for (var i = 0; i < count; i++)if (locChildren[i].zIndex > z)return i;
        return count
    }, _getCurrentIndex: function (child, z) {
        var foundCurrentIdx = false;
        var foundNewIdx = false;
        var newIndex = 0;
        var oldIndex = 0;
        var minusOne = 0, locChildren = this._children;
        var count = locChildren.length;
        for (var i = 0; i < count; i++) {
            var pNode = locChildren[i];
            if (pNode.zIndex > z && !foundNewIdx) {
                newIndex = i;
                foundNewIdx = true;
                if (foundCurrentIdx && foundNewIdx)break
            }
            if (child ==
                pNode) {
                oldIndex = i;
                foundCurrentIdx = true;
                if (!foundNewIdx)minusOne = -1;
                if (foundCurrentIdx && foundNewIdx)break
            }
        }
        if (!foundNewIdx)newIndex = count;
        newIndex += minusOne;
        return{newIndex: newIndex, oldIndex: oldIndex}
    }, _addChildHelper: function (child, z, aTag) {
        if (!child)throw"cc.ParticleBatchNode._addChildHelper(): child should be non-null";
        if (child.parent) {
            cc.log("cc.ParticleBatchNode._addChildHelper(): child already added. It can't be added again");
            return null
        }
        if (!this._children)this._children = [];
        var pos = this._searchNewPositionInChildrenForZ(z);
        this._children.splice(pos, 0, child);
        child.tag = aTag;
        child._setLocalZOrder(z);
        child.parent = this;
        if (this._running) {
            child.onEnter();
            child.onEnterTransitionDidFinish()
        }
        return pos
    }, _updateBlendFunc: function () {
        if (!this.textureAtlas.texture.hasPremultipliedAlpha()) {
            this._blendFunc.src = cc.SRC_ALPHA;
            this._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA
        }
    }, getTextureAtlas: function () {
        return this.textureAtlas
    }, setTextureAtlas: function (textureAtlas) {
        this.textureAtlas = textureAtlas
    }});
var _p = cc.ParticleBatchNode.prototype;
_p.texture;
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.ParticleBatchNode.create = function (fileImage, capacity) {
    return new cc.ParticleBatchNode(fileImage, capacity)
};cc.IMEKeyboardNotificationInfo = function (begin, end, duration) {
    this.begin = begin || cc.rect(0, 0, 0, 0);
    this.end = end || cc.rect(0, 0, 0, 0);
    this.duration = duration || 0
};
cc.IMEDelegate = cc.Class.extend({ctor: function () {
    cc.imeDispatcher.addDelegate(this)
}, removeDelegate: function () {
    cc.imeDispatcher.removeDelegate(this)
}, attachWithIME: function () {
    return cc.imeDispatcher.attachDelegateWithIME(this)
}, detachWithIME: function () {
    return cc.imeDispatcher.detachDelegateWithIME(this)
}, canAttachWithIME: function () {
    return false
}, didAttachWithIME: function () {
}, canDetachWithIME: function () {
    return false
}, didDetachWithIME: function () {
}, insertText: function (text, len) {
}, deleteBackward: function () {
},
    getContentText: function () {
        return""
    }, keyboardWillShow: function (info) {
    }, keyboardDidShow: function (info) {
    }, keyboardWillHide: function (info) {
    }, keyboardDidHide: function (info) {
    }});
cc.IMEDispatcher = cc.Class.extend({_domInputControl: null, impl: null, _currentInputString: "", _lastClickPosition: null, ctor: function () {
    this.impl = new cc.IMEDispatcher.Impl;
    this._lastClickPosition = cc.p(0, 0)
}, init: function () {
    if (cc.sys.isMobile)return;
    this._domInputControl = cc.$("#imeDispatcherInput");
    if (!this._domInputControl) {
        this._domInputControl = cc.$new("input");
        this._domInputControl.setAttribute("type", "text");
        this._domInputControl.setAttribute("id", "imeDispatcherInput");
        this._domInputControl.resize(0,
            0);
        this._domInputControl.translates(0, 0);
        this._domInputControl.style.opacity = "0";
        this._domInputControl.style.fontSize = "1px";
        this._domInputControl.setAttribute("tabindex", 2);
        this._domInputControl.style.position = "absolute";
        this._domInputControl.style.top = 0;
        this._domInputControl.style.left = 0;
        document.body.appendChild(this._domInputControl)
    }
    var selfPointer = this;
    cc._addEventListener(this._domInputControl, "input", function () {
        selfPointer._processDomInputString(selfPointer._domInputControl.value)
    }, false);
    cc._addEventListener(this._domInputControl, "keydown", function (e) {
        if (e.keyCode === cc.KEY.tab) {
            e.stopPropagation();
            e.preventDefault()
        } else if (e.keyCode == cc.KEY.enter) {
            selfPointer.dispatchInsertText("\n", 1);
            e.stopPropagation();
            e.preventDefault()
        }
    }, false);
    if (/msie/i.test(navigator.userAgent))cc._addEventListener(this._domInputControl, "keyup", function (e) {
        if (e.keyCode == cc.KEY.backspace)selfPointer._processDomInputString(selfPointer._domInputControl.value)
    }, false);
    cc._addEventListener(window, "mousedown",
        function (event) {
            var tx = event.pageX || 0;
            var ty = event.pageY || 0;
            selfPointer._lastClickPosition.x = tx;
            selfPointer._lastClickPosition.y = ty
        }, false)
}, _processDomInputString: function (text) {
    var i, startPos;
    var len = this._currentInputString.length < text.length ? this._currentInputString.length : text.length;
    for (startPos = 0; startPos < len; startPos++)if (text[startPos] !== this._currentInputString[startPos])break;
    var delTimes = this._currentInputString.length - startPos;
    var insTimes = text.length - startPos;
    for (i = 0; i < delTimes; i++)this.dispatchDeleteBackward();
    for (i = 0; i < insTimes; i++)this.dispatchInsertText(text[startPos + i], 1);
    this._currentInputString = text
}, dispatchInsertText: function (text, len) {
    if (!this.impl || !text || len <= 0)return;
    if (!this.impl._delegateWithIme)return;
    this.impl._delegateWithIme.insertText(text, len)
}, dispatchDeleteBackward: function () {
    if (!this.impl)return;
    if (!this.impl._delegateWithIme)return;
    this.impl._delegateWithIme.deleteBackward()
}, getContentText: function () {
    if (this.impl && this.impl._delegateWithIme) {
        var pszContentText = this.impl._delegateWithIme.getContentText();
        return pszContentText ? pszContentText : ""
    }
    return""
}, dispatchKeyboardWillShow: function (info) {
    if (this.impl)for (var i = 0; i < this.impl._delegateList.length; i++) {
        var delegate = this.impl._delegateList[i];
        if (delegate)delegate.keyboardWillShow(info)
    }
}, dispatchKeyboardDidShow: function (info) {
    if (this.impl)for (var i = 0; i < this.impl._delegateList.length; i++) {
        var delegate = this.impl._delegateList[i];
        if (delegate)delegate.keyboardDidShow(info)
    }
}, dispatchKeyboardWillHide: function (info) {
    if (this.impl)for (var i = 0; i < this.impl._delegateList.length; i++) {
        var delegate =
            this.impl._delegateList[i];
        if (delegate)delegate.keyboardWillHide(info)
    }
}, dispatchKeyboardDidHide: function (info) {
    if (this.impl)for (var i = 0; i < this.impl._delegateList.length; i++) {
        var delegate = this.impl._delegateList[i];
        if (delegate)delegate.keyboardDidHide(info)
    }
}, addDelegate: function (delegate) {
    if (!delegate || !this.impl)return;
    if (this.impl._delegateList.indexOf(delegate) > -1)return;
    this.impl._delegateList.splice(0, 0, delegate)
}, attachDelegateWithIME: function (delegate) {
    if (!this.impl || !delegate)return false;
    if (this.impl._delegateList.indexOf(delegate) == -1)return false;
    if (this.impl._delegateWithIme) {
        if (!this.impl._delegateWithIme.canDetachWithIME() || !delegate.canAttachWithIME())return false;
        var pOldDelegate = this.impl._delegateWithIme;
        this.impl._delegateWithIme = null;
        pOldDelegate.didDetachWithIME();
        this._focusDomInput(delegate);
        return true
    }
    if (!delegate.canAttachWithIME())return false;
    this._focusDomInput(delegate);
    return true
}, _focusDomInput: function (delegate) {
    if (cc.sys.isMobile) {
        this.impl._delegateWithIme =
            delegate;
        delegate.didAttachWithIME();
        this._currentInputString = delegate.string || "";
        var userInput = prompt("please enter your word:", this._currentInputString);
        if (userInput != null)this._processDomInputString(userInput);
        this.dispatchInsertText("\n", 1)
    } else {
        this.impl._delegateWithIme = delegate;
        this._currentInputString = delegate.string || "";
        delegate.didAttachWithIME();
        this._domInputControl.focus();
        this._domInputControl.value = this._currentInputString;
        this._domInputControlTranslate()
    }
}, _domInputControlTranslate: function () {
    if (/msie/i.test(navigator.userAgent)) {
        this._domInputControl.style.left =
            this._lastClickPosition.x + "px";
        this._domInputControl.style.top = this._lastClickPosition.y + "px"
    } else this._domInputControl.translates(this._lastClickPosition.x, this._lastClickPosition.y)
}, detachDelegateWithIME: function (delegate) {
    if (!this.impl || !delegate)return false;
    if (this.impl._delegateWithIme != delegate)return false;
    if (!delegate.canDetachWithIME())return false;
    this.impl._delegateWithIme = null;
    delegate.didDetachWithIME();
    cc._canvas.focus();
    return true
}, removeDelegate: function (delegate) {
    if (!this.impl || !delegate)return;
    if (this.impl._delegateList.indexOf(delegate) == -1)return;
    if (this.impl._delegateWithIme)if (delegate == this.impl._delegateWithIme)this.impl._delegateWithIme = null;
    cc.arrayRemoveObject(this.impl._delegateList, delegate)
}, processKeycode: function (keyCode) {
    if (keyCode < 32)if (keyCode == cc.KEY.backspace)this.dispatchDeleteBackward(); else if (keyCode == cc.KEY.enter)this.dispatchInsertText("\n", 1); else if (keyCode == cc.KEY.tab); else {
        if (keyCode == cc.KEY.escape);
    } else if (keyCode < 255)this.dispatchInsertText(String.fromCharCode(keyCode),
        1); else;
}});
cc.IMEDispatcher.Impl = cc.Class.extend({_delegateWithIme: null, _delegateList: null, ctor: function () {
    this._delegateList = []
}, findDelegate: function (delegate) {
    for (var i = 0; i < this._delegateList.length; i++)if (this._delegateList[i] == delegate)return i;
    return null
}});
cc.imeDispatcher = new cc.IMEDispatcher;
document.body ? cc.imeDispatcher.init() : cc._addEventListener(window, "load", function () {
    cc.imeDispatcher.init()
}, false);
cc.TextFieldDelegate = cc.Class.extend({onTextFieldAttachWithIME: function (sender) {
    return false
}, onTextFieldDetachWithIME: function (sender) {
    return false
}, onTextFieldInsertText: function (sender, text, len) {
    return false
}, onTextFieldDeleteBackward: function (sender, delText, len) {
    return false
}, onDraw: function (sender) {
    return false
}});
cc.TextFieldTTF = cc.LabelTTF.extend({delegate: null, colorSpaceHolder: null, _lens: null, _inputText: "", _placeHolder: "", _charCount: 0, _className: "TextFieldTTF", ctor: function (placeholder, dimensions, alignment, fontName, fontSize) {
    this.colorSpaceHolder = cc.color(127, 127, 127);
    cc.imeDispatcher.addDelegate(this);
    cc.LabelTTF.prototype.ctor.call(this);
    if (fontSize !== undefined) {
        this.initWithPlaceHolder("", dimensions, alignment, fontName, fontSize);
        if (placeholder)this.setPlaceHolder(placeholder)
    } else if (fontName === undefined &&
        alignment !== undefined) {
        this.initWithString("", arguments[1], arguments[2]);
        if (placeholder)this.setPlaceHolder(placeholder)
    }
}, getDelegate: function () {
    return this.delegate
}, setDelegate: function (value) {
    this.delegate = value
}, getCharCount: function () {
    return this._charCount
}, getColorSpaceHolder: function () {
    return this.colorSpaceHolder
}, setColorSpaceHolder: function (value) {
    this.colorSpaceHolder = value
}, initWithPlaceHolder: function (placeholder, dimensions, alignment, fontName, fontSize) {
    switch (arguments.length) {
        case 5:
            if (placeholder)this.setPlaceHolder(placeholder);
            return this.initWithString(this._placeHolder, fontName, fontSize, dimensions, alignment);
            break;
        case 3:
            if (placeholder)this.setPlaceHolder(placeholder);
            return this.initWithString(this._placeHolder, arguments[1], arguments[2]);
            break;
        default:
            throw"Argument must be non-nil ";
            break
    }
}, setString: function (text) {
    text = String(text);
    this._inputText = text || "";
    if (!this._inputText.length)cc.LabelTTF.prototype.setString.call(this, this._placeHolder); else cc.LabelTTF.prototype.setString.call(this, this._inputText);
    this._charCount =
        this._inputText.length
}, getString: function () {
    return this._inputText
}, setPlaceHolder: function (text) {
    this._placeHolder = text || "";
    if (!this._inputText.length)cc.LabelTTF.prototype.setString.call(this, this._placeHolder)
}, getPlaceHolder: function () {
    return this._placeHolder
}, draw: function (ctx) {
    var context = ctx || cc._renderContext;
    if (this.delegate && this.delegate.onDraw(this))return;
    if (this._inputText && this._inputText.length > 0) {
        cc.LabelTTF.prototype.draw.call(this, context);
        return
    }
    var color = this.color;
    this.color =
        this.colorSpaceHolder;
    if (cc._renderType === cc._RENDER_TYPE_CANVAS)this._updateTexture();
    cc.LabelTTF.prototype.draw.call(this, context);
    this.color = color
}, visit: function (ctx) {
    this._super(ctx)
}, attachWithIME: function () {
    return cc.imeDispatcher.attachDelegateWithIME(this)
}, detachWithIME: function () {
    return cc.imeDispatcher.detachDelegateWithIME(this)
}, canAttachWithIME: function () {
    return this.delegate ? !this.delegate.onTextFieldAttachWithIME(this) : true
}, didAttachWithIME: function () {
}, canDetachWithIME: function () {
    return this.delegate ?
        !this.delegate.onTextFieldDetachWithIME(this) : true
}, didDetachWithIME: function () {
}, deleteBackward: function () {
    var strLen = this._inputText.length;
    if (strLen == 0)return;
    var deleteLen = 1;
    if (this.delegate && this.delegate.onTextFieldDeleteBackward(this, this._inputText[strLen - deleteLen], deleteLen))return;
    if (strLen <= deleteLen) {
        this._inputText = "";
        this._charCount = 0;
        cc.LabelTTF.prototype.setString.call(this, this._placeHolder);
        return
    }
    this.string = this._inputText.substring(0, strLen - deleteLen)
}, removeDelegate: function () {
    cc.imeDispatcher.removeDelegate(this)
},
    insertText: function (text, len) {
        var sInsert = text;
        var pos = sInsert.indexOf("\n");
        if (pos > -1)sInsert = sInsert.substring(0, pos);
        if (sInsert.length > 0) {
            if (this.delegate && this.delegate.onTextFieldInsertText(this, sInsert, sInsert.length))return;
            var sText = this._inputText + sInsert;
            this._charCount = sText.length;
            this.string = sText
        }
        if (pos == -1)return;
        if (this.delegate && this.delegate.onTextFieldInsertText(this, "\n", 1))return;
        this.detachWithIME()
    }, getContentText: function () {
        return this._inputText
    }, keyboardWillShow: function (info) {
    },
    keyboardDidShow: function (info) {
    }, keyboardWillHide: function (info) {
    }, keyboardDidHide: function (info) {
    }});
var _p = cc.TextFieldTTF.prototype;
_p.charCount;
cc.defineGetterSetter(_p, "charCount", _p.getCharCount);
_p.placeHolder;
cc.defineGetterSetter(_p, "placeHolder", _p.getPlaceHolder, _p.setPlaceHolder);
cc.TextFieldTTF.create = function (placeholder, dimensions, alignment, fontName, fontSize) {
    return new cc.TextFieldTTF(placeholder, dimensions, alignment, fontName, fontSize)
};cc.TGA_OK = 0;
cc.TGA_ERROR_FILE_OPEN = 1;
cc.TGA_ERROR_READING_FILE = 2;
cc.TGA_ERROR_INDEXED_COLOR = 3;
cc.TGA_ERROR_MEMORY = 4;
cc.TGA_ERROR_COMPRESSED_FILE = 5;
cc.ImageTGA = function (status, type, pixelDepth, width, height, imageData, flipped) {
    this.status = status || 0;
    this.type = type || 0;
    this.pixelDepth = pixelDepth || 0;
    this.width = width || 0;
    this.height = height || 0;
    this.imageData = imageData || [];
    this.flipped = flipped || 0
};
cc.tgaLoadHeader = function (buffer, bufSize, psInfo) {
    var step = 2;
    if (step + 1 > bufSize)return false;
    var binaryReader = new cc.BinaryStreamReader(buffer);
    binaryReader.setOffset(step);
    psInfo.type = binaryReader.readByte();
    step += 10;
    if (step + 4 + 1 > bufSize)return false;
    binaryReader.setOffset(step);
    psInfo.width = binaryReader.readUnsignedShort();
    psInfo.height = binaryReader.readUnsignedInteger();
    psInfo.pixelDepth = binaryReader.readByte();
    step += 5;
    if (step + 1 > bufSize)return false;
    var garbage = binaryReader.readByte();
    psInfo.flipped =
        0;
    if (garbage & 32)psInfo.flipped = 1;
    return true
};
cc.tgaLoadImageData = function (buffer, bufSize, psInfo) {
    var mode, total, i, aux;
    var step = 18;
    mode = 0 | psInfo.pixelDepth / 2;
    total = psInfo.height * psInfo.width * mode;
    if (step + total > bufSize)return false;
    psInfo.imageData = cc.__getSubArray(buffer, step, step + total);
    if (mode >= 3)for (i = 0; i < total; i += mode) {
        aux = psInfo.imageData[i];
        psInfo.imageData[i] = psInfo.imageData[i + 2];
        psInfo.imageData[i + 2] = aux
    }
    return true
};
cc.tgaRGBtogreyscale = function (psInfo) {
    var i, j;
    if (psInfo.pixelDepth === 8)return;
    var mode = psInfo.pixelDepth / 8;
    var newImageData = new Uint8Array(psInfo.height * psInfo.width);
    if (newImageData === null)return;
    for (i = 0, j = 0; j < psInfo.width * psInfo.height; i += mode, j++)newImageData[j] = 0.3 * psInfo.imageData[i] + 0.59 * psInfo.imageData[i + 1] + 0.11 * psInfo.imageData[i + 2];
    psInfo.pixelDepth = 8;
    psInfo.type = 3;
    psInfo.imageData = newImageData
};
cc.tgaDestroy = function (psInfo) {
    if (!psInfo)return;
    psInfo.imageData = null;
    psInfo = null
};
cc.tgaLoadRLEImageData = function (buffer, bufSize, psInfo) {
    var mode, total, i, index = 0, skip = 0, flag = 0;
    var aux = [], runlength = 0;
    var step = 18;
    mode = psInfo.pixelDepth / 8;
    total = psInfo.height * psInfo.width;
    for (i = 0; i < total; i++) {
        if (runlength != 0) {
            runlength--;
            skip = flag != 0
        } else {
            if (step + 1 > bufSize)break;
            runlength = buffer[step];
            step += 1;
            flag = runlength & 128;
            if (flag)runlength -= 128;
            skip = 0
        }
        if (!skip) {
            if (step + mode > bufSize)break;
            aux = cc.__getSubArray(buffer, step, step + mode);
            step += mode;
            if (mode >= 3) {
                var tmp = aux[0];
                aux[0] = aux[2];
                aux[2] = tmp
            }
        }
        for (var j =
            0; j < mode; j++)psInfo.imageData[index + j] = aux[j];
        index += mode
    }
    return true
};
cc.tgaFlipImage = function (psInfo) {
    var mode = psInfo.pixelDepth / 8;
    var rowbytes = psInfo.width * mode;
    for (var y = 0; y < psInfo.height / 2; y++) {
        var row = cc.__getSubArray(psInfo.imageData, y * rowbytes, y * rowbytes + rowbytes);
        cc.__setDataToArray(cc.__getSubArray(psInfo.imageData, (psInfo.height - (y + 1)) * rowbytes, rowbytes), psInfo.imageData, y * rowbytes);
        cc.__setDataToArray(row, psInfo.imageData, (psInfo.height - (y + 1)) * rowbytes)
    }
    psInfo.flipped = 0
};
cc.__getSubArray = function (array, start, end) {
    if (array instanceof Array)return array.slice(start, end); else return array.subarray(start, end)
};
cc.__setDataToArray = function (sourceData, destArray, startIndex) {
    for (var i = 0; i < sourceData.length; i++)destArray[startIndex + i] = sourceData[i]
};
cc.BinaryStreamReader = cc.Class.extend({_binaryData: null, _offset: 0, ctor: function (binaryData) {
    this._binaryData = binaryData
}, setBinaryData: function (binaryData) {
    this._binaryData = binaryData;
    this._offset = 0
}, getBinaryData: function () {
    return this._binaryData
}, _checkSize: function (neededBits) {
    if (!(this._offset + Math.ceil(neededBits / 8) < this._data.length))throw new Error("Index out of bound");
}, _decodeFloat: function (precisionBits, exponentBits) {
    var length = precisionBits + exponentBits + 1;
    var size = length >> 3;
    this._checkSize(length);
    var bias = Math.pow(2, exponentBits - 1) - 1;
    var signal = this._readBits(precisionBits + exponentBits, 1, size);
    var exponent = this._readBits(precisionBits, exponentBits, size);
    var significand = 0;
    var divisor = 2;
    var curByte = 0;
    do {
        var byteValue = this._readByte(++curByte, size);
        var startBit = precisionBits % 8 || 8;
        var mask = 1 << startBit;
        while (mask >>= 1) {
            if (byteValue & mask)significand += 1 / divisor;
            divisor *= 2
        }
    } while (precisionBits -= startBit);
    this._offset += size;
    return exponent == (bias << 1) + 1 ? significand ? NaN : signal ? -Infinity : +Infinity : (1 +
        signal * -2) * (exponent || significand ? !exponent ? Math.pow(2, -bias + 1) * significand : Math.pow(2, exponent - bias) * (1 + significand) : 0)
}, _readByte: function (i, size) {
    return this._data[this._offset + size - i - 1]
}, _decodeInt: function (bits, signed) {
    var x = this._readBits(0, bits, bits / 8), max = Math.pow(2, bits);
    var result = signed && x >= max / 2 ? x - max : x;
    this._offset += bits / 8;
    return result
}, _shl: function (a, b) {
    for (++b; --b; a = ((a %= 2147483647 + 1) & 1073741824) == 1073741824 ? a * 2 : (a - 1073741824) * 2 + 2147483647 + 1);
    return a
}, _readBits: function (start, length, size) {
    var offsetLeft = (start + length) % 8;
    var offsetRight = start % 8;
    var curByte = size - (start >> 3) - 1;
    var lastByte = size + (-(start + length) >> 3);
    var diff = curByte - lastByte;
    var sum = this._readByte(curByte, size) >> offsetRight & (1 << (diff ? 8 - offsetRight : length)) - 1;
    if (diff && offsetLeft)sum += (this._readByte(lastByte++, size) & (1 << offsetLeft) - 1) << (diff-- << 3) - offsetRight;
    while (diff)sum += this._shl(this._readByte(lastByte++, size), (diff-- << 3) - offsetRight);
    return sum
}, readInteger: function () {
    return this._decodeInt(32, true)
}, readUnsignedInteger: function () {
    return this._decodeInt(32,
        false)
}, readSingle: function () {
    return this._decodeFloat(23, 8)
}, readShort: function () {
    return this._decodeInt(16, true)
}, readUnsignedShort: function () {
    return this._decodeInt(16, false)
}, readByte: function () {
    var readByte = this._data[this._offset];
    this._offset += 1;
    return readByte
}, readData: function (start, end) {
    if (this._binaryData instanceof Array)return this._binaryData.slice(start, end); else return this._binaryData.subarray(start, end)
}, setOffset: function (offset) {
    this._offset = offset
}, getOffset: function () {
    return this._offset
}});
cc.TMX_ORIENTATION_ORTHO = 0;
cc.TMX_ORIENTATION_HEX = 1;
cc.TMX_ORIENTATION_ISO = 2;
cc.TMXTiledMap = cc.NodeRGBA.extend({properties: null, mapOrientation: null, objectGroups: null, _mapSize: null, _tileSize: null, _tileProperties: null, _className: "TMXTiledMap", ctor: function (tmxFile, resourcePath) {
    cc.Node.prototype.ctor.call(this);
    this._mapSize = cc.size(0, 0);
    this._tileSize = cc.size(0, 0);
    if (resourcePath !== undefined)this.initWithXML(tmxFile, resourcePath); else if (tmxFile !== undefined)this.initWithTMXFile(tmxFile)
}, getMapSize: function () {
    return cc.size(this._mapSize.width, this._mapSize.height)
}, setMapSize: function (Var) {
    this._mapSize.width =
        Var.width;
    this._mapSize.height = Var.height
}, _getMapWidth: function () {
    return this._mapSize.width
}, _setMapWidth: function (width) {
    this._mapSize.width = width
}, _getMapHeight: function () {
    return this._mapSize.height
}, _setMapHeight: function (height) {
    this._mapSize.height = height
}, getTileSize: function () {
    return cc.size(this._tileSize.width, this._tileSize.height)
}, setTileSize: function (Var) {
    this._tileSize.width = Var.width;
    this._tileSize.height = Var.height
}, _getTileWidth: function () {
    return this._tileSize.width
}, _setTileWidth: function (width) {
    this._tileSize.width =
        width
}, _getTileHeight: function () {
    return this._tileSize.height
}, _setTileHeight: function (height) {
    this._tileSize.height = height
}, getMapOrientation: function () {
    return this.mapOrientation
}, setMapOrientation: function (Var) {
    this.mapOrientation = Var
}, getObjectGroups: function () {
    return this.objectGroups
}, setObjectGroups: function (Var) {
    this.objectGroups = Var
}, getProperties: function () {
    return this.properties
}, setProperties: function (Var) {
    this.properties = Var
}, initWithTMXFile: function (tmxFile) {
    if (!tmxFile || tmxFile.length ==
        0)throw"cc.TMXTiledMap.initWithTMXFile(): tmxFile should be non-null or non-empty string.";
    this.width = 0;
    this.height = 0;
    var mapInfo = cc.TMXMapInfo.create(tmxFile);
    if (!mapInfo)return false;
    var locTilesets = mapInfo.getTilesets();
    if (!locTilesets || locTilesets.length === 0)cc.log("cc.TMXTiledMap.initWithTMXFile(): Map not found. Please check the filename.");
    this._buildWithMapInfo(mapInfo);
    return true
}, initWithXML: function (tmxString, resourcePath) {
    this.width = 0;
    this.height = 0;
    var mapInfo = cc.TMXMapInfo.create(tmxString,
        resourcePath);
    var locTilesets = mapInfo.getTilesets();
    if (!locTilesets || locTilesets.length === 0)cc.log("cc.TMXTiledMap.initWithXML(): Map not found. Please check the filename.");
    this._buildWithMapInfo(mapInfo);
    return true
}, _buildWithMapInfo: function (mapInfo) {
    this._mapSize = mapInfo.getMapSize();
    this._tileSize = mapInfo.getTileSize();
    this.mapOrientation = mapInfo.orientation;
    this.objectGroups = mapInfo.getObjectGroups();
    this.properties = mapInfo.properties;
    this._tileProperties = mapInfo.getTileProperties();
    var idx =
        0;
    var layers = mapInfo.getLayers();
    if (layers) {
        var layerInfo = null;
        for (var i = 0, len = layers.length; i < len; i++) {
            layerInfo = layers[i];
            if (layerInfo && layerInfo.visible) {
                var child = this._parseLayer(layerInfo, mapInfo);
                this.addChild(child, idx, idx);
                this.width = Math.max(this.width, child.width);
                this.height = Math.max(this.height, child.height);
                idx++
            }
        }
    }
}, allLayers: function () {
    var retArr = [], locChildren = this._children;
    for (var i = 0, len = locChildren.length; i < len; i++) {
        var layer = locChildren[i];
        if (layer && layer instanceof cc.TMXLayer)retArr.push(layer)
    }
    return retArr
},
    getLayer: function (layerName) {
        if (!layerName || layerName.length === 0)throw"cc.TMXTiledMap.getLayer(): layerName should be non-null or non-empty string.";
        var locChildren = this._children;
        for (var i = 0; i < locChildren.length; i++) {
            var layer = locChildren[i];
            if (layer && layer.layerName == layerName)return layer
        }
        return null
    }, getObjectGroup: function (groupName) {
        if (!groupName || groupName.length === 0)throw"cc.TMXTiledMap.getObjectGroup(): groupName should be non-null or non-empty string.";
        if (this.objectGroups)for (var i = 0; i <
            this.objectGroups.length; i++) {
            var objectGroup = this.objectGroups[i];
            if (objectGroup && objectGroup.groupName == groupName)return objectGroup
        }
        return null
    }, getProperty: function (propertyName) {
        return this.properties[propertyName.toString()]
    }, propertiesForGID: function (GID) {
        return this._tileProperties[GID]
    }, _parseLayer: function (layerInfo, mapInfo) {
        var tileset = this._tilesetForLayer(layerInfo, mapInfo);
        var layer = cc.TMXLayer.create(tileset, layerInfo, mapInfo);
        layerInfo.ownTiles = false;
        layer.setupTiles();
        return layer
    },
    _tilesetForLayer: function (layerInfo, mapInfo) {
        var size = layerInfo._layerSize;
        var tilesets = mapInfo.getTilesets();
        if (tilesets)for (var i = tilesets.length - 1; i >= 0; i--) {
            var tileset = tilesets[i];
            if (tileset)for (var y = 0; y < size.height; y++)for (var x = 0; x < size.width; x++) {
                var pos = x + size.width * y;
                var gid = layerInfo._tiles[pos];
                if (gid != 0)if ((gid & cc.TMX_TILE_FLIPPED_MASK) >>> 0 >= tileset.firstGid)return tileset
            }
        }
        cc.log("cocos2d: Warning: TMX Layer " + layerInfo.name + " has no tiles");
        return null
    }});
var _p = cc.TMXTiledMap.prototype;
_p.mapWidth;
cc.defineGetterSetter(_p, "mapWidth", _p._getMapWidth, _p._setMapWidth);
_p.mapHeight;
cc.defineGetterSetter(_p, "mapHeight", _p._getMapHeight, _p._setMapHeight);
_p.tileWidth;
cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth);
_p.tileHeight;
cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight);
cc.TMXTiledMap.create = function (tmxFile, resourcePath) {
    return new cc.TMXTiledMap(tmxFile, resourcePath)
};
cc.TMX_PROPERTY_NONE = 0;
cc.TMX_PROPERTY_MAP = 1;
cc.TMX_PROPERTY_LAYER = 2;
cc.TMX_PROPERTY_OBJECTGROUP = 3;
cc.TMX_PROPERTY_OBJECT = 4;
cc.TMX_PROPERTY_TILE = 5;
cc.TMX_TILE_HORIZONTAL_FLAG = 2147483648;
cc.TMX_TILE_VERTICAL_FLAG = 1073741824;
cc.TMX_TILE_DIAGONAL_FLAG = 536870912;
cc.TMX_TILE_FLIPPED_ALL = (cc.TMX_TILE_HORIZONTAL_FLAG | cc.TMX_TILE_VERTICAL_FLAG | cc.TMX_TILE_DIAGONAL_FLAG) >>> 0;
cc.TMX_TILE_FLIPPED_MASK = ~cc.TMX_TILE_FLIPPED_ALL >>> 0;
cc.TMXLayerInfo = cc.Class.extend({properties: null, name: "", _layerSize: null, _tiles: null, visible: null, _opacity: null, ownTiles: true, _minGID: 1E5, _maxGID: 0, offset: null, ctor: function () {
    this.properties = [];
    this.name = "";
    this._layerSize = null;
    this._tiles = [];
    this.visible = true;
    this._opacity = 0;
    this.ownTiles = true;
    this._minGID = 1E5;
    this._maxGID = 0;
    this.offset = cc.p(0, 0)
}, getProperties: function () {
    return this.properties
}, setProperties: function (value) {
    this.properties = value
}});
cc.TMXTilesetInfo = cc.Class.extend({name: "", firstGid: 0, _tileSize: null, spacing: 0, margin: 0, sourceImage: "", imageSize: null, ctor: function () {
    this._tileSize = cc.size(0, 0);
    this.imageSize = cc.size(0, 0)
}, rectForGID: function (gid) {
    var rect = cc.rect(0, 0, 0, 0);
    rect.width = this._tileSize.width;
    rect.height = this._tileSize.height;
    gid &= cc.TMX_TILE_FLIPPED_MASK;
    gid = gid - parseInt(this.firstGid, 10);
    var max_x = parseInt((this.imageSize.width - this.margin * 2 + this.spacing) / (this._tileSize.width + this.spacing), 10);
    rect.x = parseInt(gid %
        max_x * (this._tileSize.width + this.spacing) + this.margin, 10);
    rect.y = parseInt(parseInt(gid / max_x, 10) * (this._tileSize.height + this.spacing) + this.margin, 10);
    return rect
}});
cc.TMXMapInfo = cc.SAXParser.extend({properties: null, orientation: null, parentElement: null, parentGID: null, layerAttrs: 0, storingCharacters: false, tmxFileName: null, currentString: null, _objectGroups: null, _mapSize: null, _tileSize: null, _layers: null, _tilesets: null, _tileProperties: null, _resources: "", _currentFirstGID: 0, ctor: function (tmxFile, resourcePath) {
    cc.SAXParser.prototype.ctor.apply(this);
    this._mapSize = cc.size(0, 0);
    this._tileSize = cc.size(0, 0);
    this._layers = [];
    this._tilesets = [];
    this._objectGroups = [];
    this.properties =
        [];
    this._tileProperties = {};
    this._currentFirstGID = 0;
    if (resourcePath !== undefined)this.initWithXML(tmxFile, resourcePath); else if (tmxFile !== undefined)this.initWithTMXFile(tmxFile)
}, getOrientation: function () {
    return this.orientation
}, setOrientation: function (value) {
    this.orientation = value
}, getMapSize: function () {
    return cc.size(this._mapSize.width, this._mapSize.height)
}, setMapSize: function (value) {
    this._mapSize.width = value.width;
    this._mapSize.height = value.height
}, _getMapWidth: function () {
    return this._mapSize.width
},
    _setMapWidth: function (width) {
        this._mapSize.width = width
    }, _getMapHeight: function () {
        return this._mapSize.height
    }, _setMapHeight: function (height) {
        this._mapSize.height = height
    }, getTileSize: function () {
        return cc.size(this._tileSize.width, this._tileSize.height)
    }, setTileSize: function (value) {
        this._tileSize.width = value.width;
        this._tileSize.height = value.height
    }, _getTileWidth: function () {
        return this._tileSize.width
    }, _setTileWidth: function (width) {
        this._tileSize.width = width
    }, _getTileHeight: function () {
        return this._tileSize.height
    },
    _setTileHeight: function (height) {
        this._tileSize.height = height
    }, getLayers: function () {
        return this._layers
    }, setLayers: function (value) {
        this._layers.push(value)
    }, getTilesets: function () {
        return this._tilesets
    }, setTilesets: function (value) {
        this._tilesets.push(value)
    }, getObjectGroups: function () {
        return this._objectGroups
    }, setObjectGroups: function (value) {
        this._objectGroups.push(value)
    }, getParentElement: function () {
        return this.parentElement
    }, setParentElement: function (value) {
        this.parentElement = value
    }, getParentGID: function () {
        return this.parentGID
    },
    setParentGID: function (value) {
        this.parentGID = value
    }, getLayerAttribs: function () {
        return this.layerAttrs
    }, setLayerAttribs: function (value) {
        this.layerAttrs = value
    }, getStoringCharacters: function () {
        return this.storingCharacters
    }, setStoringCharacters: function (value) {
        this.storingCharacters = value
    }, getProperties: function () {
        return this.properties
    }, setProperties: function (value) {
        this.properties = value
    }, initWithTMXFile: function (tmxFile) {
        this._internalInit(tmxFile, null);
        return this.parseXMLFile(tmxFile)
    }, initWithXML: function (tmxString, resourcePath) {
        this._internalInit(null, resourcePath);
        return this.parseXMLString(tmxString)
    }, parseXMLFile: function (tmxFile, isXmlString) {
        isXmlString = isXmlString || false;
        var xmlStr = isXmlString ? tmxFile : cc.loader.getRes(tmxFile);
        if (!xmlStr)throw"Please load the resource first : " + tmxFile;
        var mapXML = this._parseXML(xmlStr);
        var i, j;
        var map = mapXML.documentElement;
        var version = map.getAttribute("version");
        var orientationStr = map.getAttribute("orientation");
        if (map.nodeName == "map") {
            if (version != "1.0" && version !== null)cc.log("cocos2d: TMXFormat: Unsupported TMX version:" +
                version);
            if (orientationStr == "orthogonal")this.orientation = cc.TMX_ORIENTATION_ORTHO; else if (orientationStr == "isometric")this.orientation = cc.TMX_ORIENTATION_ISO; else if (orientationStr == "hexagonal")this.orientation = cc.TMX_ORIENTATION_HEX; else if (orientationStr !== null)cc.log("cocos2d: TMXFomat: Unsupported orientation:" + orientationStr);
            var mapSize = cc.size(0, 0);
            mapSize.width = parseFloat(map.getAttribute("width"));
            mapSize.height = parseFloat(map.getAttribute("height"));
            this.setMapSize(mapSize);
            mapSize = cc.size(0,
                0);
            mapSize.width = parseFloat(map.getAttribute("tilewidth"));
            mapSize.height = parseFloat(map.getAttribute("tileheight"));
            this.setTileSize(mapSize);
            var propertyArr = map.querySelectorAll("map \x3e properties \x3e  property");
            if (propertyArr) {
                var aPropertyDict = {};
                for (i = 0; i < propertyArr.length; i++)aPropertyDict[propertyArr[i].getAttribute("name")] = propertyArr[i].getAttribute("value");
                this.properties = aPropertyDict
            }
        }
        var tilesets = map.getElementsByTagName("tileset");
        if (map.nodeName !== "map") {
            tilesets = [];
            tilesets.push(map)
        }
        for (i =
                 0; i < tilesets.length; i++) {
            var selTileset = tilesets[i];
            var tsxName = selTileset.getAttribute("source");
            if (tsxName) {
                var tsxPath = isXmlString ? cc.path.join(this._resources, tsxName) : cc.path.changeBasename(tmxFile, tsxName);
                this.parseXMLFile(tsxPath)
            } else {
                var tileset = new cc.TMXTilesetInfo;
                tileset.name = selTileset.getAttribute("name") || "";
                tileset.firstGid = parseInt(selTileset.getAttribute("firstgid")) || 0;
                tileset.spacing = parseInt(selTileset.getAttribute("spacing")) || 0;
                tileset.margin = parseInt(selTileset.getAttribute("margin")) ||
                    0;
                var tilesetSize = cc.size(0, 0);
                tilesetSize.width = parseFloat(selTileset.getAttribute("tilewidth"));
                tilesetSize.height = parseFloat(selTileset.getAttribute("tileheight"));
                tileset._tileSize = tilesetSize;
                var image = selTileset.getElementsByTagName("image")[0];
                var imagename = image.getAttribute("source");
                var num = -1;
                if (this.tmxFileName)num = this.tmxFileName.lastIndexOf("/");
                if (num !== -1) {
                    var dir = this.tmxFileName.substr(0, num + 1);
                    tileset.sourceImage = dir + imagename
                } else tileset.sourceImage = this._resources + (this._resources ?
                    "/" : "") + imagename;
                this.setTilesets(tileset);
                var tiles = selTileset.getElementsByTagName("tile");
                if (tiles)for (var tIdx = 0; tIdx < tiles.length; tIdx++) {
                    var t = tiles[tIdx];
                    this.parentGID = parseInt(tileset.firstGid) + parseInt(t.getAttribute("id") || 0);
                    var tp = t.querySelectorAll("properties \x3e property");
                    if (tp) {
                        var dict = {};
                        for (j = 0; j < tp.length; j++) {
                            var name = tp[j].getAttribute("name");
                            dict[name] = tp[j].getAttribute("value")
                        }
                        this._tileProperties[this.parentGID] = dict
                    }
                }
            }
        }
        var layers = map.getElementsByTagName("layer");
        if (layers)for (i = 0; i < layers.length; i++) {
            var selLayer = layers[i];
            var data = selLayer.getElementsByTagName("data")[0];
            var layer = new cc.TMXLayerInfo;
            layer.name = selLayer.getAttribute("name");
            var layerSize = cc.size(0, 0);
            layerSize.width = parseFloat(selLayer.getAttribute("width"));
            layerSize.height = parseFloat(selLayer.getAttribute("height"));
            layer._layerSize = layerSize;
            var visible = selLayer.getAttribute("visible");
            layer.visible = !(visible == "0");
            var opacity = selLayer.getAttribute("opacity") || 1;
            if (opacity)layer._opacity =
                parseInt(255 * parseFloat(opacity)); else layer._opacity = 255;
            layer.offset = cc.p(parseFloat(selLayer.getAttribute("x")) || 0, parseFloat(selLayer.getAttribute("y")) || 0);
            var nodeValue = "";
            for (j = 0; j < data.childNodes.length; j++)nodeValue += data.childNodes[j].nodeValue;
            nodeValue = nodeValue.trim();
            var compression = data.getAttribute("compression");
            var encoding = data.getAttribute("encoding");
            if (compression && compression !== "gzip" && compression !== "zlib") {
                cc.log("cc.TMXMapInfo.parseXMLFile(): unsupported compression method");
                return null
            }
            switch (compression) {
                case "gzip":
                    layer._tiles = cc.unzipBase64AsArray(nodeValue, 4);
                    break;
                case "zlib":
                    var inflator = new Zlib.Inflate(cc.Codec.Base64.decodeAsArray(nodeValue, 1));
                    layer._tiles = cc.uint8ArrayToUint32Array(inflator.decompress());
                    break;
                case null:
                case "":
                    if (encoding == "base64")layer._tiles = cc.Codec.Base64.decodeAsArray(nodeValue, 4); else if (encoding === "csv") {
                        layer._tiles = [];
                        var csvTiles = nodeValue.split(",");
                        for (var csvIdx = 0; csvIdx < csvTiles.length; csvIdx++)layer._tiles.push(parseInt(csvTiles[csvIdx]))
                    } else {
                        var selDataTiles =
                            data.getElementsByTagName("tile");
                        layer._tiles = [];
                        for (var xmlIdx = 0; xmlIdx < selDataTiles.length; xmlIdx++)layer._tiles.push(parseInt(selDataTiles[xmlIdx].getAttribute("gid")))
                    }
                    break;
                default:
                    if (this.layerAttrs == cc.TMXLayerInfo.ATTRIB_NONE)cc.log("cc.TMXMapInfo.parseXMLFile(): Only base64 and/or gzip/zlib maps are supported");
                    break
            }
            var layerProps = selLayer.querySelectorAll("properties \x3e property");
            if (layerProps) {
                var layerProp = {};
                for (j = 0; j < layerProps.length; j++)layerProp[layerProps[j].getAttribute("name")] =
                    layerProps[j].getAttribute("value");
                layer.properties = layerProp
            }
            this.setLayers(layer)
        }
        var objectGroups = map.getElementsByTagName("objectgroup");
        if (objectGroups)for (i = 0; i < objectGroups.length; i++) {
            var selGroup = objectGroups[i];
            var objectGroup = new cc.TMXObjectGroup;
            objectGroup.groupName = selGroup.getAttribute("name");
            objectGroup.setPositionOffset(cc.p(parseFloat(selGroup.getAttribute("x")) * this.getTileSize().width || 0, parseFloat(selGroup.getAttribute("y")) * this.getTileSize().height || 0));
            var groupProps = selGroup.querySelectorAll("objectgroup \x3e properties \x3e property");
            if (groupProps)for (j = 0; j < groupProps.length; j++) {
                var groupProp = {};
                groupProp[groupProps[j].getAttribute("name")] = groupProps[j].getAttribute("value");
                objectGroup.properties = groupProp
            }
            var objects = selGroup.querySelectorAll("object");
            if (objects)for (j = 0; j < objects.length; j++) {
                var selObj = objects[j];
                var objectProp = {};
                objectProp["name"] = selObj.getAttribute("name") || "";
                objectProp["type"] = selObj.getAttribute("type") || "";
                objectProp["x"] = parseInt(selObj.getAttribute("x") || 0) + objectGroup.getPositionOffset().x;
                var y =
                    parseInt(selObj.getAttribute("y") || 0) + objectGroup.getPositionOffset().y;
                objectProp["width"] = parseInt(selObj.getAttribute("width")) || 0;
                objectProp["height"] = parseInt(selObj.getAttribute("height")) || 0;
                objectProp["y"] = parseInt(this.getMapSize().height * this.getTileSize().height) - y - objectProp["height"];
                var docObjProps = selObj.querySelectorAll("properties \x3e property");
                if (docObjProps)for (var k = 0; k < docObjProps.length; k++)objectProp[docObjProps[k].getAttribute("name")] = docObjProps[k].getAttribute("value");
                var polygonProps = selObj.querySelectorAll("polygon");
                if (polygonProps && polygonProps.length > 0) {
                    var selPgPointStr = polygonProps[0].getAttribute("points");
                    if (selPgPointStr)objectProp["polygonPoints"] = this._parsePointsString(selPgPointStr)
                }
                var polylineProps = selObj.querySelectorAll("polyline");
                if (polylineProps && polylineProps.length > 0) {
                    var selPlPointStr = polylineProps[0].getAttribute("points");
                    if (selPlPointStr)objectProp["polylinePoints"] = this._parsePointsString(selPlPointStr)
                }
                objectGroup.setObjects(objectProp)
            }
            this.setObjectGroups(objectGroup)
        }
        return map
    },
    _parsePointsString: function (pointsString) {
        if (!pointsString)return null;
        var points = [];
        var pointsStr = pointsString.split(" ");
        for (var i = 0; i < pointsStr.length; i++) {
            var selPointStr = pointsStr[i].split(",");
            points.push({"x": selPointStr[0], "y": selPointStr[1]})
        }
        return points
    }, parseXMLString: function (xmlString) {
        return this.parseXMLFile(xmlString, true)
    }, getTileProperties: function () {
        return this._tileProperties
    }, setTileProperties: function (tileProperties) {
        this._tileProperties.push(tileProperties)
    }, getCurrentString: function () {
        return this.currentString
    },
    setCurrentString: function (currentString) {
        this.currentString = currentString
    }, getTMXFileName: function () {
        return this.tmxFileName
    }, setTMXFileName: function (fileName) {
        this.tmxFileName = fileName
    }, _internalInit: function (tmxFileName, resourcePath) {
        this._tilesets.length = 0;
        this._layers.length = 0;
        this.tmxFileName = tmxFileName;
        if (resourcePath)this._resources = resourcePath;
        this._objectGroups.length = 0;
        this.properties.length = 0;
        this._tileProperties.length = 0;
        this.currentString = "";
        this.storingCharacters = false;
        this.layerAttrs =
            cc.TMXLayerInfo.ATTRIB_NONE;
        this.parentElement = cc.TMX_PROPERTY_NONE;
        this._currentFirstGID = 0
    }});
var _p = cc.TMXMapInfo.prototype;
_p.mapWidth;
cc.defineGetterSetter(_p, "mapWidth", _p._getMapWidth, _p._setMapWidth);
_p.mapHeight;
cc.defineGetterSetter(_p, "mapHeight", _p._getMapHeight, _p._setMapHeight);
_p.tileWidth;
cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth);
_p.tileHeight;
cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight);
cc.TMXMapInfo.create = function (tmxFile, resourcePath) {
    return new cc.TMXMapInfo(tmxFile, resourcePath)
};
cc.loader.register(["tmx", "tsx"], cc._txtLoader);
cc.TMXLayerInfo.ATTRIB_NONE = 1 << 0;
cc.TMXLayerInfo.ATTRIB_BASE64 = 1 << 1;
cc.TMXLayerInfo.ATTRIB_GZIP = 1 << 2;
cc.TMXLayerInfo.ATTRIB_ZLIB = 1 << 3;
cc.TMXObjectGroup = cc.Class.extend({properties: null, groupName: "", _positionOffset: null, _objects: null, ctor: function () {
    this.groupName = "";
    this._positionOffset = cc.p(0, 0);
    this.properties = [];
    this._objects = []
}, getPositionOffset: function () {
    return this._positionOffset
}, setPositionOffset: function (offset) {
    this._positionOffset.x = offset.x;
    this._positionOffset.y = offset.y
}, getProperties: function () {
    return this.properties
}, setProperties: function (Var) {
    this.properties.push(Var)
}, getGroupName: function () {
    return this.groupName.toString()
},
    setGroupName: function (groupName) {
        this.groupName = groupName
    }, propertyNamed: function (propertyName) {
        return this.properties[propertyName]
    }, objectNamed: function (objectName) {
        if (this._objects && this._objects.length > 0) {
            var locObjects = this._objects;
            for (var i = 0, len = locObjects.length; i < len; i++) {
                var name = locObjects[i]["name"];
                if (name && name == objectName)return locObjects[i]
            }
        }
        return null
    }, getObjects: function () {
        return this._objects
    }, setObjects: function (objects) {
        this._objects.push(objects)
    }});
cc.TMXLayer = cc.SpriteBatchNode.extend({tiles: null, tileset: null, layerOrientation: null, properties: null, layerName: "", _layerSize: null, _mapTileSize: null, _opacity: 255, _minGID: null, _maxGID: null, _vertexZvalue: null, _useAutomaticVertexZ: null, _alphaFuncValue: null, _reusedTile: null, _atlasIndexArray: null, _contentScaleFactor: null, _cacheCanvas: null, _cacheContext: null, _cacheTexture: null, _subCacheCanvas: null, _subCacheContext: null, _subCacheCount: 0, _subCacheWidth: 0, _maxCachePixel: 1E7, _className: "TMXLayer", ctor: function (tilesetInfo, layerInfo, mapInfo) {
    cc.SpriteBatchNode.prototype.ctor.call(this);
    this._descendants = [];
    this._layerSize = cc.size(0, 0);
    this._mapTileSize = cc.size(0, 0);
    if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
        var locCanvas = cc._canvas;
        var tmpCanvas = cc.newElement("canvas");
        tmpCanvas.width = locCanvas.width;
        tmpCanvas.height = locCanvas.height;
        this._cacheCanvas = tmpCanvas;
        this._cacheContext = this._cacheCanvas.getContext("2d");
        var tempTexture = new cc.Texture2D;
        tempTexture.initWithElement(tmpCanvas);
        tempTexture.handleLoadedTexture();
        this._cacheTexture = tempTexture;
        this.width = locCanvas.width;
        this.height = locCanvas.height;
        this._cachedParent = this
    }
    if (mapInfo !== undefined)this.initWithTilesetInfo(tilesetInfo, layerInfo, mapInfo)
}, setContentSize: function (size, height) {
    var locContentSize = this._contentSize;
    cc.Node.prototype.setContentSize.call(this, size, height);
    if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
        var locCanvas = this._cacheCanvas;
        var scaleFactor = cc.contentScaleFactor();
        locCanvas.width = 0 | locContentSize.width * 1.5 * scaleFactor;
        locCanvas.height =
            0 | locContentSize.height * 1.5 * scaleFactor;
        this._cacheContext.translate(0, locCanvas.height);
        var locTexContentSize = this._cacheTexture._contentSize;
        locTexContentSize.width = locCanvas.width;
        locTexContentSize.height = locCanvas.height;
        var totalPixel = locCanvas.width * locCanvas.height;
        if (totalPixel > this._maxCachePixel) {
            if (!this._subCacheCanvas)this._subCacheCanvas = [];
            if (!this._subCacheContext)this._subCacheContext = [];
            this._subCacheCount = Math.ceil(totalPixel / this._maxCachePixel);
            var locSubCacheCanvas = this._subCacheCanvas,
                i;
            for (i = 0; i < this._subCacheCount; i++) {
                if (!locSubCacheCanvas[i]) {
                    locSubCacheCanvas[i] = document.createElement("canvas");
                    this._subCacheContext[i] = locSubCacheCanvas[i].getContext("2d")
                }
                var tmpCanvas = locSubCacheCanvas[i];
                tmpCanvas.width = this._subCacheWidth = Math.round(locCanvas.width / this._subCacheCount);
                tmpCanvas.height = locCanvas.height
            }
            for (i = this._subCacheCount; i < locSubCacheCanvas.length; i++) {
                tmpCanvas.width = 0;
                tmpCanvas.height = 0
            }
        } else this._subCacheCount = 0
    }
}, getTexture: null, _getTextureForCanvas: function () {
    return this._cacheTexture
},
    visit: null, _visitForCanvas: function (ctx) {
        var context = ctx || cc._renderContext;
        if (!this._visible)return;
        context.save();
        this.transform(ctx);
        var i, locChildren = this._children;
        if (this._cacheDirty) {
            var eglViewer = cc.view;
            eglViewer._setScaleXYForRenderTexture();
            var locCacheContext = this._cacheContext, locCacheCanvas = this._cacheCanvas;
            locCacheContext.clearRect(0, 0, locCacheCanvas.width, -locCacheCanvas.height);
            locCacheContext.save();
            locCacheContext.translate(this._anchorPointInPoints.x, -this._anchorPointInPoints.y);
            if (locChildren) {
                this.sortAllChildren();
                for (i = 0; i < locChildren.length; i++)if (locChildren[i])locChildren[i].visit(locCacheContext)
            }
            locCacheContext.restore();
            if (this._subCacheCount > 0) {
                var subCacheW = this._subCacheWidth, subCacheH = locCacheCanvas.height;
                for (i = 0; i < this._subCacheCount; i++)this._subCacheContext[i].drawImage(locCacheCanvas, i * subCacheW, 0, subCacheW, subCacheH, 0, 0, subCacheW, subCacheH)
            }
            eglViewer._resetScale();
            this._cacheDirty = false
        }
        this.draw(ctx);
        context.restore()
    }, draw: null, _drawForCanvas: function (ctx) {
        var context =
            ctx || cc._renderContext;
        var posX = 0 | -this._anchorPointInPoints.x, posY = 0 | -this._anchorPointInPoints.y;
        var eglViewer = cc.view;
        var locCacheCanvas = this._cacheCanvas;
        if (locCacheCanvas) {
            var locSubCacheCount = this._subCacheCount, locCanvasHeight = locCacheCanvas.height * eglViewer._scaleY;
            if (locSubCacheCount > 0) {
                var locSubCacheCanvasArr = this._subCacheCanvas;
                for (var i = 0; i < locSubCacheCount; i++) {
                    var selSubCanvas = locSubCacheCanvasArr[i];
                    context.drawImage(locSubCacheCanvasArr[i], 0, 0, selSubCanvas.width, selSubCanvas.height,
                            posX + i * this._subCacheWidth, -(posY + locCanvasHeight), selSubCanvas.width * eglViewer._scaleX, locCanvasHeight)
                }
            } else context.drawImage(locCacheCanvas, 0, 0, locCacheCanvas.width, locCacheCanvas.height, posX, -(posY + locCanvasHeight), locCacheCanvas.width * eglViewer._scaleX, locCanvasHeight)
        }
    }, getLayerSize: function () {
        return cc.size(this._layerSize.width, this._layerSize.height)
    }, setLayerSize: function (Var) {
        this._layerSize.width = Var.width;
        this._layerSize.height = Var.height
    }, _getLayerWidth: function () {
        return this._layerSize.width
    },
    _setLayerWidth: function (width) {
        this._layerSize.width = width
    }, _getLayerHeight: function () {
        return this._layerSize.height
    }, _setLayerHeight: function (height) {
        this._layerSize.height = height
    }, getMapTileSize: function () {
        return cc.size(this._mapTileSize.width, this._mapTileSize.height)
    }, setMapTileSize: function (Var) {
        this._mapTileSize.width = Var.width;
        this._mapTileSize.height = Var.height
    }, _getTileWidth: function () {
        return this._mapTileSize.width
    }, _setTileWidth: function (width) {
        this._mapTileSize.width = width
    }, _getTileHeight: function () {
        return this._mapTileSize.height
    },
    _setTileHeight: function (height) {
        this._mapTileSize.height = height
    }, getTiles: function () {
        return this.tiles
    }, setTiles: function (Var) {
        this.tiles = Var
    }, getTileset: function () {
        return this.tileset
    }, setTileset: function (Var) {
        this.tileset = Var
    }, getLayerOrientation: function () {
        return this.layerOrientation
    }, setLayerOrientation: function (Var) {
        this.layerOrientation = Var
    }, getProperties: function () {
        return this.properties
    }, setProperties: function (Var) {
        this.properties = Var
    }, initWithTilesetInfo: function (tilesetInfo, layerInfo, mapInfo) {
        var size =
            layerInfo._layerSize;
        var totalNumberOfTiles = parseInt(size.width * size.height);
        var capacity = totalNumberOfTiles * 0.35 + 1;
        var texture;
        if (tilesetInfo)texture = cc.textureCache.addImage(tilesetInfo.sourceImage);
        if (this.initWithTexture(texture, capacity)) {
            this.layerName = layerInfo.name;
            this._layerSize = size;
            this.tiles = layerInfo._tiles;
            this._minGID = layerInfo._minGID;
            this._maxGID = layerInfo._maxGID;
            this._opacity = layerInfo._opacity;
            this.properties = layerInfo.properties;
            this._contentScaleFactor = cc.director.getContentScaleFactor();
            this.tileset = tilesetInfo;
            this._mapTileSize = mapInfo.getTileSize();
            this.layerOrientation = mapInfo.orientation;
            var offset = this._calculateLayerOffset(layerInfo.offset);
            this.setPosition(cc.pointPixelsToPoints(offset));
            this._atlasIndexArray = [];
            this.setContentSize(cc.sizePixelsToPoints(cc.size(this._layerSize.width * this._mapTileSize.width, this._layerSize.height * this._mapTileSize.height)));
            this._useAutomaticVertexZ = false;
            this._vertexZvalue = 0;
            return true
        }
        return false
    }, releaseMap: function () {
        if (this.tiles)this.tiles =
            null;
        if (this._atlasIndexArray)this._atlasIndexArray = null
    }, getTileAt: function (pos, y) {
        if (!pos)throw"cc.TMXLayer.getTileAt(): pos should be non-null";
        if (y !== undefined)pos = cc.p(pos, y);
        if (pos.x >= this._layerSize.width || pos.y >= this._layerSize.height || pos.x < 0 || pos.y < 0)throw"cc.TMXLayer.getTileAt(): invalid position";
        if (!this.tiles || !this._atlasIndexArray) {
            cc.log("cc.TMXLayer.getTileAt(): TMXLayer: the tiles map has been released");
            return null
        }
        var tile = null, gid = this.getTileGIDAt(pos);
        if (gid === 0)return tile;
        var z = 0 | pos.x + pos.y * this._layerSize.width;
        tile = this.getChildByTag(z);
        if (!tile) {
            var rect = this.tileset.rectForGID(gid);
            rect = cc.rectPixelsToPoints(rect);
            tile = new cc.Sprite;
            tile.initWithTexture(this.texture, rect);
            tile.batchNode = this;
            tile.setPosition(this.getPositionAt(pos));
            tile.vertexZ = this._vertexZForPos(pos);
            tile.anchorX = 0;
            tile.anchorY = 0;
            tile.opacity = this._opacity;
            var indexForZ = this._atlasIndexForExistantZ(z);
            this.addSpriteWithoutQuad(tile, indexForZ, z)
        }
        return tile
    }, getTileGIDAt: function (pos, y) {
        if (!pos)throw"cc.TMXLayer.getTileGIDAt(): pos should be non-null";
        if (y !== undefined)pos = cc.p(pos, y);
        if (pos.x >= this._layerSize.width || pos.y >= this._layerSize.height || pos.x < 0 || pos.y < 0)throw"cc.TMXLayer.getTileGIDAt(): invalid position";
        if (!this.tiles || !this._atlasIndexArray) {
            cc.log("cc.TMXLayer.getTileGIDAt(): TMXLayer: the tiles map has been released");
            return null
        }
        var idx = 0 | pos.x + pos.y * this._layerSize.width;
        var tile = this.tiles[idx];
        return(tile & cc.TMX_TILE_FLIPPED_MASK) >>> 0
    }, getTileFlagsAt: function (pos, y) {
        if (!pos)throw"cc.TMXLayer.getTileFlagsAt(): pos should be non-null";
        if (y !== undefined)pos = cc.p(pos, y);
        if (pos.x >= this._layerSize.width || pos.y >= this._layerSize.height || pos.x < 0 || pos.y < 0)throw"cc.TMXLayer.getTileFlagsAt(): invalid position";
        if (!this.tiles || !this._atlasIndexArray) {
            cc.log("cc.TMXLayer.getTileFlagsAt(): TMXLayer: the tiles map has been released");
            return null
        }
        var idx = 0 | pos.x + pos.y * this._layerSize.width;
        var tile = this.tiles[idx];
        return(tile & cc.TMX_TILE_FLIPPED_ALL) >>> 0
    }, setTileGID: function (gid, posOrX, flagsOrY, flags) {
        if (!posOrX)throw"cc.TMXLayer.setTileGID(): pos should be non-null";
        var pos;
        if (flags !== undefined)pos = cc.p(posOrX, flagsOrY); else {
            pos = posOrX;
            flags = flagsOrY
        }
        if (pos.x >= this._layerSize.width || pos.y >= this._layerSize.height || pos.x < 0 || pos.y < 0)throw"cc.TMXLayer.setTileGID(): invalid position";
        if (!this.tiles || !this._atlasIndexArray) {
            cc.log("cc.TMXLayer.setTileGID(): TMXLayer: the tiles map has been released");
            return
        }
        if (gid !== 0 && gid < this.tileset.firstGid) {
            cc.log("cc.TMXLayer.setTileGID(): invalid gid:" + gid);
            return
        }
        flags = flags || 0;
        this._setNodeDirtyForCache();
        var currentFlags =
            this.getTileFlagsAt(pos);
        var currentGID = this.getTileGIDAt(pos);
        if (currentGID != gid || currentFlags != flags) {
            var gidAndFlags = (gid | flags) >>> 0;
            if (gid === 0)this.removeTileAt(pos); else if (currentGID === 0)this._insertTileForGID(gidAndFlags, pos); else {
                var z = pos.x + pos.y * this._layerSize.width;
                var sprite = this.getChildByTag(z);
                if (sprite) {
                    var rect = this.tileset.rectForGID(gid);
                    rect = cc.rectPixelsToPoints(rect);
                    sprite.setTextureRect(rect, false);
                    if (flags != null)this._setupTileSprite(sprite, pos, gidAndFlags);
                    this.tiles[z] =
                        gidAndFlags
                } else this._updateTileForGID(gidAndFlags, pos)
            }
        }
    }, removeTileAt: function (pos, y) {
        if (!pos)throw"cc.TMXLayer.removeTileAt(): pos should be non-null";
        if (y !== undefined)pos = cc.p(pos, y);
        if (pos.x >= this._layerSize.width || pos.y >= this._layerSize.height || pos.x < 0 || pos.y < 0)throw"cc.TMXLayer.removeTileAt(): invalid position";
        if (!this.tiles || !this._atlasIndexArray) {
            cc.log("cc.TMXLayer.removeTileAt(): TMXLayer: the tiles map has been released");
            return
        }
        var gid = this.getTileGIDAt(pos);
        if (gid !== 0) {
            if (cc._renderType ===
                cc._RENDER_TYPE_CANVAS)this._setNodeDirtyForCache();
            var z = 0 | pos.x + pos.y * this._layerSize.width;
            var atlasIndex = this._atlasIndexForExistantZ(z);
            this.tiles[z] = 0;
            this._atlasIndexArray.splice(atlasIndex, 1);
            var sprite = this.getChildByTag(z);
            if (sprite)cc.SpriteBatchNode.prototype.removeChild.call(this, sprite, true); else {
                if (cc._renderType === cc._RENDER_TYPE_WEBGL)this.textureAtlas.removeQuadAtIndex(atlasIndex);
                if (this._children) {
                    var locChildren = this._children;
                    for (var i = 0, len = locChildren.length; i < len; i++) {
                        var child =
                            locChildren[i];
                        if (child) {
                            var ai = child.atlasIndex;
                            if (ai >= atlasIndex)child.atlasIndex = ai - 1
                        }
                    }
                }
            }
        }
    }, getPositionAt: function (pos, y) {
        if (y !== undefined)pos = cc.p(pos, y);
        var ret = cc.p(0, 0);
        switch (this.layerOrientation) {
            case cc.TMX_ORIENTATION_ORTHO:
                ret = this._positionForOrthoAt(pos);
                break;
            case cc.TMX_ORIENTATION_ISO:
                ret = this._positionForIsoAt(pos);
                break;
            case cc.TMX_ORIENTATION_HEX:
                ret = this._positionForHexAt(pos);
                break
        }
        return cc.pointPixelsToPoints(ret)
    }, getProperty: function (propertyName) {
        return this.properties[propertyName]
    },
    setupTiles: function () {
        if (cc._renderType === cc._RENDER_TYPE_CANVAS)this.tileset.imageSize = this._originalTexture.getContentSizeInPixels(); else {
            this.tileset.imageSize = this.textureAtlas.texture.getContentSizeInPixels();
            this.textureAtlas.texture.setAliasTexParameters()
        }
        this._parseInternalProperties();
        if (cc._renderType === cc._RENDER_TYPE_CANVAS)this._setNodeDirtyForCache();
        var locLayerHeight = this._layerSize.height, locLayerWidth = this._layerSize.width;
        for (var y = 0; y < locLayerHeight; y++)for (var x = 0; x < locLayerWidth; x++) {
            var pos =
                x + locLayerWidth * y;
            var gid = this.tiles[pos];
            if (gid !== 0) {
                this._appendTileForGID(gid, cc.p(x, y));
                this._minGID = Math.min(gid, this._minGID);
                this._maxGID = Math.max(gid, this._maxGID)
            }
        }
        if (!(this._maxGID >= this.tileset.firstGid && this._minGID >= this.tileset.firstGid))cc.log("cocos2d:TMX: Only 1 tileset per layer is supported")
    }, addChild: function (child, zOrder, tag) {
        cc.log("addChild: is not supported on cc.TMXLayer. Instead use setTileGID or tileAt.")
    }, removeChild: function (sprite, cleanup) {
        if (!sprite)return;
        if (this._children.indexOf(sprite) === -1) {
            cc.log("cc.TMXLayer.removeChild(): Tile does not belong to TMXLayer");
            return
        }
        if (cc._renderType === cc._RENDER_TYPE_CANVAS)this._setNodeDirtyForCache();
        var atlasIndex = sprite.atlasIndex;
        var zz = this._atlasIndexArray[atlasIndex];
        this.tiles[zz] = 0;
        this._atlasIndexArray.splice(atlasIndex, 1);
        cc.SpriteBatchNode.prototype.removeChild.call(this, sprite, cleanup)
    }, getLayerName: function () {
        return this.layerName
    }, setLayerName: function (layerName) {
        this.layerName = layerName
    }, _positionForIsoAt: function (pos) {
        return cc.p(this._mapTileSize.width /
            2 * (this._layerSize.width + pos.x - pos.y - 1), this._mapTileSize.height / 2 * (this._layerSize.height * 2 - pos.x - pos.y - 2))
    }, _positionForOrthoAt: function (pos) {
        return cc.p(pos.x * this._mapTileSize.width, (this._layerSize.height - pos.y - 1) * this._mapTileSize.height)
    }, _positionForHexAt: function (pos) {
        var diffY = pos.x % 2 == 1 ? -this._mapTileSize.height / 2 : 0;
        return cc.p(pos.x * this._mapTileSize.width * 3 / 4, (this._layerSize.height - pos.y - 1) * this._mapTileSize.height + diffY)
    }, _calculateLayerOffset: function (pos) {
        var ret = cc.p(0, 0);
        switch (this.layerOrientation) {
            case cc.TMX_ORIENTATION_ORTHO:
                ret =
                    cc.p(pos.x * this._mapTileSize.width, -pos.y * this._mapTileSize.height);
                break;
            case cc.TMX_ORIENTATION_ISO:
                ret = cc.p(this._mapTileSize.width / 2 * (pos.x - pos.y), this._mapTileSize.height / 2 * (-pos.x - pos.y));
                break;
            case cc.TMX_ORIENTATION_HEX:
                if (pos.x !== 0 || pos.y !== 0)cc.log("offset for hexagonal map not implemented yet");
                break
        }
        return ret
    }, _appendTileForGID: function (gid, pos) {
        var rect = this.tileset.rectForGID(gid);
        rect = cc.rectPixelsToPoints(rect);
        var z = 0 | pos.x + pos.y * this._layerSize.width;
        var tile = this._reusedTileWithRect(rect);
        this._setupTileSprite(tile, pos, gid);
        var indexForZ = this._atlasIndexArray.length;
        this.insertQuadFromSprite(tile, indexForZ);
        this._atlasIndexArray.splice(indexForZ, 0, z);
        return tile
    }, _insertTileForGID: function (gid, pos) {
        var rect = this.tileset.rectForGID(gid);
        rect = cc.rectPixelsToPoints(rect);
        var z = 0 | pos.x + pos.y * this._layerSize.width;
        var tile = this._reusedTileWithRect(rect);
        this._setupTileSprite(tile, pos, gid);
        var indexForZ = this._atlasIndexForNewZ(z);
        this.insertQuadFromSprite(tile, indexForZ);
        this._atlasIndexArray.splice(indexForZ,
            0, z);
        if (this._children) {
            var locChildren = this._children;
            for (var i = 0, len = locChildren.length; i < len; i++) {
                var child = locChildren[i];
                if (child) {
                    var ai = child.atlasIndex;
                    if (ai >= indexForZ)child.atlasIndex = ai + 1
                }
            }
        }
        this.tiles[z] = gid;
        return tile
    }, _updateTileForGID: function (gid, pos) {
        var rect = this.tileset.rectForGID(gid);
        var locScaleFactor = this._contentScaleFactor;
        rect = cc.rect(rect.x / locScaleFactor, rect.y / locScaleFactor, rect.width / locScaleFactor, rect.height / locScaleFactor);
        var z = pos.x + pos.y * this._layerSize.width;
        var tile = this._reusedTileWithRect(rect);
        this._setupTileSprite(tile, pos, gid);
        tile.atlasIndex = this._atlasIndexForExistantZ(z);
        tile.dirty = true;
        tile.updateTransform();
        this.tiles[z] = gid;
        return tile
    }, _parseInternalProperties: function () {
        var vertexz = this.getProperty("cc_vertexz");
        if (vertexz)if (vertexz == "automatic") {
            this._useAutomaticVertexZ = true;
            var alphaFuncVal = this.getProperty("cc_alpha_func");
            var alphaFuncValue = 0;
            if (alphaFuncVal)alphaFuncValue = parseFloat(alphaFuncVal);
            if (cc._renderType === cc._RENDER_TYPE_WEBGL) {
                this.shaderProgram =
                    cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST);
                var alphaValueLocation = cc._renderContext.getUniformLocation(this.shaderProgram.getProgram(), cc.UNIFORM_ALPHA_TEST_VALUE_S);
                this.shaderProgram.use();
                this.shaderProgram.setUniformLocationWith1f(alphaValueLocation, alphaFuncValue)
            }
        } else this._vertexZvalue = parseInt(vertexz, 10)
    }, _setupTileSprite: function (sprite, pos, gid) {
        var z = pos.x + pos.y * this._layerSize.width;
        sprite.setPosition(this.getPositionAt(pos));
        if (cc._renderType === cc._RENDER_TYPE_WEBGL)sprite.vertexZ =
            this._vertexZForPos(pos); else sprite.tag = z;
        sprite.anchorX = 0;
        sprite.anchorY = 0;
        sprite.opacity = this._opacity;
        if (cc._renderType === cc._RENDER_TYPE_WEBGL)sprite.rotation = 0;
        sprite.setFlippedX(false);
        sprite.setFlippedY(false);
        if ((gid & cc.TMX_TILE_DIAGONAL_FLAG) >>> 0) {
            sprite.anchorX = 0.5;
            sprite.anchorY = 0.5;
            sprite.x = this.getPositionAt(pos).x + sprite.width / 2;
            sprite.y = this.getPositionAt(pos).y + sprite.height / 2;
            var flag = (gid & (cc.TMX_TILE_HORIZONTAL_FLAG | cc.TMX_TILE_VERTICAL_FLAG) >>> 0) >>> 0;
            if (flag == cc.TMX_TILE_HORIZONTAL_FLAG)sprite.rotation =
                90; else if (flag == cc.TMX_TILE_VERTICAL_FLAG)sprite.rotation = 270; else if (flag == (cc.TMX_TILE_VERTICAL_FLAG | cc.TMX_TILE_HORIZONTAL_FLAG) >>> 0) {
                sprite.rotation = 90;
                sprite.setFlippedX(true)
            } else {
                sprite.rotation = 270;
                sprite.setFlippedX(true)
            }
        } else {
            if ((gid & cc.TMX_TILE_HORIZONTAL_FLAG) >>> 0)sprite.setFlippedX(true);
            if ((gid & cc.TMX_TILE_VERTICAL_FLAG) >>> 0)sprite.setFlippedY(true)
        }
    }, _reusedTileWithRect: function (rect) {
        if (cc._renderType === cc._RENDER_TYPE_WEBGL)if (!this._reusedTile) {
            this._reusedTile = new cc.Sprite;
            this._reusedTile.initWithTexture(this.texture,
                rect, false);
            this._reusedTile.batchNode = this
        } else {
            this._reusedTile.batchNode = null;
            this._reusedTile.setTextureRect(rect, false);
            this._reusedTile.batchNode = this
        } else {
            this._reusedTile = new cc.Sprite;
            this._reusedTile.initWithTexture(this._textureForCanvas, rect, false);
            this._reusedTile.batchNode = this;
            this._reusedTile.parent = this
        }
        return this._reusedTile
    }, _vertexZForPos: function (pos) {
        var ret = 0;
        var maxVal = 0;
        if (this._useAutomaticVertexZ)switch (this.layerOrientation) {
            case cc.TMX_ORIENTATION_ISO:
                maxVal = this._layerSize.width +
                    this._layerSize.height;
                ret = -(maxVal - (pos.x + pos.y));
                break;
            case cc.TMX_ORIENTATION_ORTHO:
                ret = -(this._layerSize.height - pos.y);
                break;
            case cc.TMX_ORIENTATION_HEX:
                cc.log("TMX Hexa zOrder not supported");
                break;
            default:
                cc.log("TMX invalid value");
                break
        } else ret = this._vertexZvalue;
        return ret
    }, _atlasIndexForExistantZ: function (z) {
        var item;
        if (this._atlasIndexArray) {
            var locAtlasIndexArray = this._atlasIndexArray;
            for (var i = 0, len = locAtlasIndexArray.length; i < len; i++) {
                item = locAtlasIndexArray[i];
                if (item == z)break
            }
        }
        if (typeof item !=
            "number")cc.log("cc.TMXLayer._atlasIndexForExistantZ(): TMX atlas index not found. Shall not happen");
        return i
    }, _atlasIndexForNewZ: function (z) {
        var locAtlasIndexArray = this._atlasIndexArray;
        for (var i = 0, len = locAtlasIndexArray.length; i < len; i++) {
            var val = locAtlasIndexArray[i];
            if (z < val)break
        }
        return i
    }});
var _p = cc.TMXLayer.prototype;
if (cc._renderType == cc._RENDER_TYPE_WEBGL) {
    _p.draw = cc.SpriteBatchNode.prototype.draw;
    _p.visit = cc.SpriteBatchNode.prototype.visit;
    _p.getTexture = cc.SpriteBatchNode.prototype.getTexture
} else {
    _p.draw = _p._drawForCanvas;
    _p.visit = _p._visitForCanvas;
    _p.getTexture = _p._getTextureForCanvas
}
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
_p.layerWidth;
cc.defineGetterSetter(_p, "layerWidth", _p._getLayerWidth, _p._setLayerWidth);
_p.layerHeight;
cc.defineGetterSetter(_p, "layerHeight", _p._getLayerHeight, _p._setLayerHeight);
_p.tileWidth;
cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth);
_p.tileHeight;
cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight);
cc.TMXLayer.create = function (tilesetInfo, layerInfo, mapInfo) {
    return new cc.TMXLayer(tilesetInfo, layerInfo, mapInfo)
};cc.PointObject = cc.Class.extend({_ratio: null, _offset: null, _child: null, getRatio: function () {
    return this._ratio
}, setRatio: function (value) {
    this._ratio = value
}, getOffset: function () {
    return this._offset
}, setOffset: function (value) {
    this._offset = value
}, getChild: function () {
    return this._child
}, setChild: function (value) {
    this._child = value
}, initWithCCPoint: function (ratio, offset) {
    this._ratio = ratio;
    this._offset = offset;
    this._child = null;
    return true
}});
cc.PointObject.create = function (ratio, offset) {
    var ret = new cc.PointObject;
    ret.initWithCCPoint(ratio, offset);
    return ret
};
cc.ParallaxNode = cc.NodeRGBA.extend({parallaxArray: null, _lastPosition: null, _className: "ParallaxNode", getParallaxArray: function () {
    return this.parallaxArray
}, setParallaxArray: function (value) {
    this.parallaxArray = value
}, ctor: function () {
    cc.NodeRGBA.prototype.ctor.call(this);
    this.parallaxArray = [];
    this._lastPosition = cc.p(-100, -100)
}, addChild: function (child, z, ratio, offset) {
    if (arguments.length === 3) {
        cc.log("ParallaxNode: use addChild(child, z, ratio, offset) instead");
        return
    }
    if (!child)throw"cc.ParallaxNode.addChild(): child should be non-null";
    var obj = cc.PointObject.create(ratio, offset);
    obj.setChild(child);
    this.parallaxArray.push(obj);
    child.setPosition(this._position.x * ratio.x + offset.x, this._position.y * ratio.y + offset.y);
    cc.NodeRGBA.prototype.addChild.call(this, child, z, child.tag)
}, removeChild: function (child, cleanup) {
    var locParallaxArray = this.parallaxArray;
    for (var i = 0; i < locParallaxArray.length; i++) {
        var point = locParallaxArray[i];
        if (point.getChild() == child) {
            locParallaxArray.splice(i, 1);
            break
        }
    }
    cc.NodeRGBA.prototype.removeChild.call(this, child,
        cleanup)
}, removeAllChildren: function (cleanup) {
    this.parallaxArray.length = 0;
    cc.NodeRGBA.prototype.removeAllChildren.call(this, cleanup)
}, visit: function () {
    var pos = this._absolutePosition();
    if (!cc.pointEqualToPoint(pos, this._lastPosition)) {
        var locParallaxArray = this.parallaxArray;
        for (var i = 0, len = locParallaxArray.length; i < len; i++) {
            var point = locParallaxArray[i];
            var child = point.getChild();
            child.setPosition(-pos.x + pos.x * point.getRatio().x + point.getOffset().x, -pos.y + pos.y * point.getRatio().y + point.getOffset().y)
        }
        this._lastPosition =
            pos
    }
    cc.NodeRGBA.prototype.visit.call(this)
}, _absolutePosition: function () {
    var ret = this._position;
    var cn = this;
    while (cn.parent != null) {
        cn = cn.parent;
        ret = cc.pAdd(ret, cn.getPosition())
    }
    return ret
}});
cc.ParallaxNode.create = function () {
    return new cc.ParallaxNode
};cc.CONTROL_EVENT_TOTAL_NUMBER = 9;
cc.CONTROL_EVENT_TOUCH_DOWN = 1 << 0;
cc.CONTROL_EVENT_TOUCH_DRAG_INSIDE = 1 << 1;
cc.CONTROL_EVENT_TOUCH_DRAG_OUTSIDE = 1 << 2;
cc.CONTROL_EVENT_TOUCH_DRAG_ENTER = 1 << 3;
cc.CONTROL_EVENT_TOUCH_DRAG_EXIT = 1 << 4;
cc.CONTROL_EVENT_TOUCH_UP_INSIDE = 1 << 5;
cc.CONTROL_EVENT_TOUCH_UP_OUTSIDE = 1 << 6;
cc.CONTROL_EVENT_TOUCH_CANCEL = 1 << 7;
cc.CONTROL_EVENT_VALUECHANGED = 1 << 8;
cc.CONTROL_STATE_NORMAL = 1 << 0;
cc.CONTROL_STATE_HIGHLIGHTED = 1 << 1;
cc.CONTROL_STATE_DISABLED = 1 << 2;
cc.CONTROL_STATE_SELECTED = 1 << 3;
cc.CONTROL_STATE_INITIAL = 1 << 3;
cc.Control = cc.LayerRGBA.extend({_isOpacityModifyRGB: false, _hasVisibleParents: false, _touchListener: null, _className: "Control", isOpacityModifyRGB: function () {
    return this._isOpacityModifyRGB
}, setOpacityModifyRGB: function (opacityModifyRGB) {
    this._isOpacityModifyRGB = opacityModifyRGB;
    var children = this.getChildren();
    for (var i = 0, len = children.length; i < len; i++) {
        var selNode = children[i];
        if (selNode && selNode.RGBAProtocol)selNode.setOpacityModifyRGB(opacityModifyRGB)
    }
}, _state: cc.CONTROL_STATE_NORMAL, getState: function () {
    return this._state
},
    _enabled: false, _selected: false, _highlighted: false, _dispatchTable: null, setEnabled: function (enabled) {
        this._enabled = enabled;
        this._state = enabled ? cc.CONTROL_STATE_NORMAL : cc.CONTROL_STATE_DISABLED;
        this.needsLayout()
    }, isEnabled: function () {
        return this._enabled
    }, setSelected: function (selected) {
        this._selected = selected;
        this.needsLayout()
    }, isSelected: function () {
        return this._selected
    }, setHighlighted: function (highlighted) {
        this._highlighted = highlighted;
        this.needsLayout()
    }, isHighlighted: function () {
        return this._highlighted
    },
    hasVisibleParents: function () {
        var parent = this.getParent();
        for (var c = parent; c != null; c = c.getParent())if (!c.isVisible())return false;
        return true
    }, ctor: function () {
        cc.LayerRGBA.prototype.ctor.call(this);
        this._dispatchTable = {};
        this._color = cc.color.WHITE
    }, init: function () {
        if (cc.LayerRGBA.prototype.init.call(this)) {
            this._state = cc.CONTROL_STATE_NORMAL;
            this._enabled = true;
            this._selected = false;
            this._highlighted = false;
            var listener = cc.EventListener.create({event: cc.EventListener.TOUCH_ONE_BY_ONE});
            if (this.onTouchBegan)listener.onTouchBegan =
                this.onTouchBegan.bind(this);
            if (this.onTouchMoved)listener.onTouchMoved = this.onTouchMoved.bind(this);
            if (this.onTouchEnded)listener.onTouchEnded = this.onTouchEnded.bind(this);
            if (this.onTouchCancelled)listener.onTouchCancelled = this.onTouchCancelled.bind(this);
            this._touchListener = listener;
            return true
        } else return false
    }, onEnter: function () {
        var locListener = this._touchListener;
        if (!locListener._isRegistered())cc.eventManager.addListener(locListener, this);
        cc.Node.prototype.onEnter.call(this)
    }, sendActionsForControlEvents: function (controlEvents) {
        for (var i =
            0, len = cc.CONTROL_EVENT_TOTAL_NUMBER; i < len; i++)if (controlEvents & 1 << i) {
            var invocationList = this._dispatchListforControlEvent(1 << i);
            for (var j = 0, inLen = invocationList.length; j < inLen; j++)invocationList[j].invoke(this)
        }
    }, addTargetWithActionForControlEvents: function (target, action, controlEvents) {
        for (var i = 0, len = cc.CONTROL_EVENT_TOTAL_NUMBER; i < len; i++)if (controlEvents & 1 << i)this._addTargetWithActionForControlEvent(target, action, 1 << i)
    }, removeTargetWithActionForControlEvents: function (target, action, controlEvents) {
        for (var i =
            0, len = cc.CONTROL_EVENT_TOTAL_NUMBER; i < len; i++)if (controlEvents & 1 << i)this._removeTargetWithActionForControlEvent(target, action, 1 << i)
    }, getTouchLocation: function (touch) {
        var touchLocation = touch.getLocation();
        return this.convertToNodeSpace(touchLocation)
    }, isTouchInside: function (touch) {
        var touchLocation = touch.getLocation();
        touchLocation = this.getParent().convertToNodeSpace(touchLocation);
        return cc.rectContainsPoint(this.getBoundingBox(), touchLocation)
    }, _invocationWithTargetAndActionForControlEvent: function (target, action, controlEvent) {
        return null
    }, _dispatchListforControlEvent: function (controlEvent) {
        controlEvent = controlEvent.toString();
        if (!this._dispatchTable[controlEvent])this._dispatchTable[controlEvent] = [];
        return this._dispatchTable[controlEvent]
    }, _addTargetWithActionForControlEvent: function (target, action, controlEvent) {
        var invocation = new cc.Invocation(target, action, controlEvent);
        var eventInvocationList = this._dispatchListforControlEvent(controlEvent);
        eventInvocationList.push(invocation)
    }, _removeTargetWithActionForControlEvent: function (target, action, controlEvent) {
        var eventInvocationList = this._dispatchListforControlEvent(controlEvent);
        var bDeleteObjects = true;
        if (!target && !action)eventInvocationList.length = 0; else for (var i = 0; i < eventInvocationList.length;) {
            var invocation = eventInvocationList[i];
            var shouldBeRemoved = true;
            if (target)shouldBeRemoved = target == invocation.getTarget();
            if (action)shouldBeRemoved = shouldBeRemoved && action == invocation.getAction();
            if (shouldBeRemoved)cc.arrayRemoveObject(eventInvocationList, invocation); else i++
        }
    }, needsLayout: function () {
    }});
var _p = cc.Control.prototype;
_p.state;
cc.defineGetterSetter(_p, "state", _p.getState);
_p.enabled;
cc.defineGetterSetter(_p, "enabled", _p.isEnabled, _p.setEnabled);
_p.selected;
cc.defineGetterSetter(_p, "selected", _p.isSelected, _p.setSelected);
_p.highlighted;
cc.defineGetterSetter(_p, "highlighted", _p.isHighlighted, _p.setHighlighted);
_p = null;
cc.Control.create = function () {
    var retControl = new cc.Control;
    if (retControl && retControl.init())return retControl;
    return null
};
cc.CONTROL_ZOOM_ACTION_TAG = 3435855873;
cc.ControlButton = cc.Control.extend({_doesAdjustBackgroundImage: false, zoomOnTouchDown: false, _preferredSize: null, _labelAnchorPoint: null, _currentTitle: null, _currentTitleColor: null, _titleLabel: null, _backgroundSprite: null, _opacity: 0, _isPushed: false, _titleDispatchTable: null, _titleColorDispatchTable: null, _titleLabelDispatchTable: null, _backgroundSpriteDispatchTable: null, _parentInited: false, _marginV: 0, _marginH: 0, _className: "ControlButton", ctor: function () {
    cc.Control.prototype.ctor.call(this);
    this._preferredSize =
        cc.size(0, 0);
    this._labelAnchorPoint = cc.p(0, 0);
    this._currentTitle = "";
    this._currentTitleColor = cc.color.WHITE;
    this._titleDispatchTable = {};
    this._titleColorDispatchTable = {};
    this._titleLabelDispatchTable = {};
    this._backgroundSpriteDispatchTable = {}
}, init: function () {
    return this.initWithLabelAndBackgroundSprite(cc.LabelTTF.create("", "Arial", 12), cc.Scale9Sprite.create())
}, needsLayout: function () {
    if (!this._parentInited)return;
    if (this._titleLabel)this._titleLabel.setVisible(false);
    if (this._backgroundSprite)this._backgroundSprite.setVisible(false);
    this.setLabelAnchorPoint(this._labelAnchorPoint);
    var locState = this._state;
    this._currentTitle = this.getTitleForState(locState);
    this._currentTitleColor = this.getTitleColorForState(locState);
    this._titleLabel = this.getTitleLabelForState(locState);
    var label = this._titleLabel;
    if (label && label.setString)label.setString(this._currentTitle);
    if (label && label.RGBAProtocol)label.setColor(this._currentTitleColor);
    var locContentSize = this.getContentSize();
    if (label)label.setPosition(locContentSize.width / 2, locContentSize.height /
        2);
    this._backgroundSprite = this.getBackgroundSpriteForState(locState);
    var locBackgroundSprite = this._backgroundSprite;
    if (locBackgroundSprite)locBackgroundSprite.setPosition(locContentSize.width / 2, locContentSize.height / 2);
    var titleLabelSize = cc.size(0, 0);
    if (label) {
        var boundingBox = label.getBoundingBox();
        titleLabelSize.width = boundingBox.width;
        titleLabelSize.height = boundingBox.height
    }
    if (this._doesAdjustBackgroundImage) {
        if (locBackgroundSprite)locBackgroundSprite.setContentSize(titleLabelSize.width + this._marginH *
            2, titleLabelSize.height + this._marginV * 2)
    } else if (locBackgroundSprite) {
        var preferredSize = locBackgroundSprite.getPreferredSize();
        preferredSize = cc.size(preferredSize.width, preferredSize.height);
        if (preferredSize.width <= 0)preferredSize.width = titleLabelSize.width;
        if (preferredSize.height <= 0)preferredSize.height = titleLabelSize.height;
        locBackgroundSprite.setContentSize(preferredSize)
    }
    var rectTitle = label ? label.getBoundingBox() : cc.rect(0, 0, 0, 0);
    var rectBackground = locBackgroundSprite ? locBackgroundSprite.getBoundingBox() :
        cc.rect(0, 0, 0, 0);
    var maxRect = cc.rectUnion(rectTitle, rectBackground);
    this.setContentSize(maxRect.width, maxRect.height);
    locContentSize = this.getContentSize();
    if (label) {
        label.setPosition(locContentSize.width / 2, locContentSize.height / 2);
        label.setVisible(true)
    }
    if (locBackgroundSprite) {
        locBackgroundSprite.setPosition(locContentSize.width / 2, locContentSize.height / 2);
        locBackgroundSprite.setVisible(true)
    }
}, initWithLabelAndBackgroundSprite: function (label, backgroundSprite) {
    if (!label || !label.RGBAProtocol)throw"cc.ControlButton.initWithLabelAndBackgroundSprite(): label should be non-null";
    if (!backgroundSprite)throw"cc.ControlButton.initWithLabelAndBackgroundSprite(): backgroundSprite should be non-null";
    if (cc.Control.prototype.init.call(this, true)) {
        this._parentInited = true;
        this._titleDispatchTable = {};
        this._titleColorDispatchTable = {};
        this._titleLabelDispatchTable = {};
        this._backgroundSpriteDispatchTable = {};
        this._isPushed = false;
        this.zoomOnTouchDown = true;
        this._currentTitle = null;
        this.setAdjustBackgroundImage(true);
        this.setPreferredSize(cc.size(0, 0));
        this.zoomOnTouchDown = true;
        this.ignoreAnchorPointForPosition(false);
        this.setAnchorPoint(0.5, 0.5);
        this._titleLabel = label;
        this._backgroundSprite = backgroundSprite;
        this.setOpacity(255);
        this.setOpacityModifyRGB(true);
        var tempString = label.getString();
        this.setTitleForState(tempString, cc.CONTROL_STATE_NORMAL);
        this.setTitleColorForState(label.getColor(), cc.CONTROL_STATE_NORMAL);
        this.setTitleLabelForState(label, cc.CONTROL_STATE_NORMAL);
        this.setBackgroundSpriteForState(backgroundSprite, cc.CONTROL_STATE_NORMAL);
        this._state = cc.CONTROL_STATE_NORMAL;
        this._marginH = 24;
        this._marginV =
            12;
        this._labelAnchorPoint = cc.p(0.5, 0.5);
        this.setPreferredSize(cc.size(0, 0));
        this.needsLayout();
        return true
    } else return false
}, initWithTitleAndFontNameAndFontSize: function (title, fontName, fontSize) {
    var label = cc.LabelTTF.create(title, fontName, fontSize);
    return this.initWithLabelAndBackgroundSprite(label, cc.Scale9Sprite.create())
}, initWithBackgroundSprite: function (sprite) {
    var label = cc.LabelTTF.create("", "Arial", 30);
    return this.initWithLabelAndBackgroundSprite(label, sprite)
}, doesAdjustBackgroundImage: function () {
    return this._doesAdjustBackgroundImage
},
    setAdjustBackgroundImage: function (adjustBackgroundImage) {
        this._doesAdjustBackgroundImage = adjustBackgroundImage;
        this.needsLayout()
    }, getZoomOnTouchDown: function () {
        return this.zoomOnTouchDown
    }, setZoomOnTouchDown: function (zoomOnTouchDown) {
        return this.zoomOnTouchDown = zoomOnTouchDown
    }, getPreferredSize: function () {
        return this._preferredSize
    }, setPreferredSize: function (size) {
        if (size.width === 0 && size.height === 0)this._doesAdjustBackgroundImage = true; else {
            this._doesAdjustBackgroundImage = false;
            var locTable = this._backgroundSpriteDispatchTable;
            for (var itemKey in locTable)locTable[itemKey].setPreferredSize(size)
        }
        this._preferredSize = size;
        this.needsLayout()
    }, getLabelAnchorPoint: function () {
        return this._labelAnchorPoint
    }, setLabelAnchorPoint: function (labelAnchorPoint) {
        this._labelAnchorPoint = labelAnchorPoint;
        if (this._titleLabel)this._titleLabel.setAnchorPoint(labelAnchorPoint)
    }, _getCurrentTitle: function () {
        return this._currentTitle
    }, _getCurrentTitleColor: function () {
        return this._currentTitleColor
    }, getOpacity: function () {
        return this._opacity
    }, setOpacity: function (opacity) {
        cc.Control.prototype.setOpacity.call(this,
            opacity);
        var locTable = this._backgroundSpriteDispatchTable;
        for (var itemKey in locTable)locTable[itemKey].setOpacity(opacity)
    }, setColor: function (color) {
        cc.Control.prototype.setColor.call(this, color);
        var locTable = this._backgroundSpriteDispatchTable;
        for (var key in locTable)locTable[key].setColor(color)
    }, getColor: function () {
        var locRealColor = this._realColor;
        return cc.color(locRealColor.r, locRealColor.g, locRealColor.b, locRealColor.a)
    }, isPushed: function () {
        return this._isPushed
    }, _getVerticalMargin: function () {
        return this._marginV
    },
    _getHorizontalOrigin: function () {
        return this._marginH
    }, setMargins: function (marginH, marginV) {
        this._marginV = marginV;
        this._marginH = marginH;
        this.needsLayout()
    }, setEnabled: function (enabled) {
        cc.Control.prototype.setEnabled.call(this, enabled);
        this.needsLayout()
    }, setSelected: function (enabled) {
        cc.Control.prototype.setSelected.call(this, enabled);
        this.needsLayout()
    }, setHighlighted: function (enabled) {
        this._state = enabled ? cc.CONTROL_STATE_HIGHLIGHTED : cc.CONTROL_STATE_NORMAL;
        cc.Control.prototype.setHighlighted.call(this,
            enabled);
        var action = this.getActionByTag(cc.CONTROL_ZOOM_ACTION_TAG);
        if (action)this.stopAction(action);
        this.needsLayout();
        if (this.zoomOnTouchDown) {
            var scaleValue = this.isHighlighted() && this.isEnabled() && !this.isSelected() ? 1.1 : 1;
            var zoomAction = cc.ScaleTo.create(0.05, scaleValue);
            zoomAction.setTag(cc.CONTROL_ZOOM_ACTION_TAG);
            this.runAction(zoomAction)
        }
    }, onTouchBegan: function (touch, event) {
        if (!this.isTouchInside(touch) || !this.isEnabled() || !this.isVisible() || !this.hasVisibleParents())return false;
        this._isPushed =
            true;
        this.setHighlighted(true);
        this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_DOWN);
        return true
    }, onTouchMoved: function (touch, event) {
        if (!this._enabled || !this._isPushed || this._selected) {
            if (this._highlighted)this.setHighlighted(false);
            return
        }
        var isTouchMoveInside = this.isTouchInside(touch);
        if (isTouchMoveInside && !this._highlighted) {
            this.setHighlighted(true);
            this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_DRAG_ENTER)
        } else if (isTouchMoveInside && this._highlighted)this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_DRAG_INSIDE);
        else if (!isTouchMoveInside && this._highlighted) {
            this.setHighlighted(false);
            this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_DRAG_EXIT)
        } else if (!isTouchMoveInside && !this._highlighted)this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_DRAG_OUTSIDE)
    }, onTouchEnded: function (touch, event) {
        this._isPushed = false;
        this.setHighlighted(false);
        if (this.isTouchInside(touch))this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_UP_INSIDE); else this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_UP_OUTSIDE)
    },
    onTouchCancelled: function (touch, event) {
        this._isPushed = false;
        this.setHighlighted(false);
        this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_CANCEL)
    }, getTitleForState: function (state) {
        var locTable = this._titleDispatchTable;
        if (locTable) {
            if (locTable[state])return locTable[state];
            return locTable[cc.CONTROL_STATE_NORMAL]
        }
        return""
    }, setTitleForState: function (title, state) {
        this._titleDispatchTable[state] = title || "";
        if (this.getState() == state)this.needsLayout()
    }, getTitleColorForState: function (state) {
        var colorObject =
            this._titleColorDispatchTable[state];
        if (colorObject)return colorObject;
        colorObject = this._titleColorDispatchTable[cc.CONTROL_STATE_NORMAL];
        if (colorObject)return colorObject;
        return cc.color.WHITE
    }, setTitleColorForState: function (color, state) {
        this._titleColorDispatchTable[state] = color;
        if (this.getState() == state)this.needsLayout()
    }, getTitleLabelForState: function (state) {
        var locTable = this._titleLabelDispatchTable;
        if (locTable[state])return locTable[state];
        return locTable[cc.CONTROL_STATE_NORMAL]
    }, setTitleLabelForState: function (titleLabel, state) {
        var locTable = this._titleLabelDispatchTable;
        if (locTable[state]) {
            var previousLabel = locTable[state];
            if (previousLabel)this.removeChild(previousLabel, true)
        }
        locTable[state] = titleLabel;
        titleLabel.setVisible(false);
        titleLabel.setAnchorPoint(0.5, 0.5);
        this.addChild(titleLabel, 1);
        if (this.getState() == state)this.needsLayout()
    }, setTitleTTFForState: function (fntFile, state) {
        var title = this.getTitleForState(state);
        if (!title)title = "";
        this.setTitleLabelForState(cc.LabelTTF.create(title, fntFile, 12), state)
    }, getTitleTTFForState: function (state) {
        var labelTTF =
            this.getTitleLabelForState(state);
        if (labelTTF != null && labelTTF instanceof cc.LabelTTF)return labelTTF.getFontName(); else return""
    }, setTitleTTFSizeForState: function (size, state) {
        var labelTTF = this.getTitleLabelForState(state);
        if (labelTTF != null && labelTTF instanceof cc.LabelTTF)labelTTF.setFontSize(size)
    }, getTitleTTFSizeForState: function (state) {
        var labelTTF = this.getTitleLabelForState(state);
        if (labelTTF != null && labelTTF instanceof cc.LabelTTF)return labelTTF.getFontSize();
        return 0
    }, setTitleBMFontForState: function (fntFile, state) {
        var title = this.getTitleForState(state);
        if (!title)title = "";
        this.setTitleLabelForState(cc.LabelBMFont.create(title, fntFile), state)
    }, getTitleBMFontForState: function (state) {
        var labelBMFont = this.getTitleLabelForState(state);
        if (labelBMFont != null && labelBMFont instanceof cc.LabelBMFont)return labelBMFont.getFntFile();
        return""
    }, getBackgroundSpriteForState: function (state) {
        var locTable = this._backgroundSpriteDispatchTable;
        if (locTable[state])return locTable[state];
        return locTable[cc.CONTROL_STATE_NORMAL]
    },
    setBackgroundSpriteForState: function (sprite, state) {
        var locTable = this._backgroundSpriteDispatchTable;
        if (locTable[state]) {
            var previousSprite = locTable[state];
            if (previousSprite)this.removeChild(previousSprite, true)
        }
        locTable[state] = sprite;
        sprite.setVisible(false);
        sprite.setAnchorPoint(0.5, 0.5);
        this.addChild(sprite);
        var locPreferredSize = this._preferredSize;
        if (locPreferredSize.width !== 0 || locPreferredSize.height !== 0)sprite.setPreferredSize(locPreferredSize);
        if (this._state === state)this.needsLayout()
    }, setBackgroundSpriteFrameForState: function (spriteFrame, state) {
        var sprite = cc.Scale9Sprite.createWithSpriteFrame(spriteFrame);
        this.setBackgroundSpriteForState(sprite, state)
    }});
var _p = cc.ControlButton.prototype;
_p.adjustBackground;
cc.defineGetterSetter(_p, "adjustBackground", _p.getAdjustBackgroundImage, _p.setAdjustBackgroundImage);
_p.preferredSize;
cc.defineGetterSetter(_p, "preferredSize", _p.getPreferredSize, _p.setPreferredSize);
_p.labelAnchor;
cc.defineGetterSetter(_p, "labelAnchor", _p.getLabelAnchorPoint, _p.setLabelAnchorPoint);
_p = null;
cc.ControlButton.create = function (label, backgroundSprite) {
    var controlButton;
    if (arguments.length == 0) {
        controlButton = new cc.ControlButton;
        if (controlButton && controlButton.init())return controlButton;
        return null
    } else if (arguments.length == 1) {
        controlButton = new cc.ControlButton;
        controlButton.initWithBackgroundSprite(arguments[0])
    } else if (arguments.length == 2) {
        controlButton = new cc.ControlButton;
        controlButton.initWithLabelAndBackgroundSprite(label, backgroundSprite)
    } else if (arguments.length == 3) {
        controlButton =
            new cc.ControlButton;
        controlButton.initWithTitleAndFontNameAndFontSize(arguments[0], arguments[1], arguments[2])
    }
    return controlButton
};
cc.RGBA = function (r, g, b, a) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a
};
cc.HSV = function (h, s, v) {
    this.h = h;
    this.s = s;
    this.v = v
};
cc.ControlUtils = {};
cc.ControlUtils.addSpriteToTargetWithPosAndAnchor = function (spriteName, target, pos, anchor) {
    var sprite = cc.Sprite.create("#" + spriteName);
    if (!sprite)return null;
    sprite.setPosition(pos);
    sprite.setAnchorPoint(anchor);
    target.addChild(sprite);
    return sprite
};
cc.ControlUtils.HSVfromRGB = function (rgbaValue) {
    var out = new cc.HSV;
    var min, max, delta;
    min = rgbaValue.r < rgbaValue.g ? rgbaValue.r : rgbaValue.g;
    min = min < rgbaValue.b ? min : rgbaValue.b;
    max = rgbaValue.r > rgbaValue.g ? rgbaValue.r : rgbaValue.g;
    max = max > rgbaValue.b ? max : rgbaValue.b;
    out.v = max;
    delta = max - min;
    if (max > 0)out.s = delta / max; else {
        out.s = 0;
        out.h = -1;
        return out
    }
    if (rgbaValue.r >= max)out.h = (rgbaValue.g - rgbaValue.b) / delta; else if (rgbaValue.g >= max)out.h = 2 + (rgbaValue.b - rgbaValue.r) / delta; else out.h = 4 + (rgbaValue.r - rgbaValue.g) /
        delta;
    out.h *= 60;
    if (out.h < 0)out.h += 360;
    return out
};
cc.ControlUtils.RGBfromHSV = function (hsvValue) {
    var hh, p, q, t, ff;
    var i;
    var out = new cc.RGBA;
    out.a = 1;
    if (hsvValue.s <= 0) {
        if (!hsvValue.h) {
            out.r = hsvValue.v;
            out.g = hsvValue.v;
            out.b = hsvValue.v;
            return out
        }
        out.r = 0;
        out.g = 0;
        out.b = 0;
        return out
    }
    hh = hsvValue.h;
    if (hh >= 360)hh = 0;
    hh /= 60;
    i = 0 | hh;
    ff = hh - i;
    p = hsvValue.v * (1 - hsvValue.s);
    q = hsvValue.v * (1 - hsvValue.s * ff);
    t = hsvValue.v * (1 - hsvValue.s * (1 - ff));
    switch (i) {
        case 0:
            out.r = hsvValue.v;
            out.g = t;
            out.b = p;
            break;
        case 1:
            out.r = q;
            out.g = hsvValue.v;
            out.b = p;
            break;
        case 2:
            out.r = p;
            out.g = hsvValue.v;
            out.b = t;
            break;
        case 3:
            out.r = p;
            out.g = q;
            out.b = hsvValue.v;
            break;
        case 4:
            out.r = t;
            out.g = p;
            out.b = hsvValue.v;
            break;
        default:
            out.r = hsvValue.v;
            out.g = p;
            out.b = q;
            break
    }
    return out
};
cc.ControlUtils.CCRectUnion = function (rect1, rect2) {
    return cc.rectUnion(rect1, rect2)
};
cc.Invocation = cc.Class.extend({_action: null, _target: null, _controlEvent: null, ctor: function (target, action, controlEvent) {
    this._target = target;
    this._action = action;
    this._controlEvent = controlEvent
}, getAction: function () {
    return this._action
}, getTarget: function () {
    return this._target
}, getControlEvent: function () {
    return this._controlEvent
}, invoke: function (sender) {
    if (this._target && this._action)if (typeof this._action == "string")this._target[this._action](sender, this._controlEvent); else this._action.call(this._target,
        sender, this._controlEvent)
}});
cc.Scale9Sprite = cc.NodeRGBA.extend({RGBAProtocol: true, _spriteRect: null, _capInsetsInternal: null, _positionsAreDirty: false, _scale9Image: null, _topLeft: null, _top: null, _topRight: null, _left: null, _centre: null, _right: null, _bottomLeft: null, _bottom: null, _bottomRight: null, _colorUnmodified: null, _opacityModifyRGB: false, _originalSize: null, _preferredSize: null, _opacity: 0, _color: null, _capInsets: null, _insetLeft: 0, _insetTop: 0, _insetRight: 0, _insetBottom: 0, _spritesGenerated: false, _spriteFrameRotated: false, _textureLoaded: false,
    _loadedEventListeners: null, _className: "Scale9Sprite", textureLoaded: function () {
        return this._textureLoaded
    }, addLoadedEventListener: function (callback, target) {
        this._loadedEventListeners.push({eventCallback: callback, eventTarget: target})
    }, _callLoadedEventCallbacks: function () {
        this._textureLoaded = true;
        var locListeners = this._loadedEventListeners;
        for (var i = 0, len = locListeners.length; i < len; i++) {
            var selCallback = locListeners[i];
            selCallback.eventCallback.call(selCallback.eventTarget, this)
        }
        locListeners.length = 0
    },
    _updateCapInset: function () {
        var insets, locInsetLeft = this._insetLeft, locInsetTop = this._insetTop, locInsetRight = this._insetRight;
        var locSpriteRect = this._spriteRect, locInsetBottom = this._insetBottom;
        if (locInsetLeft === 0 && locInsetTop === 0 && locInsetRight === 0 && locInsetBottom === 0)insets = cc.rect(0, 0, 0, 0); else insets = this._spriteFrameRotated ? cc.rect(locInsetBottom, locInsetLeft, locSpriteRect.width - locInsetRight - locInsetLeft, locSpriteRect.height - locInsetTop - locInsetBottom) : cc.rect(locInsetLeft, locInsetTop, locSpriteRect.width -
            locInsetLeft - locInsetRight, locSpriteRect.height - locInsetTop - locInsetBottom);
        this.setCapInsets(insets)
    }, _updatePositions: function () {
        if (!(this._topLeft && this._topRight && this._bottomRight && this._bottomLeft && this._centre))return;
        var size = this._contentSize;
        var locTopLeft = this._topLeft, locTopRight = this._topRight, locBottomRight = this._bottomRight, locBottomLeft = this._bottomLeft;
        var locCenter = this._centre, locCenterContentSize = this._centre.getContentSize();
        var locTopLeftContentSize = locTopLeft.getContentSize();
        var locBottomLeftContentSize = locBottomLeft.getContentSize();
        var sizableWidth = size.width - locTopLeftContentSize.width - locTopRight.getContentSize().width;
        var sizableHeight = size.height - locTopLeftContentSize.height - locBottomRight.getContentSize().height;
        var horizontalScale = sizableWidth / locCenterContentSize.width;
        var verticalScale = sizableHeight / locCenterContentSize.height;
        var rescaledWidth = locCenterContentSize.width * horizontalScale;
        var rescaledHeight = locCenterContentSize.height * verticalScale;
        var leftWidth =
            locBottomLeftContentSize.width;
        var bottomHeight = locBottomLeftContentSize.height;
        if (cc._renderType == cc._RENDER_TYPE_WEBGL) {
            var roundedRescaledWidth = Math.round(rescaledWidth);
            if (rescaledWidth != roundedRescaledWidth) {
                rescaledWidth = roundedRescaledWidth;
                horizontalScale = rescaledWidth / locCenterContentSize.width
            }
            var roundedRescaledHeight = Math.round(rescaledHeight);
            if (rescaledHeight != roundedRescaledHeight) {
                rescaledHeight = roundedRescaledHeight;
                verticalScale = rescaledHeight / locCenterContentSize.height
            }
        }
        locCenter.setScaleX(horizontalScale);
        locCenter.setScaleY(verticalScale);
        var locLeft = this._left, locRight = this._right, locTop = this._top, locBottom = this._bottom;
        var tempAP = cc.p(0, 0);
        locBottomLeft.setAnchorPoint(tempAP);
        locBottomRight.setAnchorPoint(tempAP);
        locTopLeft.setAnchorPoint(tempAP);
        locTopRight.setAnchorPoint(tempAP);
        locLeft.setAnchorPoint(tempAP);
        locRight.setAnchorPoint(tempAP);
        locTop.setAnchorPoint(tempAP);
        locBottom.setAnchorPoint(tempAP);
        locCenter.setAnchorPoint(tempAP);
        locBottomLeft.setPosition(0, 0);
        locBottomRight.setPosition(leftWidth +
            rescaledWidth, 0);
        locTopLeft.setPosition(0, bottomHeight + rescaledHeight);
        locTopRight.setPosition(leftWidth + rescaledWidth, bottomHeight + rescaledHeight);
        locLeft.setPosition(0, bottomHeight);
        locLeft.setScaleY(verticalScale);
        locRight.setPosition(leftWidth + rescaledWidth, bottomHeight);
        locRight.setScaleY(verticalScale);
        locBottom.setPosition(leftWidth, 0);
        locBottom.setScaleX(horizontalScale);
        locTop.setPosition(leftWidth, bottomHeight + rescaledHeight);
        locTop.setScaleX(horizontalScale);
        locCenter.setPosition(leftWidth,
            bottomHeight)
    }, ctor: function () {
        cc.NodeRGBA.prototype.ctor.call(this);
        this._spriteRect = cc.rect(0, 0, 0, 0);
        this._capInsetsInternal = cc.rect(0, 0, 0, 0);
        this._colorUnmodified = cc.color(255, 255, 255, 255);
        this._originalSize = cc.size(0, 0);
        this._preferredSize = cc.size(0, 0);
        this._color = cc.color(255, 255, 255, 255);
        this._opacity = 255;
        this._capInsets = cc.rect(0, 0, 0, 0);
        this._loadedEventListeners = []
    }, getOriginalSize: function () {
        return this._originalSize
    }, getPreferredSize: function () {
        return this._preferredSize
    }, _getPreferredWidth: function () {
        return this._preferredSize.width
    },
    _getPreferredHeight: function () {
        return this._preferredSize.height
    }, setPreferredSize: function (preferredSize) {
        this.setContentSize(preferredSize);
        this._preferredSize = preferredSize
    }, _setPreferredWidth: function (value) {
        this._setWidth(value);
        this._preferredSize.width = value
    }, _setPreferredHeight: function (value) {
        this._setHeight(value);
        this._preferredSize.height = value
    }, getOpacity: function () {
        return this._opacity
    }, setOpacity: function (opacity) {
        if (!this._scale9Image)return;
        this._opacity = opacity;
        var scaleChildren =
            this._scale9Image.getChildren();
        for (var i = 0; i < scaleChildren.length; i++) {
            var selChild = scaleChildren[i];
            if (selChild && selChild.RGBAProtocol)selChild.setOpacity(opacity)
        }
        this._color.a = opacity
    }, updateDisplayedOpacity: function (parentOpacity) {
        cc.NodeRGBA.prototype.updateDisplayedOpacity.call(this, parentOpacity);
        this.setOpacity(this._displayedOpacity)
    }, getColor: function () {
        var locColor = this._color;
        return cc.color(locColor.r, locColor.g, locColor.b, locColor.a)
    }, setColor: function (color) {
        if (!this._scale9Image)return;
        var locColor = this._color;
        locColor.r = color.r;
        locColor.g = color.g;
        locColor.b = color.b;
        var scaleChildren = this._scale9Image.getChildren();
        for (var i = 0; i < scaleChildren.length; i++) {
            var selChild = scaleChildren[i];
            if (selChild && selChild.RGBAProtocol)selChild.setColor(color)
        }
        if (color.a !== undefined && !color.a_undefined)this.setOpacity(color.a)
    }, updateDisplayedColor: function (parentColor) {
        cc.NodeRGBA.prototype.updateDisplayedColor.call(this, parentColor);
        this.setColor(this._displayedColor)
    }, getCapInsets: function () {
        return this._capInsets
    },
    setCapInsets: function (capInsets) {
        if (!this._scale9Image)return;
        var contentSize = this._contentSize;
        var tempWidth = contentSize.width, tempHeight = contentSize.height;
        this.updateWithBatchNode(this._scale9Image, this._spriteRect, this._spriteFrameRotated, capInsets);
        this.setContentSize(tempWidth, tempHeight)
    }, getInsetLeft: function () {
        return this._insetLeft
    }, setInsetLeft: function (insetLeft) {
        this._insetLeft = insetLeft;
        this._updateCapInset()
    }, getInsetTop: function () {
        return this._insetTop
    }, setInsetTop: function (insetTop) {
        this._insetTop =
            insetTop;
        this._updateCapInset()
    }, getInsetRight: function () {
        return this._insetRight
    }, setInsetRight: function (insetRight) {
        this._insetRight = insetRight;
        this._updateCapInset()
    }, getInsetBottom: function () {
        return this._insetBottom
    }, setInsetBottom: function (insetBottom) {
        this._insetBottom = insetBottom;
        this._updateCapInset()
    }, setContentSize: function (size, height) {
        cc.Node.prototype.setContentSize.call(this, size, height);
        this._positionsAreDirty = true
    }, _setWidth: function (value) {
        cc.Node.prototype._setWidth.call(this, value);
        this._positionsAreDirty = true
    }, _setHeight: function (value) {
        cc.Node.prototype._setHeight.call(this, value);
        this._positionsAreDirty = true
    }, visit: function (ctx) {
        if (this._positionsAreDirty) {
            this._updatePositions();
            this._positionsAreDirty = false
        }
        cc.NodeRGBA.prototype.visit.call(this, ctx)
    }, init: function () {
        return this.initWithBatchNode(null, cc.rect(0, 0, 0, 0), false, cc.rect(0, 0, 0, 0))
    }, initWithBatchNode: function (batchNode, rect, rotated, capInsets) {
        if (capInsets === undefined) {
            capInsets = rotated;
            rotated = false
        }
        if (batchNode)this.updateWithBatchNode(batchNode,
            rect, rotated, capInsets);
        this.setAnchorPoint(0.5, 0.5);
        this._positionsAreDirty = true;
        return true
    }, initWithFile: function (file, rect, capInsets) {
        if (file instanceof cc.Rect) {
            file = arguments[1];
            capInsets = arguments[0];
            rect = cc.rect(0, 0, 0, 0)
        } else {
            rect = rect || cc.rect(0, 0, 0, 0);
            capInsets = capInsets || cc.rect(0, 0, 0, 0)
        }
        if (!file)throw"cc.Scale9Sprite.initWithFile(): file should be non-null";
        var texture = cc.textureCache.textureForKey(file);
        if (!texture) {
            texture = cc.textureCache.addImage(file);
            var locLoaded = texture.isLoaded();
            this._textureLoaded = locLoaded;
            if (!locLoaded)texture.addLoadedEventListener(function (sender) {
                var preferredSize = this._preferredSize;
                preferredSize = cc.size(preferredSize.width, preferredSize.height);
                var size = sender.getContentSize();
                this.updateWithBatchNode(this._scale9Image, cc.rect(0, 0, size.width, size.height), false, this._capInsets);
                this.setPreferredSize(preferredSize);
                this._positionsAreDirty = true;
                this._callLoadedEventCallbacks()
            }, this)
        }
        return this.initWithBatchNode(cc.SpriteBatchNode.create(file, 9), rect,
            false, capInsets)
    }, initWithSpriteFrame: function (spriteFrame, capInsets) {
        if (!spriteFrame || !spriteFrame.getTexture())throw"cc.Scale9Sprite.initWithSpriteFrame(): spriteFrame should be non-null and its texture should be non-null";
        capInsets = capInsets || cc.rect(0, 0, 0, 0);
        var locLoaded = spriteFrame.textureLoaded();
        this._textureLoaded = locLoaded;
        if (!locLoaded)spriteFrame.addLoadedEventListener(function (sender) {
            var preferredSize = this._preferredSize;
            preferredSize = cc.size(preferredSize.width, preferredSize.height);
            this.updateWithBatchNode(this._scale9Image, sender.getRect(), cc._renderType == cc._RENDER_TYPE_WEBGL && sender.isRotated(), this._capInsets);
            this.setPreferredSize(preferredSize);
            this._positionsAreDirty = true;
            this._callLoadedEventCallbacks()
        }, this);
        var batchNode = cc.SpriteBatchNode.create(spriteFrame.getTexture(), 9);
        return this.initWithBatchNode(batchNode, spriteFrame.getRect(), cc._renderType == cc._RENDER_TYPE_WEBGL && spriteFrame.isRotated(), capInsets)
    }, initWithSpriteFrameName: function (spriteFrameName, capInsets) {
        if (!spriteFrameName)throw"cc.Scale9Sprite.initWithSpriteFrameName(): spriteFrameName should be non-null";
        capInsets = capInsets || cc.rect(0, 0, 0, 0);
        var frame = cc.spriteFrameCache.getSpriteFrame(spriteFrameName);
        if (frame == null) {
            cc.log("cc.Scale9Sprite.initWithSpriteFrameName(): can't find the sprite frame by spriteFrameName");
            return false
        }
        return this.initWithSpriteFrame(frame, capInsets)
    }, resizableSpriteWithCapInsets: function (capInsets) {
        var pReturn = new cc.Scale9Sprite;
        if (pReturn && pReturn.initWithBatchNode(this._scale9Image, this._spriteRect, false, capInsets))return pReturn;
        return null
    }, setOpacityModifyRGB: function (value) {
        if (!this._scale9Image)return;
        this._opacityModifyRGB = value;
        var scaleChildren = this._scale9Image.getChildren();
        if (scaleChildren)for (var i = 0, len = scaleChildren.length; i < len; i++)scaleChildren[i].setOpacityModifyRGB(value)
    }, isOpacityModifyRGB: function () {
        return this._opacityModifyRGB
    }, updateWithBatchNode: function (batchNode, originalRect, rotated, capInsets) {
        var opacity = this.getOpacity();
        var color = this.getColor();
        var rect = cc.rect(originalRect.x, originalRect.y, originalRect.width, originalRect.height);
        this.removeAllChildren(true);
        if (this._scale9Image !=
            batchNode)this._scale9Image = batchNode;
        var tmpTexture = batchNode.getTexture();
        var locLoaded = tmpTexture.isLoaded();
        this._textureLoaded = locLoaded;
        if (!locLoaded) {
            tmpTexture.addLoadedEventListener(function (sender) {
                this._positionsAreDirty = true;
                this._callLoadedEventCallbacks()
            }, this);
            return
        }
        var locScale9Image = this._scale9Image;
        locScale9Image.removeAllChildren(true);
        var locCapInsets = this._capInsets;
        locCapInsets.x = capInsets.x;
        locCapInsets.y = capInsets.y;
        locCapInsets.width = capInsets.width;
        locCapInsets.height =
            capInsets.height;
        this._spriteFrameRotated = rotated;
        var selTexture = locScale9Image.getTexture();
        if (cc._rectEqualToZero(rect)) {
            var textureSize = selTexture.getContentSize();
            rect = cc.rect(0, 0, textureSize.width, textureSize.height)
        }
        this._spriteRect = rect;
        var locSpriteRect = this._spriteRect;
        locSpriteRect.x = rect.x;
        locSpriteRect.y = rect.y;
        locSpriteRect.width = rect.width;
        locSpriteRect.height = rect.height;
        this._originalSize.width = rect.width;
        this._originalSize.height = rect.height;
        var locPreferredSize = this._preferredSize;
        if (locPreferredSize.width === 0 && locPreferredSize.height === 0) {
            locPreferredSize.width = rect.width;
            locPreferredSize.height = rect.height
        }
        var locCapInsetsInternal = this._capInsetsInternal;
        if (capInsets) {
            locCapInsetsInternal.x = capInsets.x;
            locCapInsetsInternal.y = capInsets.y;
            locCapInsetsInternal.width = capInsets.width;
            locCapInsetsInternal.height = capInsets.height
        }
        var w = rect.width;
        var h = rect.height;
        if (cc._rectEqualToZero(locCapInsetsInternal)) {
            locCapInsetsInternal.x = w / 3;
            locCapInsetsInternal.y = h / 3;
            locCapInsetsInternal.width =
                w / 3;
            locCapInsetsInternal.height = h / 3
        }
        var left_w = locCapInsetsInternal.x;
        var center_w = locCapInsetsInternal.width;
        var right_w = w - (left_w + center_w);
        var top_h = locCapInsetsInternal.y;
        var center_h = locCapInsetsInternal.height;
        var bottom_h = h - (top_h + center_h);
        var x = 0;
        var y = 0;
        var lefttopbounds = cc.rect(x, y, left_w, top_h);
        x += left_w;
        var centertopbounds = cc.rect(x, y, center_w, top_h);
        x += center_w;
        var righttopbounds = cc.rect(x, y, right_w, top_h);
        x = 0;
        y = 0;
        y += top_h;
        var leftcenterbounds = cc.rect(x, y, left_w, center_h);
        x += left_w;
        var centerbounds = cc.rect(x, y, center_w, center_h);
        x += center_w;
        var rightcenterbounds = cc.rect(x, y, right_w, center_h);
        x = 0;
        y = 0;
        y += top_h;
        y += center_h;
        var leftbottombounds = cc.rect(x, y, left_w, bottom_h);
        x += left_w;
        var centerbottombounds = cc.rect(x, y, center_w, bottom_h);
        x += center_w;
        var rightbottombounds = cc.rect(x, y, right_w, bottom_h);
        var t = cc.AffineTransformMakeIdentity();
        if (!rotated) {
            t = cc.AffineTransformTranslate(t, rect.x, rect.y);
            cc._RectApplyAffineTransformIn(centerbounds, t);
            cc._RectApplyAffineTransformIn(rightbottombounds,
                t);
            cc._RectApplyAffineTransformIn(leftbottombounds, t);
            cc._RectApplyAffineTransformIn(righttopbounds, t);
            cc._RectApplyAffineTransformIn(lefttopbounds, t);
            cc._RectApplyAffineTransformIn(rightcenterbounds, t);
            cc._RectApplyAffineTransformIn(leftcenterbounds, t);
            cc._RectApplyAffineTransformIn(centerbottombounds, t);
            cc._RectApplyAffineTransformIn(centertopbounds, t);
            this._centre = new cc.Sprite;
            this._centre.initWithTexture(selTexture, centerbounds);
            locScale9Image.addChild(this._centre, 0, cc.Scale9Sprite.POSITIONS_CENTRE);
            this._top = new cc.Sprite;
            this._top.initWithTexture(selTexture, centertopbounds);
            locScale9Image.addChild(this._top, 1, cc.Scale9Sprite.POSITIONS_TOP);
            this._bottom = new cc.Sprite;
            this._bottom.initWithTexture(selTexture, centerbottombounds);
            locScale9Image.addChild(this._bottom, 1, cc.Scale9Sprite.POSITIONS_BOTTOM);
            this._left = new cc.Sprite;
            this._left.initWithTexture(selTexture, leftcenterbounds);
            locScale9Image.addChild(this._left, 1, cc.Scale9Sprite.POSITIONS_LEFT);
            this._right = new cc.Sprite;
            this._right.initWithTexture(selTexture,
                rightcenterbounds);
            locScale9Image.addChild(this._right, 1, cc.Scale9Sprite.POSITIONS_RIGHT);
            this._topLeft = new cc.Sprite;
            this._topLeft.initWithTexture(selTexture, lefttopbounds);
            locScale9Image.addChild(this._topLeft, 2, cc.Scale9Sprite.POSITIONS_TOPLEFT);
            this._topRight = new cc.Sprite;
            this._topRight.initWithTexture(selTexture, righttopbounds);
            locScale9Image.addChild(this._topRight, 2, cc.Scale9Sprite.POSITIONS_TOPRIGHT);
            this._bottomLeft = new cc.Sprite;
            this._bottomLeft.initWithTexture(selTexture, leftbottombounds);
            locScale9Image.addChild(this._bottomLeft, 2, cc.Scale9Sprite.POSITIONS_BOTTOMLEFT);
            this._bottomRight = new cc.Sprite;
            this._bottomRight.initWithTexture(selTexture, rightbottombounds);
            locScale9Image.addChild(this._bottomRight, 2, cc.Scale9Sprite.POSITIONS_BOTTOMRIGHT)
        } else {
            var rotatedcenterbounds = centerbounds;
            var rotatedrightbottombounds = rightbottombounds;
            var rotatedleftbottombounds = leftbottombounds;
            var rotatedrighttopbounds = righttopbounds;
            var rotatedlefttopbounds = lefttopbounds;
            var rotatedrightcenterbounds =
                rightcenterbounds;
            var rotatedleftcenterbounds = leftcenterbounds;
            var rotatedcenterbottombounds = centerbottombounds;
            var rotatedcentertopbounds = centertopbounds;
            t = cc.AffineTransformTranslate(t, rect.height + rect.x, rect.y);
            t = cc.AffineTransformRotate(t, 1.57079633);
            centerbounds = cc.RectApplyAffineTransform(centerbounds, t);
            rightbottombounds = cc.RectApplyAffineTransform(rightbottombounds, t);
            leftbottombounds = cc.RectApplyAffineTransform(leftbottombounds, t);
            righttopbounds = cc.RectApplyAffineTransform(righttopbounds,
                t);
            lefttopbounds = cc.RectApplyAffineTransform(lefttopbounds, t);
            rightcenterbounds = cc.RectApplyAffineTransform(rightcenterbounds, t);
            leftcenterbounds = cc.RectApplyAffineTransform(leftcenterbounds, t);
            centerbottombounds = cc.RectApplyAffineTransform(centerbottombounds, t);
            centertopbounds = cc.RectApplyAffineTransform(centertopbounds, t);
            rotatedcenterbounds.x = centerbounds.x;
            rotatedcenterbounds.y = centerbounds.y;
            rotatedrightbottombounds.x = rightbottombounds.x;
            rotatedrightbottombounds.y = rightbottombounds.y;
            rotatedleftbottombounds.x =
                leftbottombounds.x;
            rotatedleftbottombounds.y = leftbottombounds.y;
            rotatedrighttopbounds.x = righttopbounds.x;
            rotatedrighttopbounds.y = righttopbounds.y;
            rotatedlefttopbounds.x = lefttopbounds.x;
            rotatedlefttopbounds.y = lefttopbounds.y;
            rotatedrightcenterbounds.x = rightcenterbounds.x;
            rotatedrightcenterbounds.y = rightcenterbounds.y;
            rotatedleftcenterbounds.x = leftcenterbounds.x;
            rotatedleftcenterbounds.y = leftcenterbounds.y;
            rotatedcenterbottombounds.x = centerbottombounds.x;
            rotatedcenterbottombounds.y = centerbottombounds.y;
            rotatedcentertopbounds.x = centertopbounds.x;
            rotatedcentertopbounds.y = centertopbounds.y;
            this._centre = new cc.Sprite;
            this._centre.initWithTexture(selTexture, rotatedcenterbounds, true);
            locScale9Image.addChild(this._centre, 0, cc.Scale9Sprite.POSITIONS_CENTRE);
            this._top = new cc.Sprite;
            this._top.initWithTexture(selTexture, rotatedcentertopbounds, true);
            locScale9Image.addChild(this._top, 1, cc.Scale9Sprite.POSITIONS_TOP);
            this._bottom = new cc.Sprite;
            this._bottom.initWithTexture(selTexture, rotatedcenterbottombounds,
                true);
            locScale9Image.addChild(this._bottom, 1, cc.Scale9Sprite.POSITIONS_BOTTOM);
            this._left = new cc.Sprite;
            this._left.initWithTexture(selTexture, rotatedleftcenterbounds, true);
            locScale9Image.addChild(this._left, 1, cc.Scale9Sprite.POSITIONS_LEFT);
            this._right = new cc.Sprite;
            this._right.initWithTexture(selTexture, rotatedrightcenterbounds, true);
            locScale9Image.addChild(this._right, 1, cc.Scale9Sprite.POSITIONS_RIGHT);
            this._topLeft = new cc.Sprite;
            this._topLeft.initWithTexture(selTexture, rotatedlefttopbounds, true);
            locScale9Image.addChild(this._topLeft, 2, cc.Scale9Sprite.POSITIONS_TOPLEFT);
            this._topRight = new cc.Sprite;
            this._topRight.initWithTexture(selTexture, rotatedrighttopbounds, true);
            locScale9Image.addChild(this._topRight, 2, cc.Scale9Sprite.POSITIONS_TOPRIGHT);
            this._bottomLeft = new cc.Sprite;
            this._bottomLeft.initWithTexture(selTexture, rotatedleftbottombounds, true);
            locScale9Image.addChild(this._bottomLeft, 2, cc.Scale9Sprite.POSITIONS_BOTTOMLEFT);
            this._bottomRight = new cc.Sprite;
            this._bottomRight.initWithTexture(selTexture,
                rotatedrightbottombounds, true);
            locScale9Image.addChild(this._bottomRight, 2, cc.Scale9Sprite.POSITIONS_BOTTOMRIGHT)
        }
        this.setContentSize(rect);
        this.addChild(locScale9Image);
        if (this._spritesGenerated) {
            this.setOpacity(opacity);
            if (color.r !== 255 || color.g !== 255 || color.b !== 255)this.setColor(color)
        }
        this._spritesGenerated = true;
        return true
    }, setSpriteFrame: function (spriteFrame) {
        var batchNode = cc.SpriteBatchNode.create(spriteFrame.getTexture(), 9);
        var locLoaded = spriteFrame.textureLoaded();
        this._textureLoaded = locLoaded;
        if (!locLoaded)spriteFrame.addLoadedEventListener(function (sender) {
            var preferredSize = this._preferredSize;
            preferredSize = cc.size(preferredSize.width, preferredSize.height);
            this.updateWithBatchNode(this._scale9Image, sender.getRect(), cc._renderType == cc._RENDER_TYPE_WEBGL && sender.isRotated(), this._capInsets);
            this.setPreferredSize(preferredSize);
            this._positionsAreDirty = true;
            this._callLoadedEventCallbacks()
        }, this);
        this.updateWithBatchNode(batchNode, spriteFrame.getRect(), cc._renderType == cc._RENDER_TYPE_WEBGL &&
            spriteFrame.isRotated(), cc.rect(0, 0, 0, 0));
        this._insetLeft = 0;
        this._insetTop = 0;
        this._insetRight = 0;
        this._insetBottom = 0
    }});
var _p = cc.Scale9Sprite.prototype;
_p.preferredSize;
cc.defineGetterSetter(_p, "preferredSize", _p.getPreferredSize, _p.setPreferredSize);
_p.capInsets;
cc.defineGetterSetter(_p, "capInsets", _p.getCapInsets, _p.setCapInsets);
_p.insetLeft;
cc.defineGetterSetter(_p, "insetLeft", _p.getInsetLeft, _p.setInsetLeft);
_p.insetTop;
cc.defineGetterSetter(_p, "insetTop", _p.getInsetTop, _p.setInsetTop);
_p.insetRight;
cc.defineGetterSetter(_p, "insetRight", _p.getInsetRight, _p.setInsetRight);
_p.insetBottom;
cc.defineGetterSetter(_p, "insetBottom", _p.getInsetBottom, _p.setInsetBottom);
_p = null;
cc.Scale9Sprite.create = function (file, rect, capInsets) {
    var pReturn;
    if (arguments.length === 2)if (typeof file == "string") {
        pReturn = new cc.Scale9Sprite;
        if (pReturn && pReturn.initWithFile(file, rect))return pReturn
    } else {
        if (file instanceof cc.Rect) {
            pReturn = new cc.Scale9Sprite;
            if (pReturn && pReturn.initWithFile(file, capInsets))return pReturn
        }
    } else if (arguments.length === 3) {
        pReturn = new cc.Scale9Sprite;
        if (pReturn && pReturn.initWithFile(file, rect, capInsets))return pReturn
    } else if (arguments.length === 1) {
        pReturn = new cc.Scale9Sprite;
        if (pReturn && pReturn.initWithFile(file))return pReturn
    } else if (arguments.length === 0) {
        pReturn = new cc.Scale9Sprite;
        if (pReturn && pReturn.init())return pReturn
    }
    return null
};
cc.Scale9Sprite.createWithSpriteFrame = function (spriteFrame, capInsets) {
    var pReturn = new cc.Scale9Sprite;
    if (pReturn && pReturn.initWithSpriteFrame(spriteFrame, capInsets))return pReturn;
    return null
};
cc.Scale9Sprite.createWithSpriteFrameName = function (spriteFrameName, capInsets) {
    if (!spriteFrameName)throw"cc.Scale9Sprite.createWithSpriteFrameName(): spriteFrameName should be non-null";
    var pReturn = new cc.Scale9Sprite;
    if (pReturn && pReturn.initWithSpriteFrameName(spriteFrameName, capInsets))return pReturn;
    return null
};
cc.Scale9Sprite.POSITIONS_CENTRE = 0;
cc.Scale9Sprite.POSITIONS_TOP = 1;
cc.Scale9Sprite.POSITIONS_LEFT = 2;
cc.Scale9Sprite.POSITIONS_RIGHT = 3;
cc.Scale9Sprite.POSITIONS_BOTTOM = 4;
cc.Scale9Sprite.POSITIONS_TOPRIGHT = 5;
cc.Scale9Sprite.POSITIONS_TOPLEFT = 6;
cc.Scale9Sprite.POSITIONS_BOTTOMRIGHT = 7;
cc.Spacer = cc.Layer.extend({});
cc.Spacer.verticalSpacer = function (space) {
    var pRet = new cc.Spacer;
    pRet.init();
    pRet.setContentSize(0, space);
    return pRet
};
cc.Spacer.horizontalSpacer = function (space) {
    var pRet = new cc.Spacer;
    pRet.init();
    pRet.setContentSize(space, 0);
    return pRet
};
cc.MenuPassive = cc.Layer.extend({RGBAProtocol: true, _color: null, _opacity: 0, _className: "MenuPassive", ctor: function () {
}, getColor: function () {
    var locColor = this._color;
    return cc.color(locColor.r, locColor.g, locColor.b, locColor.a)
}, setColor: function (color) {
    var locColor = this._color;
    locColor.r = color.r;
    locColor.g = color.g;
    locColor.b = color.b;
    if (this._children && this._children.length > 0)for (var i = 0; i < this._children.length; i++)if (this._children[i] && this._children[i].RGBAProtocol)this._children[i].setColor(color);
    if (color.a !==
        undefined && !color.a_undefined)this.setOpacity(color.a)
}, getOpacity: function () {
    return this._opacity
}, setOpacity: function (opacity) {
    this._opacity = opacity;
    if (this._children && this._children.length > 0)for (var i = 0; i < this._children.length; i++)if (this._children[i] && this._children[i].RGBAProtocol)this._children[i].setOpacity(opacity);
    this._color.a = opacity
}, initWithItems: function (item, args) {
    if (this.init()) {
        var winSize = cc.director.getWinSize();
        this.ignoreAnchorPointForPosition(true);
        this.setAnchorPoint(0.5, 0.5);
        this.setContentSize(winSize);
        this.setPosition(winSize.width / 2, winSize.height / 2);
        var z = 0;
        if (item) {
            this.addChild(item, z);
            for (var i = 0; i < args.length; i++)if (args[i]) {
                z++;
                this.addChild(args[i], z)
            }
        }
        return true
    }
    return false
}, alignItemsVertically: function () {
    this.alignItemsVerticallyWithPadding(cc.DEFAULT_PADDING)
}, alignItemsVerticallyWithPadding: function (padding) {
    var height = -padding;
    var i;
    if (this._children && this._children.length > 0)for (i = 0; i < this._children.length; i++)if (this._children[i])height += this._children[i].getContentSize().height *
        this._children[i].getScaleY() + padding;
    var width = 0;
    var y = height / 2;
    if (this._children && this._children.length > 0)for (i = 0; i < this._children.length; i++)if (this._children[i]) {
        width = Math.max(width, this._children[i].getContentSize().width);
        this._children[i].setPosition(0, y - this._children[i].getContentSize().height * this._children[i].getScaleY() / 2);
        y -= this._children[i].getContentSize().height * this._children[i].getScaleY() + padding
    }
    this.setContentSize(width, height)
}, alignItemsHorizontally: function () {
    this.alignItemsHorizontallyWithPadding(cc.DEFAULT_PADDING)
},
    alignItemsHorizontallyWithPadding: function (padding) {
        var width = -padding;
        var i;
        if (this._children && this._children.length > 0)for (i = 0; i < this._children.length; i++)if (this._children[i])width += this._children[i].getContentSize().width * this._children[i].getScaleX() + padding;
        var height = 0;
        var x = -width / 2;
        if (this._children && this._children.length > 0)for (i = 0; i < this._children.length; i++)if (this._children[i]) {
            height = Math.max(height, this._children[i].getContentSize().height);
            this._children[i].setPosition(x + this._children[i].getContentSize().width *
                this._children[i].getScaleX() / 2, 0);
            x += this._children[i].getContentSize().width * this._children[i].getScaleX() + padding
        }
        this.setContentSize(width, height)
    }, alignItemsInColumns: function (columns) {
        var rows = [];
        var i;
        for (i = 1; i < arguments.length; i++)rows.push(arguments[i]);
        var height = -5;
        var row = 0;
        var rowHeight = 0;
        var columnsOccupied = 0;
        var rowColumns;
        var tmp;
        if (this._children && this._children.length > 0)for (i = 0; i < this._children.length; i++)if (this._children[i]) {
            if (row >= rows.length) {
                cc.log("cc.MenuPassive.alignItemsInColumns(): invalid row index");
                continue
            }
            rowColumns = rows[row];
            if (!rowColumns) {
                cc.log("cc.MenuPassive.alignItemsInColumns(): can not have zero columns on a row");
                continue
            }
            tmp = this._children[i].getContentSize().height;
            rowHeight = 0 | (rowHeight >= tmp || tmp == null ? rowHeight : tmp);
            ++columnsOccupied;
            if (columnsOccupied >= rowColumns) {
                height += rowHeight + 5;
                columnsOccupied = 0;
                rowHeight = 0;
                ++row
            }
        }
        var winSize = cc.director.getWinSize();
        row = 0;
        rowHeight = 0;
        rowColumns = 0;
        var w = 0;
        var x = 0;
        var y = height / 2;
        if (this._children && this._children.length > 0)for (i = 0; i < this._children.length; i++)if (this._children[i]) {
            if (rowColumns ==
                0) {
                rowColumns = rows[row];
                w = winSize.width / (1 + rowColumns);
                x = w
            }
            tmp = this._children[i].getContentSize().height;
            rowHeight = 0 | (rowHeight >= tmp || tmp == null ? rowHeight : tmp);
            this._children[i].setPosition(x - winSize.width / 2, y - this._children[i].getContentSize().height / 2);
            x += w;
            ++columnsOccupied;
            if (columnsOccupied >= rowColumns) {
                y -= rowHeight + 5;
                columnsOccupied = 0;
                rowColumns = 0;
                rowHeight = 0;
                ++row
            }
        }
    }, alignItemsInRows: function (rows) {
        var columns = [];
        var i;
        for (i = 1; i < arguments.length; i++)columns.push(arguments[i]);
        var columnWidths =
            [];
        var columnHeights = [];
        var width = -10;
        var columnHeight = -5;
        var column = 0;
        var columnWidth = 0;
        var rowsOccupied = 0;
        var columnRows;
        var tmp;
        if (this._children && this._children.length > 0)for (i = 0; i < this._children.length; i++)if (this._children[i]) {
            if (column >= columns.length) {
                cc.log("cc.MenuPassive.alignItemsInRows(): invalid row index");
                continue
            }
            columnRows = columns[column];
            if (!columnRows) {
                cc.log("cc.MenuPassive.alignItemsInColumns(): can't have zero rows on a column");
                continue
            }
            tmp = this._children[i].getContentSize().width;
            columnWidth = 0 | (columnWidth >= tmp || tmp == null ? columnWidth : tmp);
            columnHeight += 0 | this._children[i].getContentSize().height + 5;
            ++rowsOccupied;
            if (rowsOccupied >= columnRows) {
                columnWidths.push(columnWidth);
                columnHeights.push(columnHeight);
                width += columnWidth + 10;
                rowsOccupied = 0;
                columnWidth = 0;
                columnHeight = -5;
                ++column
            }
        }
        var winSize = cc.director.getWinSize();
        column = 0;
        columnWidth = 0;
        columnRows = null;
        var x = -width / 2;
        var y = 0;
        if (this._children && this._children.length > 0)for (i = 0; i < this._children.length; i++)if (this._children[i]) {
            if (columnRows ==
                null) {
                columnRows = columns[column];
                y = columnHeights[column]
            }
            tmp = this._children[i].getContentSize().width;
            columnWidth = 0 | (columnWidth >= tmp || tmp == null ? columnWidth : tmp);
            this._children[i].setPosition(x + columnWidths[column] / 2, y - winSize.height / 2);
            y -= this._children[i].getContentSize().height + 10;
            ++rowsOccupied;
            if (rowsOccupied >= columnRows) {
                x += columnWidth + 5;
                rowsOccupied = 0;
                columnRows = 0;
                columnWidth = 0;
                ++column
            }
        }
    }, setOpacityModifyRGB: function (bValue) {
    }, isOpacityModifyRGB: function () {
        return false
    }});
cc.MenuPassive.create = function (item) {
    if (!item)item = null;
    var argArr = [];
    for (var i = 1; i < arguments.length; i++)argArr.push(arguments[i]);
    var pRet = new cc.MenuPassive;
    if (pRet && pRet.initWithItems(item, argArr))return pRet;
    return null
};
cc.MenuPassive.createWithItem = function (item) {
    return cc.MenuPassive.create(item, null)
};
cc.ControlSaturationBrightnessPicker = cc.Control.extend({_saturation: 0, _brightness: 0, _background: null, _overlay: null, _shadow: null, _slider: null, _startPos: null, _boxPos: 0, _boxSize: 0, _className: "ControlSaturationBrightnessPicker", getSaturation: function () {
    return this._saturation
}, getBrightness: function () {
    return this._brightness
}, getBackground: function () {
    return this._background
}, getOverlay: function () {
    return this._brightness
}, getShadow: function () {
    return this._shadow
}, getSlider: function () {
    return this._slider
},
    getStartPos: function () {
        return this._startPos
    }, initWithTargetAndPos: function (target, pos) {
        if (cc.Control.prototype.init.call(this)) {
            this._background = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("colourPickerBackground.png", target, pos, cc.p(0, 0));
            this._overlay = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("colourPickerOverlay.png", target, pos, cc.p(0, 0));
            this._shadow = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("colourPickerShadow.png", target, pos, cc.p(0, 0));
            this._slider = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("colourPicker.png",
                target, pos, cc.p(0.5, 0.5));
            this._startPos = pos;
            this._boxPos = 35;
            this._boxSize = this._background.getContentSize().width / 2;
            return true
        } else return false
    }, setEnabled: function (enabled) {
        cc.Control.prototype.setEnabled.call(this, enabled);
        if (this._slider)this._slider.setOpacity(enabled ? 255 : 128)
    }, updateWithHSV: function (hsv) {
        var hsvTemp = new cc.HSV;
        hsvTemp.s = 1;
        hsvTemp.h = hsv.h;
        hsvTemp.v = 1;
        var rgb = cc.ControlUtils.RGBfromHSV(hsvTemp);
        this._background.setColor(cc.color(0 | rgb.r * 255, 0 | rgb.g * 255, 0 | rgb.b * 255))
    }, updateDraggerWithHSV: function (hsv) {
        var pos =
            cc.p(this._startPos.x + this._boxPos + this._boxSize * (1 - hsv.s), this._startPos.y + this._boxPos + this._boxSize * hsv.v);
        this._updateSliderPosition(pos)
    }, _updateSliderPosition: function (sliderPosition) {
        var centerX = this._startPos.x + this._background.getBoundingBox().width * 0.5;
        var centerY = this._startPos.y + this._background.getBoundingBox().height * 0.5;
        var dx = sliderPosition.x - centerX;
        var dy = sliderPosition.y - centerY;
        var dist = Math.sqrt(dx * dx + dy * dy);
        var angle = Math.atan2(dy, dx);
        var limit = this._background.getBoundingBox().width *
            0.5;
        if (dist > limit) {
            sliderPosition.x = centerX + limit * Math.cos(angle);
            sliderPosition.y = centerY + limit * Math.sin(angle)
        }
        this._slider.setPosition(sliderPosition);
        if (sliderPosition.x < this._startPos.x + this._boxPos)sliderPosition.x = this._startPos.x + this._boxPos; else if (sliderPosition.x > this._startPos.x + this._boxPos + this._boxSize - 1)sliderPosition.x = this._startPos.x + this._boxPos + this._boxSize - 1;
        if (sliderPosition.y < this._startPos.y + this._boxPos)sliderPosition.y = this._startPos.y + this._boxPos; else if (sliderPosition.y >
            this._startPos.y + this._boxPos + this._boxSize)sliderPosition.y = this._startPos.y + this._boxPos + this._boxSize;
        this._saturation = 1 - Math.abs((this._startPos.x + this._boxPos - sliderPosition.x) / this._boxSize);
        this._brightness = Math.abs((this._startPos.y + this._boxPos - sliderPosition.y) / this._boxSize)
    }, _checkSliderPosition: function (location) {
        var centerX = this._startPos.x + this._background.getBoundingBox().width * 0.5;
        var centerY = this._startPos.y + this._background.getBoundingBox().height * 0.5;
        var dx = location.x - centerX;
        var dy = location.y - centerY;
        var dist = Math.sqrt(dx * dx + dy * dy);
        if (dist <= this._background.getBoundingBox().width * 0.5) {
            this._updateSliderPosition(location);
            this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED);
            return true
        }
        return false
    }, onTouchBegan: function (touch, event) {
        if (!this.isEnabled() || !this.isVisible())return false;
        var touchLocation = this.getTouchLocation(touch);
        return this._checkSliderPosition(touchLocation)
    }, onTouchMoved: function (touch, event) {
        var touchLocation = this.getTouchLocation(touch);
        this._checkSliderPosition(touchLocation)
    }});
var _p = cc.ControlSaturationBrightnessPicker.prototype;
_p.saturation;
cc.defineGetterSetter(_p, "saturation", _p.getSaturation);
_p.brightness;
cc.defineGetterSetter(_p, "brightness", _p.getBrightness);
_p.background;
cc.defineGetterSetter(_p, "background", _p.getBackground);
_p.overlay;
cc.defineGetterSetter(_p, "overlay", _p.getOverlay);
_p.shadow;
cc.defineGetterSetter(_p, "shadow", _p.getShadow);
_p.slider;
cc.defineGetterSetter(_p, "slider", _p.getSlider);
_p.startPos;
cc.defineGetterSetter(_p, "startPos", _p.getStartPos);
_p = null;
cc.ControlSaturationBrightnessPicker.create = function (target, pos) {
    var pRet = new cc.ControlSaturationBrightnessPicker;
    pRet.initWithTargetAndPos(target, pos);
    return pRet
};
cc.ControlHuePicker = cc.Control.extend({_hue: 0, _huePercentage: 0, _background: null, _slider: null, _startPos: null, _className: "ControlHuePicker", getHue: function () {
    return this._hue
}, setHue: function (hueValue) {
    this._hue = hueValue;
    this.setHuePercentage(this._hue / 360)
}, getHuePercentage: function () {
    return this._huePercentage
}, setHuePercentage: function (hueValueInPercent) {
    this._huePercentage = hueValueInPercent;
    this._hue = this._huePercentage * 360;
    var backgroundBox = this._background.getBoundingBox();
    var centerX = this._startPos.x +
        backgroundBox.width * 0.5;
    var centerY = this._startPos.y + backgroundBox.height * 0.5;
    var limit = backgroundBox.width * 0.5 - 15;
    var angleDeg = this._huePercentage * 360 - 180;
    var angle = cc.degreesToRadians(angleDeg);
    var x = centerX + limit * Math.cos(angle);
    var y = centerY + limit * Math.sin(angle);
    this._slider.setPosition(x, y)
}, setEnabled: function (enabled) {
    cc.Control.prototype.setEnabled.call(this, enabled);
    if (this._slider)this._slider.setOpacity(enabled ? 255 : 128)
}, getBackground: function () {
    return this._background
}, getSlider: function () {
    return this._slider
},
    getStartPos: function () {
        return this._startPos
    }, initWithTargetAndPos: function (target, pos) {
        if (cc.Control.prototype.init.call(this)) {
            this._background = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("huePickerBackground.png", target, pos, cc.p(0, 0));
            this._slider = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("colourPicker.png", target, pos, cc.p(0.5, 0.5));
            this._slider.setPosition(pos.x, pos.y + this._background.getBoundingBox().height * 0.5);
            this._startPos = pos;
            this._hue = 0;
            this._huePercentage = 0;
            return true
        } else return false
    },
    _updateSliderPosition: function (location) {
        var backgroundBox = this._background.getBoundingBox();
        var centerX = this._startPos.x + backgroundBox.width * 0.5;
        var centerY = this._startPos.y + backgroundBox.height * 0.5;
        var dx = location.x - centerX;
        var dy = location.y - centerY;
        var angle = Math.atan2(dy, dx);
        var angleDeg = cc.radiansToDegrees(angle) + 180;
        this.setHue(angleDeg);
        this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED)
    }, _checkSliderPosition: function (location) {
        var distance = Math.sqrt(Math.pow(location.x + 10, 2) + Math.pow(location.y,
            2));
        if (80 > distance && distance > 59) {
            this._updateSliderPosition(location);
            return true
        }
        return false
    }, onTouchBegan: function (touch, event) {
        if (!this.isEnabled() || !this.isVisible())return false;
        var touchLocation = this.getTouchLocation(touch);
        return this._checkSliderPosition(touchLocation)
    }, onTouchMoved: function (touch, event) {
        var touchLocation = this.getTouchLocation(touch);
        this._checkSliderPosition(touchLocation)
    }});
var _p = cc.ControlHuePicker.prototype;
_p.hue;
cc.defineGetterSetter(_p, "hue", _p.getHue, _p.setHue);
_p.huePercent;
cc.defineGetterSetter(_p, "huePercent", _p.getHuePercentage, _p.setHuePercentage);
_p.background;
cc.defineGetterSetter(_p, "background", _p.getBackground);
_p.slider;
cc.defineGetterSetter(_p, "slider", _p.getSlider);
_p.startPos;
cc.defineGetterSetter(_p, "startPos", _p.getStartPos);
_p = null;
cc.ControlHuePicker.create = function (target, pos) {
    var pRet = new cc.ControlHuePicker;
    pRet.initWithTargetAndPos(target, pos);
    return pRet
};
cc.ControlColourPicker = cc.Control.extend({_hsv: null, _colourPicker: null, _huePicker: null, _background: null, _className: "ControlColourPicker", hueSliderValueChanged: function (sender, controlEvent) {
    this._hsv.h = sender.getHue();
    var rgb = cc.ControlUtils.RGBfromHSV(this._hsv);
    cc.Control.prototype.setColor.call(this, cc.color(0 | rgb.r * 255, 0 | rgb.g * 255, 0 | rgb.b * 255));
    this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED);
    this._updateControlPicker()
}, colourSliderValueChanged: function (sender, controlEvent) {
    this._hsv.s =
        sender.getSaturation();
    this._hsv.v = sender.getBrightness();
    var rgb = cc.ControlUtils.RGBfromHSV(this._hsv);
    cc.Control.prototype.setColor.call(this, cc.color(0 | rgb.r * 255, 0 | rgb.g * 255, 0 | rgb.b * 255));
    this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED)
}, setColor: function (color) {
    cc.Control.prototype.setColor.call(this, color);
    var rgba = new cc.RGBA;
    rgba.r = color.r / 255;
    rgba.g = color.g / 255;
    rgba.b = color.b / 255;
    rgba.a = 1;
    this._hsv = cc.ControlUtils.HSVfromRGB(rgba);
    this._updateHueAndControlPicker()
}, getBackground: function () {
    return this._background
},
    init: function () {
        if (cc.Control.prototype.init.call(this)) {
            cc.spriteFrameCache.addSpriteFrames(res.CCControlColourPickerSpriteSheet_plist);
            var spriteSheet = cc.SpriteBatchNode.create(res.CCControlColourPickerSpriteSheet_png);
            this.addChild(spriteSheet);
            this._hsv = new cc.HSV(0, 0, 0);
            this._background = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("menuColourPanelBackground.png", spriteSheet, cc.p(0, 0), cc.p(0.5, 0.5));
            var backgroundPointZero = cc.pSub(this._background.getPosition(), cc.p(this._background.getContentSize().width /
                2, this._background.getContentSize().height / 2));
            var hueShift = 8;
            var colourShift = 28;
            this._huePicker = cc.ControlHuePicker.create(spriteSheet, cc.p(backgroundPointZero.x + hueShift, backgroundPointZero.y + hueShift));
            this._colourPicker = cc.ControlSaturationBrightnessPicker.create(spriteSheet, cc.p(backgroundPointZero.x + colourShift, backgroundPointZero.y + colourShift));
            this._huePicker.addTargetWithActionForControlEvents(this, this.hueSliderValueChanged, cc.CONTROL_EVENT_VALUECHANGED);
            this._colourPicker.addTargetWithActionForControlEvents(this,
                this.colourSliderValueChanged, cc.CONTROL_EVENT_VALUECHANGED);
            this._updateHueAndControlPicker();
            this.addChild(this._huePicker);
            this.addChild(this._colourPicker);
            this.setContentSize(this._background.getContentSize());
            return true
        } else return false
    }, _updateControlPicker: function () {
        this._huePicker.setHue(this._hsv.h);
        this._colourPicker.updateWithHSV(this._hsv)
    }, _updateHueAndControlPicker: function () {
        this._huePicker.setHue(this._hsv.h);
        this._colourPicker.updateWithHSV(this._hsv);
        this._colourPicker.updateDraggerWithHSV(this._hsv)
    },
    setEnabled: function (enabled) {
        cc.Control.prototype.setEnabled.call(this, enabled);
        if (this._huePicker != null)this._huePicker.setEnabled(enabled);
        if (this._colourPicker)this._colourPicker.setEnabled(enabled)
    }, onTouchBegan: function () {
        return false
    }});
var _p = cc.ControlColourPicker.prototype;
_p.background;
cc.defineGetterSetter(_p, "background", _p.getBackground);
_p = null;
cc.ControlColourPicker.create = function () {
    var pRet = new cc.ControlColourPicker;
    pRet.init();
    return pRet
};
var res = res || {};
res.CCControlColourPickerSpriteSheet_plist = res.CCControlColourPickerSpriteSheet_plist || "res/extensions/CCControlColourPickerSpriteSheet.plist";
res.CCControlColourPickerSpriteSheet_png = res.CCControlColourPickerSpriteSheet_png || "res/extensions/CCControlColourPickerSpriteSheet.png";
cc.SLIDER_MARGIN_H = 24;
cc.SLIDER_MARGIN_V = 8;
cc.ControlSlider = cc.Control.extend({_value: 0, _minimumValue: 0, _maximumValue: 0, _minimumAllowedValue: 0, _maximumAllowedValue: 0, _thumbSprite: null, _progressSprite: null, _backgroundSprite: null, _className: "ControlSlider", getValue: function () {
    return this._value
}, setValue: function (value) {
    value = Math.max(value, this._minimumValue);
    value = Math.min(value, this._maximumValue);
    this._value = value;
    this.needsLayout();
    this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED)
}, getMinimumValue: function () {
    return this._minimumValue
},
    setMinimumValue: function (minimumValue) {
        this._minimumValue = minimumValue;
        this._minimumAllowedValue = minimumValue;
        if (this._minimumValue >= this._maximumValue)this._maximumValue = this._minimumValue + 1;
        this.setValue(this._value)
    }, getMaximumValue: function () {
        return this._maximumValue
    }, setMaximumValue: function (maximumValue) {
        this._maximumValue = maximumValue;
        this._maximumAllowedValue = maximumValue;
        if (this._maximumValue <= this._minimumValue)this._minimumValue = this._maximumValue - 1;
        this.setValue(this._value)
    }, isTouchInside: function (touch) {
        var touchLocation =
            touch.getLocation();
        touchLocation = this.getParent().convertToNodeSpace(touchLocation);
        var rect = this.getBoundingBox();
        rect.width += this._thumbSprite.getContentSize().width;
        rect.x -= this._thumbSprite.getContentSize().width / 2;
        return cc.rectContainsPoint(rect, touchLocation)
    }, locationFromTouch: function (touch) {
        var touchLocation = touch.getLocation();
        touchLocation = this.convertToNodeSpace(touchLocation);
        if (touchLocation.x < 0)touchLocation.x = 0; else if (touchLocation.x > this._backgroundSprite.getContentSize().width)touchLocation.x =
            this._backgroundSprite.getContentSize().width;
        return touchLocation
    }, getMinimumAllowedValue: function () {
        return this._minimumAllowedValue
    }, setMinimumAllowedValue: function (val) {
        this._minimumAllowedValue = val
    }, getMaximumAllowedValue: function () {
        return this._maximumAllowedValue
    }, setMaximumAllowedValue: function (val) {
        this._maximumAllowedValue = val
    }, getThumbSprite: function () {
        return this._thumbSprite
    }, getProgressSprite: function () {
        return this._progressSprite
    }, getBackgroundSprite: function () {
        return this._backgroundSprite
    },
    initWithSprites: function (backgroundSprite, progressSprite, thumbSprite) {
        if (cc.Control.prototype.init.call(this)) {
            this.ignoreAnchorPointForPosition(false);
            this._backgroundSprite = backgroundSprite;
            this._progressSprite = progressSprite;
            this._thumbSprite = thumbSprite;
            var maxRect = cc.ControlUtils.CCRectUnion(backgroundSprite.getBoundingBox(), thumbSprite.getBoundingBox());
            this.setContentSize(maxRect.width, maxRect.height);
            this._backgroundSprite.setAnchorPoint(0.5, 0.5);
            this._backgroundSprite.setPosition(maxRect.width /
                2, maxRect.height / 2);
            this.addChild(this._backgroundSprite);
            this._progressSprite.setAnchorPoint(0, 0.5);
            this._progressSprite.setPosition(0, maxRect.height / 2);
            this.addChild(this._progressSprite);
            this._thumbSprite.setPosition(0, maxRect.height / 2);
            this.addChild(this._thumbSprite);
            this._minimumValue = 0;
            this._maximumValue = 1;
            this.setValue(this._minimumValue);
            return true
        } else return false
    }, setEnabled: function (enabled) {
        cc.Control.prototype.setEnabled.call(this, enabled);
        if (this._thumbSprite)this._thumbSprite.setOpacity(enabled ?
            255 : 128)
    }, sliderBegan: function (location) {
        this.setSelected(true);
        this.getThumbSprite().setColor(cc.color.GRAY);
        this.setValue(this.valueForLocation(location))
    }, sliderMoved: function (location) {
        this.setValue(this.valueForLocation(location))
    }, sliderEnded: function (location) {
        if (this.isSelected())this.setValue(this.valueForLocation(this._thumbSprite.getPosition()));
        this._thumbSprite.setColor(cc.color.WHITE);
        this.setSelected(false)
    }, getTouchLocationInControl: function (touch) {
        var touchLocation = touch.getLocation();
        touchLocation = this.convertToNodeSpace(touchLocation);
        if (touchLocation.x < 0)touchLocation.x = 0; else if (touchLocation.x > this._backgroundSprite.getContentSize().width + cc.SLIDER_MARGIN_H)touchLocation.x = this._backgroundSprite.getContentSize().width + cc.SLIDER_MARGIN_H;
        return touchLocation
    }, onTouchBegan: function (touch, event) {
        if (!this.isTouchInside(touch) || !this.isEnabled() || !this.isVisible())return false;
        var location = this.locationFromTouch(touch);
        this.sliderBegan(location);
        return true
    }, onTouchMoved: function (touch, event) {
        var location = this.locationFromTouch(touch);
        this.sliderMoved(location)
    }, onTouchEnded: function (touch, event) {
        this.sliderEnded(cc.p(0, 0))
    }, needsLayout: function () {
        var percent = (this._value - this._minimumValue) / (this._maximumValue - this._minimumValue);
        this._thumbSprite.setPositionX(percent * this._backgroundSprite.getContentSize().width);
        var textureRect = this._progressSprite.getTextureRect();
        textureRect = cc.rect(textureRect.x, textureRect.y, this._thumbSprite.getPositionX(), textureRect.height);
        this._progressSprite.setTextureRect(textureRect,
            this._progressSprite.isTextureRectRotated())
    }, valueForLocation: function (location) {
        var percent = location.x / this._backgroundSprite.getContentSize().width;
        return Math.max(Math.min(this._minimumValue + percent * (this._maximumValue - this._minimumValue), this._maximumAllowedValue), this._minimumAllowedValue)
    }});
var _p = cc.ControlSlider.prototype;
_p.value;
cc.defineGetterSetter(_p, "value", _p.getValue, _p.setValue);
_p.minValue;
cc.defineGetterSetter(_p, "minValue", _p.getMinimumValue, _p.setMinimumValue);
_p.maxValue;
cc.defineGetterSetter(_p, "maxValue", _p.getMaximumValue, _p.setMaximumValue);
_p.minAllowedValue;
cc.defineGetterSetter(_p, "minAllowedValue", _p.getMinimumAllowedValue, _p.setMinimumAllowedValue);
_p.maxAllowedValue;
cc.defineGetterSetter(_p, "maxAllowedValue", _p.getMaximumAllowedValue, _p.setMaximumAllowedValue);
_p.thumbSprite;
cc.defineGetterSetter(_p, "thumbSprite", _p.getThumbSprite);
_p.progressSprite;
cc.defineGetterSetter(_p, "progressSprite", _p.getProgressSprite);
_p.backgroundSprite;
cc.defineGetterSetter(_p, "backgroundSprite", _p.getBackgroundSprite);
_p = null;
cc.ControlSlider.create = function (bgFile, progressFile, thumbFile) {
    if (typeof bgFile == "string") {
        bgFile = cc.Sprite.create(bgFile);
        progressFile = cc.Sprite.create(progressFile);
        thumbFile = cc.Sprite.create(thumbFile)
    }
    var pRet = new cc.ControlSlider;
    pRet.initWithSprites(bgFile, progressFile, thumbFile);
    return pRet
};
cc.ControlSwitch = cc.Control.extend({_switchSprite: null, _initialTouchXPosition: 0, _moved: false, _on: false, _className: "ControlSwitch", ctor: function () {
    cc.Control.prototype.ctor.call(this)
}, initWithMaskSprite: function (maskSprite, onSprite, offSprite, thumbSprite, onLabel, offLabel) {
    if (!maskSprite)throw"cc.ControlSwitch.initWithMaskSprite(): maskSprite should be non-null.";
    if (!onSprite)throw"cc.ControlSwitch.initWithMaskSprite(): onSprite should be non-null.";
    if (!offSprite)throw"cc.ControlSwitch.initWithMaskSprite(): offSprite should be non-null.";
    if (!thumbSprite)throw"cc.ControlSwitch.initWithMaskSprite(): thumbSprite should be non-null.";
    if (this.init()) {
        this._on = true;
        this._switchSprite = new cc.ControlSwitchSprite;
        this._switchSprite.initWithMaskSprite(maskSprite, onSprite, offSprite, thumbSprite, onLabel, offLabel);
        this._switchSprite.setPosition(this._switchSprite.getContentSize().width / 2, this._switchSprite.getContentSize().height / 2);
        this.addChild(this._switchSprite);
        this.ignoreAnchorPointForPosition(false);
        this.setAnchorPoint(0.5, 0.5);
        this.setContentSize(this._switchSprite.getContentSize());
        return true
    }
    return false
}, setOn: function (isOn, animated) {
    animated = animated || false;
    this._on = isOn;
    var xPosition = this._on ? this._switchSprite.getOnPosition() : this._switchSprite.getOffPosition();
    if (animated)this._switchSprite.runAction(cc.ActionTween.create(0.2, "sliderXPosition", this._switchSprite.getSliderXPosition(), xPosition)); else this._switchSprite.setSliderXPosition(xPosition);
    this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED)
}, isOn: function () {
    return this._on
}, hasMoved: function () {
    return this._moved
},
    setEnabled: function (enabled) {
        this._enabled = enabled;
        this._switchSprite.setOpacity(enabled ? 255 : 128)
    }, locationFromTouch: function (touch) {
        var touchLocation = touch.getLocation();
        touchLocation = this.convertToNodeSpace(touchLocation);
        return touchLocation
    }, onTouchBegan: function (touch, event) {
        if (!this.isTouchInside(touch) || !this.isEnabled() || !this.isVisible())return false;
        this._moved = false;
        var location = this.locationFromTouch(touch);
        this._initialTouchXPosition = location.x - this._switchSprite.getSliderXPosition();
        this._switchSprite.getThumbSprite().setColor(cc.color.GRAY);
        this._switchSprite.needsLayout();
        return true
    }, onTouchMoved: function (touch, event) {
        var location = this.locationFromTouch(touch);
        location = cc.p(location.x - this._initialTouchXPosition, 0);
        this._moved = true;
        this._switchSprite.setSliderXPosition(location.x)
    }, onTouchEnded: function (touch, event) {
        var location = this.locationFromTouch(touch);
        this._switchSprite.getThumbSprite().setColor(cc.color.WHITE);
        if (this.hasMoved())this.setOn(!(location.x < this._switchSprite.getContentSize().width /
            2), true); else this.setOn(!this._on, true)
    }, onTouchCancelled: function (touch, event) {
        var location = this.locationFromTouch(touch);
        this._switchSprite.getThumbSprite().setColor(cc.color.WHITE);
        if (this.hasMoved())this.setOn(!(location.x < this._switchSprite.getContentSize().width / 2), true); else this.setOn(!this._on, true)
    }});
cc.ControlSwitch.create = function (maskSprite, onSprite, offSprite, thumbSprite, onLabel, offLabel) {
    var pRet = new cc.ControlSwitch;
    if (pRet && pRet.initWithMaskSprite(maskSprite, onSprite, offSprite, thumbSprite, onLabel, offLabel))return pRet;
    return null
};
cc.ControlSwitchSprite = cc.Sprite.extend({_sliderXPosition: 0, _onPosition: 0, _offPosition: 0, _textureLocation: 0, _maskLocation: 0, _maskSize: null, _onSprite: null, _offSprite: null, _thumbSprite: null, _onLabel: null, _offLabel: null, _clipper: null, _stencil: null, _backRT: null, ctor: function () {
    cc.Sprite.prototype.ctor.call(this);
    this._sliderXPosition = 0;
    this._onPosition = 0;
    this._offPosition = 0;
    this._maskLocation = 0;
    this._maskSize = cc.size(0, 0);
    this._onSprite = null;
    this._offSprite = null;
    this._thumbSprite = null;
    this._onLabel = null;
    this._offLabel = null
}, initWithMaskSprite: function (maskSprite, onSprite, offSprite, thumbSprite, onLabel, offLabel) {
    if (cc.Sprite.prototype.initWithTexture.call(this, maskSprite.getTexture())) {
        this._onPosition = 0;
        this._offPosition = -onSprite.getContentSize().width + thumbSprite.getContentSize().width / 2;
        this._sliderXPosition = this._onPosition;
        this.setOnSprite(onSprite);
        this.setOffSprite(offSprite);
        this.setThumbSprite(thumbSprite);
        this.setOnLabel(onLabel);
        this.setOffLabel(offLabel);
        this._stencil = maskSprite;
        var maskSize =
            this._maskSize = this._stencil.getContentSize();
        this._stencil.setPosition(0, 0);
        this._clipper = cc.ClippingNode.create();
        this._clipper.setAnchorPoint(0.5, 0.5);
        this._clipper.setPosition(maskSize.width / 2, maskSize.height / 2);
        this._clipper.setStencil(this._stencil);
        this._backRT = cc.RenderTexture.create(maskSize.width, maskSize.height);
        this._clipper.addChild(this._backRT.getSprite());
        this.addChild(this._clipper);
        this.addChild(this._thumbSprite);
        this.needsLayout();
        return true
    }
    return false
}, needsLayout: function () {
    this._onSprite.setPosition(this._onSprite.getContentSize().width /
        2 + this._sliderXPosition, this._onSprite.getContentSize().height / 2);
    this._offSprite.setPosition(this._onSprite.getContentSize().width + this._offSprite.getContentSize().width / 2 + this._sliderXPosition, this._offSprite.getContentSize().height / 2);
    if (this._onLabel)this._onLabel.setPosition(this._onSprite.getPositionX() - this._thumbSprite.getContentSize().width / 6, this._onSprite.getContentSize().height / 2);
    if (this._offLabel)this._offLabel.setPosition(this._offSprite.getPositionX() + this._thumbSprite.getContentSize().width /
        6, this._offSprite.getContentSize().height / 2);
    this._thumbSprite.setPosition(this._onSprite.getContentSize().width + this._sliderXPosition, this._maskSize.height / 2)
}, setSliderXPosition: function (sliderXPosition) {
    if (sliderXPosition <= this._offPosition)sliderXPosition = this._offPosition; else if (sliderXPosition >= this._onPosition)sliderXPosition = this._onPosition;
    this._sliderXPosition = sliderXPosition;
    this.needsLayout()
}, getSliderXPosition: function () {
    return this._sliderXPosition
}, _getOnSideWidth: function () {
    return this._onSprite.getContentSize().width
},
    _getOffSideWidth: function () {
        return this._offSprite.getContentSize().height
    }, updateTweenAction: function (value, key) {
        cc.log("key \x3d " + key + ", value \x3d " + value);
        this.setSliderXPosition(value)
    }, setOnPosition: function (onPosition) {
        this._onPosition = onPosition
    }, getOnPosition: function () {
        return this._onPosition
    }, setOffPosition: function (offPosition) {
        this._offPosition = offPosition
    }, getOffPosition: function () {
        return this._offPosition
    }, setMaskTexture: function (maskTexture) {
        this._stencil.setTexture(maskTexture)
    },
    getMaskTexture: function () {
        return this._stencil.getTexture()
    }, setTextureLocation: function (textureLocation) {
        this._textureLocation = textureLocation
    }, getTextureLocation: function () {
        return this._textureLocation
    }, setMaskLocation: function (maskLocation) {
        this._maskLocation = maskLocation
    }, getMaskLocation: function () {
        return this._maskLocation
    }, setOnSprite: function (onSprite) {
        this._onSprite = onSprite
    }, getOnSprite: function () {
        return this._onSprite
    }, setOffSprite: function (offSprite) {
        this._offSprite = offSprite
    }, getOffSprite: function () {
        return this._offSprite
    },
    setThumbSprite: function (thumbSprite) {
        this._thumbSprite = thumbSprite
    }, getThumbSprite: function () {
        return this._thumbSprite
    }, setOnLabel: function (onLabel) {
        this._onLabel = onLabel
    }, getOnLabel: function () {
        return this._onLabel
    }, setOffLabel: function (offLabel) {
        this._offLabel = offLabel
    }, getOffLabel: function () {
        return this._offLabel
    }});
var _p = cc.ControlSwitchSprite.prototype;
_p.sliderX;
cc.defineGetterSetter(_p, "sliderX", _p.getSliderXPosition, _p.setSliderXPosition);
_p.onPos;
cc.defineGetterSetter(_p, "onPos", _p.getOnPosition, _p.setOnPosition);
_p.offPos;
cc.defineGetterSetter(_p, "offPos", _p.getOffPosition, _p.setOffPosition);
_p.maskTexture;
cc.defineGetterSetter(_p, "maskTexture", _p.getMaskTexture, _p.setMaskTexture);
_p.maskPos;
cc.defineGetterSetter(_p, "maskPos", _p.getMaskLocation, _p.setMaskLocation);
_p.onSprite;
cc.defineGetterSetter(_p, "onSprite", _p.getOnSprite, _p.setOnSprite);
_p.offSprite;
cc.defineGetterSetter(_p, "offSprite", _p.getOffSprite, _p.setOffSprite);
_p.thumbSprite;
cc.defineGetterSetter(_p, "thumbSprite", _p.getThumbSprite, _p.setThumbSprite);
_p.onLabel;
cc.defineGetterSetter(_p, "onLabel", _p.getOnLabel, _p.setOnLabel);
_p.offLabel;
cc.defineGetterSetter(_p, "offLabel", _p.getOffLabel, _p.setOffLabel);
_p.onSideWidth;
cc.defineGetterSetter(_p, "onSideWidth", _p._getOnSideWidth);
_p.offSideWidth;
cc.defineGetterSetter(_p, "offSideWidth", _p._getOffSideWidth);
_p = null;
cc.CONTROL_STEPPER_PARTMINUS = 0;
cc.CONTROL_STEPPER_PARTPLUS = 1;
cc.CONTROL_STEPPER_PARTNONE = 2;
cc.CONTROL_STEPPER_LABELCOLOR_ENABLED = cc.color(55, 55, 55);
cc.CONTROL_STEPPER_LABELCOLOR_DISABLED = cc.color(147, 147, 147);
cc.CONTROL_STEPPER_LABELFONT = "CourierNewPSMT";
cc.AUTOREPEAT_DELTATIME = 0.15;
cc.AUTOREPEAT_INCREASETIME_INCREMENT = 12;
cc.ControlStepper = cc.Control.extend({_minusSprite: null, _plusSprite: null, _minusLabel: null, _plusLabel: null, _value: 0, _continuous: false, _autorepeat: false, _wraps: false, _minimumValue: 0, _maximumValue: 0, _stepValue: 0, _touchInsideFlag: false, _touchedPart: cc.CONTROL_STEPPER_PARTNONE, _autorepeatCount: 0, _className: "ControlStepper", ctor: function () {
    cc.Control.prototype.ctor.call(this);
    this._minusSprite = null;
    this._plusSprite = null;
    this._minusLabel = null;
    this._plusLabel = null;
    this._value = 0;
    this._continuous = false;
    this._autorepeat =
        false;
    this._wraps = false;
    this._minimumValue = 0;
    this._maximumValue = 0;
    this._stepValue = 0;
    this._touchInsideFlag = false;
    this._touchedPart = cc.CONTROL_STEPPER_PARTNONE;
    this._autorepeatCount = 0
}, initWithMinusSpriteAndPlusSprite: function (minusSprite, plusSprite) {
    if (!minusSprite)throw"cc.ControlStepper.initWithMinusSpriteAndPlusSprite(): Minus sprite should be non-null.";
    if (!plusSprite)throw"cc.ControlStepper.initWithMinusSpriteAndPlusSprite(): Plus sprite should be non-null.";
    if (this.init()) {
        this._autorepeat = true;
        this._continuous = true;
        this._minimumValue = 0;
        this._maximumValue = 100;
        this._value = 0;
        this._stepValue = 1;
        this._wraps = false;
        this.ignoreAnchorPointForPosition(false);
        this.setMinusSprite(minusSprite);
        this._minusSprite.setPosition(minusSprite.getContentSize().width / 2, minusSprite.getContentSize().height / 2);
        this.addChild(this._minusSprite);
        this.setMinusLabel(cc.LabelTTF.create("-", cc.CONTROL_STEPPER_LABELFONT, 40, cc.size(40, 40), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER));
        this._minusLabel.setColor(cc.CONTROL_STEPPER_LABELCOLOR_DISABLED);
        this._minusLabel.setPosition(this._minusSprite.getContentSize().width / 2, this._minusSprite.getContentSize().height / 2);
        this._minusSprite.addChild(this._minusLabel);
        this.setPlusSprite(plusSprite);
        this._plusSprite.setPosition(minusSprite.getContentSize().width + plusSprite.getContentSize().width / 2, minusSprite.getContentSize().height / 2);
        this.addChild(this._plusSprite);
        this.setPlusLabel(cc.LabelTTF.create("+", cc.CONTROL_STEPPER_LABELFONT, 40, cc.size(40, 40), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER));
        this._plusLabel.setColor(cc.CONTROL_STEPPER_LABELCOLOR_ENABLED);
        this._plusLabel.setPosition(this._plusSprite.getContentSize().width / 2, this._plusSprite.getContentSize().height / 2);
        this._plusSprite.addChild(this._plusLabel);
        var maxRect = cc.ControlUtils.CCRectUnion(this._minusSprite.getBoundingBox(), this._plusSprite.getBoundingBox());
        this.setContentSize(this._minusSprite.getContentSize().width + this._plusSprite.getContentSize().height, maxRect.height);
        return true
    }
    return false
}, setWraps: function (wraps) {
    this._wraps =
        wraps;
    if (this._wraps) {
        this._minusLabel.setColor(cc.CONTROL_STEPPER_LABELCOLOR_ENABLED);
        this._plusLabel.setColor(cc.CONTROL_STEPPER_LABELCOLOR_ENABLED)
    }
    this.setValue(this._value)
}, getWraps: function () {
    return this._wraps
}, setMinimumValue: function (minimumValue) {
    if (minimumValue >= this._maximumValue)throw"cc.ControlStepper.setMinimumValue(): minimumValue should be numerically less than maximumValue.";
    this._minimumValue = minimumValue;
    this.setValue(this._value)
}, getMinimumValue: function () {
    return this._minimumValue
},
    setMaximumValue: function (maximumValue) {
        if (maximumValue <= this._minimumValue)throw"cc.ControlStepper.setMaximumValue(): maximumValue should be numerically less than maximumValue.";
        this._maximumValue = maximumValue;
        this.setValue(this._value)
    }, getMaximumValue: function () {
        return this._maximumValue
    }, setValue: function (value) {
        this.setValueWithSendingEvent(value, true)
    }, getValue: function () {
        return this._value
    }, setStepValue: function (stepValue) {
        if (stepValue <= 0)throw"cc.ControlStepper.setMaximumValue(): stepValue should be numerically greater than 0.";
        this._stepValue = stepValue
    }, getStepValue: function () {
        return this._stepValue
    }, isContinuous: function () {
        return this._continuous
    }, setValueWithSendingEvent: function (value, send) {
        if (value < this._minimumValue)value = this._wraps ? this._maximumValue : this._minimumValue; else if (value > this._maximumValue)value = this._wraps ? this._minimumValue : this._maximumValue;
        this._value = value;
        if (!this._wraps) {
            this._minusLabel.setColor(value == this._minimumValue ? cc.CONTROL_STEPPER_LABELCOLOR_DISABLED : cc.CONTROL_STEPPER_LABELCOLOR_ENABLED);
            this._plusLabel.setColor(value == this._maximumValue ? cc.CONTROL_STEPPER_LABELCOLOR_DISABLED : cc.CONTROL_STEPPER_LABELCOLOR_ENABLED)
        }
        if (send)this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED)
    }, startAutorepeat: function () {
        this._autorepeatCount = -1;
        this.schedule(this.update, cc.AUTOREPEAT_DELTATIME, cc.REPEAT_FOREVER, cc.AUTOREPEAT_DELTATIME * 3)
    }, stopAutorepeat: function () {
        this.unschedule(this.update)
    }, update: function (dt) {
        this._autorepeatCount++;
        if (this._autorepeatCount < cc.AUTOREPEAT_INCREASETIME_INCREMENT &&
            this._autorepeatCount % 3 != 0)return;
        if (this._touchedPart == cc.CONTROL_STEPPER_PARTMINUS)this.setValueWithSendingEvent(this._value - this._stepValue, this._continuous); else if (this._touchedPart == cc.CONTROL_STEPPER_PARTPLUS)this.setValueWithSendingEvent(this._value + this._stepValue, this._continuous)
    }, updateLayoutUsingTouchLocation: function (location) {
        if (location.x < this._minusSprite.getContentSize().width && this._value > this._minimumValue) {
            this._touchedPart = cc.CONTROL_STEPPER_PARTMINUS;
            this._minusSprite.setColor(cc.color.GRAY);
            this._plusSprite.setColor(cc.color.WHITE)
        } else if (location.x >= this._minusSprite.getContentSize().width && this._value < this._maximumValue) {
            this._touchedPart = cc.CONTROL_STEPPER_PARTPLUS;
            this._minusSprite.setColor(cc.color.WHITE);
            this._plusSprite.setColor(cc.color.GRAY)
        } else {
            this._touchedPart = cc.CONTROL_STEPPER_PARTNONE;
            this._minusSprite.setColor(cc.color.WHITE);
            this._plusSprite.setColor(cc.color.WHITE)
        }
    }, onTouchBegan: function (touch, event) {
        if (!this.isTouchInside(touch) || !this.isEnabled() || !this.isVisible())return false;
        var location = this.getTouchLocation(touch);
        this.updateLayoutUsingTouchLocation(location);
        this._touchInsideFlag = true;
        if (this._autorepeat)this.startAutorepeat();
        return true
    }, onTouchMoved: function (touch, event) {
        if (this.isTouchInside(touch)) {
            var location = this.getTouchLocation(touch);
            this.updateLayoutUsingTouchLocation(location);
            if (!this._touchInsideFlag) {
                this._touchInsideFlag = true;
                if (this._autorepeat)this.startAutorepeat()
            }
        } else {
            this._touchInsideFlag = false;
            this._touchedPart = cc.CONTROL_STEPPER_PARTNONE;
            this._minusSprite.setColor(cc.color.WHITE);
            this._plusSprite.setColor(cc.color.WHITE);
            if (this._autorepeat)this.stopAutorepeat()
        }
    }, onTouchEnded: function (touch, event) {
        this._minusSprite.setColor(cc.color.WHITE);
        this._plusSprite.setColor(cc.color.WHITE);
        if (this._autorepeat)this.stopAutorepeat();
        if (this.isTouchInside(touch)) {
            var location = this.getTouchLocation(touch);
            this.setValue(this._value + (location.x < this._minusSprite.getContentSize().width ? 0 - this._stepValue : this._stepValue))
        }
    }, setMinusSprite: function (sprite) {
        this._minusSprite =
            sprite
    }, getMinusSprite: function () {
        return this._minusSprite
    }, setPlusSprite: function (sprite) {
        this._plusSprite = sprite
    }, getPlusSprite: function () {
        return this._plusSprite
    }, setMinusLabel: function (sprite) {
        this._minusLabel = sprite
    }, getMinusLabel: function () {
        return this._minusLabel
    }, setPlusLabel: function (sprite) {
        this._plusLabel = sprite
    }, getPlusLabel: function () {
        return this._plusLabel
    }});
var _p = cc.ControlStepper.prototype;
_p.wraps;
cc.defineGetterSetter(_p, "wraps", _p.getWraps, _p.setWraps);
_p.value;
cc.defineGetterSetter(_p, "value", _p.getValue, _p.setValue);
_p.minValue;
cc.defineGetterSetter(_p, "minValue", _p.getMinimumValue, _p.setMinimumValue);
_p.maxValue;
cc.defineGetterSetter(_p, "maxValue", _p.getMaximumValue, _p.setMaximumValue);
_p.stepValue;
cc.defineGetterSetter(_p, "stepValue", _p.getStepValue, _p.setStepValue);
_p.continuous;
cc.defineGetterSetter(_p, "continuous", _p.isContinuous);
_p.minusSprite;
cc.defineGetterSetter(_p, "minusSprite", _p.getMinusSprite, _p.setMinusSprite);
_p.plusSprite;
cc.defineGetterSetter(_p, "plusSprite", _p.getPlusSprite, _p.setPlusSprite);
_p.minusLabel;
cc.defineGetterSetter(_p, "minusLabel", _p.getMinusLabel, _p.setMinusLabel);
_p.plusLabel;
cc.defineGetterSetter(_p, "plusLabel", _p.getPlusLabel, _p.setPlusLabel);
_p = null;
cc.ControlStepper.create = function (minusSprite, plusSprite) {
    var pRet = new cc.ControlStepper;
    if (pRet && pRet.initWithMinusSpriteAndPlusSprite(minusSprite, plusSprite))return pRet;
    return null
};
cc.ControlPotentiometer = cc.Control.extend({_thumbSprite: null, _progressTimer: null, _previousLocation: null, _value: 0, _minimumValue: 0, _maximumValue: 1, _className: "ControlPotentiometer", initWithTrackSprite_ProgressTimer_ThumbSprite: function (trackSprite, progressTimer, thumbSprite) {
    if (this.init()) {
        this.setProgressTimer(progressTimer);
        this.setThumbSprite(thumbSprite);
        this._thumbSprite.setPosition(progressTimer.getPosition());
        this.addChild(thumbSprite, 2);
        this.addChild(progressTimer, 1);
        this.addChild(trackSprite);
        this.setContentSize(trackSprite.getContentSize());
        this._minimumValue = 0;
        this._maximumValue = 1;
        this.setValue(this._minimumValue);
        return true
    }
    return false
}, setEnabled: function (enabled) {
    this.setEnabled(enabled);
    if (this._thumbSprite != NULL)this._thumbSprite.setOpacity(enabled ? 255 : 128)
}, setValue: function (value) {
    if (value < this._minimumValue)value = this._minimumValue;
    if (value > this._maximumValue)value = this._maximumValue;
    this._value = value;
    var percent = (value - this._minimumValue) / (this._maximumValue - this._minimumValue);
    this._progressTimer.setPercentage(percent * 100);
    this._thumbSprite.setRotation(percent * 360);
    this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED)
}, getValue: function () {
    return this._value
}, setMinimumValue: function (minimumValue) {
    this._minimumValue = minimumValue;
    if (this._minimumValue >= this._maximumValue)this._maximumValue = this._minimumValue + 1;
    this.setValue(this._maximumValue)
}, getMinimumValue: function () {
    return this._minimumValue
}, setMaximumValue: function (maximumValue) {
    this._maximumValue = maximumValue;
    if (this._maximumValue <= this._minimumValue)this._minimumValue = this._maximumValue - 1;
    this.setValue(this._minimumValue)
}, getMaximumValue: function () {
    return this._maximumValue
}, isTouchInside: function (touch) {
    var touchLocation = this.getTouchLocation(touch);
    var distance = this.distanceBetweenPointAndPoint(this._progressTimer.getPosition(), touchLocation);
    return distance < Math.min(this.getContentSize().width / 2, this.getContentSize().height / 2)
}, onTouchBegan: function (touch, event) {
    if (!this.isTouchInside(touch) || !this.isEnabled() || !this.isVisible())return false;
    this._previousLocation = this.getTouchLocation(touch);
    this.potentiometerBegan(this._previousLocation);
    return true
}, onTouchMoved: function (touch, event) {
    var location = this.getTouchLocation(touch);
    this.potentiometerMoved(location)
}, onTouchEnded: function (touch, event) {
    this.potentiometerEnded(cc.p(0, 0))
}, distanceBetweenPointAndPoint: function (point1, point2) {
    var dx = point1.x - point2.x;
    var dy = point1.y - point2.y;
    return Math.sqrt(dx * dx + dy * dy)
}, angleInDegreesBetweenLineFromPoint_toPoint_toLineFromPoint_toPoint: function (beginLineA, endLineA, beginLineB, endLineB) {
    var a = endLineA.x - beginLineA.x;
    var b = endLineA.y - beginLineA.y;
    var c = endLineB.x - beginLineB.x;
    var d = endLineB.y - beginLineB.y;
    var atanA = Math.atan2(a, b);
    var atanB = Math.atan2(c, d);
    return(atanA - atanB) * 180 / Math.PI
}, potentiometerBegan: function (location) {
    this.setSelected(true);
    this.getThumbSprite().setColor(cc.color.GRAY)
}, potentiometerMoved: function (location) {
    var angle = this.angleInDegreesBetweenLineFromPoint_toPoint_toLineFromPoint_toPoint(this._progressTimer.getPosition(), location,
        this._progressTimer.getPosition(), this._previousLocation);
    if (angle > 180)angle -= 360; else if (angle < -180)angle += 360;
    this.setValue(this._value + angle / 360 * (this._maximumValue - this._minimumValue));
    this._previousLocation = location
}, potentiometerEnded: function (location) {
    this.getThumbSprite().setColor(cc.color.WHITE);
    this.setSelected(false)
}, setThumbSprite: function (sprite) {
    this._thumbSprite = sprite
}, getThumbSprite: function () {
    return this._thumbSprite
}, setProgressTimer: function (sprite) {
    this._progressTimer = sprite
},
    getProgressTimer: function () {
        return this._progressTimer
    }, setPreviousLocation: function (point) {
        this._previousLocation = point
    }, getPreviousLocation: function () {
        return this._previousLocation
    }});
var _p = cc.ControlPotentiometer.prototype;
_p.value;
cc.defineGetterSetter(_p, "value", _p.getValue, _p.setValue);
_p.minValue;
cc.defineGetterSetter(_p, "minValue", _p.getMinimumValue, _p.setMinimumValue);
_p.maxValue;
cc.defineGetterSetter(_p, "maxValue", _p.getMaximumValue, _p.setMaximumValue);
_p.progressTimer;
cc.defineGetterSetter(_p, "progressTimer", _p.getProgressTimer, _p.setProgressTimer);
_p.thumbSprite;
cc.defineGetterSetter(_p, "thumbSprite", _p.getThumbSprite, _p.setThumbSprite);
_p.prevLocation;
cc.defineGetterSetter(_p, "prevLocation", _p.getPreviousLocation, _p.setPreviousLocation);
_p = null;
cc.ControlPotentiometer.create = function (backgroundFile, progressFile, thumbFile) {
    var pRet = new cc.ControlPotentiometer;
    if (pRet) {
        var backgroundSprite = cc.Sprite.create(backgroundFile);
        var thumbSprite = cc.Sprite.create(thumbFile);
        var progressTimer = cc.ProgressTimer.create(cc.Sprite.create(progressFile));
        if (pRet.initWithTrackSprite_ProgressTimer_ThumbSprite(backgroundSprite, progressTimer, thumbSprite))return pRet
    }
    return null
};
cc.SCROLLVIEW_DIRECTION_NONE = -1;
cc.SCROLLVIEW_DIRECTION_HORIZONTAL = 0;
cc.SCROLLVIEW_DIRECTION_VERTICAL = 1;
cc.SCROLLVIEW_DIRECTION_BOTH = 2;
var SCROLL_DEACCEL_RATE = 0.95;
var SCROLL_DEACCEL_DIST = 1;
var BOUNCE_DURATION = 0.15;
var INSET_RATIO = 0.2;
var MOVE_INCH = 7 / 160;
var BOUNCE_BACK_FACTOR = 0.35;
cc.convertDistanceFromPointToInch = function (pointDis) {
    var eglViewer = cc.view;
    var factor = (eglViewer.getScaleX() + eglViewer.getScaleY()) / 2;
    return pointDis * factor / 160
};
cc.ScrollViewDelegate = cc.Class.extend({scrollViewDidScroll: function (view) {
}, scrollViewDidZoom: function (view) {
}});
cc.ScrollView = cc.Layer.extend({_zoomScale: 0, _minZoomScale: 0, _maxZoomScale: 0, _delegate: null, _direction: cc.SCROLLVIEW_DIRECTION_BOTH, _dragging: false, _contentOffset: null, _container: null, _touchMoved: false, _maxInset: null, _minInset: null, _bounceable: false, _clippingToBounds: false, _scrollDistance: null, _touchPoint: null, _touchLength: 0, _touches: null, _viewSize: null, _minScale: 0, _maxScale: 0, _parentScissorRect: null, _scissorRestored: false, _tmpViewRect: null, _touchListener: null, _className: "ScrollView", ctor: function () {
    cc.Layer.prototype.ctor.call(this);
    this._contentOffset = cc.p(0, 0);
    this._maxInset = cc.p(0, 0);
    this._minInset = cc.p(0, 0);
    this._scrollDistance = cc.p(0, 0);
    this._touchPoint = cc.p(0, 0);
    this._touches = [];
    this._viewSize = cc.size(0, 0);
    this._parentScissorRect = new cc.Rect(0, 0, 0, 0);
    this._tmpViewRect = new cc.Rect(0, 0, 0, 0)
}, init: function () {
    return this.initWithViewSize(cc.size(200, 200), null)
}, initWithViewSize: function (size, container) {
    var pZero = cc.p(0, 0);
    if (cc.Layer.prototype.init.call(this)) {
        this._container = container;
        if (!this._container) {
            this._container =
                cc.Layer.create();
            this._container.ignoreAnchorPointForPosition(false);
            this._container.setAnchorPoint(pZero)
        }
        this.setViewSize(size);
        this.setTouchEnabled(true);
        this._touches.length = 0;
        this._delegate = null;
        this._bounceable = true;
        this._clippingToBounds = true;
        this._direction = cc.SCROLLVIEW_DIRECTION_BOTH;
        this._container.setPosition(pZero);
        this._touchLength = 0;
        this.addChild(this._container);
        this._minScale = this._maxScale = 1;
        return true
    }
    return false
}, setContentOffset: function (offset, animated) {
    if (animated) {
        this.setContentOffsetInDuration(offset,
            BOUNCE_DURATION);
        return
    }
    if (!this._bounceable) {
        var minOffset = this.minContainerOffset();
        var maxOffset = this.maxContainerOffset();
        offset.x = Math.max(minOffset.x, Math.min(maxOffset.x, offset.x));
        offset.y = Math.max(minOffset.y, Math.min(maxOffset.y, offset.y))
    }
    this._container.setPosition(offset);
    var locDelegate = this._delegate;
    if (locDelegate != null && locDelegate.scrollViewDidScroll)locDelegate.scrollViewDidScroll(this)
}, getContentOffset: function () {
    var locPos = this._container.getPosition();
    return cc.p(locPos.x, locPos.y)
},
    setContentOffsetInDuration: function (offset, dt) {
        var scroll = cc.MoveTo.create(dt, offset);
        var expire = cc.CallFunc.create(this._stoppedAnimatedScroll, this);
        this._container.runAction(cc.Sequence.create(scroll, expire));
        this.schedule(this._performedAnimatedScroll)
    }, setZoomScale: function (scale, animated) {
        if (animated) {
            this.setZoomScaleInDuration(scale, BOUNCE_DURATION);
            return
        }
        var locContainer = this._container;
        if (locContainer.getScale() != scale) {
            var oldCenter, newCenter;
            var center;
            if (this._touchLength == 0) {
                var locViewSize =
                    this._viewSize;
                center = cc.p(locViewSize.width * 0.5, locViewSize.height * 0.5);
                center = this.convertToWorldSpace(center)
            } else center = this._touchPoint;
            oldCenter = locContainer.convertToNodeSpace(center);
            locContainer.setScale(Math.max(this._minScale, Math.min(this._maxScale, scale)));
            newCenter = locContainer.convertToWorldSpace(oldCenter);
            var offset = cc.pSub(center, newCenter);
            if (this._delegate && this._delegate.scrollViewDidZoom)this._delegate.scrollViewDidZoom(this);
            this.setContentOffset(cc.pAdd(locContainer.getPosition(),
                offset))
        }
    }, getZoomScale: function () {
        return this._container.getScale()
    }, setZoomScaleInDuration: function (s, dt) {
        if (dt > 0) {
            var locScale = this._container.getScale();
            if (locScale != s) {
                var scaleAction = cc.ActionTween.create(dt, "zoomScale", locScale, s);
                this.runAction(scaleAction)
            }
        } else this.setZoomScale(s)
    }, minContainerOffset: function () {
        var locContainer = this._container;
        var locContentSize = locContainer.getContentSize(), locViewSize = this._viewSize;
        return cc.p(locViewSize.width - locContentSize.width * locContainer.getScaleX(),
                locViewSize.height - locContentSize.height * locContainer.getScaleY())
    }, maxContainerOffset: function () {
        return cc.p(0, 0)
    }, isNodeVisible: function (node) {
        var offset = this.getContentOffset();
        var size = this.getViewSize();
        var scale = this.getZoomScale();
        var viewRect = cc.rect(-offset.x / scale, -offset.y / scale, size.width / scale, size.height / scale);
        return cc.rectIntersectsRect(viewRect, node.getBoundingBox())
    }, pause: function (sender) {
        this._container.pause();
        var selChildren = this._container.getChildren();
        for (var i = 0; i < selChildren.length; i++)selChildren[i].pause();
        this._super()
    }, resume: function (sender) {
        var selChildren = this._container.getChildren();
        for (var i = 0, len = selChildren.length; i < len; i++)selChildren[i].resume();
        this._container.resume();
        this._super()
    }, isDragging: function () {
        return this._dragging
    }, isTouchMoved: function () {
        return this._touchMoved
    }, isBounceable: function () {
        return this._bounceable
    }, setBounceable: function (bounceable) {
        this._bounceable = bounceable
    }, getViewSize: function () {
        return this._viewSize
    }, setViewSize: function (size) {
        this._viewSize = size;
        cc.Node.prototype.setContentSize.call(this,
            size)
    }, getContainer: function () {
        return this._container
    }, setContainer: function (container) {
        if (!container)return;
        this.removeAllChildren(true);
        this._container = container;
        container.ignoreAnchorPointForPosition(false);
        container.setAnchorPoint(0, 0);
        this.addChild(container);
        this.setViewSize(this._viewSize)
    }, getDirection: function () {
        return this._direction
    }, setDirection: function (direction) {
        this._direction = direction
    }, getDelegate: function () {
        return this._delegate
    }, setDelegate: function (delegate) {
        this._delegate = delegate
    },
    onTouchBegan: function (touch, event) {
        if (!this.isVisible())return false;
        var frame = this._getViewRect();
        var locContainer = this._container;
        var locPoint = locContainer.convertToWorldSpace(locContainer.convertTouchToNodeSpace(touch));
        var locTouches = this._touches;
        if (locTouches.length > 2 || this._touchMoved || !cc.rectContainsPoint(frame, locPoint))return false;
        locTouches.push(touch);
        if (locTouches.length === 1) {
            this._touchPoint = this.convertTouchToNodeSpace(touch);
            this._touchMoved = false;
            this._dragging = true;
            this._scrollDistance.x =
                0;
            this._scrollDistance.y = 0;
            this._touchLength = 0
        } else if (locTouches.length == 2) {
            this._touchPoint = cc.pMidpoint(this.convertTouchToNodeSpace(locTouches[0]), this.convertTouchToNodeSpace(locTouches[1]));
            this._touchLength = cc.pDistance(locContainer.convertTouchToNodeSpace(locTouches[0]), locContainer.convertTouchToNodeSpace(locTouches[1]));
            this._dragging = false
        }
        return true
    }, onTouchMoved: function (touch, event) {
        if (!this.isVisible())return;
        if (this._touches.length === 1 && this._dragging) {
            this._touchMoved = true;
            var frame =
                this._getViewRect();
            var newPoint = this.convertTouchToNodeSpace(touch);
            var moveDistance = cc.pSub(newPoint, this._touchPoint);
            var dis = 0, locDirection = this._direction, pos;
            if (locDirection === cc.SCROLLVIEW_DIRECTION_VERTICAL) {
                dis = moveDistance.y;
                pos = this._container.getPositionY();
                if (!(this.minContainerOffset().y <= pos && pos <= this.maxContainerOffset().y))moveDistance.y *= BOUNCE_BACK_FACTOR
            } else if (locDirection === cc.SCROLLVIEW_DIRECTION_HORIZONTAL) {
                dis = moveDistance.x;
                pos = this._container.getPositionX();
                if (!(this.minContainerOffset().x <=
                    pos && pos <= this.maxContainerOffset().x))moveDistance.x *= BOUNCE_BACK_FACTOR
            } else {
                dis = Math.sqrt(moveDistance.x * moveDistance.x + moveDistance.y * moveDistance.y);
                pos = this._container.getPositionY();
                var _minOffset = this.minContainerOffset(), _maxOffset = this.maxContainerOffset();
                if (!(_minOffset.y <= pos && pos <= _maxOffset.y))moveDistance.y *= BOUNCE_BACK_FACTOR;
                pos = this._container.getPositionX();
                if (!(_minOffset.x <= pos && pos <= _maxOffset.x))moveDistance.x *= BOUNCE_BACK_FACTOR
            }
            if (!this._touchMoved && Math.abs(cc.convertDistanceFromPointToInch(dis)) <
                MOVE_INCH)return;
            if (!this._touchMoved) {
                moveDistance.x = 0;
                moveDistance.y = 0
            }
            this._touchPoint = newPoint;
            this._touchMoved = true;
            if (this._dragging) {
                switch (locDirection) {
                    case cc.SCROLLVIEW_DIRECTION_VERTICAL:
                        moveDistance.x = 0;
                        break;
                    case cc.SCROLLVIEW_DIRECTION_HORIZONTAL:
                        moveDistance.y = 0;
                        break;
                    default:
                        break
                }
                var locPosition = this._container.getPosition();
                var newX = locPosition.x + moveDistance.x;
                var newY = locPosition.y + moveDistance.y;
                this._scrollDistance = moveDistance;
                this.setContentOffset(cc.p(newX, newY))
            }
        } else if (this._touches.length ===
            2 && !this._dragging) {
            var len = cc.pDistance(this._container.convertTouchToNodeSpace(this._touches[0]), this._container.convertTouchToNodeSpace(this._touches[1]));
            this.setZoomScale(this.getZoomScale() * len / this._touchLength)
        }
    }, onTouchEnded: function (touch, event) {
        if (!this.isVisible())return;
        if (this._touches.length == 1 && this._touchMoved)this.schedule(this._deaccelerateScrolling);
        this._touches.length = 0;
        this._dragging = false;
        this._touchMoved = false
    }, onTouchCancelled: function (touch, event) {
        if (!this.isVisible())return;
        this._touches.length = 0;
        this._dragging = false;
        this._touchMoved = false
    }, setContentSize: function (size, height) {
        if (this.getContainer() != null) {
            if (height === undefined)this.getContainer().setContentSize(size); else this.getContainer().setContentSize(size, height);
            this.updateInset()
        }
    }, _setWidth: function (value) {
        var container = this.getContainer();
        if (container != null) {
            container._setWidth(value);
            this.updateInset()
        }
    }, _setHeight: function (value) {
        var container = this.getContainer();
        if (container != null) {
            container._setHeight(value);
            this.updateInset()
        }
    }, getContentSize: function () {
        return this._container.getContentSize()
    }, updateInset: function () {
        if (this.getContainer() != null) {
            var locViewSize = this._viewSize;
            var tempOffset = this.maxContainerOffset();
            this._maxInset.x = tempOffset.x + locViewSize.width * INSET_RATIO;
            this._maxInset.y = tempOffset.y + locViewSize.height * INSET_RATIO;
            tempOffset = this.minContainerOffset();
            this._minInset.x = tempOffset.x - locViewSize.width * INSET_RATIO;
            this._minInset.y = tempOffset.y - locViewSize.height * INSET_RATIO
        }
    }, isClippingToBounds: function () {
        return this._clippingToBounds
    },
    setClippingToBounds: function (clippingToBounds) {
        this._clippingToBounds = clippingToBounds
    }, visit: function (ctx) {
        if (!this.isVisible())return;
        var context = ctx || cc._renderContext;
        var i, locChildren = this._children, selChild, childrenLen;
        if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
            context.save();
            this.transform(context);
            this._beforeDraw(context);
            if (locChildren && locChildren.length > 0) {
                childrenLen = locChildren.length;
                this.sortAllChildren();
                for (i = 0; i < childrenLen; i++) {
                    selChild = locChildren[i];
                    if (selChild && selChild._localZOrder <
                        0)selChild.visit(context); else break
                }
                this.draw(context);
                for (; i < childrenLen; i++)locChildren[i].visit(context)
            } else this.draw(context);
            this._afterDraw();
            context.restore()
        } else {
            cc.kmGLPushMatrix();
            var locGrid = this.grid;
            if (locGrid && locGrid.isActive()) {
                locGrid.beforeDraw();
                this.transformAncestors()
            }
            this.transform(context);
            this._beforeDraw(context);
            if (locChildren && locChildren.length > 0) {
                childrenLen = locChildren.length;
                for (i = 0; i < childrenLen; i++) {
                    selChild = locChildren[i];
                    if (selChild && selChild._localZOrder < 0)selChild.visit();
                    else break
                }
                this.draw(context);
                for (; i < childrenLen; i++)locChildren[i].visit()
            } else this.draw(context);
            this._afterDraw(context);
            if (locGrid && locGrid.isActive())locGrid.afterDraw(this);
            cc.kmGLPopMatrix()
        }
    }, addChild: function (child, zOrder, tag) {
        if (!child)throw new Error("child must not nil!");
        zOrder = zOrder || child.getLocalZOrder();
        tag = tag || child.getTag();
        if (this._container != child)this._container.addChild(child, zOrder, tag); else cc.Layer.prototype.addChild.call(this, child, zOrder, tag)
    }, isTouchEnabled: function () {
        return this._touchListener !=
            null
    }, setTouchEnabled: function (e) {
        if (this._touchListener)cc.eventManager.removeListener(this._touchListener);
        this._touchListener = null;
        if (!e) {
            this._dragging = false;
            this._touchMoved = false;
            this._touches.length = 0
        } else {
            var listener = cc.EventListener.create({event: cc.EventListener.TOUCH_ONE_BY_ONE});
            if (this.onTouchBegan)listener.onTouchBegan = this.onTouchBegan.bind(this);
            if (this.onTouchMoved)listener.onTouchMoved = this.onTouchMoved.bind(this);
            if (this.onTouchEnded)listener.onTouchEnded = this.onTouchEnded.bind(this);
            if (this.onTouchCancelled)listener.onTouchCancelled = this.onTouchCancelled.bind(this);
            this._touchListener = listener;
            cc.eventManager.addListener(listener, this)
        }
    }, _initWithViewSize: function (size) {
        return null
    }, _relocateContainer: function (animated) {
        var min = this.minContainerOffset();
        var max = this.maxContainerOffset();
        var locDirection = this._direction;
        var oldPoint = this._container.getPosition();
        var newX = oldPoint.x;
        var newY = oldPoint.y;
        if (locDirection === cc.SCROLLVIEW_DIRECTION_BOTH || locDirection === cc.SCROLLVIEW_DIRECTION_HORIZONTAL) {
            newX =
                Math.max(newX, min.x);
            newX = Math.min(newX, max.x)
        }
        if (locDirection == cc.SCROLLVIEW_DIRECTION_BOTH || locDirection == cc.SCROLLVIEW_DIRECTION_VERTICAL) {
            newY = Math.min(newY, max.y);
            newY = Math.max(newY, min.y)
        }
        if (newY != oldPoint.y || newX != oldPoint.x)this.setContentOffset(cc.p(newX, newY), animated)
    }, _deaccelerateScrolling: function (dt) {
        if (this._dragging) {
            this.unschedule(this._deaccelerateScrolling);
            return
        }
        var maxInset, minInset;
        var oldPosition = this._container.getPosition();
        var locScrollDistance = this._scrollDistance;
        this._container.setPosition(oldPosition.x +
            locScrollDistance.x, oldPosition.y + locScrollDistance.y);
        if (this._bounceable) {
            maxInset = this._maxInset;
            minInset = this._minInset
        } else {
            maxInset = this.maxContainerOffset();
            minInset = this.minContainerOffset()
        }
        var newX = this._container.getPositionX();
        var newY = this._container.getPositionY();
        locScrollDistance.x = locScrollDistance.x * SCROLL_DEACCEL_RATE;
        locScrollDistance.y = locScrollDistance.y * SCROLL_DEACCEL_RATE;
        this.setContentOffset(cc.p(newX, newY));
        if (Math.abs(locScrollDistance.x) <= SCROLL_DEACCEL_DIST && Math.abs(locScrollDistance.y) <=
            SCROLL_DEACCEL_DIST || newY > maxInset.y || newY < minInset.y || newX > maxInset.x || newX < minInset.x || newX == maxInset.x || newX == minInset.x || newY == maxInset.y || newY == minInset.y) {
            this.unschedule(this._deaccelerateScrolling);
            this._relocateContainer(true)
        }
    }, _performedAnimatedScroll: function (dt) {
        if (this._dragging) {
            this.unschedule(this._performedAnimatedScroll);
            return
        }
        if (this._delegate && this._delegate.scrollViewDidScroll)this._delegate.scrollViewDidScroll(this)
    }, _stoppedAnimatedScroll: function (node) {
        this.unschedule(this._performedAnimatedScroll);
        if (this._delegate && this._delegate.scrollViewDidScroll)this._delegate.scrollViewDidScroll(this)
    }, _beforeDraw: function (context) {
        if (this._clippingToBounds) {
            this._scissorRestored = false;
            var frame = this._getViewRect(), locEGLViewer = cc.view;
            var scaleX = this.getScaleX();
            var scaleY = this.getScaleY();
            var ctx = context || cc._renderContext;
            if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
                var getWidth = this._viewSize.width * scaleX * locEGLViewer.getScaleX();
                var getHeight = this._viewSize.height * scaleY * locEGLViewer.getScaleY();
                var startX = 0;
                var startY = 0;
                ctx.beginPath();
                ctx.rect(startX, startY, getWidth, -getHeight);
                ctx.clip();
                ctx.closePath()
            } else {
                var EGLViewer = cc.view;
                if (EGLViewer.isScissorEnabled()) {
                    this._scissorRestored = true;
                    this._parentScissorRect = EGLViewer.getScissorRect();
                    if (cc.rectIntersection(frame, this._parentScissorRect)) {
                        var locPSRect = this._parentScissorRect;
                        var x = Math.max(frame.x, locPSRect.x);
                        var y = Math.max(frame.y, locPSRect.y);
                        var xx = Math.min(frame.x + frame.width, locPSRect.x + locPSRect.width);
                        var yy = Math.min(frame.y +
                            frame.height, locPSRect.y + locPSRect.height);
                        EGLViewer.setScissorInPoints(x, y, xx - x, yy - y)
                    }
                } else {
                    ctx.enable(ctx.SCISSOR_TEST);
                    EGLViewer.setScissorInPoints(frame.x, frame.y, frame.width, frame.height)
                }
            }
        }
    }, _afterDraw: function (context) {
        if (this._clippingToBounds && cc._renderType === cc._RENDER_TYPE_WEBGL)if (this._scissorRestored) {
            var rect = this._parentScissorRect;
            cc.view.setScissorInPoints(rect.x, rect.y, rect.width, rect.height)
        } else {
            var ctx = context || cc._renderContext;
            ctx.disable(ctx.SCISSOR_TEST)
        }
    }, _handleZoom: function () {
    },
    _getViewRect: function () {
        var screenPos = this.convertToWorldSpace(cc.p(0, 0));
        var locViewSize = this._viewSize;
        var scaleX = this.getScaleX();
        var scaleY = this.getScaleY();
        for (var p = this._parent; p != null; p = p.getParent()) {
            scaleX *= p.getScaleX();
            scaleY *= p.getScaleY()
        }
        if (scaleX < 0) {
            screenPos.x += locViewSize.width * scaleX;
            scaleX = -scaleX
        }
        if (scaleY < 0) {
            screenPos.y += locViewSize.height * scaleY;
            scaleY = -scaleY
        }
        var locViewRect = this._tmpViewRect;
        locViewRect.x = screenPos.x;
        locViewRect.y = screenPos.y;
        locViewRect.width = locViewSize.width *
            scaleX;
        locViewRect.height = locViewSize.height * scaleY;
        return locViewRect
    }});
var _p = cc.ScrollView.prototype;
_p.minOffset;
cc.defineGetterSetter(_p, "minOffset", _p.minContainerOffset);
_p.maxOffset;
cc.defineGetterSetter(_p, "maxOffset", _p.maxContainerOffset);
_p.bounceable;
cc.defineGetterSetter(_p, "bounceable", _p.isBounceable, _p.setBounceable);
_p.viewSize;
cc.defineGetterSetter(_p, "viewSize", _p.getViewSize, _p.setViewSize);
_p.container;
cc.defineGetterSetter(_p, "container", _p.getContainer, _p.setContainer);
_p.direction;
cc.defineGetterSetter(_p, "direction", _p.getDirection, _p.setDirection);
_p.delegate;
cc.defineGetterSetter(_p, "delegate", _p.getDelegate, _p.setDelegate);
_p.clippingToBounds;
cc.defineGetterSetter(_p, "clippingToBounds", _p.isClippingToBounds, _p.setClippingToBounds);
_p = null;
cc.ScrollView.create = function (size, container) {
    var pRet = new cc.ScrollView;
    if (arguments.length == 2) {
        if (pRet && pRet.initWithViewSize(size, container))return pRet
    } else if (pRet && pRet.init())return pRet;
    return null
};
cc.SortableObject = cc.Class.extend({setObjectID: function (objectId) {
}, getObjectID: function () {
    return 0
}});
cc.SortedObject = cc.SortableObject.extend({_objectID: 0, ctor: function () {
    this._objectID = 0
}, setObjectID: function (objectID) {
    this._objectID = objectID
}, getObjectID: function () {
    return this._objectID
}});
var _compareObject = function (val1, val2) {
    return val1.getObjectID() - val2.getObjectID()
};
cc.ArrayForObjectSorting = cc.Class.extend({_saveObjectArr: null, ctor: function () {
    this._saveObjectArr = []
}, insertSortedObject: function (addObject) {
    if (!addObject)throw"cc.ArrayForObjectSorting.insertSortedObject(): addObject should be non-null.";
    var idx = this.indexOfSortedObject(addObject);
    this.insertObject(addObject, idx)
}, removeSortedObject: function (delObject) {
    if (this.count() == 0)return;
    var idx = this.indexOfSortedObject(delObject);
    if (idx < this.count() && idx != cc.INVALID_INDEX) {
        var foundObj = this.objectAtIndex(idx);
        if (foundObj.getObjectID() == delObject.getObjectID())this.removeObjectAtIndex(idx)
    }
}, setObjectID_ofSortedObject: function (tag, setObject) {
    var idx = this.indexOfSortedObject(setObject);
    if (idx < this.count() && idx != cc.INVALID_INDEX) {
        var foundObj = this.objectAtIndex(idx);
        if (foundObj.getObjectID() == setObject.getObjectID()) {
            this.removeObjectAtIndex(idx);
            foundObj.setObjectID(tag);
            this.insertSortedObject(foundObj)
        }
    }
}, objectWithObjectID: function (tag) {
    if (this.count() == 0)return null;
    var foundObj = new cc.SortedObject;
    foundObj.setObjectID(tag);
    var idx = this.indexOfSortedObject(foundObj);
    if (idx < this.count() && idx != cc.INVALID_INDEX) {
        foundObj = this.objectAtIndex(idx);
        if (foundObj.getObjectID() != tag)foundObj = null
    }
    return foundObj
}, getObjectWithObjectID: function (tag) {
    return null
}, indexOfSortedObject: function (idxObj) {
    var idx = 0;
    if (idxObj) {
        var uPrevObjectID = 0;
        var uOfSortObjectID = idxObj.getObjectID();
        var locObjectArr = this._saveObjectArr;
        for (var i = 0; i < locObjectArr.length; i++) {
            var pSortableObj = locObjectArr[i];
            var curObjectID =
                pSortableObj.getObjectID();
            if (uOfSortObjectID == curObjectID || uOfSortObjectID >= uPrevObjectID && uOfSortObjectID < curObjectID)break;
            uPrevObjectID = curObjectID;
            idx++
        }
    } else idx = cc.INVALID_INDEX;
    return idx
}, count: function () {
    return this._saveObjectArr.length
}, lastObject: function () {
    var locObjectArr = this._saveObjectArr;
    if (locObjectArr.length == 0)return null;
    return locObjectArr[locObjectArr.length - 1]
}, objectAtIndex: function (idx) {
    return this._saveObjectArr[idx]
}, addObject: function (addObj) {
    this._saveObjectArr.push(addObj);
    this._saveObjectArr.sort(_compareObject)
}, removeObjectAtIndex: function (idx) {
    this._saveObjectArr.splice(idx, 1);
    this._saveObjectArr.sort(_compareObject)
}, insertObject: function (addObj, idx) {
    this._saveObjectArr.splice(idx, 0, addObj);
    this._saveObjectArr.sort(_compareObject)
}});
cc.TABLEVIEW_FILL_TOPDOWN = 0;
cc.TABLEVIEW_FILL_BOTTOMUP = 1;
cc.TableViewCell = cc.Node.extend({_idx: 0, _className: "TableViewCell", getIdx: function () {
    return this._idx
}, setIdx: function (idx) {
    this._idx = idx
}, reset: function () {
    this._idx = cc.INVALID_INDEX
}, setObjectID: function (idx) {
    this._idx = idx
}, getObjectID: function () {
    return this._idx
}});
var _p = cc.TableViewCell.prototype;
_p.objectId;
cc.defineGetterSetter(_p, "objectId", _p.getObjectID, _p.setObjectID);
_p = null;
cc.TableViewDelegate = cc.ScrollViewDelegate.extend({tableCellTouched: function (table, cell) {
}, tableCellHighlight: function (table, cell) {
}, tableCellUnhighlight: function (table, cell) {
}, tableCellWillRecycle: function (table, cell) {
}});
cc.TableViewDataSource = cc.Class.extend({tableCellSizeForIndex: function (table, idx) {
    return this.cellSizeForTable(table)
}, cellSizeForTable: function (table) {
    return cc.size(0, 0)
}, tableCellAtIndex: function (table, idx) {
    return null
}, numberOfCellsInTableView: function (table) {
    return 0
}});
cc.TableView = cc.ScrollView.extend({_vOrdering: null, _indices: null, _cellsFreed: null, _dataSource: null, _tableViewDelegate: null, _oldDirection: null, _cellsPositions: null, _touchedCell: null, ctor: function () {
    cc.ScrollView.prototype.ctor.call(this);
    this._oldDirection = cc.SCROLLVIEW_DIRECTION_NONE;
    this._cellsPositions = []
}, __indexFromOffset: function (offset) {
    var low = 0;
    var high = this._dataSource.numberOfCellsInTableView(this) - 1;
    var search;
    switch (this.getDirection()) {
        case cc.SCROLLVIEW_DIRECTION_HORIZONTAL:
            search = offset.x;
            break;
        default:
            search = offset.y;
            break
    }
    var locCellsPositions = this._cellsPositions;
    while (high >= low) {
        var index = 0 | low + (high - low) / 2;
        var cellStart = locCellsPositions[index];
        var cellEnd = locCellsPositions[index + 1];
        if (search >= cellStart && search <= cellEnd)return index; else if (search < cellStart)high = index - 1; else low = index + 1
    }
    if (low <= 0)return 0;
    return-1
}, _indexFromOffset: function (offset) {
    var locOffset = {x: offset.x, y: offset.y};
    var locDataSource = this._dataSource;
    var maxIdx = locDataSource.numberOfCellsInTableView(this) -
        1;
    if (this._vOrdering === cc.TABLEVIEW_FILL_TOPDOWN)locOffset.y = this.getContainer().getContentSize().height - locOffset.y;
    var index = this.__indexFromOffset(locOffset);
    if (index != -1) {
        index = Math.max(0, index);
        if (index > maxIdx)index = cc.INVALID_INDEX
    }
    return index
}, __offsetFromIndex: function (index) {
    var offset;
    switch (this.getDirection()) {
        case cc.SCROLLVIEW_DIRECTION_HORIZONTAL:
            offset = cc.p(this._cellsPositions[index], 0);
            break;
        default:
            offset = cc.p(0, this._cellsPositions[index]);
            break
    }
    return offset
}, _offsetFromIndex: function (index) {
    var offset =
        this.__offsetFromIndex(index);
    var cellSize = this._dataSource.tableCellSizeForIndex(this, index);
    if (this._vOrdering === cc.TABLEVIEW_FILL_TOPDOWN)offset.y = this.getContainer().getContentSize().height - offset.y - cellSize.height;
    return offset
}, _updateCellPositions: function () {
    var cellsCount = this._dataSource.numberOfCellsInTableView(this);
    var locCellsPositions = this._cellsPositions;
    if (cellsCount > 0) {
        var currentPos = 0;
        var cellSize, locDataSource = this._dataSource;
        for (var i = 0; i < cellsCount; i++) {
            locCellsPositions[i] =
                currentPos;
            cellSize = locDataSource.tableCellSizeForIndex(this, i);
            switch (this.getDirection()) {
                case cc.SCROLLVIEW_DIRECTION_HORIZONTAL:
                    currentPos += cellSize.width;
                    break;
                default:
                    currentPos += cellSize.height;
                    break
            }
        }
        this._cellsPositions[cellsCount] = currentPos
    }
}, _updateContentSize: function () {
    var size = cc.size(0, 0);
    var cellsCount = this._dataSource.numberOfCellsInTableView(this);
    if (cellsCount > 0) {
        var maxPosition = this._cellsPositions[cellsCount];
        switch (this.getDirection()) {
            case cc.SCROLLVIEW_DIRECTION_HORIZONTAL:
                size =
                    cc.size(maxPosition, this._viewSize.height);
                break;
            default:
                size = cc.size(this._viewSize.width, maxPosition);
                break
        }
    }
    this.setContentSize(size);
    if (this._oldDirection != this._direction) {
        if (this._direction == cc.SCROLLVIEW_DIRECTION_HORIZONTAL)this.setContentOffset(cc.p(0, 0)); else this.setContentOffset(cc.p(0, this.minContainerOffset().y));
        this._oldDirection = this._direction
    }
}, _moveCellOutOfSight: function (cell) {
    if (this._tableViewDelegate && this._tableViewDelegate.tableCellWillRecycle)this._tableViewDelegate.tableCellWillRecycle(this,
        cell);
    this._cellsFreed.addObject(cell);
    this._cellsUsed.removeSortedObject(cell);
    cc.arrayRemoveObject(this._indices, cell.getIdx());
    cell.reset();
    if (cell.getParent() == this.getContainer())this.getContainer().removeChild(cell, true)
}, _setIndexForCell: function (index, cell) {
    cell.setAnchorPoint(0, 0);
    cell.setPosition(this._offsetFromIndex(index));
    cell.setIdx(index)
}, _addCellIfNecessary: function (cell) {
    if (cell.getParent() != this.getContainer())this.getContainer().addChild(cell);
    this._cellsUsed.insertSortedObject(cell);
    var locIndices = this._indices, addIdx = cell.getIdx();
    if (locIndices.indexOf(addIdx) == -1) {
        locIndices.push(addIdx);
        locIndices.sort(function (a, b) {
            return a - b
        })
    }
}, getDataSource: function () {
    return this._dataSource
}, setDataSource: function (source) {
    this._dataSource = source
}, getDelegate: function () {
    return this._tableViewDelegate
}, setDelegate: function (delegate) {
    this._tableViewDelegate = delegate
}, setVerticalFillOrder: function (fillOrder) {
    if (this._vOrdering != fillOrder) {
        this._vOrdering = fillOrder;
        if (this._cellsUsed.count() >
            0)this.reloadData()
    }
}, getVerticalFillOrder: function () {
    return this._vOrdering
}, initWithViewSize: function (size, container) {
    if (cc.ScrollView.prototype.initWithViewSize.call(this, size, container)) {
        this._cellsUsed = new cc.ArrayForObjectSorting;
        this._cellsFreed = new cc.ArrayForObjectSorting;
        this._indices = [];
        this._tableViewDelegate = null;
        this._vOrdering = cc.TABLEVIEW_FILL_BOTTOMUP;
        this.setDirection(cc.SCROLLVIEW_DIRECTION_VERTICAL);
        cc.ScrollView.prototype.setDelegate.call(this, this);
        return true
    }
    return false
},
    updateCellAtIndex: function (idx) {
        if (idx == cc.INVALID_INDEX || idx > this._dataSource.numberOfCellsInTableView(this) - 1)return;
        var cell = this.cellAtIndex(idx);
        if (cell)this._moveCellOutOfSight(cell);
        cell = this._dataSource.tableCellAtIndex(this, idx);
        this._setIndexForCell(idx, cell);
        this._addCellIfNecessary(cell)
    }, insertCellAtIndex: function (idx) {
        if (idx == cc.INVALID_INDEX || idx > this._dataSource.numberOfCellsInTableView(this) - 1)return;
        var newIdx, locCellsUsed = this._cellsUsed;
        var cell = locCellsUsed.objectWithObjectID(idx);
        if (cell) {
            newIdx = locCellsUsed.indexOfSortedObject(cell);
            for (var i = newIdx; i < locCellsUsed.count(); i++) {
                cell = locCellsUsed.objectAtIndex(i);
                this._setIndexForCell(cell.getIdx() + 1, cell)
            }
        }
        cell = this._dataSource.tableCellAtIndex(this, idx);
        this._setIndexForCell(idx, cell);
        this._addCellIfNecessary(cell);
        this._updateCellPositions();
        this._updateContentSize()
    }, removeCellAtIndex: function (idx) {
        if (idx == cc.INVALID_INDEX || idx > this._dataSource.numberOfCellsInTableView(this) - 1)return;
        var cell = this.cellAtIndex(idx);
        if (!cell)return;
        var locCellsUsed = this._cellsUsed;
        var newIdx = locCellsUsed.indexOfSortedObject(cell);
        this._moveCellOutOfSight(cell);
        cc.arrayRemoveObject(this._indices, idx);
        this._updateCellPositions();
        for (var i = locCellsUsed.count() - 1; i > newIdx; i--) {
            cell = locCellsUsed.objectAtIndex(i);
            this._setIndexForCell(cell.getIdx() - 1, cell)
        }
    }, reloadData: function () {
        this._oldDirection = cc.SCROLLVIEW_DIRECTION_NONE;
        var locCellsUsed = this._cellsUsed, locCellsFreed = this._cellsFreed, locContainer = this.getContainer();
        for (var i = 0, len = locCellsUsed.count(); i <
            len; i++) {
            var cell = locCellsUsed.objectAtIndex(i);
            if (this._tableViewDelegate && this._tableViewDelegate.tableCellWillRecycle)this._tableViewDelegate.tableCellWillRecycle(this, cell);
            locCellsFreed.addObject(cell);
            cell.reset();
            if (cell.getParent() == locContainer)locContainer.removeChild(cell, true)
        }
        this._indices = [];
        this._cellsUsed = new cc.ArrayForObjectSorting;
        this._updateCellPositions();
        this._updateContentSize();
        if (this._dataSource.numberOfCellsInTableView(this) > 0)this.scrollViewDidScroll(this)
    }, dequeueCell: function () {
        if (this._cellsFreed.count() ===
            0)return null; else {
            var cell = this._cellsFreed.objectAtIndex(0);
            this._cellsFreed.removeObjectAtIndex(0);
            return cell
        }
    }, cellAtIndex: function (idx) {
        var i = this._indices.indexOf(idx);
        if (i == -1)return null;
        return this._cellsUsed.objectWithObjectID(idx)
    }, scrollViewDidScroll: function (view) {
        var locDataSource = this._dataSource;
        var countOfItems = locDataSource.numberOfCellsInTableView(this);
        if (0 === countOfItems)return;
        if (this._tableViewDelegate != null && this._tableViewDelegate.scrollViewDidScroll)this._tableViewDelegate.scrollViewDidScroll(this);
        var idx = 0, locViewSize = this._viewSize, locContainer = this.getContainer();
        var offset = this.getContentOffset();
        offset.x *= -1;
        offset.y *= -1;
        var maxIdx = Math.max(countOfItems - 1, 0);
        if (this._vOrdering === cc.TABLEVIEW_FILL_TOPDOWN)offset.y = offset.y + locViewSize.height / locContainer.getScaleY();
        var startIdx = this._indexFromOffset(offset);
        if (startIdx === cc.INVALID_INDEX)startIdx = countOfItems - 1;
        if (this._vOrdering === cc.TABLEVIEW_FILL_TOPDOWN)offset.y -= locViewSize.height / locContainer.getScaleY(); else offset.y += locViewSize.height /
            locContainer.getScaleY();
        offset.x += locViewSize.width / locContainer.getScaleX();
        var endIdx = this._indexFromOffset(offset);
        if (endIdx === cc.INVALID_INDEX)endIdx = countOfItems - 1;
        var cell, locCellsUsed = this._cellsUsed;
        if (locCellsUsed.count() > 0) {
            cell = locCellsUsed.objectAtIndex(0);
            idx = cell.getIdx();
            while (idx < startIdx) {
                this._moveCellOutOfSight(cell);
                if (locCellsUsed.count() > 0) {
                    cell = locCellsUsed.objectAtIndex(0);
                    idx = cell.getIdx()
                } else break
            }
        }
        if (locCellsUsed.count() > 0) {
            cell = locCellsUsed.lastObject();
            idx = cell.getIdx();
            while (idx <= maxIdx && idx > endIdx) {
                this._moveCellOutOfSight(cell);
                if (locCellsUsed.count() > 0) {
                    cell = locCellsUsed.lastObject();
                    idx = cell.getIdx()
                } else break
            }
        }
        var locIndices = this._indices;
        for (var i = startIdx; i <= endIdx; i++) {
            if (locIndices.indexOf(i) != -1)continue;
            this.updateCellAtIndex(i)
        }
    }, scrollViewDidZoom: function (view) {
    }, onTouchEnded: function (touch, event) {
        if (!this.isVisible())return;
        if (this._touchedCell) {
            var bb = this.getBoundingBox();
            var tmpOrigin = cc.p(bb.x, bb.y);
            tmpOrigin = this._parent.convertToWorldSpace(tmpOrigin);
            bb.x = tmpOrigin.x;
            bb.y = tmpOrigin.y;
            var locTableViewDelegate = this._tableViewDelegate;
            if (cc.rectContainsPoint(bb, touch.getLocation()) && locTableViewDelegate != null) {
                if (locTableViewDelegate.tableCellUnhighlight)locTableViewDelegate.tableCellUnhighlight(this, this._touchedCell);
                if (locTableViewDelegate.tableCellTouched)locTableViewDelegate.tableCellTouched(this, this._touchedCell)
            }
            this._touchedCell = null
        }
        cc.ScrollView.prototype.onTouchEnded.call(this, touch, event)
    }, onTouchBegan: function (touch, event) {
        if (!this.isVisible())return false;
        var touchResult = cc.ScrollView.prototype.onTouchBegan.call(this, touch, event);
        if (this._touches.length === 1) {
            var index, point;
            point = this.getContainer().convertTouchToNodeSpace(touch);
            index = this._indexFromOffset(point);
            if (index === cc.INVALID_INDEX)this._touchedCell = null; else this._touchedCell = this.cellAtIndex(index);
            if (this._touchedCell && this._tableViewDelegate != null && this._tableViewDelegate.tableCellHighlight)this._tableViewDelegate.tableCellHighlight(this, this._touchedCell)
        } else if (this._touchedCell) {
            if (this._tableViewDelegate !=
                null && this._tableViewDelegate.tableCellUnhighlight)this._tableViewDelegate.tableCellUnhighlight(this, this._touchedCell);
            this._touchedCell = null
        }
        return touchResult
    }, onTouchMoved: function (touch, event) {
        cc.ScrollView.prototype.onTouchMoved.call(this, touch, event);
        if (this._touchedCell && this.isTouchMoved()) {
            if (this._tableViewDelegate != null && this._tableViewDelegate.tableCellUnhighlight)this._tableViewDelegate.tableCellUnhighlight(this, this._touchedCell);
            this._touchedCell = null
        }
    }, onTouchCancelled: function (touch, event) {
        cc.ScrollView.prototype.onTouchCancelled.call(this, touch, event);
        if (this._touchedCell) {
            if (this._tableViewDelegate != null && this._tableViewDelegate.tableCellUnhighlight)this._tableViewDelegate.tableCellUnhighlight(this, this._touchedCell);
            this._touchedCell = null
        }
    }});
var _p = cc.TableView.prototype;
_p.dataSource;
cc.defineGetterSetter(_p, "dataSource", _p.getDataSource, _p.setDataSource);
_p.delegate;
cc.defineGetterSetter(_p, "delegate", _p.getDelegate, _p.setDelegate);
_p.verticalFillOrder;
cc.defineGetterSetter(_p, "verticalFillOrder", _p.getVerticalFillOrder, _p.setVerticalFillOrder);
_p = null;
cc.TableView.create = function (dataSource, size, container) {
    var table = new cc.TableView;
    table.initWithViewSize(size, container);
    table.setDataSource(dataSource);
    table._updateCellPositions();
    table._updateContentSize();
    return table
};cc.DOM = {};
cc.DOM._addMethods = function (node) {
    for (var funcs in cc.DOM.methods)node[funcs] = cc.DOM.methods[funcs];
    cc.defineGetterSetter(node, "x", node.getPositionX, node.setPositionX);
    cc.defineGetterSetter(node, "y", node.getPositionY, node.setPositionY);
    cc.defineGetterSetter(node, "width", node._getWidth, node._setWidth);
    cc.defineGetterSetter(node, "height", node._getHeight, node._setHeight);
    cc.defineGetterSetter(node, "anchorX", node._getAnchorX, node._setAnchorX);
    cc.defineGetterSetter(node, "anchorY", node._getAnchorY, node._setAnchorY);
    cc.defineGetterSetter(node, "scale", node.getScale, node.setScale);
    cc.defineGetterSetter(node, "scaleX", node.getScaleX, node.setScaleX);
    cc.defineGetterSetter(node, "scaleY", node.getScaleY, node.getScaleY);
    cc.defineGetterSetter(node, "rotation", node.getRotation, node.setRotation);
    cc.defineGetterSetter(node, "skewX", node.getSkewX, node.setSkewX);
    cc.defineGetterSetter(node, "skewY", node.getSkewY, node.setSkewY);
    cc.defineGetterSetter(node, "visible", node.isVisible, node.setVisible);
    cc.defineGetterSetter(node, "parent",
        node.getParent, node.setParent);
    cc.defineGetterSetter(node, "opacity", node.getOpacity, node.setOpacity)
};
cc.DOM.methods = {setPosition: function (x, y) {
    if (y === undefined) {
        this._position.x = x.x;
        this._position.y = x.y
    } else {
        this._position.x = x;
        this._position.y = y
    }
    this.setNodeDirty();
    this.dom.translates(this._position.x, -this._position.y)
}, setPositionY: function (y) {
    this._position.y = y;
    this.setNodeDirty();
    this.dom.translates(this._position.x, -this._position.y)
}, setPositionX: function (x) {
    this._position.x = x;
    this.setNodeDirty();
    this.dom.translates(this._position.x, -this._position.y)
}, setScale: function (scale, scaleY) {
    this._scaleX =
        scale;
    this._scaleY = scaleY || scale;
    this.setNodeDirty();
    this.dom.resize(this._scaleX, this._scaleY)
}, setScaleX: function (x) {
    this._scaleX = x;
    this.setNodeDirty();
    this.dom.resize(this._scaleX, this._scaleY)
}, setScaleY: function (y) {
    this._scaleY = y;
    this.setNodeDirty();
    this.dom.resize(this._scaleX, this._scaleY)
}, setAnchorPoint: function (point, y) {
    var locAnchorPoint = this._anchorPoint;
    if (y === undefined) {
        locAnchorPoint.x = point.x;
        locAnchorPoint.y = point.y
    } else {
        locAnchorPoint.x = point;
        locAnchorPoint.y = y
    }
    var locAPP = this._anchorPointInPoints,
        locSize = this._contentSize;
    locAPP.x = locSize.width * locAnchorPoint.x;
    locAPP.y = locSize.height * locAnchorPoint.y;
    this.dom.style[cc.$.pfx + "TransformOrigin"] = "" + locAPP.x + "px " + -locAPP.y + "px";
    if (this.ignoreAnchor) {
        this.dom.style.marginLeft = 0;
        this.dom.style.marginBottom = 0
    } else {
        this.dom.style.marginLeft = this.isToggler ? 0 : -locAPP.x + "px";
        this.dom.style.marginBottom = -locAPP.y + "px"
    }
    this.setNodeDirty()
}, _setAnchorX: function (x) {
    var locAnchorPoint = this._anchorPoint;
    if (x === locAnchorPoint.x)return;
    locAnchorPoint.x = x;
    var locAPP = this._anchorPointInPoints, locSize = this._contentSize;
    locAPP.x = locSize.width * locAnchorPoint.x;
    this.dom.style[cc.$.pfx + "TransformOrigin"] = "" + locAPP.x + "px " + -locAPP.y + "px";
    if (this.ignoreAnchor) {
        this.dom.style.marginLeft = 0;
        this.dom.style.marginBottom = 0
    } else this.dom.style.marginLeft = this.isToggler ? 0 : -locAPP.x + "px";
    this.setNodeDirty()
}, _setAnchorY: function (y) {
    var locAnchorPoint = this._anchorPoint;
    if (y === locAnchorPoint.y)return;
    locAnchorPoint.y = y;
    var locAPP = this._anchorPointInPoints, locSize = this._contentSize;
    locAPP.y = locSize.height * locAnchorPoint.y;
    this.dom.style[cc.$.pfx + "TransformOrigin"] = "" + locAPP.x + "px " + -locAPP.y + "px";
    if (this.ignoreAnchor) {
        this.dom.style.marginLeft = 0;
        this.dom.style.marginBottom = 0
    } else this.dom.style.marginBottom = -locAPP.y + "px";
    this.setNodeDirty()
}, setContentSize: function (size, height) {
    var locContentSize = this._contentSize;
    if (height === undefined) {
        locContentSize.width = size.width;
        locContentSize.height = size.height
    } else {
        locContentSize.width = size;
        locContentSize.height = height
    }
    var locAPP = this._anchorPointInPoints,
        locAnchorPoint = this._anchorPoint;
    locAPP.x = locContentSize.width * locAnchorPoint.x;
    locAPP.y = locContentSize.height * locAnchorPoint.y;
    this.dom.width = locContentSize.width;
    this.dom.height = locContentSize.height;
    this.setAnchorPoint(this.getAnchorPoint());
    if (this.canvas) {
        this.canvas.width = locContentSize.width;
        this.canvas.height = locContentSize.height
    }
    this.setNodeDirty();
    this.redraw()
}, _setWidth: function (width) {
    var locContentSize = this._contentSize;
    if (width === locContentSize.width)return;
    locContentSize.width = width;
    var locAPP = this._anchorPointInPoints, locAnchorPoint = this._anchorPoint;
    locAPP.x = locContentSize.width * locAnchorPoint.x;
    this.dom.width = locContentSize.width;
    this.anchorX = locAnchorPoint.x;
    if (this.canvas)this.canvas.width = locContentSize.width;
    this.setNodeDirty();
    this.redraw()
}, _setHeight: function (height) {
    var locContentSize = this._contentSize;
    if (height === locContentSize.height)return;
    locContentSize.height = height;
    var locAPP = this._anchorPointInPoints, locAnchorPoint = this._anchorPoint;
    locAPP.y = locContentSize.height *
        locAnchorPoint.y;
    this.dom.height = locContentSize.height;
    this.anchorY = locAnchorPoint.y;
    if (this.canvas)this.canvas.height = locContentSize.height;
    this.setNodeDirty();
    this.redraw()
}, setRotation: function (newRotation) {
    if (this._rotation == newRotation)return;
    this._rotationX = this._rotationY = newRotation;
    this._rotationRadiansX = this._rotationX * (Math.PI / 180);
    this._rotationRadiansY = this._rotationY * (Math.PI / 180);
    this.setNodeDirty();
    this.dom.rotate(newRotation)
}, setSkewX: function (x) {
    this._skewX = x;
    this.setNodeDirty();
    this.dom.setSkew(this._skewX, this._skewY)
}, setSkewY: function (y) {
    this._skewY = y;
    this.setNodeDirty();
    this.dom.setSkew(this._skewX, this._skewY)
}, setVisible: function (x) {
    this._visible = x;
    this.setNodeDirty();
    if (this.dom)this.dom.style.display = x ? "block" : "none"
}, _setLocalZOrder: function (z) {
    this._localZOrder = z;
    this.setNodeDirty();
    if (this.dom)this.dom.zIndex = z
}, setParent: function (p) {
    this._parent = p;
    if (p !== null) {
        p.setAnchorPoint(p.getAnchorPoint());
        this.setNodeDirty();
        cc.DOM.parentDOM(this)
    }
}, resume: function () {
    this.getScheduler().resumeTarget(this);
    this.getActionManager().resumeTarget(this);
    cc.eventManager.resumeTarget(this);
    if (this.dom && !this.dom.parentNode)if (!this.getParent())this.dom.appendTo(cc.container); else cc.DOM.parentDOM(this);
    if (this.dom)this.dom.style.visibility = "visible"
}, pause: function () {
    this.getScheduler().pauseTarget(this);
    this.getActionManager().pauseTarget(this);
    cc.eventManager.pauseTarget(this);
    if (this.dom)this.dom.style.visibility = "hidden"
}, cleanup: function () {
    this.stopAllActions();
    this.unscheduleAllCallbacks();
    this._arrayMakeObjectsPerformSelector(this._children,
        cc.Node.StateCallbackType.cleanup);
    if (this.dom)this.dom.remove()
}, removeFromParentAndCleanup: function () {
    this.dom.remove()
}, setOpacity: function (o) {
    this._opacity = o;
    this.dom.style.opacity = o / 255
}, redraw: function () {
    if (this.isSprite) {
        var tmp = this._children;
        this._children = [];
        cc.Sprite.prototype.visit.call(this, this.ctx);
        this._children = tmp
    } else cc.Sprite.prototype.visit.call(this, this.ctx)
}};
cc.DOM._resetEGLViewDiv = function () {
    var eglViewDiv = cc.$("#EGLViewDiv");
    if (eglViewDiv) {
        var eglViewer = cc.view;
        var designSize = eglViewer.getDesignResolutionSize();
        var viewPortRect = eglViewer.getViewPortRect();
        var screenSize = eglViewer.getFrameSize();
        var pixelRatio = eglViewer.getDevicePixelRatio();
        var designSizeWidth = designSize.width, designSizeHeight = designSize.height;
        if (designSize.width === 0 && designSize.height === 0) {
            designSizeWidth = screenSize.width;
            designSizeHeight = screenSize.height
        }
        var viewPortWidth = viewPortRect.width /
            pixelRatio;
        if (viewPortRect.width === 0 && viewPortRect.height === 0)viewPortWidth = screenSize.width;
        eglViewDiv.style.position = "absolute";
        eglViewDiv.style.width = designSizeWidth + "px";
        eglViewDiv.style.maxHeight = designSizeHeight + "px";
        eglViewDiv.style.margin = 0;
        eglViewDiv.resize(eglViewer.getScaleX() / pixelRatio, eglViewer.getScaleY() / pixelRatio);
        eglViewDiv.style.left = (viewPortWidth - designSizeWidth) / 2 + "px";
        eglViewDiv.style.bottom = "0px"
    }
};
cc.DOM.parentDOM = function (x) {
    var p = x.getParent();
    if (!p || !x.dom)return false;
    if (!p.dom) {
        cc.DOM.placeHolder(p);
        p.setParent = cc.DOM.methods.setParent
    }
    x.dom.appendTo(p.dom);
    p.setAnchorPoint(p.getAnchorPoint());
    if (p.getParent())cc.DOM.parentDOM(p); else if (p.isRunning()) {
        var eglViewDiv = cc.$("#EGLViewDiv");
        if (eglViewDiv)p.dom.appendTo(eglViewDiv); else {
            eglViewDiv = cc.$new("div");
            eglViewDiv.id = "EGLViewDiv";
            var eglViewer = cc.view;
            var designSize = eglViewer.getDesignResolutionSize();
            var viewPortRect = eglViewer.getViewPortRect();
            var screenSize = eglViewer.getFrameSize();
            var pixelRatio = eglViewer.getDevicePixelRatio();
            var designSizeWidth = designSize.width, designSizeHeight = designSize.height;
            if (designSize.width === 0 && designSize.height === 0) {
                designSizeWidth = screenSize.width;
                designSizeHeight = screenSize.height
            }
            var viewPortWidth = viewPortRect.width / pixelRatio;
            if (viewPortRect.width === 0 && viewPortRect.height === 0)viewPortWidth = screenSize.width;
            eglViewDiv.style.position = "absolute";
            eglViewDiv.style.width = designSizeWidth + "px";
            eglViewDiv.style.maxHeight =
                designSizeHeight + "px";
            eglViewDiv.style.margin = 0;
            eglViewDiv.resize(eglViewer.getScaleX() / pixelRatio, eglViewer.getScaleY() / pixelRatio);
            eglViewDiv.style.left = (viewPortWidth - designSizeWidth) / 2 + "px";
            eglViewDiv.style.bottom = "0px";
            p.dom.appendTo(eglViewDiv);
            eglViewDiv.appendTo(cc.container)
        }
    }
    return true
};
cc.DOM.setTransform = function (x) {
    if (x.ctx) {
        x.ctx.translate(x.getAnchorPointInPoints().x, x.getAnchorPointInPoints().y);
        if (x.isSprite) {
            var tmp = x._children;
            x._children = [];
            cc.Sprite.prototype.visit.call(x, x.ctx);
            x._children = tmp
        } else cc.Sprite.prototype.visit.call(x, x.ctx)
    }
    if (x.dom) {
        x.dom.position.x = x.getPositionX();
        x.dom.position.y = -x.getPositionY();
        x.dom.rotation = x.getRotation();
        x.dom.scale = {x: x.getScaleX(), y: x.getScaleY()};
        x.dom.skew = {x: x.getSkewX(), y: x.getSkewY()};
        if (x.setAnchorPoint)x.setAnchorPoint(x.getAnchorPoint());
        x.dom.transforms()
    }
};
cc.DOM.forSprite = function (x) {
    x.dom = cc.$new("div");
    x.canvas = cc.$new("canvas");
    var locContentSize = x.getContentSize();
    x.canvas.width = locContentSize.width;
    x.canvas.height = locContentSize.height;
    x.dom.style.position = "absolute";
    x.dom.style.bottom = 0;
    x.ctx = x.canvas.getContext("2d");
    x.dom.appendChild(x.canvas);
    if (x.getParent())cc.DOM.parentDOM(x);
    x.isSprite = true
};
cc.DOM.placeHolder = function (x) {
    x.dom = cc.$new("div");
    x.placeholder = true;
    x.dom.style.position = "absolute";
    x.dom.style.bottom = 0;
    x.dom.style.width = (x.getContentSize().width || cc.director.getWinSize().width) + "px";
    x.dom.style.maxHeight = (x.getContentSize().height || cc.director.getWinSize().height) + "px";
    x.dom.style.margin = 0;
    cc.DOM.setTransform(x);
    x.dom.transforms();
    cc.DOM._addMethods(x)
};
cc.DOM.convert = function (nodeObject) {
    if (arguments.length > 1) {
        cc.DOM.convert(arguments);
        return
    } else if (arguments.length == 1 && !arguments[0].length) {
        cc.DOM.convert([arguments[0]]);
        return
    }
    var args = arguments[0];
    for (var i = 0; i < args.length; i++) {
        if (args[i]instanceof cc.Sprite) {
            if (!args[i].dom)cc.DOM.forSprite(args[i])
        } else cc.log("DOM converter only supports sprite and menuitems yet");
        cc.DOM._addMethods(args[i]);
        args[i].visit = function () {
        };
        args[i].transform = function () {
        };
        cc.DOM.setTransform(args[i]);
        args[i].setVisible(args[i].isVisible())
    }
};
cc.KEYBOARD_RETURNTYPE_DEFAULT = 0;
cc.KEYBOARD_RETURNTYPE_DONE = 1;
cc.KEYBOARD_RETURNTYPE_SEND = 2;
cc.KEYBOARD_RETURNTYPE_SEARCH = 3;
cc.KEYBOARD_RETURNTYPE_GO = 4;
cc.EDITBOX_INPUT_MODE_ANY = 0;
cc.EDITBOX_INPUT_MODE_EMAILADDR = 1;
cc.EDITBOX_INPUT_MODE_NUMERIC = 2;
cc.EDITBOX_INPUT_MODE_PHONENUMBER = 3;
cc.EDITBOX_INPUT_MODE_URL = 4;
cc.EDITBOX_INPUT_MODE_DECIMAL = 5;
cc.EDITBOX_INPUT_MODE_SINGLELINE = 6;
cc.EDITBOX_INPUT_FLAG_PASSWORD = 0;
cc.EDITBOX_INPUT_FLAG_SENSITIVE = 1;
cc.EDITBOX_INPUT_FLAG_INITIAL_CAPS_WORD = 2;
cc.EDITBOX_INPUT_FLAG_INITIAL_CAPS_SENTENCE = 3;
cc.EDITBOX_INPUT_FLAG_INITIAL_CAPS_ALL_CHARACTERS = 4;
cc.EditBoxDelegate = cc.Class.extend({editBoxEditingDidBegin: function (sender) {
}, editBoxEditingDidEnd: function (sender) {
}, editBoxTextChanged: function (sender, text) {
}, editBoxReturn: function (sender) {
}});
cc.EditBox = cc.ControlButton.extend({_domInputSprite: null, _delegate: null, _editBoxInputMode: cc.EDITBOX_INPUT_MODE_ANY, _editBoxInputFlag: cc.EDITBOX_INPUT_FLAG_SENSITIVE, _keyboardReturnType: cc.KEYBOARD_RETURNTYPE_DEFAULT, _text: "", _placeholderText: "", _textColor: null, _placeholderColor: null, _maxLength: 50, _adjustHeight: 18, _edTxt: null, _edFontSize: 14, _edFontName: "Arial", _placeholderFontName: "", _placeholderFontSize: 14, _tooltip: false, _className: "EditBox", ctor: function (boxSize) {
    cc.ControlButton.prototype.ctor.call(this);
    this._textColor = cc.color.WHITE;
    this._placeholderColor = cc.color.GRAY;
    this.setContentSize(boxSize);
    var tmpDOMSprite = this._domInputSprite = new cc.Sprite;
    tmpDOMSprite.draw = function () {
    };
    this.addChild(tmpDOMSprite);
    var selfPointer = this;
    var tmpEdTxt = this._edTxt = cc.newElement("input");
    tmpEdTxt.type = "text";
    tmpEdTxt.style.fontSize = this._edFontSize + "px";
    tmpEdTxt.style.color = "#000000";
    tmpEdTxt.style.border = 0;
    tmpEdTxt.style.background = "transparent";
    tmpEdTxt.style.width = "100%";
    tmpEdTxt.style.height = "100%";
    tmpEdTxt.style.active =
        0;
    tmpEdTxt.style.outline = "medium";
    var onCanvasClick = function () {
        tmpEdTxt.blur()
    };
    cc._addEventListener(tmpEdTxt, "input", function () {
        if (selfPointer._delegate && selfPointer._delegate.editBoxTextChanged)selfPointer._delegate.editBoxTextChanged(selfPointer, this.value)
    });
    cc._addEventListener(tmpEdTxt, "keypress", function (e) {
        if (e.keyCode === cc.KEY.enter) {
            e.stopPropagation();
            e.preventDefault();
            cc._canvas.focus()
        }
    });
    cc._addEventListener(tmpEdTxt, "focus", function () {
        if (this.value == selfPointer._placeholderText) {
            this.value =
                "";
            this.style.fontSize = selfPointer._edFontSize + "px";
            this.style.color = cc.colorToHex(selfPointer._textColor)
        }
        if (selfPointer._delegate && selfPointer._delegate.editBoxEditingDidBegin)selfPointer._delegate.editBoxEditingDidBegin(selfPointer);
        cc._addEventListener(cc._canvas, "click", onCanvasClick)
    });
    cc._addEventListener(tmpEdTxt, "blur", function () {
        if (this.value == "") {
            this.value = selfPointer._placeholderText;
            this.style.fontSize = selfPointer._placeholderFontSize + "px";
            this.style.color = cc.colorToHex(selfPointer._placeholderColor)
        }
        if (selfPointer._delegate &&
            selfPointer._delegate.editBoxEditingDidEnd)selfPointer._delegate.editBoxEditingDidEnd(selfPointer);
        if (selfPointer._delegate && selfPointer._delegate.editBoxReturn)selfPointer._delegate.editBoxReturn(selfPointer);
        cc._canvas.removeEventListener("click", onCanvasClick)
    });
    cc.DOM.convert(tmpDOMSprite);
    tmpDOMSprite.dom.appendChild(tmpEdTxt);
    tmpDOMSprite.dom.showTooltipDiv = false;
    tmpDOMSprite.dom.style.width = boxSize.width - 6 + "px";
    tmpDOMSprite.dom.style.height = boxSize.height - 6 + "px";
    tmpDOMSprite.canvas.remove()
},
    setFont: function (fontName, fontSize) {
        this._edFontSize = fontSize;
        this._edFontName = fontName;
        this._setFontToEditBox()
    }, _setFont: function (fontStyle) {
        var res = cc.LabelTTF._fontStyleRE.exec(fontStyle);
        if (res) {
            this._edFontSize = parseInt(res[1]);
            this._edFontName = res[2];
            this._setFontToEditBox()
        }
    }, setFontName: function (fontName) {
        this._edFontName = fontName;
        this._setFontToEditBox()
    }, setFontSize: function (fontSize) {
        this._edFontSize = fontSize;
        this._setFontToEditBox()
    }, _setFontToEditBox: function () {
        if (this._edTxt.value !=
            this._placeholderText) {
            this._edTxt.style.fontFamily = this._edFontName;
            this._edTxt.style.fontSize = this._edFontSize + "px"
        }
    }, setText: function (text) {
        cc.log("Please use the setString");
        if (text != null)if (text == "") {
            this._edTxt.value = this._placeholderText;
            this._edTxt.style.color = cc.colorToHex(this._placeholderColor)
        } else {
            this._edTxt.value = text;
            this._edTxt.style.color = cc.colorToHex(this._textColor)
        }
    }, setString: function (text) {
        if (text != null)if (text == "") {
            this._edTxt.value = this._placeholderText;
            this._edTxt.style.color =
                cc.colorToHex(this._placeholderColor)
        } else {
            this._edTxt.value = text;
            this._edTxt.style.color = cc.colorToHex(this._textColor)
        }
    }, setFontColor: function (color) {
        this._textColor = color;
        if (this._edTxt.value != this._placeholderText)this._edTxt.style.color = cc.colorToHex(color)
    }, setMaxLength: function (maxLength) {
        if (!isNaN(maxLength) && maxLength > 0) {
            this._maxLength = maxLength;
            this._edTxt.maxLength = maxLength
        }
    }, getMaxLength: function () {
        return this._maxLength
    }, setPlaceHolder: function (text) {
        if (text != null) {
            var oldPlaceholderText =
                this._placeholderText;
            this._placeholderText = text;
            if (this._edTxt.value == oldPlaceholderText) {
                this._edTxt.value = text;
                this._edTxt.style.color = cc.colorToHex(this._placeholderColor);
                this._setPlaceholderFontToEditText()
            }
        }
    }, setPlaceholderFont: function (fontName, fontSize) {
        this._placeholderFontName = fontName;
        this._placeholderFontSize = fontSize;
        this._setPlaceholderFontToEditText()
    }, _setPlaceholderFont: function (fontStyle) {
        var res = cc.LabelTTF._fontStyleRE.exec(fontStyle);
        if (res) {
            this._placeholderFontName = res[2];
            this._placeholderFontSize = parseInt(res[1]);
            this._setPlaceholderFontToEditText()
        }
    }, setPlaceholderFontName: function (fontName) {
        this._placeholderFontName = fontName;
        this._setPlaceholderFontToEditText()
    }, setPlaceholderFontSize: function (fontSize) {
        this._placeholderFontSize = fontSize;
        this._setPlaceholderFontToEditText()
    }, _setPlaceholderFontToEditText: function () {
        if (this._edTxt.value == this._placeholderText) {
            this._edTxt.style.fontFamily = this._placeholderFontName;
            this._edTxt.style.fontSize = this._placeholderFontSize +
                "px"
        }
    }, setPlaceholderFontColor: function (color) {
        this._placeholderColor = color;
        if (this._edTxt.value == this._placeholderText)this._edTxt.style.color = cc.colorToHex(color)
    }, setInputFlag: function (inputFlag) {
        this._editBoxInputFlag = inputFlag;
        if (inputFlag == cc.EDITBOX_INPUT_FLAG_PASSWORD)this._edTxt.type = "password"; else this._edTxt.type = "text"
    }, getText: function () {
        cc.log("Please use the getString");
        return this._edTxt.value
    }, getString: function () {
        return this._edTxt.value
    }, initWithSizeAndBackgroundSprite: function (size, normal9SpriteBg) {
        if (this.initWithBackgroundSprite(normal9SpriteBg)) {
            this._domInputSprite.x = 3;
            this._domInputSprite.y = 3;
            this.setZoomOnTouchDown(false);
            this.setPreferredSize(size);
            this.x = 0;
            this.y = 0;
            this._addTargetWithActionForControlEvent(this, this.touchDownAction, cc.CONTROL_EVENT_TOUCH_UP_INSIDE);
            return true
        }
        return false
    }, setDelegate: function (delegate) {
        this._delegate = delegate
    }, getPlaceHolder: function () {
        return this._placeholderText
    }, setInputMode: function (inputMode) {
        this._editBoxInputMode = inputMode
    },
    setReturnType: function (returnType) {
        this._keyboardReturnType = returnType
    }, keyboardWillShow: function (info) {
        var rectTracked = cc.EditBox.getRect(this);
        rectTracked.y -= 4;
        if (!rectTracked.intersectsRect(info.end)) {
            cc.log("needn't to adjust view layout.");
            return
        }
        this._adjustHeight = info.end.getMaxY() - rectTracked.getMinY()
    }, keyboardDidShow: function (info) {
    }, keyboardWillHide: function (info) {
    }, keyboardDidHide: function (info) {
    }, touchDownAction: function (sender, controlEvent) {
    }, initWithBackgroundColor: function (size, bgColor) {
        this._edWidth =
            size.width;
        this.dom.style.width = this._edWidth.toString() + "px";
        this._edHeight = size.height;
        this.dom.style.height = this._edHeight.toString() + "px";
        this.dom.style.backgroundColor = cc.colorToHex(bgColor)
    }});
var _p = cc.EditBox.prototype;
_p.font;
cc.defineGetterSetter(_p, "font", null, _p._setFont);
_p.fontName;
cc.defineGetterSetter(_p, "fontName", null, _p.setFontName);
_p.fontSize;
cc.defineGetterSetter(_p, "fontSize", null, _p.setFontSize);
_p.fontColor;
cc.defineGetterSetter(_p, "fontColor", null, _p.setFontColor);
_p.string;
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
_p.maxLength;
cc.defineGetterSetter(_p, "maxLength", _p.getMaxLength, _p.setMaxLength);
_p.placeHolder;
cc.defineGetterSetter(_p, "placeHolder", _p.getPlaceHolder, _p.setPlaceHolder);
_p.placeHolderFont;
cc.defineGetterSetter(_p, "placeHolderFont", null, _p._setPlaceholderFont);
_p.placeHolderFontName;
cc.defineGetterSetter(_p, "placeHolderFontName", null, _p.setPlaceholderFontName);
_p.placeHolderFontSize;
cc.defineGetterSetter(_p, "placeHolderFontSize", null, _p.setPlaceholderFontSize);
_p.placeHolderFontColor;
cc.defineGetterSetter(_p, "placeHolderFontColor", null, _p.setPlaceholderFontColor);
_p.inputFlag;
cc.defineGetterSetter(_p, "inputFlag", null, _p.setInputFlag);
_p.delegate;
cc.defineGetterSetter(_p, "delegate", null, _p.setDelegate);
_p.inputMode;
cc.defineGetterSetter(_p, "inputMode", null, _p.setInputMode);
_p.returnType;
cc.defineGetterSetter(_p, "returnType", null, _p.setReturnType);
_p = null;
cc.EditBox.getRect = function (node) {
    var contentSize = node.getContentSize();
    var rect = cc.rect(0, 0, contentSize.width, contentSize.height);
    return cc.RectApplyAffineTransform(rect, node.nodeToWorldTransform())
};
cc.EditBox.create = function (size, normal9SpriteBg, press9SpriteBg, disabled9SpriteBg) {
    var edbox = new cc.EditBox(size);
    if (edbox.initWithSizeAndBackgroundSprite(size, normal9SpriteBg)) {
        if (press9SpriteBg)edbox.setBackgroundSpriteForState(press9SpriteBg, cc.CONTROL_STATE_HIGHLIGHTED);
        if (disabled9SpriteBg)edbox.setBackgroundSpriteForState(disabled9SpriteBg, cc.CONTROL_STATE_DISABLED)
    }
    return edbox
};cc.ProtectedNode = cc.NodeRGBA.extend({_protectedChildren: null, _reorderProtectedChildDirty: !1, _insertProtectedChild: function (a, b) {
    this._reorderProtectedChildDirty = !0;
    this._protectedChildren.push(a);
    a._setLocalZOrder(b)
}, ctor: function () {
    cc.NodeRGBA.prototype.ctor.call(this);
    this._protectedChildren = []
}, addProtectedChild: function (a, b, c) {
    cc.assert(null != a, "child must be non-nil");
    cc.assert(!a.parent, "child already added. It can't be added again");
    b = b || a.getLocalZOrder();
    c && a.setTag(c);
    this._insertProtectedChild(a,
        b);
    a.setParent(this);
    a.setOrderOfArrival(cc.s_globalOrderOfArrival);
    if (this._running && (a.onEnter(), this._isTransitionFinished))a.onEnterTransitionDidFinish();
    this._cascadeColorEnabled && this._enableCascadeColor();
    this._cascadeOpacityEnabled && this._enableCascadeOpacity()
}, getProtectedChildByTag: function (a) {
    cc.assert(a != cc.NODE_TAG_INVALID, "Invalid tag");
    for (var b = this._protectedChildren, c = 0, d = b.length; c < d; c++)if (b.getTag() == a)return b[c];
    return null
}, removeProtectedChild: function (a, b) {
    null == b && (b = !0);
    var c = this._protectedChildren;
    if (0 !== c.length) {
        var d = c.indexOf(a);
        -1 < d && (this._running && (a.onExitTransitionDidStart(), a.onExit()), b && a.cleanup(), a.setParent(null), c.splice(d, 1))
    }
}, removeProtectedChildByTag: function (a, b) {
    cc.assert(a != cc.NODE_TAG_INVALID, "Invalid tag");
    null == b && (b = !0);
    var c = this.getProtectedChildByTag(a);
    null == c ? cc.log("cocos2d: removeChildByTag(tag \x3d %d): child not found!", a) : this.removeProtectedChild(c, b)
}, removeAllProtectedChildren: function () {
    this.removeAllProtectedChildrenWithCleanup(!0)
},
    removeAllProtectedChildrenWithCleanup: function (a) {
        null == a && (a = !0);
        for (var b = this._protectedChildren, c = 0, d = b.length; c < d; c++) {
            var e = b[c];
            this._running && (e.onExitTransitionDidStart(), e.onExit());
            a && e.cleanup();
            e.setParent(null)
        }
        b.length = 0
    }, reorderProtectedChild: function (a, b) {
        cc.assert(null != a, "Child must be non-nil");
        this._reorderProtectedChildDirty = !0;
        a.setOrderOfArrival(cc.s_globalOrderOfArrival++);
        a._setLocalZOrder(b)
    }, sortAllProtectedChildren: function () {
        if (this._reorderProtectedChildDirty) {
            var a =
                this._protectedChildren, b = a.length, c, d, e;
            for (c = 1; c < b; c++) {
                e = a[c];
                for (d = c - 1; 0 <= d;) {
                    if (e._localZOrder < a[d]._localZOrder)a[d + 1] = a[d]; else if (e._localZOrder === a[d]._localZOrder && e.arrivalOrder < a[d].arrivalOrder)a[d + 1] = a[d]; else break;
                    d--
                }
                a[d + 1] = e
            }
            this._reorderProtectedChildDirty = !1
        }
    }, visit: null, _visitForCanvas: function (a) {
        if (this._visible) {
            a = a || cc._renderContext;
            var b, c, d = this._children, e, f = this._protectedChildren, g = this._children.length, h = f.length;
            a.save();
            this.transform(a);
            this.sortAllChildren();
            this.sortAllProtectedChildren();
            for (b = 0; b < g; b++)if (e = d[b], 0 > e._localZOrder)e.visit(a); else break;
            for (c = 0; c < h; c++)if (e = f[c], 0 > e._localZOrder)e.visit(a); else break;
            for (this.draw(a); b < g; b++)d[b] && d[b].visit(a);
            for (; c < h; c++)f[b] && f[b].visit(a);
            this._cacheDirty = !1;
            this.arrivalOrder = 0;
            a.restore()
        }
    }, _visitForWebGL: function () {
        if (this._visible) {
            var a = cc._renderContext, b, c = cc.current_stack, d;
            c.stack.push(c.top);
            cc.kmMat4Assign(this._stackMatrix, c.top);
            c.top = this._stackMatrix;
            var e = this.grid;
            e && e._active && e.beforeDraw();
            this.transform();
            var f =
                this._children, g = this._protectedChildren, h = f.length, k = g.length;
            this.sortAllChildren();
            this.sortAllProtectedChildren();
            for (b = 0; b < h; b++)if (f[b] && 0 > f[b]._localZOrder)f[b].visit(); else break;
            for (d = 0; d < k; d++)if (g[d] && 0 > g[d]._localZOrder)g[d].visit(); else break;
            for (this.draw(a); b < h; b++)f[b] && f[b].visit();
            for (; d < k; d++)g[d] && g[d].visit();
            this.arrivalOrder = 0;
            e && e._active && e.afterDraw(this);
            c.top = c.stack.pop()
        }
    }, cleanup: function () {
        cc.Node.prototype.cleanup.call(this);
        for (var a = this._protectedChildren, b = 0, c =
            a.length; b < c; b++)a[b].cleanup()
    }, onEnter: function () {
        cc.Node.prototype.onEnter.call(this);
        for (var a = this._protectedChildren, b = 0, c = a.length; b < c; b++)a[b].onEnter()
    }, onEnterTransitionDidFinish: function () {
        cc.Node.prototype.onEnterTransitionDidFinish.call(this);
        for (var a = this._protectedChildren, b = 0, c = a.length; b < c; b++)a[b].onEnterTransitionDidFinish()
    }, onExit: function () {
        cc.Node.prototype.onExit.call(this);
        for (var a = this._protectedChildren, b = 0, c = a.length; b < c; b++)a[b].onExit()
    }, onExitTransitionDidStart: function () {
        cc.Node.prototype.onExitTransitionDidStart.call(this);
        for (var a = this._protectedChildren, b = 0, c = a.length; b < c; b++)a[b].onExitTransitionDidStart()
    }, updateDisplayedOpacity: function (a) {
        this._displayedOpacity = this._realOpacity * a / 255;
        this._updateColor();
        if (this._cascadeOpacityEnabled) {
            var b, c = this._children, d = this._displayedOpacity;
            a = 0;
            for (b = c.length; a < b; a++)c[a].updateDisplayedOpacity && c[a].updateDisplayedOpacity(d);
            c = this._protectedChildren;
            a = 0;
            for (b = c.length; a < b; a++)c[a].updateDisplayedOpacity && c[a].updateDisplayedOpacity(d)
        }
    }, updateDisplayedColor: function (a) {
        var b =
            this._displayedColor, c = this._realColor;
        b.r = c.r * a.r / 255;
        b.g = c.g * a.g / 255;
        b.b = c.b * a.b / 255;
        this._updateColor();
        if (this._cascadeColorEnabled) {
            var d = this._children;
            a = 0;
            for (c = d.length; a < c; a++)d[a].updateDisplayedColor && d[a].updateDisplayedColor(b);
            d = this._protectedChildren;
            a = 0;
            for (c = d.length; a < c; a++)d[a].updateDisplayedColor && d[a].updateDisplayedColor(b)
        }
    }, disableCascadeColor: function () {
        var a = cc.color.WHITE, b, c, d = this._children;
        b = 0;
        for (c = d.length; b < c; b++)d[b].updateDisplayedColor(a);
        d = this._protectedChildren;
        b = 0;
        for (c = d.length; b < c; b++)d[b].updateDisplayedColor(a)
    }});
cc.ProtectedNode.prototype.visit = cc._renderType === cc._RENDER_TYPE_CANVAS ? cc.ProtectedNode.prototype._visitForCanvas : cc.ProtectedNode.prototype._visitForWebGL;
cc.ProtectedNode.create = function () {
    return new cc.ProtectedNode
};
var ccui = ccui || {};
ccui.Class = ccui.Class || cc.Class;
ccui.Class.extend = ccui.Class.extend || cc.Class.extend;
ccui.Node = ccui.Node || cc.Node;
ccui.Node.extend = ccui.Node.extend || cc.Node.extend;
ccui.NodeRGBA = ccui.NodeRGBA || cc.NodeRGBA;
ccui.NodeRGBA.extend = ccui.NodeRGBA.extend || cc.NodeRGBA.extend;
ccui.ProtectedNode = ccui.ProtectedNode || cc.ProtectedNode;
ccui.ProtectedNode.extend = ccui.ProtectedNode.extend || cc.ProtectedNode.extend;
ccui.cocosGUIVersion = "CocosGUI v1.0.0.0";
ccui.Widget = cc.ProtectedNode.extend({_enabled: !0, _bright: !0, _touchEnabled: !1, _brightStyle: null, _updateEnabled: !1, _touchBeganPosition: null, _touchMovePosition: null, _touchEndPosition: null, _touchEventListener: null, _touchEventSelector: null, _name: "default", _widgetType: null, _actionTag: 0, _size: cc.size(0, 0), _customSize: null, _layoutParameterDictionary: null, _layoutParameterType: 0, _focused: !1, _focusEnabled: !0, _ignoreSize: !1, _affectByClipping: !1, _sizeType: null, _sizePercent: null, positionType: null, _positionPercent: null,
    _reorderWidgetChildDirty: !1, _hitted: !1, _nodes: null, _touchListener: null, _color: null, _className: "Widget", _flippedX: !1, _flippedY: !1, _opacity: 255, _highlight: !1, _touchEventCallback: null, ctor: function () {
        cc.ProtectedNode.prototype.ctor.call(this);
        this._brightStyle = ccui.Widget.BRIGHT_STYLE_NONE;
        this._touchBeganPosition = cc.p(0, 0);
        this._touchMovePosition = cc.p(0, 0);
        this._touchEndPosition = cc.p(0, 0);
        this._widgetType = ccui.Widget.TYPE_WIDGET;
        this._size = cc.size(0, 0);
        this._customSize = cc.size(0, 0);
        this._layoutParameterDictionary =
        {};
        this._sizeType = ccui.Widget.SIZE_ABSOLUTE;
        this._sizePercent = cc.p(0, 0);
        this.positionType = ccui.Widget.POSITION_ABSOLUTE;
        this._positionPercent = cc.p(0, 0);
        this._nodes = [];
        this._color = cc.color(255, 255, 255, 255);
        this._layoutParameterType = ccui.LayoutParameter.NONE;
        this.init()
    }, init: function () {
        return cc.ProtectedNode.prototype.init.call(this) ? (this._layoutParameterDictionary = {}, this.initRenderer(), this.setBright(!0), this.onFocusChanged = this.onFocusChange.bind(this), this.onNextFocusedWidget = null, this.setAnchorPoint(cc.p(0.5,
            0.5)), this.ignoreContentAdaptWithSize(!0), this.setCascadeColorEnabled(!0), this.setCascadeOpacityEnabled(!0), !0) : !1
    }, onEnter: function () {
        this.updateSizeAndPosition();
        cc.ProtectedNode.prototype.onEnter.call(this)
    }, onExit: function () {
        this.unscheduleUpdate();
        cc.ProtectedNode.prototype.onExit.call(this)
    }, visit: function (a) {
        this._visible && (this.adaptRenderers(), cc.ProtectedNode.prototype.visit.call(this, a))
    }, getWidgetParent: function () {
        var a = this.getParent();
        return a instanceof ccui.Widget ? a : null
    }, _updateContentSizeWithTextureSize: function (a) {
        var b =
            this._size;
        this._ignoreSize ? (b.width = a.width, b.height = a.height) : (b.width = this._customSize.width, b.height = this._customSize.height);
        this.onSizeChanged()
    }, _isAncestorsEnabled: function () {
        var a = this._getAncensterWidget(this);
        return null == a ? !0 : a && !a.isEnabled() ? !1 : a._isAncestorsEnabled()
    }, _getAncensterWidget: function (a) {
        if (null == a)return null;
        a = a.getParent();
        return null == a ? null : a instanceof ccui.Widget ? a : this._getAncensterWidget(a.getParent())
    }, _isAncestorsVisible: function (a) {
        return null == a ? !0 : (a = a.getParent()) && !a.isVisible() ? !1 : this._isAncestorsVisible(a)
    }, _cleanupWidget: function () {
        this._eventDispatcher.removeEventListener(this._touchListener);
        this._focusedWidget == this && (this._focusedWidget = null)
    }, setEnabled: function (a) {
        this._enabled = a
    }, initRenderer: function () {
    }, addNode: function (a, b, c) {
        a instanceof ccui.Widget ? cc.log("Please use addChild to add a Widget.") : (cc.Node.prototype.addChild.call(this, a, b, c), this._nodes.push(a))
    }, getNodeByTag: function (a) {
        for (var b = this._nodes, c = 0; c < b.length; c++) {
            var d = b[c];
            if (d &&
                d.getTag() == a)return d
        }
        return null
    }, getNodes: function () {
        return this._nodes
    }, removeNode: function (a, b) {
        cc.Node.prototype.removeChild.call(this, a);
        cc.arrayRemoveObject(this._nodes, a)
    }, removeNodeByTag: function (a, b) {
        var c = this.getNodeByTag(a);
        c ? this.removeNode(c) : cc.log("cocos2d: removeNodeByTag(tag \x3d %d): child not found!", a)
    }, removeAllNodes: function () {
        for (var a = 0; a < this._nodes.length; a++)cc.Node.prototype.removeChild.call(this, this._nodes[a]);
        this._nodes.length = 0
    }, setSize: function (a) {
        var b = this._customSize.width =
            a.width;
        a = this._customSize.height = a.height;
        this._ignoreSize && (b = this.width, a = this.height);
        this._size.width = b;
        this._size.height = a;
        this._running && ((a = this.getWidgetParent()) ? (b = a.width, a = a.height) : (b = this._parent.width, a = this._parent.height), this._sizePercent.x = 0 < b ? this._customSize.width / b : 0, this._sizePercent.y = 0 < a ? this._customSize.height / a : 0);
        this.onSizeChanged()
    }, _setWidth: function (a) {
        a = this._customSize.width = a;
        this._ignoreSize && (a = this.width);
        this._size.width = a;
        this._running && (a = (a = this.getWidgetParent()) ?
            a.width : this._parent.width, this._sizePercent.x = 0 < a ? this._customSize.width / a : 0);
        this.onSizeChanged()
    }, _setHeight: function (a) {
        a = this._customSize.height = a;
        this._ignoreSize && (a = this.height);
        this._size.height = a;
        this._running && (a = (a = this.getWidgetParent()) ? a.height : this._parent.height, this._sizePercent.y = 0 < a ? this._customSize.height / a : 0);
        this.onSizeChanged()
    }, setSizePercent: function (a) {
        this._sizePercent.x = a.x;
        this._sizePercent.y = a.y;
        var b = this._customSize.width, c = this._customSize.height;
        this._running && ((c =
            this.getWidgetParent()) ? (b = c.width * a.x, c = c.height * a.y) : (b = this._parent.width * a.x, c = this._parent.height * a.y));
        this._ignoreSize || (this._size.width = b, this._size.height = c);
        this._customSize.width = b;
        this._customSize.height = c;
        this.onSizeChanged()
    }, _setWidthPercent: function (a) {
        this._sizePercent.x = a;
        var b = this._customSize.width;
        this._running && (b = this.getWidgetParent(), b = (b ? b.width : this._parent.width) * a);
        this._ignoreSize || (this._size.width = b);
        this._customSize.width = b;
        this.onSizeChanged()
    }, _setHeightPercent: function (a) {
        this._sizePercent.y =
            a;
        var b = this._customSize.height;
        this._running && (b = this.getWidgetParent(), b = (b ? b.height : this._parent.height) * a);
        this._ignoreSize || (this._size.height = b);
        this._customSize.height = b;
        this.onSizeChanged()
    }, updateSizeAndPosition: function (a) {
        a || (a = (a = this.getWidgetParent()) ? a.getLayoutSize() : this._parent.getContentSize());
        var b;
        switch (this._sizeType) {
            case ccui.Widget.SIZE_ABSOLUTE:
                b = this._ignoreSize ? this.getContentSize() : this._customSize;
                this._size.width = b.width;
                this._size.height = b.height;
                var c = b = 0;
                0 < a.width &&
                (b = this._customSize.width / a.width);
                0 < a.height && (c = this._customSize.height / a.height);
                this._sizePercent.x = b;
                this._sizePercent.y = c;
                break;
            case ccui.Widget.SIZE_PERCENT:
                c = cc.size(a.width * this._sizePercent.x, a.height * this._sizePercent.y), b = this._ignoreSize ? this.getVirtualRendererSize() : c, this._size.width = b.width, this._size.height = b.height, this._customSize.width = c.width, this._customSize.height = c.height
        }
        this.onSizeChanged();
        b = this.getPosition();
        switch (this.positionType) {
            case ccui.Widget.POSITION_ABSOLUTE:
                0 >=
                a.width || 0 >= a.height ? (this._positionPercent.x = 0, this._positionPercent.y = 0) : (this._positionPercent.x = b.x / a.width, this._positionPercent.y = b.y / a.height);
                break;
            case ccui.Widget.POSITION_PERCENT:
                b = cc.p(a.width * this._positionPercent.x, a.height * this._positionPercent.y)
        }
        this.setPosition(b)
    }, setSizeType: function (a) {
        this._sizeType = a
    }, getSizeType: function () {
        return this._sizeType
    }, ignoreContentAdaptWithSize: function (a) {
        this._ignoreSize != a && (a = (this._ignoreSize = a) ? this.getContentSize() : this._customSize, this._size.width =
            a.width, this._size.height = a.height, this.onSizeChanged())
    }, isIgnoreContentAdaptWithSize: function () {
        return this._ignoreSize
    }, getSize: function () {
        return cc.size(this._size)
    }, getCustomSize: function () {
        return cc.size(this._customSize)
    }, getLayoutSize: function () {
        return cc.size(this._size)
    }, getSizePercent: function () {
        return cc.p(this._sizePercent)
    }, _getWidthPercent: function () {
        return this._sizePercent.x
    }, _getHeightPercent: function () {
        return this._sizePercent.y
    }, getWorldPosition: function () {
        return this.convertToWorldSpace(cc.p(this._anchorPoint.x *
            this._contentSize.width, this._anchorPoint.y * this._contentSize.height))
    }, getVirtualRenderer: function () {
        return this
    }, getVirtualRendererSize: function () {
        return cc.size(this._contentSize)
    }, onSizeChanged: function () {
        this.setContentSize(this._size);
        for (var a = this.getChildren(), b = 0, c = a.length; b < c; b++) {
            var d = a[b];
            d instanceof ccui.Widget && d.updateSizeAndPosition()
        }
    }, getContentSize: function () {
        return this._size
    }, _getWidth: function () {
        return this._size.width
    }, _getHeight: function () {
        return this._size.height
    }, setTouchEnabled: function (a) {
        this._touchEnabled !==
        a && ((this._touchEnabled = a) ? (this._touchListener = cc.EventListener.create({event: cc.EventListener.TOUCH_ONE_BY_ONE, swallowTouches: !0, onTouchBegan: this.onTouchBegan.bind(this), onTouchMoved: this.onTouchMoved.bind(this), onTouchEnded: this.onTouchEnded.bind(this)}), cc.eventManager.addListener(this._touchListener, this)) : cc.eventManager.removeListener(this._touchListener))
    }, isTouchEnabled: function () {
        return this._touchEnabled
    }, isHighlighted: function () {
        return this._highlight
    }, setHighlighted: function (a) {
        if (a !=
            this._highlight)if (this._highlight = a, this._bright)this._highlight ? this.setBrightStyle(ccui.Widget.BRIGHT_STYLE_HIGH_LIGHT) : this.setBrightStyle(ccui.Widget.BRIGHT_STYLE_NORMAL); else this.onPressStateChangedToDisabled()
    }, setUpdateEnabled: function (a) {
        this._updateEnabled != a && ((this._updateEnabled = a) ? this.scheduleUpdate() : this.unscheduleUpdate())
    }, isUpdateEnabled: function () {
        return this._updateEnabled
    }, isFocused: function () {
        return this._focused
    }, setFocused: function (a) {
        if (this._focused = a)this._focusedWidget =
            this
    }, isFocusEnabled: function () {
        return this._focusEnabled
    }, setFocusEnabled: function (a) {
        this._focused = a
    }, findNextFocusedWidget: function (a, b) {
        if (null == this.onNextFocusedWidget || null == this.onNextFocusedWidget(a)) {
            var c = b instanceof ccui.Layout;
            if (this.isFocused() || c) {
                var d = this.getParent();
                return null == d ? c ? b.findNextFocusedWidget(a, b) : b : d.findNextFocusedWidget(a, b)
            }
            return b
        }
        c = this.onNextFocusedWidget(a);
        this.dispatchFocusEvent(this, c);
        return c
    }, requestFocus: function () {
        this != this._focusedWidget && this.dispatchFocusEvent(this._focusedWidget,
            this)
    }, getCurrentFocusedWidget: function () {
        return this._focusedWidget
    }, enableDpadNavigation: function (a) {
    }, onFocusChanged: null, onNextFocusedWidget: null, interceptTouchEvent: function (a, b, c) {
        var d = this.getWidgetParent();
        d && d.interceptTouchEvent(a, b, c)
    }, onFocusChange: function (a, b) {
        a && a.setFocused(!1);
        b && b.setFocused(!0)
    }, dispatchFocusEvent: function (a, b) {
        a && !a.isFocused() && (a = this._focusedWidget);
        if (b != a) {
            if (b && b.onFocusChanged)b.onFocusChanged(a, b);
            if (a && b.onFocusChanged)a.onFocusChanged(a, b);
            cc.eventManager.dispatchEvent(new cc.EventFocus(a,
                b))
        }
    }, setBright: function (a) {
        if (this._bright = a)this._brightStyle = ccui.Widget.BRIGHT_STYLE_NONE, this.setBrightStyle(ccui.Widget.BRIGHT_STYLE_NORMAL); else this.onPressStateChangedToDisabled()
    }, setBrightStyle: function (a) {
        if (this._brightStyle != a)switch (this._brightStyle = a = a || ccui.Widget.BRIGHT_STYLE_NORMAL, this._brightStyle) {
            case ccui.Widget.BRIGHT_STYLE_NORMAL:
                this.onPressStateChangedToNormal();
                break;
            case ccui.Widget.BRIGHT_STYLE_HIGH_LIGHT:
                this.onPressStateChangedToPressed()
        }
    }, onPressStateChangedToNormal: function () {
    },
    onPressStateChangedToPressed: function () {
    }, onPressStateChangedToDisabled: function () {
    }, didNotSelectSelf: function () {
    }, onTouchBegan: function (a, b) {
        this._hitted = !1;
        if (this.isVisible() && this.isEnabled() && this._isAncestorsEnabled() && this._isAncestorsVisible(this)) {
            var c = a.getLocation();
            this._touchBeganPosition.x = c.x;
            this._touchBeganPosition.y = c.y;
            this.hitTest(this._touchBeganPosition) && this.isClippingParentContainsPoint(this._touchBeganPosition) && (this._hitted = !0)
        }
        if (!this._hitted)return!1;
        this.setHighlighted(!0);
        (c = this.getWidgetParent()) && c.interceptTouchEvent(ccui.Widget.TOUCH_BAGAN, this, a);
        this.pushDownEvent();
        return!0
    }, onTouchMoved: function (a, b) {
        var c = a.getLocation();
        this._touchMovePosition.x = c.x;
        this._touchMovePosition.y = c.y;
        this.setHighlighted(this.hitTest(c));
        (c = this.getWidgetParent()) && c.interceptTouchEvent(ccui.Widget.TOUCH_MOVED, this, a);
        this.moveEvent()
    }, onTouchEnded: function (a, b) {
        var c = a.getLocation();
        this._touchEndPosition.x = c.x;
        this._touchEndPosition.y = c.y;
        (c = this.getWidgetParent()) && c.interceptTouchEvent(ccui.Widget.TOUCH_ENDED,
            this, a);
        c = this._highlight;
        this.setHighlighted(!1);
        c ? this.releaseUpEvent() : this.cancelUpEvent()
    }, onTouchCancelled: function (a) {
        this.setHighlighted(!1);
        this.cancelUpEvent()
    }, onTouchLongClicked: function (a) {
        this.longClickEvent()
    }, pushDownEvent: function () {
        this._touchEventCallback && this._touchEventCallback(this, ccui.Widget.TOUCH_BAGAN);
        this._touchEventListener && this._touchEventSelector && this._touchEventSelector.call(this._touchEventListener, this, ccui.Widget.TOUCH_BEGAN)
    }, moveEvent: function () {
        this._touchEventCallback &&
        this._touchEventCallback(this, ccui.Widget.TOUCH_MOVED);
        this._touchEventListener && this._touchEventSelector && this._touchEventSelector.call(this._touchEventListener, this, ccui.Widget.TOUCH_MOVED)
    }, releaseUpEvent: function () {
        this._touchEventCallback && this._touchEventCallback(this, ccui.Widget.TOUCH_ENDED);
        this._touchEventListener && this._touchEventSelector && this._touchEventSelector.call(this._touchEventListener, this, ccui.Widget.TOUCH_ENDED)
    }, cancelUpEvent: function () {
        this._touchEventCallback && this._touchEventCallback(this,
            ccui.Widget.TOUCH_CANCELED);
        this._touchEventListener && this._touchEventSelector && this._touchEventSelector.call(this._touchEventListener, this, ccui.Widget.TOUCH_CANCELED)
    }, longClickEvent: function () {
    }, addTouchEventListener: function (a, b) {
        void 0 === b ? this._touchEventCallback = a : (this._touchEventSelector = a, this._touchEventListener = b)
    }, hitTest: function (a) {
        var b = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        return cc.rectContainsPoint(b, this.convertToNodeSpace(a))
    }, isClippingParentContainsPoint: function (a) {
        this._affectByClipping = !1;
        for (var b = this.getParent(), c = null; b;) {
            if (b instanceof ccui.Layout && b.isClippingEnabled()) {
                this._affectByClipping = !0;
                c = b;
                break
            }
            b = b.getParent()
        }
        return!this._affectByClipping ? !0 : c ? c.hitTest(a) ? c.isClippingParentContainsPoint(a) : !1 : !0
    }, clippingParentAreaContainPoint: function (a) {
        cc.log("clippingParentAreaContainPoint is deprecated. Please use isClippingParentContainsPoint instead.");
        this.isClippingParentContainsPoint(a)
    }, checkChildInfo: function (a, b, c) {
        var d = this.getWidgetParent();
        d && d.checkChildInfo(a,
            b, c)
    }, setPosition: function (a, b) {
        if (this._running) {
            var c = this.getWidgetParent();
            c && (c = c.getSize(), 0 >= c.width || 0 >= c.height ? (this._positionPercent.x = 0, this._positionPercent.y = 0) : b ? (this._positionPercent.x = a / c.width, this._positionPercent.y = b / c.height) : (this._positionPercent.x = a.x / c.width, this._positionPercent.y = a.y / c.height))
        }
        cc.Node.prototype.setPosition.call(this, a, b)
    }, setPositionX: function (a) {
        if (this._running) {
            var b = this.getWidgetParent();
            b && (b = b.width, this._positionPercent.x = 0 >= b ? 0 : a / b)
        }
        cc.Node.prototype.setPositionX.call(this,
            a)
    }, setPositionY: function (a) {
        if (this._running) {
            var b = this.getWidgetParent();
            b && (b = b.height, this._positionPercent.y = 0 >= b ? 0 : a / b)
        }
        cc.Node.prototype.setPositionY.call(this, a)
    }, setPositionPercent: function (a) {
        this._positionPercent = a;
        if (this._running && (a = this.getWidgetParent()))a = a.getSize(), this.setPosition(a.width * this._positionPercent.x, a.height * this._positionPercent.y)
    }, _setXPercent: function (a) {
        this._positionPercent.x = a;
        if (this._running) {
            var b = this.getWidgetParent();
            b && this.setPositionX(b.width * a)
        }
    },
    _setYPercent: function (a) {
        this._positionPercent.y = a;
        if (this._running) {
            var b = this.getWidgetParent();
            b && this.setPositionY(b.height * a)
        }
    }, updateAnchorPoint: function () {
        this.setAnchorPoint(this.getAnchorPoint())
    }, getPositionPercent: function () {
        return cc.p(this._positionPercent)
    }, _getXPercent: function () {
        return this._positionPercent.x
    }, _getYPercent: function () {
        return this._positionPercent.y
    }, setPositionType: function (a) {
        this.positionType = a
    }, getPositionType: function () {
        return this.positionType
    }, setFlippedX: function (a) {
        this._flippedX =
            a;
        this.updateFlippedX()
    }, isFlippedX: function () {
        return this._flippedX
    }, setFlippedY: function (a) {
        this._flippedY = a;
        this.updateFlippedY()
    }, isFlippedY: function () {
        return this._flippedY
    }, updateFlippedX: function () {
    }, updateFlippedY: function () {
    }, adaptRenderers: function () {
    }, isBright: function () {
        return this._bright
    }, isEnabled: function () {
        return this._enabled
    }, getLeftBoundary: function () {
        return this.getPositionX() - this._getAnchorX() * this._size.width
    }, getBottomBoundary: function () {
        return this.getPositionY() - this._getAnchorY() *
            this._size.height
    }, getRightBoundary: function () {
        return this.getLeftBoundary() + this._size.width
    }, getTopBoundary: function () {
        return this.getBottomBoundary() + this._size.height
    }, getTouchStartPos: function () {
        cc.log("getTouchStartPos is deprecated. Please use getTouchBeganPosition instead.");
        return this.getTouchBeganPosition()
    }, getTouchBeganPosition: function () {
        return cc.p(this._touchBeganPosition)
    }, getTouchMovePos: function () {
        cc.log("getTouchMovePos is deprecated. Please use getTouchMovePosition instead.");
        return this.getTouchMovePosition()
    }, getTouchMovePosition: function () {
        return cc.p(this._touchMovePosition)
    }, getTouchEndPos: function () {
        cc.log("getTouchEndPos is deprecated. Please use getTouchEndPosition instead.");
        return this.getTouchEndPosition()
    }, getTouchEndPosition: function () {
        return cc.p(this._touchEndPosition)
    }, setName: function (a) {
        this._name = a
    }, getName: function () {
        return this._name
    }, getWidgetType: function () {
        return this._widgetType
    }, setLayoutParameter: function (a) {
        a && (this._layoutParameterDictionary[a.getLayoutType()] =
            a, this._layoutParameterType = a.getLayoutType())
    }, getLayoutParameter: function (a) {
        a = a || this._layoutParameterType;
        return this._layoutParameterDictionary[a]
    }, getDescription: function () {
        return"Widget"
    }, clone: function () {
        var a = this.createCloneInstance();
        a.copyProperties(this);
        a.copyClonedWidgetChildren(this);
        return a
    }, createCloneInstance: function () {
        return ccui.Widget.create()
    }, copyClonedWidgetChildren: function (a) {
        a = a.getChildren();
        for (var b = 0; b < a.length; b++) {
            var c = a[b];
            c instanceof ccui.Widget && this.addChild(c.clone())
        }
    },
    copySpecialProperties: function (a) {
    }, copyProperties: function (a) {
        this.setEnabled(a.isEnabled());
        this.setVisible(a.isVisible());
        this.setBright(a.isBright());
        this.setTouchEnabled(a.isTouchEnabled());
        this.setLocalZOrder(a.getLocalZOrder());
        this.setUpdateEnabled(a.isUpdateEnabled());
        this.setTag(a.getTag());
        this.setName(a.getName());
        this.setActionTag(a.getActionTag());
        this._ignoreSize.width = a._ignoreSize.width;
        this._ignoreSize.height = a._ignoreSize.height;
        this._size.width = a._size.width;
        this._size.height =
            a._size.height;
        this._customSize.width = a._customSize.width;
        this._customSize.height = a._customSize.height;
        this.copySpecialProperties(a);
        this._sizeType = a.getSizeType();
        this._sizePercent.x = a._sizePercent.x;
        this._sizePercent.y = a._sizePercent.y;
        this.positionType = a.positionType;
        this._positionPercent.x = a._positionPercent.x;
        this._positionPercent.y = a._positionPercent.y;
        this.setPosition(a.getPosition());
        this.setAnchorPoint(a.getAnchorPoint());
        this.setScaleX(a.getScaleX());
        this.setScaleY(a.getScaleY());
        this.setRotation(a.getRotation());
        this.setRotationX(a.getRotationX());
        this.setRotationY(a.getRotationY());
        this.setFlippedX(a.isFlippedX());
        this.setFlippedY(a.isFlippedY());
        this.setColor(a.getColor());
        this.setOpacity(a.getOpacity());
        this._touchEventCallback = a._touchEventCallback;
        this._touchEventListener = a._touchEventListener;
        this._touchEventSelector = a._touchEventSelector;
        this._focused = a._focused;
        this._focusEnabled = a._focusEnabled;
        for (var b in a._layoutParameterDictionary) {
            var c = a._layoutParameterDictionary[b];
            c && this.setLayoutParameter(c.clone())
        }
        this.onSizeChanged()
    },
    setActionTag: function (a) {
        this._actionTag = a
    }, getActionTag: function () {
        return this._actionTag
    }, getColor: function () {
        return cc.color(this._color.r, this._color.g, this._color.b, this._color.a)
    }, setOpacity: function (a) {
        a !== this._color.a && (this._color.a = a, this.updateTextureOpacity(a))
    }, getOpacity: function () {
        return this._displayedOpacity
    }, updateTextureOpacity: function (a) {
        for (var b in this._children) {
            var c = this._children[b];
            c && c.RGBAProtocol && c.setOpacity(a)
        }
    }, updateColorToRenderer: function (a) {
        a.RGBAProtocol &&
        a.setColor(this._color)
    }, updateOpacityToRenderer: function (a) {
        a.RGBAProtocol && a.setOpacity(this._color.a)
    }, updateRGBAToRenderer: function (a) {
        a.setColor(this._color);
        a.setOpacity(this._opacity)
    }});
var _p = ccui.Widget.prototype;
cc.defineGetterSetter(_p, "xPercent", _p._getXPercent, _p._setXPercent);
cc.defineGetterSetter(_p, "yPercent", _p._getYPercent, _p._setYPercent);
cc.defineGetterSetter(_p, "widthPercent", _p._getWidthPercent, _p._setWidthPercent);
cc.defineGetterSetter(_p, "heightPercent", _p._getHeightPercent, _p._setHeightPercent);
cc.defineGetterSetter(_p, "widgetParent", _p.getWidgetParent);
cc.defineGetterSetter(_p, "enabled", _p.isEnabled, _p.setEnabled);
cc.defineGetterSetter(_p, "focused", _p.isFocused, _p.setFocused);
cc.defineGetterSetter(_p, "sizeType", _p.getSizeType, _p.setSizeType);
cc.defineGetterSetter(_p, "widgetType", _p.getWidgetType);
cc.defineGetterSetter(_p, "touchEnabled", _p.isTouchEnabled, _p.setTouchEnabled);
cc.defineGetterSetter(_p, "updateEnabled", _p.isUpdateEnabled, _p.setUpdateEnabled);
cc.defineGetterSetter(_p, "bright", _p.isBright, _p.setBright);
cc.defineGetterSetter(_p, "name", _p.getName, _p.setName);
cc.defineGetterSetter(_p, "actionTag", _p.getActionTag, _p.setActionTag);
cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
_p = null;
ccui.Widget.create = function () {
    return new ccui.Widget
};
ccui.Widget.BRIGHT_STYLE_NONE = -1;
ccui.Widget.BRIGHT_STYLE_NORMAL = 0;
ccui.Widget.BRIGHT_STYLE_HIGH_LIGHT = 1;
ccui.Widget.TYPE_WIDGET = 0;
ccui.Widget.TYPE_CONTAINER = 1;
ccui.Widget.LEFT = 0;
ccui.Widget.RIGHT = 1;
ccui.Widget.UP = 0;
ccui.Widget.DOWN = 1;
ccui.Widget.LOCAL_TEXTURE = 0;
ccui.Widget.PLIST_TEXTURE = 1;
ccui.Widget.TOUCH_BEGAN = 0;
ccui.Widget.TOUCH_MOVED = 1;
ccui.Widget.TOUCH_ENDED = 2;
ccui.Widget.TOUCH_CANCELED = 3;
ccui.Widget.SIZE_ABSOLUTE = 0;
ccui.Widget.SIZE_PERCENT = 1;
ccui.Widget.POSITION_ABSOLUTE = 0;
ccui.Widget.POSITION_PERCENT = 1;
cc.EventFocus = cc.Event.extend({_widgetGetFocus: null, _widgetLoseFocus: null, ctor: function (a, b) {
    this._widgetGetFocus = b;
    this._widgetLoseFocus = a
}});
ccui.Layout = ccui.Widget.extend({_clippingEnabled: !1, _backGroundScale9Enabled: null, _backGroundImage: null, _backGroundImageFileName: null, _backGroundImageCapInsets: null, _colorType: null, _bgImageTexType: ccui.Widget.LOCAL_TEXTURE, _colorRender: null, _gradientRender: null, _color: null, _startColor: null, _endColor: null, _alongVector: null, _opacity: 255, _backGroundImageTextureSize: null, _layoutType: null, _doLayoutDirty: !0, _clippingRectDirty: !0, _clippingType: null, _clippingStencil: null, _handleScissor: !1, _scissorRectDirty: !1,
    _clippingRect: null, _clippingParent: null, _className: "Layout", _backGroundImageColor: null, _finalPositionX: 0, _finalPositionY: 0, _currentStencilEnabled: 0, _currentStencilWriteMask: 0, _currentStencilFunc: 0, _currentStencilRef: 0, _currentStencilValueMask: 0, _currentStencilFail: 0, _currentStencilPassDepthFail: 0, _currentStencilPassDepthPass: 0, _currentDepthWriteMask: 0, _currentAlphaTestEnabled: 0, _currentAlphaTestFunc: 0, _currentAlphaTestRef: 0, _backGroundImageOpacity: 0, _mask_layer_le: 0, _loopFocus: !1, _passFocusToChild: !1,
    _isFocusPassing: !1, ctor: function () {
        this._layoutType = ccui.Layout.ABSOLUTE;
        this._widgetType = ccui.Widget.TYPE_CONTAINER;
        this._clippingType = ccui.Layout.CLIPPING_STENCIL;
        this._colorType = ccui.Layout.BG_COLOR_NONE;
        ccui.Widget.prototype.ctor.call(this);
        this._backGroundImageCapInsets = cc.rect(0, 0, 0, 0);
        this._color = cc.color(255, 255, 255, 255);
        this._startColor = cc.color(255, 255, 255, 255);
        this._endColor = cc.color(255, 255, 255, 255);
        this._alongVector = cc.p(0, -1);
        this._backGroundImageTextureSize = cc.size(0, 0);
        this._clippingRect =
            cc.rect(0, 0, 0, 0);
        this._backGroundImageColor = cc.color(255, 255, 255, 255)
    }, onEnter: function () {
        ccui.Widget.prototype.onEnter.call(this);
        if (this._clippingStencil)this._clippingStencil.onEnter();
        this._clippingRectDirty = this._doLayoutDirty = !0
    }, onExit: function () {
        ccui.Widget.prototype.onExit.call(this);
        if (this._clippingStencil)this._clippingStencil.onExit()
    }, setLoopFocus: function (a) {
        this._loopFocus = a
    }, isLoopFocus: function () {
        return this._loopFocus
    }, setPassFocusToChild: function (a) {
        this._passFocusToChild = a
    }, isPassFocusToChild: function () {
        return this._passFocusToChild
    },
    findNextFocusedWidget: function (a, b) {
        if (this._isFocusPassing || this.isFocused()) {
            var c = this.getParent();
            this._isFocusPassing = !1;
            if (this._passFocusToChild) {
                var d = this._passFocusToChild(a, b);
                return d instanceof ccui.Layout && c ? (c._isFocusPassing = !0, c.findNextFocusedWidget(a, this)) : d
            }
            if (null == c)return this;
            c._isFocusPassing = !0;
            return c.findNextFocusedWidget(a, this)
        }
        if (b.isFocused() || b instanceof ccui.Layout)if (this._layoutType == ccui.Layout.LINEAR_HORIZONTAL)switch (a) {
            case ccui.Widget.LEFT:
                return this._getPreviousFocusedWidget(a,
                    b);
            case ccui.Widget.RIGHT:
                return this._getNextFocusedWidget(a, b);
            case ccui.Widget.DOWN:
            case ccui.Widget.UP:
                return this._isLastWidgetInContainer(this, a) ? this._isWidgetAncestorSupportLoopFocus(b, a) ? this.findNextFocusedWidget(a, this) : b : this.findNextFocusedWidget(a, this);
            default:
                return cc.assert(0, "Invalid Focus Direction"), b
        } else if (this._layoutType == ccui.Layout.LINEAR_VERTICAL)switch (a) {
            case ccui.Widget.LEFT:
            case ccui.Widget.RIGHT:
                return this._isLastWidgetInContainer(this, a) ? this._isWidgetAncestorSupportLoopFocus(b,
                    a) ? this.findNextFocusedWidget(a, this) : b : this.findNextFocusedWidget(a, this);
            case ccui.Widget.DOWN:
                return this._getNextFocusedWidget(a, b);
            case ccui.Widget.UP:
                return this._getPreviousFocusedWidget(a, b);
            default:
                return cc.assert(0, "Invalid Focus Direction"), b
        } else return cc.assert(0, "Un Supported Layout type, please use VBox and HBox instead!!!"), b; else return b
    }, onPassFocusToChild: null, init: function () {
        return ccui.Widget.prototype.init.call(this) ? (this.ignoreContentAdaptWithSize(!1), this.setSize(cc.size(0,
            0)), this.setAnchorPoint(0, 0), this.onPassFocusToChild = this._findNearestChildWidgetIndex.bind(this), !0) : !1
    }, __stencilDraw: function (a) {
        a = a || cc._renderContext;
        for (var b = this._clippingStencil, c = cc.view.getScaleX(), d = cc.view.getScaleY(), e = 0; e < b._buffer.length; e++) {
            var f = b._buffer[e].verts, g = f[0];
            a.beginPath();
            a.moveTo(g.x * c, -g.y * d);
            for (var g = 1, h = f.length; g < h; g++)a.lineTo(f[g].x * c, -f[g].y * d)
        }
    }, addChild: function (a, b, c) {
        a instanceof ccui.Widget && this.supplyTheLayoutParameterLackToChild(a);
        ccui.Widget.prototype.addChild.call(this,
            a, b, c);
        this._doLayoutDirty = !0
    }, removeChild: function (a, b) {
        ccui.Widget.prototype.removeChild.call(this, a, b);
        this._doLayoutDirty = !0
    }, removeAllChildren: function (a) {
        ccui.Widget.prototype.removeAllChildren.call(this, a);
        this._doLayoutDirty = !0
    }, removeAllChildrenWithCleanup: function (a) {
        ccui.Widget.prototype.removeAllChildrenWithCleanup(a);
        this._doLayoutDirty = !0
    }, isClippingEnabled: function () {
        return this._clippingEnabled
    }, visit: function (a) {
        if (this._visible)if (this.adaptRenderers(), this._doLayout(), this._clippingEnabled)switch (this._clippingType) {
            case ccui.Layout.CLIPPING_STENCIL:
                this.stencilClippingVisit(a);
                break;
            case ccui.Layout.CLIPPING_SCISSOR:
                this.scissorClippingVisit(a)
        } else ccui.Widget.prototype.visit.call(this, a)
    }, sortAllChildren: function () {
        ccui.Widget.prototype.sortAllChildren.call(this);
        this._doLayout()
    }, stencilClippingVisit: null, _stencilClippingVisitForWebGL: function (a) {
        var b = a || cc._renderContext;
        if (this._clippingStencil && this._clippingStencil.isVisible())if (ccui.Layout._layer = -1, ccui.Layout._layer + 1 == cc.stencilBits)ccui.Layout._visit_once = !0, ccui.Layout._visit_once && (cc.log("Nesting more than " +
            cc.stencilBits + "stencils is not supported. Everything will be drawn without stencil for this node and its childs."), ccui.Layout._visit_once = !1), cc.Node.prototype.visit.call(this, a); else {
            ccui.Layout._layer++;
            var c = 1 << ccui.Layout._layer, d = c | c - 1;
            a = b.isEnabled(b.STENCIL_TEST);
            var e = b.getParameter(b.STENCIL_WRITEMASK), f = b.getParameter(b.STENCIL_FUNC), g = b.getParameter(b.STENCIL_REF), h = b.getParameter(b.STENCIL_VALUE_MASK), k = b.getParameter(b.STENCIL_FAIL), m = b.getParameter(b.STENCIL_PASS_DEPTH_FAIL), l = b.getParameter(b.STENCIL_PASS_DEPTH_PASS);
            b.enable(b.STENCIL_TEST);
            b.stencilMask(c);
            var p = b.getParameter(b.DEPTH_WRITEMASK);
            b.depthMask(!1);
            b.stencilFunc(b.NEVER, c, c);
            b.stencilOp(b.ZERO, b.KEEP, b.KEEP);
            cc._drawingUtil.drawSolidRect(cc.p(0, 0), cc.pFromSize(cc.director.getWinSize()), cc.color(255, 255, 255, 255));
            b.stencilFunc(b.NEVER, c, c);
            b.stencilOp(b.REPLACE, b.KEEP, b.KEEP);
            cc.kmGLPushMatrix();
            this.transform();
            this._clippingStencil.visit();
            b.depthMask(p);
            b.stencilFunc(b.EQUAL, d, d);
            b.stencilOp(b.KEEP, b.KEEP, b.KEEP);
            d = c = 0;
            this.sortAllChildren();
            this.sortAllProtectedChildren();
            for (var p = this._children, q = this._protectedChildren, r = p.length, s = q.length, n; c < r; c++)if ((n = p[c]) && 0 > n.getLocalZOrder())n.visit(); else break;
            for (; d < s; d++)if ((n = q[d]) && 0 > n.getLocalZOrder())n.visit(); else break;
            for (this.draw(); c < r; c++)p[c].visit();
            for (; d < s; d++)q[d].visit();
            b.stencilFunc(f, g, h);
            b.stencilOp(k, m, l);
            b.stencilMask(e);
            a || b.disable(b.STENCIL_TEST);
            ccui.Layout._layer--;
            cc.kmGLPopMatrix()
        }
    }, _stencilClippingVisitForCanvas: function (a) {
        if (this._clippingStencil && this._clippingStencil.isVisible()) {
            a =
                a || cc._renderContext;
            if (this._cangodhelpme() || this._clippingStencil instanceof cc.Sprite) {
                var b = a.canvas, c = ccui.Layout._getSharedCache();
                c.width = b.width;
                c.height = b.height;
                c.getContext("2d").drawImage(b, 0, 0);
                a.save();
                cc.Node.prototype.visit.call(this, a);
                a.globalCompositeOperation = "destination-in";
                this.transform(a);
                this._clippingStencil.visit();
                a.restore();
                a.save();
                a.setTransform(1, 0, 0, 1, 0, 0);
                a.globalCompositeOperation = "destination-over";
                a.drawImage(c, 0, 0)
            } else {
                var c = this._children, d;
                a.save();
                this.transform(a);
                this._clippingStencil.visit(a);
                a.clip();
                this._cangodhelpme(!0);
                this.sortAllChildren();
                this.sortAllProtectedChildren();
                for (var e, f = this._protectedChildren, g = c.length, h = f.length, b = 0; b < g; b++)if ((d = c[b]) && 0 > d._localZOrder)d.visit(a); else break;
                for (e = 0; e < h; e++)if ((d = f[e]) && 0 > d._localZOrder)d.visit(a); else break;
                for (; b < g; b++)c[b].visit(a);
                for (; e < h; e++)f[e].visit(a);
                this._cangodhelpme(!1)
            }
            a.restore()
        }
    }, _godhelpme: !1, _cangodhelpme: function (a) {
        if (!0 === a || !1 === a)cc.ClippingNode.prototype._godhelpme = a;
        return cc.ClippingNode.prototype._godhelpme
    },
    scissorClippingVisit: null, _scissorClippingVisitForWebGL: function (a) {
        var b = this.getClippingRect();
        a = a || cc._renderContext;
        this._handleScissor && a.enable(a.SCISSOR_TEST);
        cc.view.setScissorInPoints(b.x, b.y, b.width, b.height);
        cc.Node.prototype.visit.call(this);
        this._handleScissor && a.disable(a.SCISSOR_TEST)
    }, setClippingEnabled: function (a) {
        if (a != this._clippingEnabled)switch (this._clippingEnabled = a, this._clippingType) {
            case ccui.Layout.CLIPPING_STENCIL:
                if (a) {
                    this._clippingStencil = cc.DrawNode.create();
                    cc._renderType ===
                    cc._RENDER_TYPE_CANVAS && (this._clippingStencil.draw = this.__stencilDraw.bind(this));
                    if (this._running)this._clippingStencil.onEnter();
                    this.setStencilClippingSize(this._contentSize)
                } else {
                    if (this._running)this._clippingStencil.onExit();
                    this._clippingStencil = null
                }
        }
    }, setClippingType: function (a) {
        if (a != this._clippingType) {
            var b = this.isClippingEnabled();
            this.setClippingEnabled(!1);
            this._clippingType = a;
            this.setClippingEnabled(b)
        }
    }, getClippingType: function () {
        return this._clippingType
    }, setStencilClippingSize: function (a) {
        if (this._clippingEnabled &&
            this._clippingType == ccui.Layout.CLIPPING_STENCIL) {
            var b = [];
            b[0] = cc.p(0, 0);
            b[1] = cc.p(a.width, 0);
            b[2] = cc.p(a.width, a.height);
            b[3] = cc.p(0, a.height);
            a = cc.color.GREEN;
            this._clippingStencil.clear();
            this._clippingStencil.drawPoly(b, 4, a, 0, a)
        }
    }, rendererVisitCallBack: function () {
        this._doLayout()
    }, getClippingRect: function () {
        if (this._clippingRectDirty) {
            var a = this.convertToWorldSpace(cc.p(0, 0)), b = this.nodeToWorldTransform(), c = this._contentSize.width * b.a, b = this._contentSize.height * b.d, d;
            d = this;
            for (var e = !1; d;)if ((d =
                d.getParent()) && d instanceof ccui.Layout && d.isClippingEnabled())if (e || (this._clippingParent = d, e = !0), d._clippingType == ccui.Layout.CLIPPING_SCISSOR) {
                this._handleScissor = !1;
                break
            }
            if (this._clippingParent) {
                d = this._clippingParent.getClippingRect();
                var e = a.x - c * this._anchorPoint.x, f = a.y - b * this._anchorPoint.y, g = c, h = b, k = a.x - d.x;
                0 > k && (e = d.x, g += k);
                c = a.x + c - (d.x + d.width);
                0 < c && (g -= c);
                c = a.y + b - (d.y + d.height);
                0 < c && (h -= c);
                a = a.y - d.y;
                0 > a && (f = d.x, h += a);
                0 > g && (g = 0);
                0 > h && (h = 0);
                this._clippingRect.x = e;
                this._clippingRect.y =
                    f;
                this._clippingRect.width = g;
                this._clippingRect.height = h
            } else this._clippingRect.x = a.x - c * this._anchorPoint.x, this._clippingRect.y = a.y - b * this._anchorPoint.y, this._clippingRect.width = c, this._clippingRect.height = b;
            this._clippingRectDirty = !1
        }
        return this._clippingRect
    }, onSizeChanged: function () {
        ccui.Widget.prototype.onSizeChanged.call(this);
        this.setStencilClippingSize(this._contentSize);
        this._clippingRectDirty = this._doLayoutDirty = !0;
        this._backGroundImage && (this._backGroundImage.setPosition(0.5 * this._contentSize.width,
                0.5 * this._contentSize.height), this._backGroundScale9Enabled && this._backGroundImage instanceof cc.Scale9Sprite && this._backGroundImage.setPreferredSize(this._contentSize));
        this._colorRender && this._colorRender.setContentSize(this._contentSize);
        this._gradientRender && this._gradientRender.setContentSize(this._contentSize)
    }, setBackGroundImageScale9Enabled: function (a) {
        this._backGroundScale9Enabled != a && (this.removeProtectedChild(this._backGroundImage), this._backGroundImage = null, this._backGroundScale9Enabled =
            a, this.addBackGroundImage(), this.setBackGroundImage(this._backGroundImageFileName, this._bgImageTexType), this.setBackGroundImageCapInsets(this._backGroundImageCapInsets))
    }, isBackGroundImageScale9Enabled: function () {
        return this._backGroundScale9Enabled
    }, setBackGroundImage: function (a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            null == this._backGroundImage && this.addBackGroundImage();
            this._backGroundImageFileName = a;
            this._bgImageTexType = b;
            if (this._backGroundScale9Enabled) {
                var c = this._backGroundImage;
                switch (this._bgImageTexType) {
                    case ccui.Widget.LOCAL_TEXTURE:
                        c.initWithFile(a);
                        break;
                    case ccui.Widget.PLIST_TEXTURE:
                        c.initWithSpriteFrameName(a)
                }
                c.setPreferredSize(this._contentSize)
            } else switch (c = this._backGroundImage, this._bgImageTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    c.setTexture(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    c.setSpriteFrame(a)
            }
            this._backGroundImageTextureSize = this._backGroundImage.getContentSize();
            this._backGroundImage.setPosition(this._contentSize.width / 2, this._contentSize.height / 2);
            this._updateBackGroundImageColor()
        }
    }, setBackGroundImageCapInsets: function (a) {
        this._backGroundImageCapInsets =
            a;
        this._backGroundScale9Enabled && this._backGroundImage.setCapInsets(a)
    }, getBackGroundImageCapInsets: function () {
        return this._backGroundImageCapInsets
    }, supplyTheLayoutParameterLackToChild: function (a) {
        if (a)switch (this._layoutType) {
            case ccui.Layout.LINEAR_HORIZONTAL:
            case ccui.Layout.LINEAR_VERTICAL:
                var b = a.getLayoutParameter(ccui.LayoutParameter.LINEAR);
                b || a.setLayoutParameter(ccui.LinearLayoutParameter.create());
                break;
            case ccui.Layout.RELATIVE:
                (b = a.getLayoutParameter(ccui.LayoutParameter.RELATIVE)) ||
                a.setLayoutParameter(ccui.RelativeLayoutParameter.create())
        }
    }, addBackGroundImage: function () {
        this._backGroundScale9Enabled ? (this._backGroundImage = cc.Scale9Sprite.create(), this._backGroundImage.setPreferredSize(this._contentSize)) : this._backGroundImage = cc.Sprite.create();
        this.addProtectedChild(this._backGroundImage, ccui.Layout.BACKGROUND_IMAGE_ZORDER, -1);
        this._backGroundImage.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    }, removeBackGroundImage: function () {
        this._backGroundImage && (this.removeProtectedChild(this._backGroundImage),
            this._backGroundImage = null, this._backGroundImageFileName = "", this._backGroundImageTextureSize = cc.size(0, 0))
    }, setBackGroundColorType: function (a) {
        if (this._colorType != a) {
            switch (this._colorType) {
                case ccui.Layout.BG_COLOR_NONE:
                    this._colorRender && (this.removeProtectedChild(this._colorRender), this._colorRender = null);
                    this._gradientRender && (this.removeProtectedChild(this._gradientRender), this._gradientRender = null);
                    break;
                case ccui.Layout.BG_COLOR_SOLID:
                    this._colorRender && (this.removeProtectedChild(this._colorRender),
                        this._colorRender = null);
                    break;
                case ccui.Layout.BG_COLOR_GRADIENT:
                    this._gradientRender && (this.removeProtectedChild(this._gradientRender), this._gradientRender = null)
            }
            this._colorType = a;
            switch (this._colorType) {
                case ccui.Layout.BG_COLOR_SOLID:
                    this._colorRender = cc.LayerColor.create();
                    this._colorRender.setContentSize(this._contentSize);
                    this._colorRender.setOpacity(this._opacity);
                    this._colorRender.setColor(this._color);
                    this.addProtectedChild(this._colorRender, ccui.Layout.BACKGROUND_RENDERER_ZORDER, -1);
                    break;
                case ccui.Layout.BG_COLOR_GRADIENT:
                    this._gradientRender = cc.LayerGradient.create(cc.color(255, 0, 0, 255), cc.color(0, 255, 0, 255)), this._gradientRender.setContentSize(this._contentSize), this._gradientRender.setOpacity(this._opacity), this._gradientRender.setStartColor(this._startColor), this._gradientRender.setEndColor(this._endColor), this._gradientRender.setVector(this._alongVector), this.addProtectedChild(this._gradientRender, ccui.Layout.BACKGROUND_RENDERER_ZORDER, -1)
            }
        }
    }, getBackGroundColorType: function () {
        return this._colorType
    },
    setBackGroundColor: function (a, b) {
        b ? (this._startColor.r = a.r, this._startColor.g = a.g, this._startColor.b = a.b, this._gradientRender && this._gradientRender.setStartColor(a), this._endColor = b, this._gradientRender && this._gradientRender.setEndColor(b)) : (this._color.r = a.r, this._color.g = a.g, this._color.b = a.b, this._colorRender && this._colorRender.setColor(a))
    }, getBackGroundColor: function () {
        var a = this._color;
        return cc.color(a.r, a.g, a.b, a.a)
    }, getBackGroundStartColor: function () {
        var a = this._startColor;
        return cc.color(a.r,
            a.g, a.b, a.a)
    }, getBackGroundEndColor: function () {
        var a = this._endColor;
        return cc.color(a.r, a.g, a.b, a.a)
    }, setBackGroundColorOpacity: function (a) {
        this._opacity = a;
        switch (this._colorType) {
            case ccui.Layout.BG_COLOR_SOLID:
                this._colorRender.setOpacity(a);
                break;
            case ccui.Layout.BG_COLOR_GRADIENT:
                this._gradientRender.setOpacity(a)
        }
    }, getBackGroundColorOpacity: function () {
        return this._opacity
    }, setBackGroundColorVector: function (a) {
        this._alongVector.x = a.x;
        this._alongVector.y = a.y;
        this._gradientRender && this._gradientRender.setVector(a)
    },
    getBackGroundColorVector: function () {
        return this._alongVector
    }, setBackGroundImageColor: function (a) {
        this._backGroundImageColor.r = a.r;
        this._backGroundImageColor.g = a.g;
        this._backGroundImageColor.b = a.b;
        this._updateBackGroundImageColor()
    }, setBackGroundImageOpacity: function (a) {
        this._backGroundImageColor.a = a;
        this.getBackGroundImageColor()
    }, getBackGroundImageColor: function () {
        var a = this._backGroundImageColor;
        return cc.color(a.r, a.g, a.b, a.a)
    }, getBackGroundImageOpacity: function () {
        return this._backGroundImageColor.a
    },
    _updateBackGroundImageColor: function () {
        this._backGroundImage && this._backGroundImage.setColor(this._backGroundImageColor)
    }, getBackGroundImageTextureSize: function () {
        return this._backGroundImageTextureSize
    }, setLayoutType: function (a) {
        this._layoutType = a;
        a = this._children;
        for (var b = null, c = 0; c < a.length; c++)b = a[c], b instanceof ccui.Widget && this.supplyTheLayoutParameterLackToChild(b);
        this._doLayoutDirty = !0
    }, getLayoutType: function () {
        return this._layoutType
    }, requestDoLayout: function () {
        this._doLayoutDirty = !0
    },
    _doLayout: function () {
        if (this._doLayoutDirty) {
            var a = this._createLayoutManager();
            a && a._doLayout(this);
            this._doLayoutDirty = !1
        }
    }, _createLayoutManager: function () {
        var a = null;
        switch (this._layoutType) {
            case ccui.Layout.LINEAR_VERTICAL:
                a = ccui.LinearVerticalLayoutManager.create();
                break;
            case ccui.Layout.LINEAR_HORIZONTAL:
                a = ccui.LinearHorizontalLayoutManager.create();
                break;
            case ccui.Layout.RELATIVE:
                a = ccui.RelativeLayoutManager.create()
        }
        return a
    }, _getLayoutContentSize: function () {
        return this.getContentSize()
    }, _getLayoutElements: function () {
        return this.getChildren()
    },
    _onBeforeVisitStencil: function () {
    }, _drawFullScreenQuadClearStencil: function () {
    }, _onAfterDrawStencil: function () {
    }, _onAfterVisitStencil: function () {
    }, _onAfterVisitScissor: function () {
    }, _onAfterVisitScissor: function () {
    }, _updateBackGroundImageOpacity: function () {
        this._backGroundImage && this._backGroundImage.setOpacity(this._backGroundImageOpacity)
    }, _updateBackGroundImageRGBA: function () {
        this._backGroundImage && (this._backGroundImage.setColor(this._backGroundImageColor), this._backGroundImage.setOpacity(this._backGroundImageOpacity))
    },
    _getLayoutAccumulatedSize: function () {
        for (var a = this.getChildren(), b = cc.size(0, 0), c = 0, d, e = 0, f = a.length; e < f; e++)if (d = a[e], null != d && d instanceof ccui.Layout)d = d._getLayoutAccumulatedSize(), b.width += d.width, b.height += d.height; else if (d instanceof ccui.Widget) {
            c++;
            var g = w.getLayoutParameter().getMargin();
            d = w.getContentSize();
            b.width += d.width + 0.5 * (g.right + g.left);
            b.height += d.height + 0.5 * (g.top + g.bottom)
        }
        a = this.getLayoutType();
        a == ccui.Layout.LINEAR_HORIZONTAL && (b.height -= b.height / c * (c - 1));
        a == ccui.Layout.LINEAR_VERTICAL &&
        (b.width -= b.width / c * (c - 1));
        return b
    }, _findNearestChildWidgetIndex: function (a, b) {
        if (null == b || b == this)return this._findFirstFocusEnabledWidgetIndex();
        var c = 0, d = this.getChildren(), e = d.length, f, g = cc.FLT_MAX, h = 0;
        if (a == ccui.Widget.LEFT || a == ccui.Widget.RIGHT || a == ccui.Widget.DOWN || a == ccui.Widget.UP) {
            for (f = this._getWorldCenterPoint(b); c < e;) {
                var k = d[c];
                k && (k instanceof ccui.Widget && k.isFocusEnabled()) && (k = k instanceof ccui.Layout ? k._calculateNearestDistance(b) : cc.pLength(cc.pSub(this._getWorldCenterPoint(k),
                    f)), k < g && (h = c, g = k));
                c++
            }
            return h
        }
        cc.assert(0, "invalid focus direction!");
        return 0
    }, _findFarestChildWidgetIndex: function (a, b) {
        if (null == b || b == this)return this._findFirstFocusEnabledWidgetIndex();
        var c = 0, d = this.getChildren().size(), e = -cc.FLT_MAX, f = 0;
        if (a == ccui.Widget.LEFT || a == ccui.Widget.RIGHT || a == ccui.Widget.DOWN || a == ccui.Widget.UP) {
            for (var g = this._getWorldCenterPoint(b); c < d;) {
                if (w && w instanceof ccui.Widget && w.isFocusEnabled()) {
                    var h = w instanceof ccui.Layout ? w._calculateFarestDistance(b) : cc.pLength(cc.pSub(this._getWorldCenterPoint(w),
                        g));
                    h > e && (f = c, e = h)
                }
                c++
            }
            return f
        }
        cc.assert(0, "invalid focus direction!!!");
        return 0
    }, _calculateNearestDistance: function (a) {
        for (var b = cc.FLT_MAX, c = this._getWorldCenterPoint(a), d = this._children, e = 0, f = d.length; e < f; e++) {
            var g = d[e];
            if (g instanceof ccui.Layout)g = g._calculateNearestDistance(a); else if (g instanceof ccui.Widget && g.isFocusEnabled())g = cc.pLength(cc.pSub(this._getWorldCenterPoint(g), c)); else continue;
            g < b && (b = g)
        }
        return b
    }, _calculateFarestDistance: function (a) {
        for (var b = -cc.FLT_MAX, c = this._getWorldCenterPoint(a),
                 d = this._children, e = 0, f = d.length; e < f; e++) {
            var g = d[e];
            if (g instanceof ccui.Layout)g = g._calculateFarestDistance(a); else if (g instanceof ccui.Widget && g.isFocusEnabled())g = this._getWorldCenterPoint(w), g = cc.pLength(cc.pSub(g, c)); else continue;
            g > b && (b = g)
        }
        return b
    }, _findProperSearchingFunctor: function (a, b) {
        if (null != b) {
            var c = this._getWorldCenterPoint(b), d = this._getWorldCenterPoint(this._findFirstNonLayoutWidget());
            a == ccui.Widget.LEFT ? this.onPassFocusToChild = c.x > d.x ? this._findNearestChildWidgetIndex.bind(this) :
                this._findFarestChildWidgetIndex.bind(this) : a == ccui.Widget.RIGHT ? this.onPassFocusToChild = c.x > d.x ? this._findFarestChildWidgetIndex.bind(this) : this._findNearestChildWidgetIndex.bind(this) : a == ccui.Widget.DOWN ? this.onPassFocusToChild = c.y > d.y ? this._findNearestChildWidgetIndex.bind(this) : this._findFarestChildWidgetIndex.bind(this) : a == ccui.Widget.UP ? this.onPassFocusToChild = c.y < d.y ? this._findNearestChildWidgetIndex.bind(this) : this._findFarestChildWidgetIndex.bind(this) : cc.assert(0, "invalid direction!")
        }
    },
    _findFirstNonLayoutWidget: function () {
        for (var a = this._children, b = 0, c = a.length; b < c; b++) {
            var d = a[b];
            if (d instanceof ccui.Layout) {
                if (d = d._findFirstNonLayoutWidget())return d
            } else if (d instanceof cc.Widget)return d
        }
        return null
    }, _findFirstFocusEnabledWidgetIndex: function () {
        for (var a = 0, b = this.getChildren(), c = b.length; a < c;) {
            var d = b[a];
            if (d && d instanceof ccui.Widget && d.isFocusEnabled())return a;
            a++
        }
        return 0
    }, _findFocusEnabledChildWidgetByIndex: function (a) {
        var b = this._getChildWidgetByIndex(a);
        return b ? b.isFocusEnabled() ?
            b : this._findFocusEnabledChildWidgetByIndex(a + 1) : null
    }, _getWorldCenterPoint: function (a) {
        var b = a instanceof ccui.Layout ? a._getLayoutAccumulatedSize() : a.getContentSize();
        return a.convertToWorldSpace(cc.p(b.width / 2, b.height / 2))
    }, _getNextFocusedWidget: function (a, b) {
        var c = null, c = this._children, d = c.indexOf(b), d = d + 1;
        if (d < c.length) {
            if (c = this._getChildWidgetByIndex(d)) {
                if (c.isFocusEnabled()) {
                    if (c instanceof ccui.Layout)return c._isFocusPassing = !0, c.findNextFocusedWidget(a, c);
                    this.dispatchFocusEvent(b, c);
                    return c
                }
                return this._getNextFocusedWidget(a,
                    c)
            }
            return b
        }
        if (this._loopFocus) {
            if (this._checkFocusEnabledChild()) {
                c = this._getChildWidgetByIndex(0);
                if (c.isFocusEnabled()) {
                    if (c instanceof ccui.Layout)return c._isFocusPassing = !0, c.findNextFocusedWidget(a, c);
                    this.dispatchFocusEvent(b, c);
                    return c
                }
                return this._getNextFocusedWidget(a, c)
            }
            return b instanceof ccui.Layout ? b : this._focusedWidget
        }
        return this._isLastWidgetInContainer(b, a) ? this._isWidgetAncestorSupportLoopFocus(this, a) ? this.findNextFocusedWidget(a, this) : b instanceof ccui.Layout ? b : this._focusedWidget :
            this.findNextFocusedWidget(a, this)
    }, _getPreviousFocusedWidget: function (a, b) {
        var c = null, c = this._children, d = c.indexOf(b), d = d - 1;
        if (0 <= d) {
            c = this._getChildWidgetByIndex(d);
            if (c.isFocusEnabled()) {
                if (c instanceof ccui.Layout)return c._isFocusPassing = !0, c.findNextFocusedWidget(a, c);
                this.dispatchFocusEvent(b, c);
                return c
            }
            return this._getPreviousFocusedWidget(a, c)
        }
        if (this._loopFocus) {
            if (this._checkFocusEnabledChild()) {
                d = c.length - 1;
                c = this._getChildWidgetByIndex(d);
                if (c.isFocusEnabled()) {
                    if (c instanceof ccui.Layout)return c._isFocusPassing = !0, c.findNextFocusedWidget(a, c);
                    this.dispatchFocusEvent(b, c);
                    return c
                }
                return this._getPreviousFocusedWidget(a, c)
            }
            return b instanceof ccui.Layout ? b : this._focusedWidget
        }
        return this._isLastWidgetInContainer(b, a) ? this._isWidgetAncestorSupportLoopFocus(this, a) ? this.findNextFocusedWidget(a, this) : b instanceof ccui.Layout ? b : this._focusedWidget : this.findNextFocusedWidget(a, this)
    }, _getChildWidgetByIndex: function (a) {
        for (var b = this._children, c = b.length, d = 0, e = a; a < c;) {
            var f = b[a];
            if (f && f instanceof ccui.Widget)return f;
            d++;
            a++
        }
        for (a = 0; a < e;) {
            if ((c = b[a]) && c instanceof ccui.Widget)return c;
            d++;
            a++
        }
        return null
    }, _isLastWidgetInContainer: function (a, b) {
        var c = a.getParent();
        if (c instanceof ccui.Layout)return!0;
        var d = c.getChildren(), e = d.indexOf(a);
        if (c.getLayoutType() == ccui.Layout.LINEAR_HORIZONTAL) {
            if (b == ccui.Widget.LEFT)return 0 == e ? 1 * this._isLastWidgetInContainer(c, b) : !1;
            if (b == ccui.Widget.RIGHT)return e == d.length - 1 ? 1 * this._isLastWidgetInContainer(c, b) : !1;
            if (b == ccui.Widget.DOWN || b == ccui.Widget.UP)return this._isLastWidgetInContainer(c,
                b)
        } else if (c.getLayoutType() == ccui.Layout.LINEAR_VERTICAL) {
            if (b == ccui.Widget.UP)return 0 == e ? 1 * this._isLastWidgetInContainer(c, b) : !1;
            if (b == ccui.Widget.DOWN)return e == d.length - 1 ? 1 * this._isLastWidgetInContainer(c, b) : !1;
            if (b == ccui.Widget.LEFT || b == ccui.Widget.RIGHT)return this._isLastWidgetInContainer(c, b)
        } else cc.assert(0, "invalid layout Type");
        return!1
    }, _isWidgetAncestorSupportLoopFocus: function (a, b) {
        var c = a.getParent();
        if (null == c)return!1;
        if (c.isLoopFocus()) {
            var d = c.getLayoutType();
            if (d == ccui.Layout.LINEAR_HORIZONTAL)return b ==
                ccui.Widget.LEFT || b == ccui.Widget.RIGHT ? !0 : this._isWidgetAncestorSupportLoopFocus(c, b);
            if (d == ccui.Layout.LINEAR_VERTICAL)return b == ccui.Widget.DOWN || b == ccui.Widget.UP ? !0 : this._isWidgetAncestorSupportLoopFocus(c, b);
            cc.assert(0, "invalid layout type")
        } else return this._isWidgetAncestorSupportLoopFocus(c, b)
    }, _passFocusToChild: function (a, b) {
        if (this._checkFocusEnabledChild()) {
            var c = this.getCurrentFocusedWidget();
            this._findProperSearchingFunctor(a, c);
            c = this.onPassFocusToChild(a, c);
            c = this._getChildWidgetByIndex(c);
            if (c instanceof ccui.Layout)return c._isFocusPassing = !0, c.findNextFocusedWidget(a, c);
            this.dispatchFocusEvent(b, c);
            return c
        }
        return this
    }, _checkFocusEnabledChild: function () {
        for (var a = this._children, b = 0, c = a.length; b < c; b++) {
            var d = a[b];
            if (d && d instanceof ccui.Widget && d.isFocusEnabled())return!0
        }
        return!1
    }, getDescription: function () {
        return"Layout"
    }, createCloneInstance: function () {
        return ccui.Layout.create()
    }, copyClonedWidgetChildren: function (a) {
        ccui.Widget.prototype.copyClonedWidgetChildren.call(this, a)
    },
    copySpecialProperties: function (a) {
        this.setBackGroundImageScale9Enabled(a._backGroundScale9Enabled);
        this.setBackGroundImage(a._backGroundImageFileName, a._bgImageTexType);
        this.setBackGroundImageCapInsets(a._backGroundImageCapInsets);
        this.setBackGroundColorType(a._colorType);
        this.setBackGroundColor(a._color);
        this.setBackGroundColor(a._startColor, a._endColor);
        this.setBackGroundColorOpacity(a._opacity);
        this.setBackGroundColorVector(a._alongVector);
        this.setLayoutType(a._layoutType);
        this.setClippingEnabled(a._clippingEnabled);
        this.setClippingType(a._clippingType);
        this._loopFocus = a._loopFocus;
        this._passFocusToChild = a._passFocusToChild
    }});
ccui.Layout._init_once = null;
ccui.Layout._visit_once = null;
ccui.Layout._layer = null;
ccui.Layout._sharedCache = null;
cc._renderType == cc._RENDER_TYPE_WEBGL ? (ccui.Layout.prototype.stencilClippingVisit = ccui.Layout.prototype._stencilClippingVisitForWebGL, ccui.Layout.prototype.scissorClippingVisit = ccui.Layout.prototype._scissorClippingVisitForWebGL) : (ccui.Layout.prototype.stencilClippingVisit = ccui.Layout.prototype._stencilClippingVisitForCanvas, ccui.Layout.prototype.scissorClippingVisit = ccui.Layout.prototype._stencilClippingVisitForCanvas);
ccui.Layout._getSharedCache = function () {
    return cc.ClippingNode._sharedCache || (cc.ClippingNode._sharedCache = cc.newElement("canvas"))
};
_p = ccui.Layout.prototype;
cc.defineGetterSetter(_p, "clippingEnabled", _p.isClippingEnabled, _p.setClippingEnabled);
cc.defineGetterSetter(_p, "clippingType", null, _p.setClippingType);
cc.defineGetterSetter(_p, "layoutType", _p.getLayoutType, _p.setLayoutType);
_p = null;
ccui.Layout.create = function () {
    return new ccui.Layout
};
ccui.Layout.BG_COLOR_NONE = 0;
ccui.Layout.BG_COLOR_SOLID = 1;
ccui.Layout.BG_COLOR_GRADIENT = 2;
ccui.Layout.ABSOLUTE = 0;
ccui.Layout.LINEAR_VERTICAL = 1;
ccui.Layout.LINEAR_HORIZONTAL = 2;
ccui.Layout.RELATIVE = 3;
ccui.Layout.CLIPPING_STENCIL = 0;
ccui.Layout.CLIPPING_SCISSOR = 1;
ccui.Layout.BACKGROUND_IMAGE_ZORDER = -2;
ccui.Layout.BACKGROUND_RENDERER_ZORDER = -2;
ccui.Margin = ccui.Class.extend({left: 0, top: 0, right: 0, bottom: 0, ctor: function (a, b, c, d) {
    a && void 0 === b && (this.left = a.left, this.top = a.top, this.right = a.right, this.bottom = a.bottom);
    void 0 !== d && (this.left = a, this.top = b, this.right = c, this.bottom = d)
}, setMargin: function (a, b, c, d) {
    this.left = a;
    this.top = b;
    this.right = c;
    this.bottom = d
}, equals: function (a) {
    return this.left == a.left && this.top == a.top && this.right == a.right && this.bottom == a.bottom
}});
ccui.MarginZero = function () {
    return new ccui.Margin(0, 0, 0, 0)
};
ccui.LayoutParameter = ccui.Class.extend({_margin: null, _layoutParameterType: null, ctor: function () {
    this._margin = new ccui.Margin;
    this._layoutParameterType = ccui.LayoutParameter.NONE
}, setMargin: function (a, b, c, d) {
    "object" === typeof a ? (this._margin.left = a.left, this._margin.top = a.top, this._margin.right = a.right, this._margin.bottom = a.bottom) : (this._margin.left = a, this._margin.top = b, this._margin.right = c, this._margin.bottom = d)
}, getMargin: function () {
    return this._margin
}, getLayoutType: function () {
    return this._layoutParameterType
},
    clone: function () {
        var a = this.createCloneInstance();
        a.copyProperties(this);
        return a
    }, createCloneInstance: function () {
        return ccui.LayoutParameter.create()
    }, copyProperties: function (a) {
        this._margin = a._margin
    }});
ccui.LayoutParameter.create = function () {
    return new ccui.LayoutParameter
};
ccui.LayoutParameter.NONE = 0;
ccui.LayoutParameter.LINEAR = 1;
ccui.LayoutParameter.RELATIVE = 2;
ccui.LinearLayoutParameter = ccui.LayoutParameter.extend({_linearGravity: null, ctor: function () {
    ccui.LayoutParameter.prototype.ctor.call(this);
    this._linearGravity = ccui.LinearLayoutParameter.NONE;
    this._layoutParameterType = ccui.LayoutParameter.LINEAR
}, setGravity: function (a) {
    this._linearGravity = a
}, getGravity: function () {
    return this._linearGravity
}, createCloneInstance: function () {
    return ccui.LinearLayoutParameter.create()
}, copyProperties: function (a) {
    ccui.LayoutParameter.prototype.copyProperties.call(this, a);
    a && (this.setAlign(a._relativeAlign), this.setRelativeName(a._relativeLayoutName), this.setRelativeToWidgetName(a._relativeWidgetName), this.setGravity(a._linearGravity))
}});
ccui.LinearLayoutParameter.create = function () {
    return new ccui.LinearLayoutParameter
};
ccui.LinearLayoutParameter.NONE = 0;
ccui.LinearLayoutParameter.LEFT = 1;
ccui.LinearLayoutParameter.TOP = 2;
ccui.LinearLayoutParameter.RIGHT = 3;
ccui.LinearLayoutParameter.BOTTOM = 4;
ccui.LinearLayoutParameter.CENTER_VERTICAL = 5;
ccui.LinearLayoutParameter.CENTER_HORIZONTAL = 6;
ccui.RelativeLayoutParameter = ccui.LayoutParameter.extend({_relativeAlign: null, _relativeWidgetName: "", _relativeLayoutName: "", _put: !1, ctor: function () {
    ccui.LayoutParameter.prototype.ctor.call(this);
    this._relativeAlign = ccui.RelativeLayoutParameter.NONE;
    this._relativeLayoutName = this._relativeWidgetName = "";
    this._put = !1;
    this._layoutParameterType = ccui.LayoutParameter.RELATIVE
}, setAlign: function (a) {
    this._relativeAlign = a
}, getAlign: function () {
    return this._relativeAlign
}, setRelativeToWidgetName: function (a) {
    this._relativeWidgetName =
        a
}, getRelativeToWidgetName: function () {
    return this._relativeWidgetName
}, setRelativeName: function (a) {
    this._relativeLayoutName = a
}, getRelativeName: function () {
    return this._relativeLayoutName
}, createCloneInstance: function () {
    return ccui.RelativeLayoutParameter.create()
}, copyProperties: function (a) {
    ccui.LayoutParameter.prototype.copyProperties.call(this, a);
    this.setAlign(a._relativeAlign);
    this.setRelativeToWidgetName(a._relativeWidgetName);
    this.setRelativeName(a._relativeLayoutName)
}});
ccui.RelativeLayoutParameter.create = function () {
    return new ccui.RelativeLayoutParameter
};
ccui.RelativeLayoutParameter.NONE = 0;
ccui.RelativeLayoutParameter.PARENT_TOP_LEFT = 1;
ccui.RelativeLayoutParameter.PARENT_TOP_CENTER_HORIZONTAL = 2;
ccui.RelativeLayoutParameter.PARENT_TOP_RIGHT = 3;
ccui.RelativeLayoutParameter.PARENT_LEFT_CENTER_VERTICAL = 4;
ccui.RelativeLayoutParameter.CENTER_IN_PARENT = 5;
ccui.RelativeLayoutParameter.PARENT_RIGHT_CENTER_VERTICAL = 6;
ccui.RelativeLayoutParameter.PARENT_LEFT_BOTTOM = 7;
ccui.RelativeLayoutParameter.PARENT_BOTTOM_CENTER_HORIZONTAL = 8;
ccui.RelativeLayoutParameter.PARENT_RIGHT_BOTTOM = 9;
ccui.RelativeLayoutParameter.LOCATION_ABOVE_LEFTALIGN = 10;
ccui.RelativeLayoutParameter.LOCATION_ABOVE_CENTER = 11;
ccui.RelativeLayoutParameter.LOCATION_ABOVE_RIGHTALIGN = 12;
ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_TOPALIGN = 13;
ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_CENTER = 14;
ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_BOTTOMALIGN = 15;
ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_TOPALIGN = 16;
ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_CENTER = 17;
ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_BOTTOMALIGN = 18;
ccui.RelativeLayoutParameter.LOCATION_BELOW_LEFTALIGN = 19;
ccui.RelativeLayoutParameter.LOCATION_BELOW_CENTER = 20;
ccui.RelativeLayoutParameter.LOCATION_BELOW_RIGHTALIGN = 21;
ccui.LINEAR_GRAVITY_NONE = 0;
ccui.LINEAR_GRAVITY_LEFT = 1;
ccui.LINEAR_GRAVITY_TOP = 2;
ccui.LINEAR_GRAVITY_RIGHT = 3;
ccui.LINEAR_GRAVITY_BOTTOM = 4;
ccui.LINEAR_GRAVITY_CENTER_VERTICAL = 5;
ccui.LINEAR_GRAVITY_CENTER_HORIZONTAL = 6;
ccui.RELATIVE_ALIGN_NONE = 0;
ccui.RELATIVE_ALIGN_PARENT_TOP_LEFT = 1;
ccui.RELATIVE_ALIGN_PARENT_TOP_CENTER_HORIZONTAL = 2;
ccui.RELATIVE_ALIGN_PARENT_TOP_RIGHT = 3;
ccui.RELATIVE_ALIGN_PARENT_LEFT_CENTER_VERTICAL = 4;
ccui.RELATIVE_ALIGN_PARENT_CENTER = 5;
ccui.RELATIVE_ALIGN_PARENT_RIGHT_CENTER_VERTICAL = 6;
ccui.RELATIVE_ALIGN_PARENT_LEFT_BOTTOM = 7;
ccui.RELATIVE_ALIGN_PARENT_BOTTOM_CENTER_HORIZONTAL = 8;
ccui.RELATIVE_ALIGN_PARENT_RIGHT_BOTTOM = 9;
ccui.RELATIVE_ALIGN_LOCATION_ABOVE_LEFT = 10;
ccui.RELATIVE_ALIGN_LOCATION_ABOVE_CENTER = 11;
ccui.RELATIVE_ALIGN_LOCATION_ABOVE_RIGHT = 12;
ccui.RELATIVE_ALIGN_LOCATION_LEFT_TOP = 13;
ccui.RELATIVE_ALIGN_LOCATION_LEFT_CENTER = 14;
ccui.RELATIVE_ALIGN_LOCATION_LEFT_BOTTOM = 15;
ccui.RELATIVE_ALIGN_LOCATION_RIGHT_TOP = 16;
ccui.RELATIVE_ALIGN_LOCATION_RIGHT_CENTER = 17;
ccui.RELATIVE_ALIGN_LOCATION_RIGHT_BOTTOM = 18;
ccui.RELATIVE_ALIGN_LOCATION_BELOW_TOP = 19;
ccui.RELATIVE_ALIGN_LOCATION_BELOW_CENTER = 20;
ccui.RELATIVE_ALIGN_LOCATION_BELOW_BOTTOM = 21;
ccui.LayoutManager = ccui.Class.extend({_doLayout: function (a) {
}});
ccui.LinearVerticalLayoutManager = ccui.LayoutManager.extend({_doLayout: function (a) {
    var b = a._getLayoutContentSize();
    a = a._getLayoutElements();
    for (var c = b.height, d = 0, e = a.length; d < e; d++) {
        var f = a[d];
        if (f) {
            var g = f.getLayoutParameter();
            if (g) {
                var h = g.getGravity(), k = f.getAnchorPoint(), m = f.getContentSize(), l = k.x * m.width, c = c - (1 - k.y) * m.height;
                switch (h) {
                    case ccui.LinearLayoutParameter.RIGHT:
                        l = b.width - (1 - k.x) * m.width;
                        break;
                    case ccui.LinearLayoutParameter.CENTER_HORIZONTAL:
                        l = b.width / 2 - m.width * (0.5 - k.x)
                }
                g = g.getMargin();
                l += g.left;
                c -= g.top;
                f.setPosition(l, c);
                c = f.getPositionY() - f.getAnchorPoint().y * f.getContentSize().height - g.bottom
            }
        }
    }
}});
ccui.LinearVerticalLayoutManager.create = function () {
    return new ccui.LinearVerticalLayoutManager
};
ccui.LinearHorizontalLayoutManager = ccui.LayoutManager.extend({_doLayout: function (a) {
    var b = a._getLayoutContentSize();
    a = a._getLayoutElements();
    for (var c = 0, d = 0, e = a.length; d < e; d++) {
        var f = a[d];
        if (f) {
            var g = f.getLayoutParameter();
            if (g) {
                var h = g.getGravity(), k = f.getAnchorPoint(), m = f.getSize(), c = c + k.x * m.width, l = b.height - (1 - k.y) * m.height;
                switch (h) {
                    case ccui.LinearLayoutParameter.BOTTOM:
                        l = k.y * m.height;
                        break;
                    case ccui.LinearLayoutParameter.CENTER_VERTICAL:
                        l = b.height / 2 - m.height * (0.5 - k.y)
                }
                g = g.getMargin();
                c += g.left;
                l -= g.top;
                f.setPosition(c, l);
                c = f.getRightBoundary() + g.right
            }
        }
    }
}});
ccui.LinearHorizontalLayoutManager.create = function () {
    return new ccui.LinearHorizontalLayoutManager
};
ccui.RelativeLayoutManager = ccui.LayoutManager.extend({_unlayoutChildCount: null, _widgetChildren: null, _widget: null, _finalPositionX: 0, _finalPositionY: 0, _relativeWidgetLP: null, _doLayout: function (a) {
    for (var b = this._widgetChildren = this._getAllWidgets(a); 0 < this._unlayoutChildCount;) {
        for (var c = 0, d = b.length; c < d; c++) {
            this._widget = b[c];
            var e = this._widget.getLayoutParameter();
            e && !e._put && this._caculateFinalPositionWithRelativeWidget(a) && (this._caculateFinalPositionWithRelativeAlign(), this._widget.setPosition(this._finalPositionX,
                this._finalPositionY), e._put = !0)
        }
        this._unlayoutChildCount--
    }
    this._widgetChildren.length = 0
}, _getAllWidgets: function (a) {
    a = a._getLayoutElements();
    for (var b = [], c = 0, d = a.length; c < d; c++) {
        var e = a[c];
        e && (e.getLayoutParameter()._put = !1, this._unlayoutChildCount++, b.push(e))
    }
    return b
}, _getRelativeWidget: function (a) {
    var b = null;
    if ((a = a.getLayoutParameter().getRelativeToWidgetName()) && 0 != a.length)for (var c = this._widgetChildren, d = 0, e = c.length; d < e; d++) {
        var f = c[d];
        if (f) {
            var g = f.getLayoutParameter();
            if (g && g.getRelativeName() ==
                a) {
                b = f;
                this._relativeWidgetLP = g;
                break
            }
        }
    }
    return b
}, _caculateFinalPositionWithRelativeWidget: function (a) {
    var b = this._widget, c = b.getAnchorPoint(), d = b.getContentSize();
    this._finalPositionY = this._finalPositionX = 0;
    var e = this._getRelativeWidget(b), b = b.getLayoutParameter().getAlign();
    a = a._getLayoutContentSize();
    switch (b) {
        case ccui.RelativeLayoutParameter.NONE:
        case ccui.RelativeLayoutParameter.PARENT_TOP_LEFT:
            this._finalPositionX = c.x * d.width;
            this._finalPositionY = a.height - (1 - c.y) * d.height;
            break;
        case ccui.RelativeLayoutParameter.PARENT_TOP_CENTER_HORIZONTAL:
            this._finalPositionX =
                0.5 * a.width - d.width * (0.5 - c.x);
            this._finalPositionY = a.height - (1 - c.y) * d.height;
            break;
        case ccui.RelativeLayoutParameter.PARENT_TOP_RIGHT:
            this._finalPositionX = a.width - (1 - c.x) * d.width;
            this._finalPositionY = a.height - (1 - c.y) * d.height;
            break;
        case ccui.RelativeLayoutParameter.PARENT_LEFT_CENTER_VERTICAL:
            this._finalPositionX = c.x * d.width;
            this._finalPositionY = 0.5 * a.height - d.height * (0.5 - c.y);
            break;
        case ccui.RelativeLayoutParameter.CENTER_IN_PARENT:
            this._finalPositionX = 0.5 * a.width - d.width * (0.5 - c.x);
            this._finalPositionY =
                0.5 * a.height - d.height * (0.5 - c.y);
            break;
        case ccui.RelativeLayoutParameter.PARENT_RIGHT_CENTER_VERTICAL:
            this._finalPositionX = a.width - (1 - c.x) * d.width;
            this._finalPositionY = 0.5 * a.height - d.height * (0.5 - c.y);
            break;
        case ccui.RelativeLayoutParameter.PARENT_LEFT_BOTTOM:
            this._finalPositionX = c.x * d.width;
            this._finalPositionY = c.y * d.height;
            break;
        case ccui.RelativeLayoutParameter.PARENT_BOTTOM_CENTER_HORIZONTAL:
            this._finalPositionX = 0.5 * a.width - d.width * (0.5 - c.x);
            this._finalPositionY = c.y * d.height;
            break;
        case ccui.RelativeLayoutParameter.PARENT_RIGHT_BOTTOM:
            this._finalPositionX =
                a.width - (1 - c.x) * d.width;
            this._finalPositionY = c.y * d.height;
            break;
        case ccui.RelativeLayoutParameter.LOCATION_ABOVE_LEFTALIGN:
            if (e) {
                if (this._relativeWidgetLP && !this._relativeWidgetLP._put)return!1;
                var b = e.getTopBoundary(), f = e.getLeftBoundary();
                this._finalPositionY = b + c.y * d.height;
                this._finalPositionX = f + c.x * d.width
            }
            break;
        case ccui.RelativeLayoutParameter.LOCATION_ABOVE_CENTER:
            if (e) {
                if (this._relativeWidgetLP && !this._relativeWidgetLP._put)return!1;
                a = e.getContentSize();
                b = e.getTopBoundary();
                this._finalPositionY =
                    b + c.y * d.height;
                this._finalPositionX = e.getLeftBoundary() + 0.5 * a.width + c.x * d.width - 0.5 * d.width
            }
            break;
        case ccui.RelativeLayoutParameter.LOCATION_ABOVE_RIGHTALIGN:
            if (e) {
                if (this._relativeWidgetLP && !this._relativeWidgetLP._put)return!1;
                b = e.getTopBoundary();
                f = e.getRightBoundary();
                this._finalPositionY = b + c.y * d.height;
                this._finalPositionX = f - (1 - c.x) * d.width
            }
            break;
        case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_TOPALIGN:
            if (e) {
                if (this._relativeWidgetLP && !this._relativeWidgetLP._put)return!1;
                b = e.getTopBoundary();
                f = e.getLeftBoundary();
                this._finalPositionY = b - (1 - c.y) * d.height;
                this._finalPositionX = f - (1 - c.x) * d.width
            }
            break;
        case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_CENTER:
            if (e) {
                if (this._relativeWidgetLP && !this._relativeWidgetLP._put)return!1;
                a = e.getContentSize();
                f = e.getLeftBoundary();
                this._finalPositionX = f - (1 - c.x) * d.width;
                this._finalPositionY = e.getBottomBoundary() + 0.5 * a.height + c.y * d.height - 0.5 * d.height
            }
            break;
        case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_BOTTOMALIGN:
            if (e) {
                if (this._relativeWidgetLP && !this._relativeWidgetLP._put)return!1;
                b = e.getBottomBoundary();
                f = e.getLeftBoundary();
                this._finalPositionY = b + c.y * d.height;
                this._finalPositionX = f - (1 - c.x) * d.width
            }
            break;
        case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_TOPALIGN:
            if (e) {
                if (this._relativeWidgetLP && !this._relativeWidgetLP._put)return!1;
                b = e.getTopBoundary();
                f = e.getRightBoundary();
                this._finalPositionY = b - (1 - c.y) * d.height;
                this._finalPositionX = f + c.x * d.width
            }
            break;
        case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_CENTER:
            if (e) {
                if (this._relativeWidgetLP && !this._relativeWidgetLP._put)return!1;
                a = e.getContentSize();
                f = e.getRightBoundary();
                this._finalPositionX = f + c.x * d.width;
                this._finalPositionY = e.getBottomBoundary() + 0.5 * a.height + c.y * d.height - 0.5 * d.height
            }
            break;
        case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_BOTTOMALIGN:
            if (e) {
                if (this._relativeWidgetLP && !this._relativeWidgetLP._put)return!1;
                b = e.getBottomBoundary();
                f = e.getRightBoundary();
                this._finalPositionY = b + c.y * d.height;
                this._finalPositionX = f + c.x * d.width
            }
            break;
        case ccui.RelativeLayoutParameter.LOCATION_BELOW_LEFTALIGN:
            if (e) {
                if (this._relativeWidgetLP && !this._relativeWidgetLP._put)return!1;
                b = e.getBottomBoundary();
                f = e.getLeftBoundary();
                this._finalPositionY = b - (1 - c.y) * d.height;
                this._finalPositionX = f + c.x * d.width
            }
            break;
        case ccui.RelativeLayoutParameter.LOCATION_BELOW_CENTER:
            if (e) {
                if (this._relativeWidgetLP && !this._relativeWidgetLP._put)return!1;
                a = e.getContentSize();
                b = e.getBottomBoundary();
                this._finalPositionY = b - (1 - c.y) * d.height;
                this._finalPositionX = e.getLeftBoundary() + 0.5 * a.width + c.x * d.width - 0.5 * d.width
            }
            break;
        case ccui.RelativeLayoutParameter.LOCATION_BELOW_RIGHTALIGN:
            if (e) {
                if (this._relativeWidgetLP && !this._relativeWidgetLP._put)return!1;
                b = e.getBottomBoundary();
                f = e.getRightBoundary();
                this._finalPositionY = b - (1 - c.y) * d.height;
                this._finalPositionX = f - (1 - c.x) * d.width
            }
    }
    return!0
}, _caculateFinalPositionWithRelativeAlign: function () {
    var a = this._widget.getLayoutParameter(), b = a.getMargin();
    switch (a.getAlign()) {
        case ccui.RelativeLayoutParameter.NONE:
        case ccui.RelativeLayoutParameter.PARENT_TOP_LEFT:
            this._finalPositionX += b.left;
            this._finalPositionY -= b.top;
            break;
        case ccui.RelativeLayoutParameter.PARENT_TOP_CENTER_HORIZONTAL:
            this._finalPositionY -=
                b.top;
            break;
        case ccui.RelativeLayoutParameter.PARENT_TOP_RIGHT:
            this._finalPositionX -= b.right;
            this._finalPositionY -= b.top;
            break;
        case ccui.RelativeLayoutParameter.PARENT_LEFT_CENTER_VERTICAL:
            this._finalPositionX += b.left;
            break;
        case ccui.RelativeLayoutParameter.PARENT_RIGHT_CENTER_VERTICAL:
            this._finalPositionX -= b.right;
            break;
        case ccui.RelativeLayoutParameter.PARENT_LEFT_BOTTOM:
            this._finalPositionX += b.left;
            this._finalPositionY += b.bottom;
            break;
        case ccui.RelativeLayoutParameter.PARENT_BOTTOM_CENTER_HORIZONTAL:
            this._finalPositionY +=
                b.bottom;
            break;
        case ccui.RelativeLayoutParameter.PARENT_RIGHT_BOTTOM:
            this._finalPositionX -= b.right;
            this._finalPositionY += b.bottom;
            break;
        case ccui.RelativeLayoutParameter.LOCATION_ABOVE_LEFTALIGN:
            this._finalPositionY += b.bottom;
            this._finalPositionX += b.left;
            break;
        case ccui.RelativeLayoutParameter.LOCATION_ABOVE_RIGHTALIGN:
            this._finalPositionY += b.bottom;
            this._finalPositionX -= b.right;
            break;
        case ccui.RelativeLayoutParameter.LOCATION_ABOVE_CENTER:
            this._finalPositionY += b.bottom;
            break;
        case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_TOPALIGN:
            this._finalPositionX -=
                b.right;
            this._finalPositionY -= b.top;
            break;
        case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_BOTTOMALIGN:
            this._finalPositionX -= b.right;
            this._finalPositionY += b.bottom;
            break;
        case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_CENTER:
            this._finalPositionX -= b.right;
            break;
        case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_TOPALIGN:
            this._finalPositionX += b.left;
            this._finalPositionY -= b.top;
            break;
        case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_BOTTOMALIGN:
            this._finalPositionX += b.left;
            this._finalPositionY +=
                b.bottom;
            break;
        case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_CENTER:
            this._finalPositionX += b.left;
            break;
        case ccui.RelativeLayoutParameter.LOCATION_BELOW_LEFTALIGN:
            this._finalPositionY -= b.top;
            this._finalPositionX += b.left;
            break;
        case ccui.RelativeLayoutParameter.LOCATION_BELOW_RIGHTALIGN:
            this._finalPositionY -= b.top;
            this._finalPositionX -= b.right;
            break;
        case ccui.RelativeLayoutParameter.LOCATION_BELOW_CENTER:
            this._finalPositionY -= b.top
    }
}});
ccui.RelativeLayoutManager.create = function () {
    return new ccui.RelativeLayoutManager
};
ccui.HBox = ccui.Layout.extend({init: function () {
    return ccui.Layout.prototype.init.call(this) ? (this.setLayoutType(ccui.Layout.LINEAR_HORIZONTAL), !0) : !1
}, initWithSize: function (a) {
    return this.init() ? (this.setSize(a), !0) : !1
}});
ccui.HBox.create = function (a) {
    var b = new ccui.HBox;
    return a ? b.initWithSize() ? b : null : b
};
ccui.RelativeBox = ccui.Layout.extend({init: function () {
    return ccui.Layout.prototype.init.call(this) ? (this.setLayoutType(ccui.Layout.RELATIVE), !0) : !1
}, initWithSize: function (a) {
    return this.init() ? (this.setSize(a), !0) : !1
}});
ccui.RelativeBox.create = function (a) {
    var b = new ccui.RelativeBox;
    return a ? b.initWithSize() ? b : null : b
};
ccui.VBox = ccui.Layout.extend({init: function () {
    return ccui.Layout.prototype.init.call(this) ? (this.setLayoutType(ccui.Layout.VERTICAL), !0) : !1
}, initWithSize: function (a) {
    return this.init() ? (this.setSize(a), !0) : !1
}});
ccui.VBox.create = function (a) {
    var b = new ccui.VBox;
    return a ? b.initWithSize() ? b : null : b
};
ccui.helper = {seekWidgetByTag: function (a, b) {
    if (!a)return null;
    if (a.getTag() == b)return a;
    for (var c = a.getChildren(), d = c.length, e = 0; e < d; e++) {
        var f = ccui.helper.seekWidgetByTag(c[e], b);
        if (null != f)return f
    }
    return null
}, seekWidgetByName: function (a, b) {
    if (!a)return null;
    if (a.getName() == b)return a;
    for (var c = a.getChildren(), d = c.length, e = 0; e < d; e++) {
        var f = ccui.helper.seekWidgetByName(c[e], b);
        if (null != f)return f
    }
    return null
}, seekWidgetByRelativeName: function (a, b) {
    if (!a)return null;
    for (var c = a.getChildren(), d = c.length,
             e = 0; e < d; e++) {
        var f = c[e], g = f.getLayoutParameter(ccui.LayoutParameter.RELATIVE);
        if (g && g.getRelativeName() == b)return f
    }
    return null
}, seekActionWidgetByActionTag: function (a, b) {
    if (!a)return null;
    if (a.getActionTag() == b)return a;
    for (var c = a.getChildren(), d = 0; d < c.length; d++) {
        var e = ccui.helper.seekActionWidgetByActionTag(c[d], b);
        if (null != e)return e
    }
    return null
}};
ccui.Button = ccui.Widget.extend({_buttonNormalRenderer: null, _buttonClickedRenderer: null, _buttonDisableRenderer: null, _titleRenderer: null, _normalFileName: "", _clickedFileName: "", _disabledFileName: "", _prevIgnoreSize: !0, _scale9Enabled: !1, _capInsetsNormal: null, _capInsetsPressed: null, _capInsetsDisabled: null, _normalTexType: ccui.Widget.LOCAL_TEXTURE, _pressedTexType: ccui.Widget.LOCAL_TEXTURE, _disabledTexType: ccui.Widget.LOCAL_TEXTURE, _normalTextureSize: null, _pressedTextureSize: null, _disabledTextureSize: null,
    pressedActionEnabled: !1, _titleColor: null, _normalTextureScaleXInSize: 1, _normalTextureScaleYInSize: 1, _pressedTextureScaleXInSize: 1, _pressedTextureScaleYInSize: 1, _normalTextureLoaded: !1, _pressedTextureLoaded: !1, _disabledTextureLoaded: !1, _cascadeOpacityEnabled: !0, _className: "Button", _normalTextureAdaptDirty: !0, _pressedTextureAdaptDirty: !0, _disabledTextureAdaptDirty: !0, _fontName: "Thonburi", _fontSize: 12, _type: 0, ctor: function () {
        this._capInsetsNormal = cc.rect(0, 0, 0, 0);
        this._capInsetsPressed = cc.rect(0, 0, 0,
            0);
        this._capInsetsDisabled = cc.rect(0, 0, 0, 0);
        var a = this._size;
        this._normalTextureSize = cc.size(a.width, a.height);
        this._pressedTextureSize = cc.size(a.width, a.height);
        this._disabledTextureSize = cc.size(a.width, a.height);
        this._titleColor = cc.color.WHITE;
        ccui.Widget.prototype.ctor.call(this)
    }, init: function (a, b, c, d) {
        if (ccui.Widget.prototype.init.call(this)) {
            this.setTouchEnabled(!0);
            if (void 0 === a)return!0;
            this.loadTextures(a, b, c, d)
        }
        return!1
    }, initRenderer: function () {
        this._buttonNormalRenderer = cc.Sprite.create();
        this._buttonClickedRenderer = cc.Sprite.create();
        this._buttonDisableRenderer = cc.Sprite.create();
        this._titleRenderer = cc.LabelTTF.create("");
        this.addProtectedChild(this._buttonNormalRenderer, ccui.Button.NORMAL_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._buttonClickedRenderer, ccui.Button.PRESSED_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._buttonDisableRenderer, ccui.Button.DISABLED_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._titleRenderer, ccui.Button.TITLE_RENDERER_ZORDER, -1)
    }, setScale9Enabled: function (a) {
        this._scale9Enabled !=
        a && (this._brightStyle = ccui.Widget.BRIGHT_STYLE_NONE, this._scale9Enabled = a, this.removeProtectedChild(this._buttonNormalRenderer), this.removeProtectedChild(this._buttonClickedRenderer), this.removeProtectedChild(this._buttonDisableRenderer), this._scale9Enabled ? (this._buttonNormalRenderer = cc.Scale9Sprite.create(), this._buttonClickedRenderer = cc.Scale9Sprite.create(), this._buttonDisableRenderer = cc.Scale9Sprite.create()) : (this._buttonNormalRenderer = cc.Sprite.create(), this._buttonClickedRenderer = cc.Sprite.create(),
            this._buttonDisableRenderer = cc.Sprite.create()), this.loadTextureNormal(this._normalFileName, this._normalTexType), this.loadTexturePressed(this._clickedFileName, this._pressedTexType), this.loadTextureDisabled(this._disabledFileName, this._disabledTexType), this.addProtectedChild(this._buttonNormalRenderer, ccui.Button.NORMAL_RENDERER_ZORDER, -1), this.addProtectedChild(this._buttonClickedRenderer, ccui.Button.PRESSED_RENDERER_ZORDER, -1), this.addProtectedChild(this._buttonDisableRenderer, ccui.Button.DISABLED_RENDERER_ZORDER,
            -1), this._scale9Enabled ? (a = this._ignoreSize, this.ignoreContentAdaptWithSize(!1), this._prevIgnoreSize = a) : this.ignoreContentAdaptWithSize(this._prevIgnoreSize), this.setCapInsetsNormalRenderer(this._capInsetsNormal), this.setCapInsetsPressedRenderer(this._capInsetsPressed), this.setCapInsetsDisabledRenderer(this._capInsetsDisabled), this.setBright(this._bright))
    }, isScale9Enabled: function () {
        return this._scale9Enabled
    }, ignoreContentAdaptWithSize: function (a) {
        if (!this._scale9Enabled || this._scale9Enabled && !a)ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this,
            a), this._prevIgnoreSize = a
    }, getVirtualRendererSize: function () {
        return this._normalTextureSize
    }, loadTextures: function (a, b, c, d) {
        this.loadTextureNormal(a, d);
        this.loadTexturePressed(b, d);
        this.loadTextureDisabled(c, d)
    }, loadTextureNormal: function (a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._normalFileName = a;
            this._normalTexType = b;
            if (this._scale9Enabled) {
                var c = this._buttonNormalRenderer;
                switch (this._normalTexType) {
                    case ccui.Widget.LOCAL_TEXTURE:
                        c.initWithFile(a);
                        break;
                    case ccui.Widget.PLIST_TEXTURE:
                        c.initWithSpriteFrameName(a)
                }
                c.setCapInsets(this._capInsetsNormal)
            } else switch (c =
                this._buttonNormalRenderer, this._normalTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    c.setTexture(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    c.setSpriteFrame(a)
            }
            this._normalTextureSize = this._buttonNormalRenderer.getContentSize();
            this.updateFlippedX();
            this.updateFlippedY();
            this._buttonNormalRenderer.setColor(this.getColor());
            this._buttonNormalRenderer.setOpacity(this.getOpacity());
            this._updateContentSizeWithTextureSize(this._normalTextureSize);
            this._normalTextureAdaptDirty = this._normalTextureLoaded = !0
        }
    }, loadTexturePressed: function (a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._clickedFileName = a;
            this._pressedTexType = b;
            if (this._scale9Enabled) {
                var c = this._buttonClickedRenderer;
                switch (this._pressedTexType) {
                    case ccui.Widget.LOCAL_TEXTURE:
                        c.initWithFile(a);
                        break;
                    case ccui.Widget.PLIST_TEXTURE:
                        c.initWithSpriteFrameName(a)
                }
                c.setCapInsets(this._capInsetsPressed)
            } else switch (c = this._buttonClickedRenderer, this._pressedTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    c.setTexture(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    c.setSpriteFrame(a)
            }
            this._pressedTextureSize =
                this._buttonClickedRenderer.getContentSize();
            this.updateFlippedX();
            this.updateFlippedY();
            this._buttonDisableRenderer.setColor(this.getColor());
            this._buttonDisableRenderer.setOpacity(this.getOpacity());
            this._pressedTextureAdaptDirty = this._pressedTextureLoaded = !0
        }
    }, loadTextureDisabled: function (a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._disabledFileName = a;
            this._disabledTexType = b;
            if (this._scale9Enabled) {
                var c = this._buttonDisableRenderer;
                switch (this._disabledTexType) {
                    case ccui.Widget.LOCAL_TEXTURE:
                        c.initWithFile(a);
                        break;
                    case ccui.Widget.PLIST_TEXTURE:
                        c.initWithSpriteFrameName(a)
                }
                c.setCapInsets(this._capInsetsDisabled)
            } else switch (c = this._buttonDisableRenderer, this._disabledTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    c.setTexture(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    c.setSpriteFrame(a)
            }
            this._disabledTextureSize = this._buttonDisableRenderer.getContentSize();
            this.updateFlippedX();
            this.updateFlippedY();
            this._buttonDisableRenderer.setColor(this.getColor());
            this._buttonDisableRenderer.setOpacity(this.getOpacity());
            this._disabledTextureAdaptDirty = this._disabledTextureLoaded = !0
        }
    }, setCapInsets: function (a) {
        this.setCapInsetsNormalRenderer(a);
        this.setCapInsetsPressedRenderer(a);
        this.setCapInsetsDisabledRenderer(a)
    }, setCapInsetsNormalRenderer: function (a) {
        this._capInsetsNormal = a;
        this._scale9Enabled && this._buttonNormalRenderer.setCapInsets(a)
    }, getCapInsetsNormalRenderer: function () {
        return this._capInsetsNormal
    }, setCapInsetsPressedRenderer: function (a) {
        this._capInsetsPressed = a;
        this._scale9Enabled && this._buttonClickedRenderer.setCapInsets(a)
    },
    getCapInsetsPressedRenderer: function () {
        return this._capInsetsPressed
    }, setCapInsetsDisabledRenderer: function (a) {
        this._capInsetsDisabled = a;
        this._scale9Enabled && this._buttonDisableRenderer.setCapInsets(a)
    }, getCapInsetsDisabledRenderer: function () {
        return this._capInsetsDisabled
    }, onPressStateChangedToNormal: function () {
        this._buttonNormalRenderer.setVisible(!0);
        this._buttonClickedRenderer.setVisible(!1);
        this._buttonDisableRenderer.setVisible(!1);
        if (this._pressedTextureLoaded) {
            if (this.pressedActionEnabled) {
                this._buttonNormalRenderer.stopAllActions();
                this._buttonClickedRenderer.stopAllActions();
                var a = cc.ScaleTo.create(0.05, this._normalTextureScaleXInSize, this._normalTextureScaleYInSize);
                this._buttonNormalRenderer.runAction(a);
                this._buttonClickedRenderer.setScale(this._pressedTextureScaleXInSize, this._pressedTextureScaleYInSize)
            }
        } else this._scale9Enabled ? this.updateTexturesRGBA() : (this._buttonNormalRenderer.stopAllActions(), this._buttonNormalRenderer.setScale(this._normalTextureScaleXInSize, this._normalTextureScaleYInSize))
    }, onPressStateChangedToPressed: function () {
        if (this._pressedTextureLoaded) {
            if (this._buttonNormalRenderer.setVisible(!1),
                this._buttonClickedRenderer.setVisible(!0), this._buttonDisableRenderer.setVisible(!1), this.pressedActionEnabled) {
                this._buttonNormalRenderer.stopAllActions();
                this._buttonClickedRenderer.stopAllActions();
                var a = cc.ScaleTo.create(0.05, this._pressedTextureScaleXInSize + 0.1, this._pressedTextureScaleYInSize + 0.1);
                this._buttonClickedRenderer.runAction(a);
                this._buttonNormalRenderer.setScale(this._pressedTextureScaleXInSize + 0.1, this._pressedTextureScaleYInSize + 0.1)
            }
        } else this._buttonNormalRenderer.setVisible(!0),
            this._buttonClickedRenderer.setVisible(!0), this._buttonDisableRenderer.setVisible(!1), this._scale9Enabled ? this._buttonNormalRenderer.setColor(cc.Color.GRAY) : (this._buttonNormalRenderer.stopAllActions(), this._buttonNormalRenderer.setScale(this._normalTextureScaleXInSize + 0.1, this._normalTextureScaleYInSize + 0.1))
    }, onPressStateChangedToDisabled: function () {
        this._buttonNormalRenderer.setVisible(!1);
        this._buttonClickedRenderer.setVisible(!1);
        this._buttonDisableRenderer.setVisible(!0);
        this._buttonNormalRenderer.setScale(this._normalTextureScaleXInSize,
            this._normalTextureScaleYInSize);
        this._buttonClickedRenderer.setScale(this._pressedTextureScaleXInSize, this._pressedTextureScaleYInSize)
    }, setFlippedX: function (a) {
        this._titleRenderer.setFlippedX(a);
        this._scale9Enabled || (this._buttonNormalRenderer.setFlippedX(a), this._buttonClickedRenderer.setFlippedX(a), this._buttonDisableRenderer.setFlippedX(a))
    }, setFlipY: function (a) {
        this._titleRenderer.setFlippedY(a);
        this._scale9Enabled || (this._buttonNormalRenderer.setFlippedY(a), this._buttonClickedRenderer.setFlippedY(a),
            this._buttonDisableRenderer.setFlippedY(a))
    }, isFlippedX: function () {
        return this._scale9Enabled ? !1 : this._buttonNormalRenderer.isFlippedX()
    }, isFlippedY: function () {
        return this._scale9Enabled ? !1 : this._buttonNormalRenderer.isFlippedY()
    }, updateFlippedX: function () {
        var a = this._flippedX ? -1 : 1;
        this._titleRenderer.setScaleX(a);
        this._scale9Enabled ? (this._buttonNormalRenderer.setScaleX(a), this._buttonClickedRenderer.setScaleX(a), this._buttonDisableRenderer.setScaleX(a)) : (this._buttonNormalRenderer.setFlippedX(this._flippedX),
            this._buttonClickedRenderer.setFlippedX(this._flippedX), this._buttonDisableRenderer.setFlippedX(this._flippedX))
    }, updateFlippedY: function () {
        var a = this._flippedY ? -1 : 1;
        this._titleRenderer.setScaleY(a);
        this._scale9Enabled ? (this._buttonNormalRenderer.setScaleY(a), this._buttonClickedRenderer.setScaleY(a), this._buttonDisableRenderer.setScaleY(a)) : (this._buttonNormalRenderer.setFlippedY(this._flippedY), this._buttonClickedRenderer.setFlippedY(this._flippedY), this._buttonDisableRenderer.setFlippedY(this._flippedY))
    },
    updateTexturesRGBA: function () {
        this._buttonNormalRenderer.setColor(this.getColor());
        this._buttonClickedRenderer.setColor(this.getColor());
        this._buttonDisableRenderer.setColor(this.getColor());
        this._buttonNormalRenderer.setOpacity(this.getOpacity());
        this._buttonClickedRenderer.setOpacity(this.getOpacity());
        this._buttonDisableRenderer.setOpacity(this.getOpacity())
    }, setAnchorPoint: function (a, b) {
        void 0 === b ? (ccui.Widget.prototype.setAnchorPoint.call(this, a), this._buttonNormalRenderer.setAnchorPoint(a),
            this._buttonClickedRenderer.setAnchorPoint(a), this._buttonDisableRenderer.setAnchorPoint(a)) : (ccui.Widget.prototype.setAnchorPoint.call(this, a, b), this._buttonNormalRenderer.setAnchorPoint(a, b), this._buttonClickedRenderer.setAnchorPoint(a, b), this._buttonDisableRenderer.setAnchorPoint(a, b));
        this._titleRenderer.setPosition(this._size.width * (0.5 - this._anchorPoint.x), this._size.height * (0.5 - this._anchorPoint.y))
    }, _setAnchorX: function (a) {
        ccui.Widget.prototype._setAnchorX.call(this, a);
        this._buttonNormalRenderer._setAnchorX(a);
        this._buttonClickedRenderer._setAnchorX(a);
        this._buttonDisableRenderer._setAnchorX(a);
        this._titleRenderer.setPositionX(this._size.width * (0.5 - this._anchorPoint.x))
    }, _setAnchorY: function (a) {
        ccui.Widget.prototype._setAnchorY.call(this, a);
        this._buttonNormalRenderer._setAnchorY(a);
        this._buttonClickedRenderer._setAnchorY(a);
        this._buttonDisableRenderer._setAnchorY(a);
        this._titleRenderer.setPositionY(this._size.height * (0.5 - this._anchorPoint.y))
    }, onSizeChanged: function () {
        ccui.Widget.prototype.onSizeChanged.call(this);
        this.updateTitleLocation();
        this.normalTextureScaleChangedWithSize();
        this.pressedTextureScaleChangedWithSize();
        this.disabledTextureScaleChangedWithSize()
    }, getContentSize: function () {
        return this._normalTextureSize
    }, _getWidth: function () {
        return this._scale9Enabled ? this._size.width : this._normalTextureSize.width
    }, _getHeight: function () {
        return this._scale9Enabled ? this._size.height : this._normalTextureSize.height
    }, getVirtualRenderer: function () {
        if (this._bright)switch (this._brightStyle) {
            case ccui.Widget.BRIGHT_STYLE_NORMAL:
                return this._buttonNormalRenderer;
            case ccui.Widget.BRIGHT_STYLE_HIGH_LIGHT:
                return this._buttonClickedRenderer;
            default:
                return null
        } else return this._buttonDisableRenderer
    }, normalTextureScaleChangedWithSize: function () {
        if (this._ignoreSize)this._scale9Enabled || (this._buttonNormalRenderer.setScale(1), this._normalTextureScaleXInSize = this._normalTextureScaleYInSize = 1); else if (this._scale9Enabled)this._buttonNormalRenderer.setPreferredSize(this._size), this._normalTextureScaleXInSize = this._normalTextureScaleYInSize = 1; else {
            var a = this._normalTextureSize;
            if (0 >= a.width || 0 >= a.height) {
                this._buttonNormalRenderer.setScale(1);
                return
            }
            var b = this._size.width / a.width, a = this._size.height / a.height;
            this._buttonNormalRenderer.setScaleX(b);
            this._buttonNormalRenderer.setScaleY(a);
            this._normalTextureScaleXInSize = b;
            this._normalTextureScaleYInSize = a
        }
        this._buttonNormalRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    }, pressedTextureScaleChangedWithSize: function () {
        if (this._ignoreSize)this._scale9Enabled || (this._buttonClickedRenderer.setScale(1),
            this._pressedTextureScaleXInSize = this._pressedTextureScaleYInSize = 1); else if (this._scale9Enabled)this._buttonClickedRenderer.setPreferredSize(this._size), this._pressedTextureScaleXInSize = this._pressedTextureScaleYInSize = 1; else {
            var a = this._pressedTextureSize;
            if (0 >= a.width || 0 >= a.height) {
                this._buttonClickedRenderer.setScale(1);
                return
            }
            var b = this._size.width / a.width, a = this._size.height / a.height;
            this._buttonClickedRenderer.setScaleX(b);
            this._buttonClickedRenderer.setScaleY(a);
            this._pressedTextureScaleXInSize =
                b;
            this._pressedTextureScaleYInSize = a
        }
        this._buttonClickedRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    }, disabledTextureScaleChangedWithSize: function () {
        if (this._ignoreSize)this._scale9Enabled || this._buttonDisableRenderer.setScale(1); else if (this._scale9Enabled)this._buttonDisableRenderer.setPreferredSize(this._size); else {
            var a = this._disabledTextureSize;
            if (0 >= a.width || 0 >= a.height) {
                this._buttonDisableRenderer.setScale(1);
                return
            }
            var b = this._size.height / a.height;
            this._buttonDisableRenderer.setScaleX(this._size.width /
                a.width);
            this._buttonDisableRenderer.setScaleY(b)
        }
        this._buttonDisableRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    }, adaptRenderers: function () {
        this._normalTextureAdaptDirty && (this.normalTextureScaleChangedWithSize(), this._normalTextureAdaptDirty = !1);
        this._pressedTextureAdaptDirty && (this.pressedTextureScaleChangedWithSize(), this._pressedTextureAdaptDirty = !1);
        this._disabledTextureAdaptDirty && (this.disabledTextureScaleChangedWithSize(), this._disabledTextureAdaptDirty = !1)
    },
    updateTitleLocation: function () {
        this._titleRenderer.setPosition(0.5 * this._contentSize.width, 0.5 * this._contentSize.height)
    }, setPressedActionEnabled: function (a) {
        this.pressedActionEnabled = a
    }, setTitleText: function (a) {
        this._titleRenderer.setString(a)
    }, getTitleText: function () {
        return this._titleRenderer.getString()
    }, setTitleColor: function (a) {
        this._titleColor.r = a.r;
        this._titleColor.g = a.g;
        this._titleColor.b = a.b;
        this._titleRenderer.updateDisplayedColor(a)
    }, getTitleColor: function () {
        return this._titleRenderer.getColor()
    },
    setTitleFontSize: function (a) {
        this._titleRenderer.setFontSize(a)
    }, getTitleFontSize: function () {
        return this._titleRenderer.getFontSize()
    }, setTitleFontName: function (a) {
        this._titleRenderer.setFontName(a)
    }, getTitleFontName: function () {
        return this._titleRenderer.getFontName()
    }, _setTitleFont: function (a) {
        this._titleRenderer.font = a
    }, _getTitleFont: function () {
        return this._titleRenderer.font
    }, updateTextureColor: function () {
        this.updateColorToRenderer(this._buttonNormalRenderer);
        this.updateColorToRenderer(this._buttonClickedRenderer);
        this.updateColorToRenderer(this._buttonDisableRenderer)
    }, getDescription: function () {
        return"Button"
    }, createCloneInstance: function () {
        return ccui.Button.create()
    }, copySpecialProperties: function (a) {
        this._prevIgnoreSize = a._prevIgnoreSize;
        this.setScale9Enabled(a._scale9Enabled);
        this.loadTextureNormal(a._normalFileName, a._normalTexType);
        this.loadTexturePressed(a._clickedFileName, a._pressedTexType);
        this.loadTextureDisabled(a._disabledFileName, a._disabledTexType);
        this.setCapInsetsNormalRenderer(a._capInsetsNormal);
        this.setCapInsetsPressedRenderer(a._capInsetsPressed);
        this.setCapInsetsDisabledRenderer(a._capInsetsDisabled);
        this.setTitleText(a.getTitleText());
        this.setTitleFontName(a.getTitleFontName());
        this.setTitleFontSize(a.getTitleFontSize());
        this.setTitleColor(a.getTitleColor());
        this.setPressedActionEnabled(a.pressedActionEnabled)
    }});
_p = ccui.Button.prototype;
cc.defineGetterSetter(_p, "titleText", _p.getTitleText, _p.setTitleText);
cc.defineGetterSetter(_p, "titleFont", _p._getTitleFont, _p._setTitleFont);
cc.defineGetterSetter(_p, "titleFontSize", _p.getTitleFontSize, _p.setTitleFontSize);
cc.defineGetterSetter(_p, "titleFontName", _p.getTitleFontName, _p.setTitleFontName);
cc.defineGetterSetter(_p, "titleColor", _p.getTitleColor, _p.setTitleColor);
_p = null;
ccui.Button.create = function (a, b, c, d) {
    var e = new ccui.Button;
    if (void 0 === a)return e;
    e.init(a, b, c, d)
};
ccui.Button.NORMAL_RENDERER_ZORDER = -2;
ccui.Button.PRESSED_RENDERER_ZORDER = -2;
ccui.Button.DISABLED_RENDERER_ZORDER = -2;
ccui.Button.TITLE_RENDERER_ZORDER = -1;
ccui.Button.SYSTEM = 0;
ccui.Button.TTF = 1;
ccui.CheckBox = ccui.Widget.extend({_backGroundBoxRenderer: null, _backGroundSelectedBoxRenderer: null, _frontCrossRenderer: null, _backGroundBoxDisabledRenderer: null, _frontCrossDisabledRenderer: null, _isSelected: !0, _checkBoxEventListener: null, _checkBoxEventSelector: null, _checkBoxEventCallback: null, _backGroundTexType: ccui.Widget.LOCAL_TEXTURE, _backGroundSelectedTexType: ccui.Widget.LOCAL_TEXTURE, _frontCrossTexType: ccui.Widget.LOCAL_TEXTURE, _backGroundDisabledTexType: ccui.Widget.LOCAL_TEXTURE, _frontCrossDisabledTexType: ccui.Widget.LOCAL_TEXTURE,
    _backGroundFileName: "", _backGroundSelectedFileName: "", _frontCrossFileName: "", _backGroundDisabledFileName: "", _frontCrossDisabledFileName: "", _className: "CheckBox", _backGroundBoxRendererAdaptDirty: !0, _backGroundSelectedBoxRendererAdaptDirty: !0, _frontCrossRendererAdaptDirty: !0, _backGroundBoxDisabledRendererAdaptDirty: !0, _frontCrossDisabledRendererAdaptDirty: !0, ctor: function () {
        ccui.Widget.prototype.ctor.call(this)
    }, init: function (a, b, c, d, e, f) {
        return ccui.Widget.prototype.init.call(this) ? (this._isSelected = !0, this.setTouchEnabled(!0), void 0 === a && this.loadTextures(a, b, c, d, e, f), !0) : !1
    }, initRenderer: function () {
        this._backGroundBoxRenderer = cc.Sprite.create();
        this._backGroundSelectedBoxRenderer = cc.Sprite.create();
        this._frontCrossRenderer = cc.Sprite.create();
        this._backGroundBoxDisabledRenderer = cc.Sprite.create();
        this._frontCrossDisabledRenderer = cc.Sprite.create();
        this.addProtectedChild(this._backGroundBoxRenderer, ccui.CheckBox.BOX_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._backGroundSelectedBoxRenderer,
            ccui.CheckBox.BOX_SELECTED_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._frontCrossRenderer, ccui.CheckBox.FRONT_CROSS_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._backGroundBoxDisabledRenderer, ccui.CheckBox.BOX_DISABLED_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._frontCrossDisabledRenderer, ccui.CheckBox.FRONT_CROSS_DISABLED_RENDERER_ZORDER, -1);
        window.test = [this._backGroundBoxRenderer, this._backGroundSelectedBoxRenderer, this._frontCrossRenderer, this._backGroundBoxDisabledRenderer, this._frontCrossDisabledRenderer];
        window.a = this
    }, loadTextures: function (a, b, c, d, e, f) {
        this.loadTextureBackGround(a, f);
        this.loadTextureBackGroundSelected(b, f);
        this.loadTextureFrontCross(c, f);
        this.loadTextureBackGroundDisabled(d, f);
        this.loadTextureFrontCrossDisabled(e, f)
    }, loadTextureBackGround: function (a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._backGroundFileName = a;
            this._backGroundTexType = b;
            var c = this._backGroundBoxRenderer;
            switch (this._backGroundTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    c.setTexture(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    c.setSpriteFrame(a)
            }
            this.backGroundTextureScaleChangedWithSize();
            c.textureLoaded() || (this._backGroundBoxRenderer.setContentSize(this._customSize), c.addLoadedEventListener(function () {
                this.backGroundTextureScaleChangedWithSize()
            }, this));
            this.updateFlippedX();
            this.updateFlippedY();
            this._backGroundBoxRenderer.setColor(this.getColor());
            this._backGroundBoxRenderer.setOpacity(this.getOpacity());
            this._updateContentSizeWithTextureSize(this._backGroundBoxRenderer.getContentSize());
            this._backGroundBoxRendererAdaptDirty = !0
        }
    }, loadTextureBackGroundSelected: function (a, b) {
        if (a) {
            b =
                b || ccui.Widget.LOCAL_TEXTURE;
            this._backGroundSelectedFileName = a;
            this._backGroundSelectedTexType = b;
            switch (this._backGroundSelectedTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._backGroundSelectedBoxRenderer.setTexture(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._backGroundSelectedBoxRenderer.setSpriteFrame(a)
            }
            this.updateFlippedX();
            this.updateFlippedY();
            this._backGroundSelectedBoxRenderer.setColor(this.getColor());
            this._backGroundSelectedBoxRenderer.setOpacity(this.getOpacity());
            this._backGroundSelectedBoxRendererAdaptDirty = !0
        }
    }, loadTextureFrontCross: function (a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._frontCrossFileName = a;
            this._frontCrossTexType = b;
            switch (this._frontCrossTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._frontCrossRenderer.setTexture(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._frontCrossRenderer.setSpriteFrame(a)
            }
            this.updateFlippedX();
            this.updateFlippedY();
            this._frontCrossRenderer.setColor(this.getColor());
            this._frontCrossRenderer.setOpacity(this.getOpacity());
            this._frontCrossRendererAdaptDirty = !0
        }
    },
    loadTextureBackGroundDisabled: function (a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._backGroundDisabledFileName = a;
            this._backGroundDisabledTexType = b;
            switch (this._backGroundDisabledTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._backGroundBoxDisabledRenderer.setTexture(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._backGroundBoxDisabledRenderer.setSpriteFrame(a)
            }
            this.updateFlippedX();
            this.updateFlippedY();
            this._backGroundBoxDisabledRenderer.setColor(this.getColor());
            this._backGroundBoxDisabledRenderer.setOpacity(this.getOpacity());
            this._backGroundBoxDisabledRendererAdaptDirty = !0
        }
    }, loadTextureFrontCrossDisabled: function (a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._frontCrossDisabledFileName = a;
            this._frontCrossDisabledTexType = b;
            switch (this._frontCrossDisabledTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._frontCrossDisabledRenderer.setTexture(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._frontCrossDisabledRenderer.setSpriteFrame(a)
            }
            this.updateFlippedX();
            this.updateFlippedY();
            this._frontCrossDisabledRenderer.setColor(this.getColor());
            this._frontCrossDisabledRenderer.setOpacity(this.getOpacity());
            this._frontCrossDisabledRendererAdaptDirty = !0
        }
    }, onPressStateChangedToNormal: function () {
        this._backGroundBoxRenderer.setVisible(!0);
        this._backGroundSelectedBoxRenderer.setVisible(!1);
        this._backGroundBoxDisabledRenderer.setVisible(!1);
        this._frontCrossDisabledRenderer.setVisible(!1)
    }, onPressStateChangedToPressed: function () {
        this._backGroundBoxRenderer.setVisible(!1);
        this._backGroundSelectedBoxRenderer.setVisible(!0);
        this._backGroundBoxDisabledRenderer.setVisible(!1);
        this._frontCrossDisabledRenderer.setVisible(!1)
    }, onPressStateChangedToDisabled: function () {
        this._backGroundBoxRenderer.setVisible(!1);
        this._backGroundSelectedBoxRenderer.setVisible(!1);
        this._backGroundBoxDisabledRenderer.setVisible(!0);
        this._frontCrossRenderer.setVisible(!1);
        this._isSelected && this._frontCrossDisabledRenderer.setVisible(!0)
    }, setSelectedState: function (a) {
        a != this._isSelected && (this._isSelected = a, this._frontCrossRenderer.setVisible(this._isSelected))
    }, getSelectedState: function () {
        return this._isSelected
    },
    selectedEvent: function () {
        this._checkBoxEventCallback && this._checkBoxEventCallback(this, ccui.CheckBox.EVENT_SELECTED);
        this._checkBoxEventListener && this._checkBoxEventSelector && this._checkBoxEventSelector.call(this._checkBoxEventListener, this, ccui.CheckBox.EVENT_SELECTED)
    }, unSelectedEvent: function () {
        this._checkBoxEventCallback && this._checkBoxEventCallback(this, ccui.CheckBox.EVENT_UNSELECTED);
        this._checkBoxEventListener && this._checkBoxEventSelector && this._checkBoxEventSelector.call(this._checkBoxEventListener,
            this, ccui.CheckBox.EVENT_UNSELECTED)
    }, releaseUpEvent: function () {
        ccui.Widget.prototype.releaseUpEvent.call(this);
        this._isSelected ? (this.setSelectedState(!1), this.unSelectedEvent()) : (this.setSelectedState(!0), this.selectedEvent())
    }, addEventListenerCheckBox: function (a, b) {
        this._checkBoxEventSelector = a;
        this._checkBoxEventListener = b
    }, addEventListener: function (a) {
        this._checkBoxEventCallback = a
    }, getVirtualRendererSize: function () {
        return this._backGroundBoxRenderer.getContentSize()
    }, updateFlippedX: function () {
        this._backGroundBoxRenderer.setFlippedX(this._flippedX);
        this._backGroundSelectedBoxRenderer.setFlippedX(this._flippedX);
        this._frontCrossRenderer.setFlippedX(this._flippedX);
        this._backGroundBoxDisabledRenderer.setFlippedX(this._flippedX);
        this._frontCrossDisabledRenderer.setFlippedX(this._flippedX)
    }, updateFlippedY: function () {
        this._backGroundBoxRenderer.setFlippedY(this._flippedY);
        this._backGroundSelectedBoxRenderer.setFlippedY(this._flippedY);
        this._frontCrossRenderer.setFlippedY(this._flippedY);
        this._backGroundBoxDisabledRenderer.setFlippedY(this._flippedY);
        this._frontCrossDisabledRenderer.setFlippedY(this._flippedY)
    }, setAnchorPoint: function (a, b) {
        void 0 === b ? (ccui.Widget.prototype.setAnchorPoint.call(this, a), this._backGroundBoxRenderer.setAnchorPoint(a), this._backGroundSelectedBoxRenderer.setAnchorPoint(a), this._backGroundBoxDisabledRenderer.setAnchorPoint(a), this._frontCrossRenderer.setAnchorPoint(a), this._frontCrossDisabledRenderer.setAnchorPoint(a)) : (ccui.Widget.prototype.setAnchorPoint.call(this, a, b), this._backGroundBoxRenderer.setAnchorPoint(a, b),
            this._backGroundSelectedBoxRenderer.setAnchorPoint(a, b), this._backGroundBoxDisabledRenderer.setAnchorPoint(a, b), this._frontCrossRenderer.setAnchorPoint(a, b), this._frontCrossDisabledRenderer.setAnchorPoint(a, b))
    }, _setAnchorX: function (a) {
        ccui.Widget.prototype._setAnchorX.call(this, a);
        this._backGroundBoxRenderer._setAnchorX(a);
        this._backGroundSelectedBoxRenderer._setAnchorX(a);
        this._backGroundBoxDisabledRenderer._setAnchorX(a);
        this._frontCrossRenderer._setAnchorX(a);
        this._frontCrossDisabledRenderer._setAnchorX(a)
    },
    _setAnchorY: function (a) {
        ccui.Widget.prototype._setAnchorY.call(this, a);
        this._backGroundBoxRenderer._setAnchorY(a);
        this._backGroundSelectedBoxRenderer._setAnchorY(a);
        this._backGroundBoxDisabledRenderer._setAnchorY(a);
        this._frontCrossRenderer._setAnchorY(a);
        this._frontCrossDisabledRenderer._setAnchorY(a)
    }, onSizeChanged: function () {
        ccui.Widget.prototype.onSizeChanged.call(this);
        this._frontCrossDisabledRendererAdaptDirty = this._backGroundBoxDisabledRendererAdaptDirty = this._frontCrossRendererAdaptDirty =
            this._backGroundSelectedBoxRendererAdaptDirty = this._backGroundBoxRendererAdaptDirty = !0
    }, getContentSize: function () {
        return this._backGroundBoxRenderer.getContentSize()
    }, _getWidth: function () {
        return this._backGroundBoxRenderer._getWidth()
    }, _getHeight: function () {
        return this._backGroundBoxRenderer._getHeight()
    }, getVirtualRenderer: function () {
        return this._backGroundBoxRenderer
    }, backGroundTextureScaleChangedWithSize: function () {
        if (this._ignoreSize)this._backGroundBoxRenderer.setScale(1); else {
            var a = this._backGroundBoxRenderer.getContentSize();
            if (0 >= a.width || 0 >= a.height) {
                this._backGroundBoxRenderer.setScale(1);
                return
            }
            var b = this._size.height / a.height;
            this._backGroundBoxRenderer.setScaleX(this._size.width / a.width);
            this._backGroundBoxRenderer.setScaleY(b)
        }
        a = this._contentSize.width / 2;
        b = this._contentSize.height / 2;
        this._backGroundBoxRenderer.setPosition(a, b);
        this._backGroundSelectedBoxRenderer.setPosition(a, b);
        this._frontCrossRenderer.setPosition(a, b);
        this._backGroundBoxDisabledRenderer.setPosition(a, b);
        this._frontCrossDisabledRenderer.setPosition(a,
            b)
    }, backGroundSelectedTextureScaleChangedWithSize: function () {
        if (this._ignoreSize)this._backGroundSelectedBoxRenderer.setScale(1); else {
            var a = this._backGroundSelectedBoxRenderer.getContentSize();
            if (0 >= a.width || 0 >= a.height)this._backGroundSelectedBoxRenderer.setScale(1); else {
                var b = this._size.height / a.height;
                this._backGroundSelectedBoxRenderer.setScaleX(this._size.width / a.width);
                this._backGroundSelectedBoxRenderer.setScaleY(b)
            }
        }
    }, frontCrossTextureScaleChangedWithSize: function () {
        if (this._ignoreSize)this._frontCrossRenderer.setScale(1);
        else {
            var a = this._frontCrossRenderer.getContentSize();
            if (0 >= a.width || 0 >= a.height)this._frontCrossRenderer.setScale(1); else {
                var b = this._size.height / a.height;
                this._frontCrossRenderer.setScaleX(this._size.width / a.width);
                this._frontCrossRenderer.setScaleY(b)
            }
        }
    }, backGroundDisabledTextureScaleChangedWithSize: function () {
        if (this._ignoreSize)this._backGroundBoxDisabledRenderer.setScale(1); else {
            var a = this._backGroundBoxDisabledRenderer.getContentSize();
            if (0 >= a.width || 0 >= a.height)this._backGroundBoxDisabledRenderer.setScale(1);
            else {
                var b = this._size.height / a.height;
                this._backGroundBoxDisabledRenderer.setScaleX(this._size.width / a.width);
                this._backGroundBoxDisabledRenderer.setScaleY(b)
            }
        }
    }, frontCrossDisabledTextureScaleChangedWithSize: function () {
        if (this._ignoreSize)this._frontCrossDisabledRenderer.setScale(1); else {
            var a = this._frontCrossDisabledRenderer.getContentSize();
            if (0 >= a.width || 0 >= a.height)this._frontCrossDisabledRenderer.setScale(1); else {
                var b = this._size.height / a.height;
                this._frontCrossDisabledRenderer.setScaleX(this._size.width /
                    a.width);
                this._frontCrossDisabledRenderer.setScaleY(b)
            }
        }
    }, updateTextureColor: function () {
        this.updateColorToRenderer(this._backGroundBoxRenderer);
        this.updateColorToRenderer(this._backGroundSelectedBoxRenderer);
        this.updateColorToRenderer(this._frontCrossRenderer);
        this.updateColorToRenderer(this._backGroundBoxDisabledRenderer);
        this.updateColorToRenderer(this._frontCrossDisabledRenderer)
    }, updateTextureOpacity: function () {
        this.updateOpacityToRenderer(this._backGroundBoxRenderer);
        this.updateOpacityToRenderer(this._backGroundSelectedBoxRenderer);
        this.updateOpacityToRenderer(this._frontCrossRenderer);
        this.updateOpacityToRenderer(this._backGroundBoxDisabledRenderer);
        this.updateOpacityToRenderer(this._frontCrossDisabledRenderer)
    }, getDescription: function () {
        return"CheckBox"
    }, createCloneInstance: function () {
        return ccui.CheckBox.create()
    }, copySpecialProperties: function (a) {
        a instanceof ccui.CheckBox && (this.loadTextureBackGround(a._backGroundFileName, a._backGroundTexType), this.loadTextureBackGroundSelected(a._backGroundSelectedFileName, a._backGroundSelectedTexType),
            this.loadTextureFrontCross(a._frontCrossFileName, a._frontCrossTexType), this.loadTextureBackGroundDisabled(a._backGroundDisabledFileName, a._backGroundDisabledTexType), this.loadTextureFrontCrossDisabled(a._frontCrossDisabledFileName, a._frontCrossDisabledTexType), this.setSelectedState(a._isSelected), this._checkBoxEventListener = a._checkBoxEventListener, this._checkBoxEventSelector = a._checkBoxEventSelector, this._checkBoxEventCallback = a._checkBoxEventCallback)
    }, adaptRenderers: function () {
        this._backGroundBoxRendererAdaptDirty &&
        (this.backGroundTextureScaleChangedWithSize(), this._backGroundBoxRendererAdaptDirty = !1);
        this._backGroundSelectedBoxRendererAdaptDirty && (this.backGroundSelectedTextureScaleChangedWithSize(), this._backGroundSelectedBoxRendererAdaptDirty = !1);
        this._frontCrossRendererAdaptDirty && (this.frontCrossTextureScaleChangedWithSize(), this._frontCrossRendererAdaptDirty = !1);
        this._backGroundBoxDisabledRendererAdaptDirty && (this.backGroundDisabledTextureScaleChangedWithSize(), this._backGroundBoxDisabledRendererAdaptDirty = !1);
        this._frontCrossDisabledRendererAdaptDirty && (this.frontCrossDisabledTextureScaleChangedWithSize(), this._frontCrossDisabledRendererAdaptDirty = !1)
    }});
_p = ccui.CheckBox.prototype;
cc.defineGetterSetter(_p, "selected", _p.getSelectedState, _p.setSelectedState);
_p = null;
ccui.CheckBox.create = function (a, b, c, d, e, f) {
    var g = new ccui.CheckBox;
    void 0 === a ? g.init() : g.init(a, b, c, d, e, f);
    return g
};
ccui.CheckBox.EVENT_SELECTED = 0;
ccui.CheckBox.EVENT_UNSELECTED = 1;
ccui.CheckBox.BOX_RENDERER_ZORDER = -1;
ccui.CheckBox.BOX_SELECTED_RENDERER_ZORDER = -1;
ccui.CheckBox.BOX_DISABLED_RENDERER_ZORDER = -1;
ccui.CheckBox.FRONT_CROSS_RENDERER_ZORDER = -1;
ccui.CheckBox.FRONT_CROSS_DISABLED_RENDERER_ZORDER = -1;
ccui.ImageView = ccui.Widget.extend({_scale9Enabled: !1, _prevIgnoreSize: !0, _capInsets: null, _imageRenderer: null, _textureFile: "", _imageTexType: ccui.Widget.LOCAL_TEXTURE, _imageTextureSize: null, _className: "ImageView", _imageRendererAdaptDirty: !0, ctor: function () {
    this._capInsets = cc.rect(0, 0, 0, 0);
    this._imageTextureSize = cc.size(this._size.width, this._size.height);
    ccui.Widget.prototype.ctor.call(this)
}, init: function (a, b) {
    ccui.Widget.prototype.init.call(this);
    void 0 !== a && this.loadTexture(a, b);
    return!0
}, initRenderer: function () {
    this._imageRenderer =
        cc.Sprite.create();
    this.addProtectedChild(this._imageRenderer, ccui.ImageView.RENDERER_ZORDER, -1)
}, loadTexture: function (a, b) {
    if (a) {
        b = b || ccui.Widget.LOCAL_TEXTURE;
        this._textureFile = a;
        this._imageTexType = b;
        var c = this._imageRenderer;
        switch (this._imageTexType) {
            case ccui.Widget.LOCAL_TEXTURE:
                this._scale9Enabled ? (c.initWithFile(a), c.setCapInsets(this._capInsets)) : c.setTexture(a);
                break;
            case ccui.Widget.PLIST_TEXTURE:
                this._scale9Enabled ? (c.initWithSpriteFrameName(a), c.setCapInsets(this._capInsets)) : c.setSpriteFrame(a)
        }
        this._imageTextureSize =
            c.getContentSize();
        this.updateFlippedX();
        this.updateFlippedY();
        c.setColor(this.getColor());
        c.setOpacity(this.getOpacity());
        this._updateContentSizeWithTextureSize(this._imageTextureSize);
        this._imageRendererAdaptDirty = !0
    }
}, setTextureRect: function (a) {
    this._scale9Enabled || this._imageRenderer.setTextureRect(a)
}, updateFlippedX: function () {
    this._scale9Enabled ? this._imageRenderer.setScaleX(this._flippedX ? -1 : 1) : this._imageRenderer.setFlippedX(this._flippedX)
}, updateFlippedY: function () {
    this._scale9Enabled ? this._imageRenderer.setScaleY(this._flippedY ?
        -1 : 1) : this._imageRenderer.setFlippedY(this._flippedY)
}, adaptRenderers: function () {
    this._imageRendererAdaptDirty && (this.imageTextureScaleChangedWithSize(), this._imageRendererAdaptDirty = !1)
}, setScale9Enabled: function (a) {
    this._scale9Enabled != a && (this._scale9Enabled = a, this.removeProtectedChild(this._imageRenderer), this._imageRenderer = null, this._imageRenderer = this._scale9Enabled ? cc.Scale9Sprite.create() : cc.Sprite.create(), this.loadTexture(this._textureFile, this._imageTexType), this.addProtectedChild(this._imageRenderer,
        ccui.ImageView.RENDERER_ZORDER, -1), this._scale9Enabled ? (a = this._ignoreSize, this.ignoreContentAdaptWithSize(!1), this._prevIgnoreSize = a) : this.ignoreContentAdaptWithSize(this._prevIgnoreSize), this.setCapInsets(this._capInsets))
}, isScale9Enabled: function () {
    return this._scale9Enabled
}, ignoreContentAdaptWithSize: function (a) {
    if (!this._scale9Enabled || this._scale9Enabled && !a)ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this, a), this._prevIgnoreSize = a
}, setCapInsets: function (a) {
    this._capInsets = a;
    this._scale9Enabled &&
    this._imageRenderer.setCapInsets(a)
}, getCapInsets: function () {
    return this._capInsets
}, setAnchorPoint: function (a, b) {
    void 0 === b ? (ccui.Widget.prototype.setAnchorPoint.call(this, a), this._imageRenderer.setAnchorPoint(a)) : (ccui.Widget.prototype.setAnchorPoint.call(this, a, b), this._imageRenderer.setAnchorPoint(a, b))
}, _setAnchorX: function (a) {
    ccui.Widget.prototype._setAnchorX.call(this, a);
    this._imageRenderer._setAnchorX(a)
}, _setAnchorY: function (a) {
    ccui.Widget.prototype._setAnchorY.call(this, a);
    this._imageRenderer._setAnchorY(a)
},
    onSizeChanged: function () {
        ccui.Widget.prototype.onSizeChanged.call(this);
        this._imageRendererAdaptDirty = !0
    }, getContentSize: function () {
        return this._imageTextureSize
    }, _getWidth: function () {
        return this._imageTextureSize.width
    }, _getHeight: function () {
        return this._imageTextureSize.height
    }, getVirtualRenderer: function () {
        return this._imageRenderer
    }, imageTextureScaleChangedWithSize: function () {
        if (this._ignoreSize)this._scale9Enabled || this._imageRenderer.setScale(1); else if (this._scale9Enabled)this._imageRenderer.setPreferredSize(this._size);
        else {
            var a = this._imageRenderer.getContentSize();
            if (0 >= a.width || 0 >= a.height) {
                this._imageRenderer.setScale(1);
                return
            }
            this._imageRenderer.setScaleX(this._size.width / a.width);
            this._imageRenderer.setScaleY(this._size.height / a.height)
        }
        this._imageRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    }, updateTextureColor: function () {
        this.updateColorToRenderer(this._imageRenderer)
    }, updateTextureOpacity: function () {
        this.updateOpacityToRenderer(this._imageRenderer)
    }, getDescription: function () {
        return"ImageView"
    },
    getVirtualRendererSize: function () {
    }, createCloneInstance: function () {
        return ccui.ImageView.create()
    }, copySpecialProperties: function (a) {
        a instanceof ccui.ImageView && (this._prevIgnoreSize = a._prevIgnoreSize, this.setScale9Enabled(a._scale9Enabled), this.loadTexture(a._textureFile, a._imageTexType), this.setCapInsets(a._capInsets))
    }});
ccui.ImageView.create = function (a, b) {
    var c = new ccui.ImageView;
    void 0 !== a && c.init(a, b);
    return c
};
ccui.ImageView.RENDERER_ZORDER = -1;
ccui.LoadingBar = ccui.Widget.extend({_direction: null, _percent: 100, _totalLength: 0, _barRenderer: null, _renderBarTexType: ccui.Widget.LOCAL_TEXTURE, _barRendererTextureSize: null, _scale9Enabled: !1, _prevIgnoreSize: !0, _capInsets: null, _textureFile: "", _isTextureLoaded: !1, _className: "LoadingBar", _barRendererAdaptDirty: !0, ctor: function () {
    this._direction = ccui.LoadingBar.TYPE_LEFT;
    this._barRendererTextureSize = cc.size(0, 0);
    this._capInsets = cc.rect(0, 0, 0, 0);
    ccui.Widget.prototype.ctor.call(this)
}, initRenderer: function () {
    this._barRenderer =
        cc.Sprite.create();
    cc.Node.prototype.addChild.call(this, this._barRenderer, ccui.LoadingBar.RENDERER_ZORDER, -1);
    this._barRenderer.setAnchorPoint(0, 0.5)
}, setDirection: function (a) {
    if (this._direction != a)switch (this._direction = a, this._direction) {
        case ccui.LoadingBar.TYPE_LEFT:
            this._barRenderer.setAnchorPoint(0, 0.5);
            this._barRenderer.setPosition(0.5 * -this._totalLength, 0);
            this._scale9Enabled || this._barRenderer.setFlippedX(!1);
            break;
        case ccui.LoadingBar.TYPE_RIGHT:
            this._barRenderer.setAnchorPoint(1, 0.5), this._barRenderer.setPosition(0.5 *
                this._totalLength, 0), this._scale9Enabled || this._barRenderer.setFlippedX(!0)
    }
}, getDirection: function () {
    return this._direction
}, loadTexture: function (a, b) {
    if (a) {
        this._renderBarTexType = b = b || ccui.Widget.LOCAL_TEXTURE;
        this._textureFile = a;
        var c = this._barRenderer;
        switch (this._renderBarTexType) {
            case ccui.Widget.LOCAL_TEXTURE:
                this._scale9Enabled ? (c.initWithFile(a), c.setCapInsets(this._capInsets)) : c.setTexture(a);
                break;
            case ccui.Widget.PLIST_TEXTURE:
                this._scale9Enabled ? (c.initWithSpriteFrameName(a), c.setCapInsets(this._capInsets)) :
                    c.setSpriteFrame(a)
        }
        c.setColor(this.getColor());
        c.setOpacity(this.getOpacity());
        var d = c.getContentSize();
        this._barRendererTextureSize.width = d.width;
        this._barRendererTextureSize.height = d.height;
        switch (this._direction) {
            case ccui.LoadingBar.TYPE_LEFT:
                c.setAnchorPoint(0, 0.5);
                this._scale9Enabled || c.setFlippedX(!1);
                break;
            case ccui.LoadingBar.TYPE_RIGHT:
                c.setAnchorPoint(1, 0.5), this._scale9Enabled || c.setFlippedX(!0)
        }
        this.barRendererScaleChangedWithSize();
        this._updateContentSizeWithTextureSize(this._barRendererTextureSize);
        this._barRendererAdaptDirty = !0
    }
}, setScale9Enabled: function (a) {
    this._scale9Enabled != a && (this._scale9Enabled = a, this.removeProtectedChild(this._barRenderer), this._barRenderer = this._scale9Enabled ? cc.Scale9Sprite.create() : cc.Sprite.create(), this.loadTexture(this._textureFile, this._renderBarTexType), this.addProtectedChild(this._barRenderer, ccui.LoadingBar.RENDERER_ZORDER, -1), this._scale9Enabled ? (a = this._ignoreSize, this.ignoreContentAdaptWithSize(!1), this._prevIgnoreSize = a) : this.ignoreContentAdaptWithSize(this._prevIgnoreSize),
        this.setCapInsets(this._capInsets), this.setPercent(this._percent))
}, isScale9Enabled: function () {
    return this._scale9Enabled
}, setCapInsets: function (a) {
    this._capInsets = a;
    this._scale9Enabled && this._barRenderer.setCapInsets(a)
}, getCapInsets: function () {
    return this._capInsets
}, setPercent: function (a) {
    if (!(0 > a || 100 < a) && !(0 >= this._totalLength))if (this._percent = a, a = this._percent / 100, this._scale9Enabled)this.setScale9Scale(); else {
        var b = this._barRenderer.getTextureRect();
        this._barRenderer.setTextureRect(cc.rect(b.x,
            b.y, this._barRendererTextureSize.width * a, this._barRendererTextureSize.height))
    }
}, getPercent: function () {
    return this._percent
}, onSizeChanged: function () {
    ccui.Widget.prototype.onSizeChanged.call(this);
    this._barRendererAdaptDirty = !0
}, ignoreContentAdaptWithSize: function (a) {
    if (!this._scale9Enabled || this._scale9Enabled && !a)ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this, a), this._prevIgnoreSize = a
}, getVirtualRendererSize: function () {
    return this._barRendererTextureSize
}, getContentSize: function () {
    return this._barRendererTextureSize
},
    _getWidth: function () {
        return this._barRendererTextureSize.width
    }, _getHeight: function () {
        return this._barRendererTextureSize.height
    }, getVirtualRenderer: function () {
        return this._barRenderer
    }, barRendererScaleChangedWithSize: function () {
        var a = this._barRenderer;
        if (this._ignoreSize)this._scale9Enabled || (this._totalLength = this._barRendererTextureSize.width, a.setScale(1)); else if (this._totalLength = this._size.width, this._scale9Enabled)this.setScale9Scale(); else {
            var b = this._barRendererTextureSize;
            if (0 >= b.width ||
                0 >= b.height) {
                a.setScale(1);
                return
            }
            var c = this._size.height / b.height;
            a.setScaleX(this._size.width / b.width);
            a.setScaleY(c)
        }
        switch (this._direction) {
            case ccui.LoadingBar.TYPE_LEFT:
                a.setPosition(0, 0.5 * this._contentSize.height);
                break;
            case ccui.LoadingBar.TYPE_RIGHT:
                a.setPosition(this._totalLength, 0.5 * this._contentSize.height)
        }
    }, adaptRenderers: function () {
        this._barRendererAdaptDirty && (this.barRendererScaleChangedWithSize(), this._barRendererAdaptDirty = !1)
    }, setScale9Scale: function () {
        this._barRenderer.setPreferredSize(cc.size(this._percent /
            100 * this._totalLength, this._size.height))
    }, updateTextureColor: function () {
        this.updateColorToRenderer(this._barRenderer)
    }, updateTextureOpacity: function () {
        this.updateOpacityToRenderer(this._barRenderer)
    }, getDescription: function () {
        return"LoadingBar"
    }, createCloneInstance: function () {
        return ccui.LoadingBar.create()
    }, copySpecialProperties: function (a) {
        a instanceof ccui.LoadingBar && (this._prevIgnoreSize = a._prevIgnoreSize, this.setScale9Enabled(a._scale9Enabled), this.loadTexture(a._textureFile, a._renderBarTexType),
            this.setCapInsets(a._capInsets), this.setPercent(a._percent), this.setDirection(a._direction))
    }});
_p = ccui.LoadingBar.prototype;
cc.defineGetterSetter(_p, "direction", _p.getDirection, _p.setDirection);
cc.defineGetterSetter(_p, "percent", _p.getPercent, _p.setPercent);
_p = null;
ccui.LoadingBar.create = function (a, b) {
    var c = new ccui.LoadingBar;
    void 0 !== a && c.loadTexture(a);
    void 0 !== b && c.setPercent(b);
    return c
};
ccui.LoadingBar.TYPE_LEFT = 0;
ccui.LoadingBar.TYPE_RIGHT = 1;
ccui.LoadingBar.RENDERER_ZORDER = -1;
ccui.Slider = ccui.Widget.extend({_barRenderer: null, _progressBarRenderer: null, _progressBarTextureSize: null, _slidBallNormalRenderer: null, _slidBallPressedRenderer: null, _slidBallDisabledRenderer: null, _slidBallRenderer: null, _barLength: 0, _percent: 0, _scale9Enabled: !1, _prevIgnoreSize: !0, _textureFile: "", _progressBarTextureFile: "", _slidBallNormalTextureFile: "", _slidBallPressedTextureFile: "", _slidBallDisabledTextureFile: "", _capInsetsBarRenderer: null, _capInsetsProgressBarRenderer: null, _sliderEventListener: null,
    _sliderEventSelector: null, _barTexType: ccui.Widget.LOCAL_TEXTURE, _progressBarTexType: ccui.Widget.LOCAL_TEXTURE, _ballNTexType: ccui.Widget.LOCAL_TEXTURE, _ballPTexType: ccui.Widget.LOCAL_TEXTURE, _ballDTexType: ccui.Widget.LOCAL_TEXTURE, _isTextureLoaded: !1, _className: "Slider", _barRendererAdaptDirty: !0, _progressBarRendererDirty: !0, ctor: function () {
        this._progressBarTextureSize = cc.size(0, 0);
        this._capInsetsBarRenderer = cc.rect(0, 0, 0, 0);
        this._capInsetsProgressBarRenderer = cc.rect(0, 0, 0, 0);
        ccui.Widget.prototype.ctor.call(this)
    },
    init: function () {
        return ccui.Widget.prototype.init.call(this) ? !0 : !1
    }, initRenderer: function () {
        this._barRenderer = cc.Sprite.create();
        this._progressBarRenderer = cc.Sprite.create();
        this._progressBarRenderer.setAnchorPoint(0, 0.5);
        this.addProtectedChild(this._barRenderer, ccui.Slider.BASEBAR_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._progressBarRenderer, ccui.Slider.PROGRESSBAR_RENDERER_ZORDER, -1);
        this._slidBallNormalRenderer = cc.Sprite.create();
        this._slidBallPressedRenderer = cc.Sprite.create();
        this._slidBallPressedRenderer.setVisible(!1);
        this._slidBallDisabledRenderer = cc.Sprite.create();
        this._slidBallDisabledRenderer.setVisible(!1);
        this._slidBallRenderer = cc.Node.create();
        this._slidBallRenderer.addChild(this._slidBallNormalRenderer);
        this._slidBallRenderer.addChild(this._slidBallPressedRenderer);
        this._slidBallRenderer.addChild(this._slidBallDisabledRenderer);
        this.addProtectedChild(this._slidBallRenderer, ccui.Slider.BALL_RENDERER_ZORDER, -1)
    }, loadBarTexture: function (a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._textureFile = a;
            this._barTexType =
                b;
            var c = this._barRenderer;
            switch (this._barTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._scale9Enabled ? c.initWithFile(a) : c.setTexture(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._scale9Enabled ? c.initWithSpriteFrameName(a) : c.setSpriteFrame(a)
            }
            c.setColor(this.getColor());
            c.setOpacity(this.getOpacity());
            this._progressBarRendererDirty = this._barRendererAdaptDirty = !0;
            this._updateContentSizeWithTextureSize(this._barRenderer.getContentSize())
        }
    }, loadProgressBarTexture: function (a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._progressBarTextureFile = a;
            this._progressBarTexType = b;
            var c = this._progressBarRenderer;
            switch (this._progressBarTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._scale9Enabled ? c.initWithFile(a) : c.setTexture(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._scale9Enabled ? c.initWithSpriteFrameName(a) : c.setSpriteFrame(a)
            }
            this._progressBarRenderer.setColor(this.getColor());
            this._progressBarRenderer.setOpacity(this.getOpacity());
            this._progressBarRenderer.setAnchorPoint(cc.p(0, 0.5));
            c = this._progressBarRenderer.getContentSize();
            this._progressBarTextureSize = {width: c.width, height: c.height};
            this._progressBarRendererDirty = !0
        }
    }, setScale9Enabled: function (a) {
        this._scale9Enabled != a && (this._scale9Enabled = a, this.removeProtectedChild(this._barRenderer, !0), this.removeProtectedChild(this._progressBarRenderer, !0), this._progressBarRenderer = this._barRenderer = null, this._scale9Enabled ? (this._barRenderer = cc.Scale9Sprite.create(), this._progressBarRenderer = cc.Scale9Sprite.create()) : (this._barRenderer = cc.Sprite.create(), this._progressBarRenderer =
            cc.Sprite.create()), this.loadBarTexture(this._textureFile, this._barTexType), this.loadProgressBarTexture(this._progressBarTextureFile, this._progressBarTexType), this.addProtectedChild(this._barRenderer, ccui.Slider.BASEBAR_RENDERER_ZORDER, -1), this.addProtectedChild(this._progressBarRenderer, ccui.Slider.PROGRESSBAR_RENDERER_ZORDER, -1), this._scale9Enabled ? (a = this._ignoreSize, this.ignoreContentAdaptWithSize(!1), this._prevIgnoreSize = a) : this.ignoreContentAdaptWithSize(this._prevIgnoreSize), this.setCapInsetsBarRenderer(this._capInsetsBarRenderer),
            this.setCapInsetProgressBarRenderer(this._capInsetsProgressBarRenderer))
    }, isScale9Enabled: function () {
        return this._scale9Enabled
    }, ignoreContentAdaptWithSize: function (a) {
        if (!this._scale9Enabled || this._scale9Enabled && !a)ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this, a), this._prevIgnoreSize = a
    }, setCapInsets: function (a) {
        this.setCapInsetsBarRenderer(a);
        this.setCapInsetProgressBarRenderer(a)
    }, setCapInsetsBarRenderer: function (a) {
        this._capInsetsBarRenderer = a;
        this._scale9Enabled && this._barRenderer.setCapInsets(a)
    },
    getCapInsetsBarRenderer: function () {
        return this._capInsetsBarRenderer
    }, setCapInsetProgressBarRenderer: function (a) {
        this._capInsetsProgressBarRenderer = a;
        this._scale9Enabled && this._progressBarRenderer.setCapInsets(a)
    }, getCapInsetsProgressBarRebderer: function () {
        return this._capInsetsProgressBarRenderer
    }, loadSlidBallTextures: function (a, b, c, d) {
        this.loadSlidBallTextureNormal(a, d);
        this.loadSlidBallTexturePressed(b, d);
        this.loadSlidBallTextureDisabled(c, d)
    }, loadSlidBallTextureNormal: function (a, b) {
        if (a) {
            b = b ||
                ccui.Widget.LOCAL_TEXTURE;
            this._slidBallNormalTextureFile = a;
            this._ballNTexType = b;
            switch (this._ballNTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._slidBallNormalRenderer.setTexture(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._slidBallNormalRenderer.setSpriteFrame(a)
            }
            this._slidBallNormalRenderer.setColor(this.getColor());
            this._slidBallNormalRenderer.setOpacity(this.getOpacity())
        }
    }, loadSlidBallTexturePressed: function (a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._slidBallPressedTextureFile = a;
            this._ballPTexType =
                b;
            switch (this._ballPTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._slidBallPressedRenderer.setTexture(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._slidBallPressedRenderer.setSpriteFrame(a)
            }
            this._slidBallPressedRenderer.setColor(this.getColor());
            this._slidBallPressedRenderer.setOpacity(this.getOpacity())
        }
    }, loadSlidBallTextureDisabled: function (a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._slidBallDisabledTextureFile = a;
            this._ballDTexType = b;
            switch (this._ballDTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._slidBallDisabledRenderer.setTexture(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._slidBallDisabledRenderer.setSpriteFrame(a)
            }
            this._slidBallDisabledRenderer.setColor(this.getColor());
            this._slidBallDisabledRenderer.setOpacity(this.getOpacity())
        }
    }, setPercent: function (a) {
        100 < a && (a = 100);
        0 > a && (a = 0);
        this._percent = a;
        a = this._barLength * (a / 100);
        this._slidBallRenderer.setPosition(cc.p(a, this._contentSize.height / 2));
        if (this._scale9Enabled)this._progressBarRenderer.setPreferredSize(cc.size(a, this._progressBarTextureSize.height)); else {
            var b = this._progressBarRenderer,
                c = b.getTextureRect();
            b.setTextureRect(cc.rect(c.x, c.y, a, c.height), b.isTextureRectRotated())
        }
    }, hitTest: function (a) {
        a = this._slidBallNormalRenderer.convertToNodeSpace(a);
        var b = this._slidBallNormalRenderer.getContentSize(), b = cc.rect(0, 0, b.width, b.height);
        return cc.rectContainsPoint(b, a)
    }, onTouchBegan: function (a, b) {
        var c = ccui.Widget.prototype.onTouchBegan.call(this, a, b);
        if (this._hitted) {
            var d = this.convertToNodeSpace(this._touchBeganPosition);
            this.setPercent(this.getPercentWithBallPos(d.x));
            this.percentChangedEvent()
        }
        return c
    },
    onTouchMoved: function (a, b) {
        var c = a.getLocation(), c = this.convertToNodeSpace(c);
        this.setPercent(this.getPercentWithBallPos(c.x));
        this.percentChangedEvent()
    }, onTouchEnded: function (a, b) {
        ccui.Widget.prototype.onTouchEnded.call(this, a, b)
    }, onTouchCancelled: function (a, b) {
        ccui.Widget.prototype.onTouchCancelled.call(this, a, b)
    }, getPercentWithBallPos: function (a) {
        return 100 * (a / this._barLength)
    }, addEventListenerSlider: function (a, b) {
        this._sliderEventSelector = a;
        this._sliderEventListener = b
    }, addEventListener: function (a) {
        this._eventCallback =
            a
    }, percentChangedEvent: function () {
        this._sliderEventListener && this._sliderEventSelector && this._sliderEventSelector.call(this._sliderEventListener, this, ccui.Slider.EVENT_PERCENT_CHANGED);
        this._eventCallback && this._eventCallback(ccui.Slider.EVENT_PERCENT_CHANGED)
    }, getPercent: function () {
        return this._percent
    }, onSizeChanged: function () {
        ccui.Widget.prototype.onSizeChanged.call(this);
        this._progressBarRendererDirty = this._barRendererAdaptDirty = !0
    }, adaptRenderers: function () {
        this._barRendererAdaptDirty && (this.barRendererScaleChangedWithSize(),
            this._barRendererAdaptDirty = !1);
        this._progressBarRendererDirty && (this.progressBarRendererScaleChangedWithSize(), this._progressBarRendererDirty = !1)
    }, getVirtualRendererSize: function () {
        return this._barRenderer.getContentSize()
    }, getVirtualRenderer: function () {
        return this._barRenderer
    }, barRendererScaleChangedWithSize: function () {
        if (this._ignoreSize)this._barRenderer.setScale(1), this._barLength = this._contentSize.width; else if (this._barLength = this._contentSize.width, this._scale9Enabled)this._barRenderer.setPreferredSize(this._contentSize);
        else {
            var a = this._barRenderer.getContentSize();
            if (0 >= a.width || 0 >= a.height) {
                this._barRenderer.setScale(1);
                return
            }
            var b = this._contentSize.height / a.height;
            this._barRenderer.setScaleX(this._contentSize.width / a.width);
            this._barRenderer.setScaleY(b)
        }
        this._barRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2);
        this.setPercent(this._percent)
    }, progressBarRendererScaleChangedWithSize: function () {
        if (this._ignoreSize) {
            if (!this._scale9Enabled) {
                var a = this._progressBarTextureSize, b = this._contentSize.width /
                    a.width, a = this._contentSize.height / a.height;
                this._progressBarRenderer.setScaleX(b);
                this._progressBarRenderer.setScaleY(a)
            }
        } else if (this._scale9Enabled)this._progressBarRenderer.setPreferredSize(this._contentSize), this._progressBarTextureSize = this._progressBarRenderer.getContentSize(); else {
            a = this._progressBarTextureSize;
            if (0 >= a.width || 0 >= a.height) {
                this._progressBarRenderer.setScale(1);
                return
            }
            b = this._contentSize.width / a.width;
            a = this._contentSize.height / a.height;
            this._progressBarRenderer.setScaleX(b);
            this._progressBarRenderer.setScaleY(a)
        }
        this._progressBarRenderer.setPosition(0, this._contentSize.height / 2);
        this.setPercent(this._percent)
    }, getContentSize: function () {
        var a = this._barRenderer.getContentSize();
        return cc.size(a.width, a.height)
    }, _getWidth: function () {
        return this._barRenderer._getWidth()
    }, _getHeight: function () {
        return this._barRenderer._getHeight()
    }, onPressStateChangedToNormal: function () {
        this._slidBallNormalRenderer.setVisible(!0);
        this._slidBallPressedRenderer.setVisible(!1);
        this._slidBallDisabledRenderer.setVisible(!1)
    },
    onPressStateChangedToPressed: function () {
        this._slidBallNormalRenderer.setVisible(!1);
        this._slidBallPressedRenderer.setVisible(!0);
        this._slidBallDisabledRenderer.setVisible(!1)
    }, onPressStateChangedToDisabled: function () {
        this._slidBallNormalRenderer.setVisible(!1);
        this._slidBallPressedRenderer.setVisible(!1);
        this._slidBallDisabledRenderer.setVisible(!0)
    }, getDescription: function () {
        return"Slider"
    }, createCloneInstance: function () {
        return ccui.Slider.create()
    }, copySpecialProperties: function (a) {
        this._prevIgnoreSize =
            a._prevIgnoreSize;
        this.setScale9Enabled(a._scale9Enabled);
        this.loadBarTexture(a._textureFile, a._barTexType);
        this.loadProgressBarTexture(a._progressBarTextureFile, a._progressBarTexType);
        this.loadSlidBallTextureNormal(a._slidBallNormalTextureFile, a._ballNTexType);
        this.loadSlidBallTexturePressed(a._slidBallPressedTextureFile, a._ballPTexType);
        this.loadSlidBallTextureDisabled(a._slidBallDisabledTextureFile, a._ballDTexType);
        this.setPercent(a.getPercent());
        this._sliderEventListener = a._sliderEventListener;
        this._sliderEventSelector = a._sliderEventSelector;
        this._eventCallback = a._eventCallback
    }, updateTextureColor: function () {
        this.updateColorToRenderer(this._barRenderer);
        this.updateColorToRenderer(this._progressBarRenderer);
        this.updateColorToRenderer(this._slidBallNormalRenderer);
        this.updateColorToRenderer(this._slidBallPressedRenderer);
        this.updateColorToRenderer(this._slidBallDisabledRenderer)
    }, updateTextureOpacity: function () {
        this.updateOpacityToRenderer(this._barRenderer);
        this.updateOpacityToRenderer(this._progressBarRenderer);
        this.updateOpacityToRenderer(this._slidBallNormalRenderer);
        this.updateOpacityToRenderer(this._slidBallPressedRenderer);
        this.updateOpacityToRenderer(this._slidBallDisabledRenderer)
    }});
_p = ccui.Slider.prototype;
cc.defineGetterSetter(_p, "percent", _p.getPercent, _p.setPercent);
_p = null;
ccui.Slider.create = function () {
    var a = new ccui.Slider;
    return a && a.init() ? a : null
};
ccui.Slider.EVENT_PERCENT_CHANGED = 0;
ccui.Slider.BASEBAR_RENDERER_ZORDER = -3;
ccui.Slider.PROGRESSBAR_RENDERER_ZORDER = -2;
ccui.Slider.BALL_RENDERER_ZORDER = -1;
ccui.Text = ccui.Widget.extend({_touchScaleChangeEnabled: !1, _normalScaleValueX: 1, _normalScaleValueY: 1, _fontName: "Thonburi", _fontSize: 10, _onSelectedScaleOffset: 0.5, _labelRenderer: "", _textAreaSize: null, _textVerticalAlignment: 0, _textHorizontalAlignment: 0, _className: "Text", _type: null, _labelRendererAdaptDirty: !0, ctor: function () {
    this._type = ccui.Text.Type.SYSTEM;
    this._textAreaSize = cc.size(0, 0);
    ccui.Widget.prototype.ctor.call(this)
}, init: function (a, b, c) {
    return ccui.Widget.prototype.init.call(this) ? (0 < arguments.length &&
        (this.setString(a), this.setFontName(b), this.setFontSize(c)), !0) : !1
}, initRenderer: function () {
    this._labelRenderer = cc.LabelTTF.create();
    cc.Node.prototype.addChild.call(this, this._labelRenderer, ccui.Text.RENDERER_ZORDER, -1)
}, setText: function (a) {
    cc.log("Please use the setString");
    this.setString(a)
}, setString: function (a) {
    this._labelRenderer.setString(a);
    this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize());
    this._labelRendererAdaptDirty = !0
}, getStringValue: function () {
    cc.log("Please use the getString");
    return this._labelRenderer.getString()
}, getString: function () {
    return this._labelRenderer.getString()
}, getStringLength: function () {
    return this._labelRenderer.getStringLength()
}, setFontSize: function (a) {
    this._fontSize = a;
    this._labelRenderer.setFontSize(a);
    this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize());
    this._labelRendererAdaptDirty = !0
}, getFontSize: function () {
    return this._fontSize
}, setFontName: function (a) {
    this._fontName = a;
    this._labelRenderer.setFontName(a);
    this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize());
    this._labelRendererAdaptDirty = !0
}, setTextAreaSize: function (a) {
    this._labelRenderer.setDimensions(a);
    this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize());
    this._labelRendererAdaptDirty = !0
}, getTextAreaSize: function () {
    return this._labelRenderer.getDimensions()
}, setTextHorizontalAlignment: function (a) {
    this._labelRenderer.setHorizontalAlignment(a);
    this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize());
    this._labelRendererAdaptDirty = !0
}, getTextHorizontalAlignment: function () {
    return this._labelRenderer.getHorizontalAlignment()
},
    setTextVerticalAlignment: function (a) {
        this._labelRenderer.setVerticalAlignment(a);
        this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize());
        this._labelRendererAdaptDirty = !0
    }, getTextVerticalAlignment: function () {
        return this._labelRenderer.getVerticalAlignment()
    }, setTouchScaleChangeEnabled: function (a) {
        this._touchScaleChangeEnabled = a
    }, isTouchScaleChangeEnabled: function () {
        return this._touchScaleChangeEnabled
    }, onPressStateChangedToNormal: function () {
        this._touchScaleChangeEnabled && (this._labelRenderer.setScaleX(this._normalScaleValueX),
            this._labelRenderer.setScaleY(this._normalScaleValueY))
    }, onPressStateChangedToPressed: function () {
        this._touchScaleChangeEnabled && (this._labelRenderer.setScaleX(this._normalScaleValueX + this._onSelectedScaleOffset), this._labelRenderer.setScaleY(this._normalScaleValueY + this._onSelectedScaleOffset))
    }, onPressStateChangedToDisabled: function () {
    }, updateFlippedX: function () {
        this._flippedX ? this._labelRenderer.setScaleX(-1) : this._labelRenderer.setScaleX(1)
    }, onSizeChanged: function () {
        ccui.Widget.prototype.onSizeChanged.call(this);
        this._labelRendererAdaptDirty = !0
    }, adaptRenderers: function () {
        this._labelRendererAdaptDirty && (this.labelScaleChangedWithSize(), this._labelRendererAdaptDirty = !1)
    }, getVirtualRendererSize: function () {
        return this._labelRenderer.getContentSize()
    }, getVirtualRenderer: function () {
        return this._labelRenderer
    }, labelScaleChangedWithSize: function () {
        if (this._ignoreSize)this._labelRenderer.setScale(1), this._normalScaleValueX = this._normalScaleValueY = 1; else {
            this._labelRenderer.setDimensions(cc.size(this._contentSize.width,
                this._contentSize.height));
            var a = this._labelRenderer.getContentSize();
            if (0 >= a.width || 0 >= a.height) {
                this._labelRenderer.setScale(1);
                return
            }
            var b = this._contentSize.width / a.width, a = this._contentSize.height / a.height;
            this._labelRenderer.setScaleX(b);
            this._labelRenderer.setScaleY(a);
            this._normalScaleValueX = b;
            this._normalScaleValueY = a
        }
        this._labelRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    }, getDescription: function () {
        return"Label"
    }, enableShadow: function (a, b, c) {
        this._labelRenderer.enableShadow(a,
            b, c)
    }, enableOutline: function (a, b) {
        this._labelRenderer.enableOutline(a, b)
    }, enableGlow: function (a) {
        this._type == ccui.Text.Type.TTF && this._labelRenderer.enableGlow(a)
    }, disableEffect: function () {
        this._labelRenderer.disableEffect()
    }, createCloneInstance: function () {
        return ccui.Text.create()
    }, getFontName: function () {
        return this._fontName
    }, getType: function () {
        return this._type
    }, _setFont: function (a) {
        var b = cc.LabelTTF._fontStyleRE.exec(a);
        b && (this._fontSize = parseInt(b[1]), this._fontName = b[2], this._labelRenderer._setFont(a),
            this.labelScaleChangedWithSize())
    }, _getFont: function () {
        return this._labelRenderer._getFont()
    }, _setBoundingWidth: function (a) {
        this._textAreaSize.width = a;
        this._labelRenderer._setBoundingWidth(a);
        this.labelScaleChangedWithSize()
    }, _setBoundingHeight: function (a) {
        this._textAreaSize.height = a;
        this._labelRenderer._setBoundingHeight(a);
        this.labelScaleChangedWithSize()
    }, _getBoundingWidth: function () {
        return this._textAreaSize.width
    }, _getBoundingHeight: function () {
        return this._textAreaSize.height
    }, copySpecialProperties: function (a) {
        a instanceof
        a && (this.setFontName(a._fontName), this.setFontSize(a.getFontSize()), this.setString(a.getString()), this.setTouchScaleChangeEnabled(a.touchScaleEnabled), this.setTextAreaSize(a._textAreaSize), this.setTextHorizontalAlignment(a._labelRenderer.getHorizontalAlignment()), this.setTextVerticalAlignment(a._labelRenderer.getVerticalAlignment()))
    }});
_p = ccui.Text.prototype;
cc.defineGetterSetter(_p, "boundingWidth", _p._getBoundingWidth, _p._setBoundingWidth);
cc.defineGetterSetter(_p, "boundingHeight", _p._getBoundingHeight, _p._setBoundingHeight);
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
cc.defineGetterSetter(_p, "stringLength", _p.getStringLength);
cc.defineGetterSetter(_p, "font", _p._getFont, _p._setFont);
cc.defineGetterSetter(_p, "fontSize", _p.getFontSize, _p.setFontSize);
cc.defineGetterSetter(_p, "fontName", _p.getFontName, _p.setFontName);
cc.defineGetterSetter(_p, "textAlign", _p.getTextHorizontalAlignment, _p.setTextHorizontalAlignment);
cc.defineGetterSetter(_p, "verticalAlign", _p.getTextVerticalAlignment, _p.setTextVerticalAlignment);
_p = null;
ccui.Label = ccui.Text.create = function (a, b, c) {
    var d = new ccui.Text;
    if (0 < arguments.length) {
        if (d && d.init(a, b, c))return d
    } else if (d && d.init())return d;
    return null
};
ccui.Text.RENDERER_ZORDER = -1;
ccui.Text.Type = {SYSTEM: 0, TTF: 1};
ccui.TextAtlas = ccui.Widget.extend({_labelAtlasRenderer: null, _stringValue: "", _charMapFileName: "", _itemWidth: 0, _itemHeight: 0, _startCharMap: "", _className: "TextAtlas", _labelAtlasRendererAdaptDirty: null, ctor: function () {
    ccui.Widget.prototype.ctor.call(this)
}, initRenderer: function () {
    this._labelAtlasRenderer = new cc.LabelAtlas;
    this._labelAtlasRenderer.setAnchorPoint(cc.p(0.5, 0.5));
    this.addProtectedChild(this._labelAtlasRenderer, ccui.TextAtlas.RENDERER_ZORDER, -1)
}, setProperty: function (a, b, c, d, e) {
    this._stringValue =
        a;
    this._charMapFileName = b;
    this._itemWidth = c;
    this._itemHeight = d;
    this._startCharMap = e;
    this._labelAtlasRenderer.initWithString(a, this._charMapFileName, this._itemWidth, this._itemHeight, this._startCharMap[0]);
    this._updateContentSizeWithTextureSize(this._labelAtlasRenderer.getContentSize());
    this._labelAtlasRendererAdaptDirty = !0
}, setString: function (a) {
    this._stringValue = a;
    this._labelAtlasRenderer.setString(a);
    this._updateContentSizeWithTextureSize(this._labelAtlasRenderer.getContentSize());
    this._labelAtlasRendererAdaptDirty = !0
}, setStringValue: function (a) {
    cc.log("Please use the setString");
    this.setString(a)
}, getStringValue: function () {
    cc.log("Please use the getString");
    return this.getString()
}, getString: function () {
    return this._labelAtlasRenderer.getString()
}, getStringLength: function () {
    return this._labelAtlasRenderer.getStringLength()
}, onSizeChanged: function () {
    ccui.Widget.prototype.onSizeChanged.call(this);
    this._labelAtlasRendererAdaptDirty = !0
}, adaptRenderers: function () {
    this._labelAtlasRendererAdaptDirty && (this.labelAtlasScaleChangedWithSize(),
        this._labelAtlasRendererAdaptDirty = !1)
}, getVirtualRendererSize: function () {
    return this._labelAtlasRenderer.getContentSize()
}, getVirtualRenderer: function () {
    return this._labelAtlasRenderer
}, labelAtlasScaleChangedWithSize: function () {
    if (this._ignoreSize)this._labelAtlasRenderer.setScale(1); else {
        var a = this._labelAtlasRenderer.getContentSize();
        if (0 >= a.width || 0 >= a.height) {
            this._labelAtlasRenderer.setScale(1);
            return
        }
        var b = this._size.height / a.height;
        this._labelAtlasRenderer.setScaleX(this._size.width / a.width);
        this._labelAtlasRenderer.setScaleY(b)
    }
    this._labelAtlasRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
}, getDescription: function () {
    return"LabelAtlas"
}, createCloneInstance: function () {
    return ccui.TextAtlas.create()
}, copySpecialProperties: function (a) {
    a && this.setProperty(a._stringValue, a._charMapFileName, a._itemWidth, a._itemHeight, a._startCharMap)
}});
_p = ccui.TextAtlas.prototype;
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
_p = null;
ccui.TextAtlas.create = function (a, b, c, d, e) {
    var f = new ccui.TextAtlas;
    return f && f.init() ? (0 < arguments.length && f.setProperty(a, b, c, d, e), f) : null
};
ccui.TextAtlas.RENDERER_ZORDER = -1;
ccui.LabelBMFont = ccui.TextBMFont = ccui.Widget.extend({_labelBMFontRenderer: null, _fntFileHasInit: !1, _fntFileName: "", _stringValue: "", _className: "TextBMFont", _labelBMFontRendererAdaptDirty: !0, ctor: function () {
    ccui.Widget.prototype.ctor.call(this)
}, initRenderer: function () {
    this._labelBMFontRenderer = cc.LabelBMFont.create();
    this.addProtectedChild(this._labelBMFontRenderer, ccui.TextBMFont.RENDERER_ZORDER, -1)
}, setFntFile: function (a) {
    a && (this._fntFileName = a, this._labelBMFontRenderer.initWithString("", a), this.updateAnchorPoint(),
        this.labelBMFontScaleChangedWithSize(), this._labelBMFontRenderer.textureLoaded() || this._labelBMFontRenderer.addLoadedEventListener(function () {
        this.labelBMFontScaleChangedWithSize()
    }, this), this._labelBMFontRenderer.setColor(this.getColor()), this._labelBMFontRenderer.setOpacity(this.getOpacity()), this._fntFileHasInit = !0, this.setString(this._stringValue))
}, setText: function (a) {
    cc.log("Please use the setString");
    this.setString(a)
}, setString: function (a) {
    this._stringValue = a;
    this._fntFileHasInit && (this._labelBMFontRenderer.setString(a),
        this._updateContentSizeWithTextureSize(this._labelBMFontRenderer.getContentSize()), this._labelBMFontRendererAdaptDirty = !0)
}, getString: function () {
    return this._stringValue
}, getStringLength: function () {
    return this._labelBMFontRenderer.getStringLength()
}, onSizeChanged: function () {
    ccui.Widget.prototype.onSizeChanged.call(this);
    this._labelBMFontRendererAdaptDirty = !0
}, adaptRenderers: function () {
    this._labelBMFontRendererAdaptDirty && (this.labelBMFontScaleChangedWithSize(), this._labelBMFontRendererAdaptDirty = !1)
}, getVirtualRendererSize: function () {
    return this._labelBMFontRenderer.getContentSize()
}, getVirtualRenderer: function () {
    return this._labelBMFontRenderer
}, labelBMFontScaleChangedWithSize: function () {
    if (this._ignoreSize)this._labelBMFontRenderer.setScale(1); else {
        var a = this._labelBMFontRenderer.getContentSize();
        if (0 >= a.width || 0 >= a.height) {
            this._labelBMFontRenderer.setScale(1);
            return
        }
        var b = this._size.height / a.height;
        this._labelBMFontRenderer.setScaleX(this._size.width / a.width);
        this._labelBMFontRenderer.setScaleY(b)
    }
    this._labelBMFontRenderer.setPosition(this._contentSize.width /
        2, this._contentSize.height / 2)
}, getDescription: function () {
    return"LabelBMFont"
}});
_p = ccui.TextBMFont.prototype;
cc.defineGetterSetter(_p, "string", _p.getString, _p.setStringValue);
_p = null;
ccui.TextBMFont.create = function (a, b) {
    var c = new ccui.TextBMFont;
    return c && c.init() ? (b && a && (c.setFntFile(b), c.setString(a)), c) : null
};
ccui.TextBMFont.RENDERER_ZORDER = -1;
ccui.UICCTextField = cc.TextFieldTTF.extend({maxLengthEnabled: !1, maxLength: 0, passwordEnabled: !1, _passwordStyleText: "", _attachWithIME: !1, _detachWithIME: !1, _insertText: !1, _deleteBackward: !1, _className: "UICCTextField", _textFieldRendererAdaptDirty: !0, ctor: function () {
    cc.TextFieldTTF.prototype.ctor.call(this);
    this.maxLengthEnabled = !1;
    this.maxLength = 0;
    this.passwordEnabled = !1;
    this._passwordStyleText = "*";
    this._deleteBackward = this._insertText = this._detachWithIME = this._attachWithIME = !1
}, onEnter: function () {
    cc.TextFieldTTF.prototype.setDelegate.call(this,
        this)
}, onTextFieldAttachWithIME: function (a) {
    this.setAttachWithIME(!0);
    return!1
}, onTextFieldInsertText: function (a, b, c) {
    if (1 == c && "\n" == b)return!1;
    this.setInsertText(!0);
    return this.maxLengthEnabled && cc.TextFieldTTF.prototype.getCharCount.call(this) >= this.maxLength ? !0 : !1
}, onTextFieldDeleteBackward: function (a, b, c) {
    this.setDeleteBackward(!0);
    return!1
}, onTextFieldDetachWithIME: function (a) {
    this.setDetachWithIME(!0);
    return!1
}, insertText: function (a, b) {
    "\n" != a && this.maxLengthEnabled && this.getString().length >=
        this.maxLength ? this.passwordEnabled && this.setPasswordText(this.getString()) : (cc.TextFieldTTF.prototype.insertText.call(this, a, b), this.passwordEnabled && 0 < cc.TextFieldTTF.prototype.getCharCount.call(this) && this.setPasswordText(this.getString()))
}, deleteBackward: function () {
    cc.TextFieldTTF.prototype.deleteBackward.call(this);
    0 < cc.TextFieldTTF.prototype.getCharCount.call(this) && this.passwordEnabled && this.setPasswordText(this._inputText)
}, openIME: function () {
    cc.TextFieldTTF.prototype.attachWithIME.call(this)
},
    closeIME: function () {
        cc.TextFieldTTF.prototype.detachWithIME.call(this)
    }, setMaxLengthEnabled: function (a) {
        this.maxLengthEnabled = a
    }, isMaxLengthEnabled: function () {
        return this.maxLengthEnabled
    }, setMaxLength: function (a) {
        this.maxLength = a
    }, getMaxLength: function () {
        return this.maxLength
    }, getCharCount: function () {
        return cc.TextFieldTTF.prototype.getCharCount.call(this)
    }, setPasswordEnabled: function (a) {
        this.passwordEnabled = a
    }, isPasswordEnabled: function () {
        return this.passwordEnabled
    }, setPasswordStyleText: function (a) {
        if (!(1 <
            a.length)) {
            var b = a.charCodeAt(0);
            33 > b || 126 < b || (this._passwordStyleText = a)
        }
    }, setPasswordText: function (a) {
        var b = "", c = a.length;
        a = c;
        this.maxLengthEnabled && c > this.maxLength && (a = this.maxLength);
        for (c = 0; c < a; ++c)b += this._passwordStyleText;
        cc.LabelTTF.prototype.setString.call(this, b)
    }, setAttachWithIME: function (a) {
        this._attachWithIME = a
    }, getAttachWithIME: function () {
        return this._attachWithIME
    }, setDetachWithIME: function (a) {
        this._detachWithIME = a
    }, getDetachWithIME: function () {
        return this._detachWithIME
    }, setInsertText: function (a) {
        this._insertText =
            a
    }, getInsertText: function () {
        return this._insertText
    }, setDeleteBackward: function (a) {
        this._deleteBackward = a
    }, getDeleteBackward: function () {
        return this._deleteBackward
    }, init: function () {
        return ccui.Widget.prototype.init.call(this) ? (this.setTouchEnabled(!0), !0) : !1
    }, onDraw: function (a) {
        return!1
    }});
ccui.UICCTextField.create = function (a, b, c) {
    var d = new ccui.UICCTextField;
    return d && d.initWithString("", b, c) ? (a && d.setPlaceHolder(a), d) : null
};
ccui.TextField = ccui.Widget.extend({_textFieldRender: null, _touchWidth: 0, _touchHeight: 0, _useTouchArea: !1, _textFieldEventListener: null, _textFieldEventSelector: null, _attachWithIMEListener: null, _detachWithIMEListener: null, _insertTextListener: null, _deleteBackwardListener: null, _attachWithIMESelector: null, _detachWithIMESelector: null, _insertTextSelector: null, _deleteBackwardSelector: null, _passwordStyleText: "", _textFieldRendererAdaptDirty: !0, ctor: function () {
    ccui.Widget.prototype.ctor.call(this)
}, init: function () {
    return ccui.Widget.prototype.init.call(this) ?
        (this.setTouchEnabled(!0), !0) : !1
}, onEnter: function () {
    ccui.Widget.prototype.onEnter.call(this);
    this.setUpdateEnabled(!0)
}, onExit: function () {
    this.setUpdateEnabled(!1);
    ccui.Layout.prototype.onExit.call(this)
}, initRenderer: function () {
    this._textFieldRender = ccui.UICCTextField.create("input words here", "Thonburi", 20);
    this.addProtectedChild(this._textFieldRender, ccui.TextField.RENDERER_ZORDER, -1)
}, setTouchSize: function (a) {
    this._touchWidth = a.width;
    this._touchHeight = a.height
}, setTouchAreaEnabled: function (a) {
    this._useTouchArea =
        a
}, adaptRenderers: function () {
    this._textFieldRendererAdaptDirty && (this.textfieldRendererScaleChangedWithSize(), this._textFieldRendererAdaptDirty = !1)
}, hitTest: function (a) {
    if (this._useTouchArea) {
        a = this.convertToNodeSpace(a);
        var b = cc.rect(-this._touchWidth * this._anchorPoint.x, -this._touchHeight * this._anchorPoint.y, this._touchWidth, this._touchHeight);
        if (a.x >= b.origin.x && a.x <= b.origin.x + b.size.width && a.y >= b.origin.y && a.y <= b.origin.y + b.size.height)return!0
    } else return ccui.Widget.prototype.hitTest.call(this,
        a);
    return!1
}, getTouchSize: function () {
    return cc.size(this._touchWidth, this._touchHeight)
}, setText: function (a) {
    cc.log("Please use the setString");
    this.setString(a)
}, setString: function (a) {
    a && (a = String(a), this.isMaxLengthEnabled() && (a = a.substr(0, this.getMaxLength())), this.isPasswordEnabled() ? (this._textFieldRender.setPasswordText(a), this._textFieldRender.setString(""), this._textFieldRender.insertText(a, a.length)) : this._textFieldRender.setString(a), this._textFieldRendererAdaptDirty = !0, this._updateContentSizeWithTextureSize(this._textFieldRender.getContentSize()))
},
    setPlaceHolder: function (a) {
        this._textFieldRender.setPlaceHolder(a);
        this._textFieldRendererAdaptDirty = !0;
        this._updateContentSizeWithTextureSize(this._textFieldRender.getContentSize())
    }, getPlaceHolder: function () {
        return this._textFieldRender.getPlaceHolder()
    }, _setFont: function (a) {
        this._textFieldRender._setFont(a);
        this._textFieldRendererAdaptDirty = !0
    }, _getFont: function () {
        return this._textFieldRender._getFont()
    }, setFontSize: function (a) {
        this._textFieldRender.setFontSize(a);
        this._textFieldRendererAdaptDirty = !0;
        this._updateContentSizeWithTextureSize(this._textFieldRender.getContentSize())
    }, getFontSize: function () {
        return this._textFieldRender.getSystemFontSize()
    }, setFontName: function (a) {
        this._textFieldRender.setFontName(a);
        this._textFieldRendererAdaptDirty = !0;
        this._updateContentSizeWithTextureSize(this._textFieldRender.getContentSize())
    }, getFontName: function () {
        return this._textFieldRender.getSystemFontName()
    }, didNotSelectSelf: function () {
        this._textFieldRender.detachWithIME()
    }, getStringValue: function () {
        cc.log("Please use the getString");
        return this.getString()
    }, getString: function () {
        return this._textFieldRender.getString()
    }, getStringLength: function () {
        return this._textFieldRender.getStringLength()
    }, onTouchBegan: function (a, b) {
        var c = this, d = ccui.Widget.prototype.onTouchBegan.call(c, a, b);
        c._hitted && setTimeout(function () {
            c._textFieldRender.attachWithIME()
        }, 0);
        return d
    }, setMaxLengthEnabled: function (a) {
        this._textFieldRender.setMaxLengthEnabled(a)
    }, isMaxLengthEnabled: function () {
        return this._textFieldRender.isMaxLengthEnabled()
    }, setMaxLength: function (a) {
        this._textFieldRender.setMaxLength(a);
        this.setString(this.getString())
    }, getMaxLength: function () {
        return this._textFieldRender.getMaxLength()
    }, setPasswordEnabled: function (a) {
        this._textFieldRender.setPasswordEnabled(a)
    }, isPasswordEnabled: function () {
        return this._textFieldRender.isPasswordEnabled()
    }, setPasswordStyleText: function (a) {
        this._textFieldRender.setPasswordStyleText(a);
        this._passwordStyleText = a;
        this.setString(this.getString())
    }, getPasswordStyleText: function () {
        return this._passwordStyleText
    }, update: function (a) {
        this.getAttachWithIME() &&
        (this.attachWithIMEEvent(), this.setAttachWithIME(!1));
        this.getDetachWithIME() && (this.detachWithIMEEvent(), this.setDetachWithIME(!1));
        this.getInsertText() && (this.insertTextEvent(), this.setInsertText(!1), this._textFieldRendererAdaptDirty = !0, this._updateContentSizeWithTextureSize(this._textFieldRender.getContentSize()));
        this.getDeleteBackward() && (this.deleteBackwardEvent(), this.setDeleteBackward(!1), this._textFieldRendererAdaptDirty = !0, this._updateContentSizeWithTextureSize(this._textFieldRender.getContentSize()))
    },
    getAttachWithIME: function () {
        return this._textFieldRender.getAttachWithIME()
    }, setAttachWithIME: function (a) {
        this._textFieldRender.setAttachWithIME(a)
    }, getDetachWithIME: function () {
        return this._textFieldRender.getDetachWithIME()
    }, setDetachWithIME: function (a) {
        this._textFieldRender.setDetachWithIME(a)
    }, getInsertText: function () {
        return this._textFieldRender.getInsertText()
    }, setInsertText: function (a) {
        this._textFieldRender.setInsertText(a)
    }, getDeleteBackward: function () {
        return this._textFieldRender.getDeleteBackward()
    },
    setDeleteBackward: function (a) {
        this._textFieldRender.setDeleteBackward(a)
    }, attachWithIMEEvent: function () {
        this._textFieldEventListener && this._textFieldEventSelector && this._textFieldEventSelector.call(this._textFieldEventListener, this, ccui.TextField.EVENT_ATTACH_WITH_ME);
        this._eventCallback && this._eventCallback(this, 0)
    }, detachWithIMEEvent: function () {
        this._textFieldEventListener && this._textFieldEventSelector && this._textFieldEventSelector.call(this._textFieldEventListener, this, ccui.TextField.EVENT_DETACH_WITH_ME);
        this._eventCallback && this._eventCallback(this, 1)
    }, insertTextEvent: function () {
        this._textFieldEventListener && this._textFieldEventSelector && this._textFieldEventSelector.call(this._textFieldEventListener, this, ccui.TextField.EVENT_INSERT_TEXT);
        this._eventCallback && this._eventCallback(this, 2)
    }, deleteBackwardEvent: function () {
        this._textFieldEventListener && this._textFieldEventSelector && this._textFieldEventSelector.call(this._textFieldEventListener, this, ccui.TextField.EVENT_DELETE_BACKWARD);
        this._eventCallback &&
        this._eventCallback(this, 3)
    }, addEventListenerTextField: function (a, b) {
        this._textFieldEventSelector = a;
        this._textFieldEventListener = b
    }, setAnchorPoint: function (a, b) {
        void 0 === b ? (ccui.Widget.prototype.setAnchorPoint.call(this, a), this._textFieldRender.setAnchorPoint(a)) : (ccui.Widget.prototype.setAnchorPoint.call(this, a, b), this._textFieldRender.setAnchorPoint(a, b))
    }, _setAnchorX: function (a) {
        ccui.Widget.prototype._setAnchorX.call(this, a);
        this._textFieldRender._setAnchorX(a)
    }, _setAnchorY: function (a) {
        ccui.Widget.prototype._setAnchorY.call(this,
            a);
        this._textFieldRender._setAnchorY(a)
    }, onSizeChanged: function () {
        ccui.Widget.prototype.onSizeChanged.call(this);
        this._textFieldRendererAdaptDirty = !0
    }, textfieldRendererScaleChangedWithSize: function () {
        if (this._ignoreSize) {
            this._textFieldRender.setScale(1);
            var a = this.getContentSize();
            this._size.width = a.width;
            this._size.height = a.height
        } else {
            a = this.getContentSize();
            if (0 >= a.width || 0 >= a.height) {
                this._textFieldRender.setScale(1);
                return
            }
            var b = this._size.height / a.height;
            this._textFieldRender.setScaleX(this._size.width /
                a.width);
            this._textFieldRender.setScaleY(b)
        }
        this._textFieldRender.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    }, getContentSize: function () {
        return this._textFieldRender.getContentSize()
    }, _getWidth: function () {
        return this._textFieldRender._getWidth()
    }, _getHeight: function () {
        return this._textFieldRender._getHeight()
    }, getVirtualRenderer: function () {
        return this._textFieldRender
    }, updateTextureColor: function () {
        this.updateColorToRenderer(this._textFieldRender)
    }, updateTextureOpacity: function () {
        this.updateOpacityToRenderer(this._textFieldRender)
    },
    getDescription: function () {
        return"TextField"
    }, attachWithIME: function () {
        this._textFieldRender.attachWithIME()
    }, createCloneInstance: function () {
        return ccui.TextField.create()
    }, copySpecialProperties: function (a) {
        this.setString(a._textFieldRender.getString());
        this.setPlaceHolder(a.getString());
        this.setFontSize(a._textFieldRender.getFontSize());
        this.setFontName(a._textFieldRender.getFontName());
        this.setMaxLengthEnabled(a.isMaxLengthEnabled());
        this.setMaxLength(a.getMaxLength());
        this.setPasswordEnabled(a.isPasswordEnabled());
        this.setPasswordStyleText(a._passwordStyleText);
        this.setAttachWithIME(a.getAttachWithIME());
        this.setDetachWithIME(a.getDetachWithIME());
        this.setInsertText(a.getInsertText());
        this.setDeleteBackward(a.getDeleteBackward())
    }});
ccui.TextField.create = function (a, b, c) {
    var d = new ccui.TextField;
    return d && d.init() ? (a && (b && c) && (d.setPlaceHolder(a), d.setFontName(b), d.setFontSize(c)), d) : null
};
_p = ccui.TextField.prototype;
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
cc.defineGetterSetter(_p, "placeHolder", _p.getPlaceHolder, _p.setPlaceHolder);
cc.defineGetterSetter(_p, "font", _p._getFont, _p._setFont);
cc.defineGetterSetter(_p, "fontSize", _p.getFontSize, _p.setFontSize);
cc.defineGetterSetter(_p, "fontName", _p.getFontName, _p.setFontName);
cc.defineGetterSetter(_p, "maxLengthEnabled", _p.isMaxLengthEnabled, _p.setMaxLengthEnabled);
cc.defineGetterSetter(_p, "maxLength", _p.getMaxLength, _p.setMaxLength);
cc.defineGetterSetter(_p, "passwordEnabled", _p.isPasswordEnabled, _p.setPasswordEnabled);
_p = null;
ccui.TextField.create = function () {
    return new ccui.TextField
};
ccui.TextField.EVENT_ATTACH_WITH_ME = 0;
ccui.TextField.EVENT_DETACH_WITH_ME = 1;
ccui.TextField.EVENT_INSERT_TEXT = 2;
ccui.TextField.EVENT_DELETE_BACKWARD = 3;
ccui.TextField.RENDERER_ZORDER = -1;
ccui.RichElement = ccui.Class.extend({type: 0, tag: 0, color: null, ctor: function () {
    this.tag = this.type = 0;
    this.color = cc.color(255, 255, 255, 255)
}, init: function (a, b, c) {
    this.tag = a;
    this.color.r = b.r;
    this.color.g = b.g;
    this.color.b = b.b;
    this.color.a = c
}});
ccui.RichElementText = ccui.RichElement.extend({text: "", fontName: "", fontSize: 0, ctor: function () {
    ccui.RichElement.prototype.ctor.call(this);
    this.type = ccui.RichElement.TEXT;
    this.fontName = this.text = "";
    this.fontSize = 0
}, init: function (a, b, c, d, e, f) {
    ccui.RichElement.prototype.init.call(this, a, b, c);
    this.text = d;
    this.fontName = e;
    this.fontSize = f
}});
ccui.RichElementText.create = function (a, b, c, d, e, f) {
    var g = new ccui.RichElementText;
    g.init(a, b, c, d, e, f);
    return g
};
ccui.RichElementImage = ccui.RichElement.extend({filePath: "", textureRect: null, textureType: 0, ctor: function () {
    ccui.RichElement.prototype.ctor.call(this);
    this.type = ccui.RichElement.IMAGE;
    this.filePath = "";
    this.textureRect = cc.rect(0, 0, 0, 0);
    this.textureType = 0
}, init: function (a, b, c, d) {
    ccui.RichElement.prototype.init.call(this, a, b, c);
    this.filePath = d
}});
ccui.RichElementImage.create = function (a, b, c, d) {
    var e = new ccui.RichElementImage;
    e.init(a, b, c, d);
    return e
};
ccui.RichElementCustomNode = ccui.RichElement.extend({customNode: null, ctor: function () {
    ccui.RichElement.prototype.ctor.call(this);
    this.type = ccui.RichElement.CUSTOM;
    this.customNode = null
}, init: function (a, b, c, d) {
    ccui.RichElement.prototype.init.call(this, a, b, c);
    this.customNode = d
}});
ccui.RichElementCustomNode.create = function (a, b, c, d) {
    var e = new ccui.RichElementCustomNode;
    e.init(a, b, c, d);
    return e
};
ccui.RichText = ccui.Widget.extend({_formatTextDirty: !1, _richElements: null, _elementRenders: null, _leftSpaceWidth: 0, _verticalSpace: 0, _elementRenderersContainer: null, ctor: function () {
    ccui.Widget.prototype.ctor.call(this);
    this._formatTextDirty = !1;
    this._richElements = [];
    this._elementRenders = [];
    this._verticalSpace = this._leftSpaceWidth = 0
}, initRenderer: function () {
    this._elementRenderersContainer = cc.Node.create();
    this._elementRenderersContainer.setAnchorPoint(0.5, 0.5);
    this.addProtectedChild(this._elementRenderersContainer,
        0, -1)
}, insertElement: function (a, b) {
    this._richElements.splice(b, 0, a);
    this._formatTextDirty = !0
}, pushBackElement: function (a) {
    this._richElements.push(a);
    this._formatTextDirty = !0
}, removeElement: function (a) {
    "number" === typeof a ? this._richElements.splice(a, 1) : cc.arrayRemoveObject(this._richElements, a);
    this._formatTextDirty = !0
}, formatText: function () {
    if (this._formatTextDirty) {
        this._elementRenderersContainer.removeAllChildren();
        this._elementRenders.length = 0;
        var a, b, c = this._richElements;
        if (this._ignoreSize) {
            this.addNewLine();
            for (a = 0; a < c.length; a++) {
                b = c[a];
                var d = null;
                switch (b.type) {
                    case ccui.RichElement.TEXT:
                        d = cc.LabelTTF.create(b.text, b.fontName, b.fontSize);
                        break;
                    case ccui.RichElement.IMAGE:
                        d = cc.Sprite.create(b.filePath);
                        break;
                    case ccui.RichElement.CUSTOM:
                        d = b.customNode
                }
                d.setColor(b.color);
                d.setOpacity(b.color.a);
                this.pushToContainer(d)
            }
        } else {
            this.addNewLine();
            for (a = 0; a < c.length; a++)switch (b = c[a], b.type) {
                case ccui.RichElement.TEXT:
                    this.handleTextRenderer(b.text, b.fontName, b.fontSize, b.color);
                    break;
                case ccui.RichElement.IMAGE:
                    this.handleImageRenderer(b.filePath,
                        b.color, b.color.a);
                    break;
                case ccui.RichElement.CUSTOM:
                    this.handleCustomRenderer(b.customNode)
            }
        }
        this.formatRenderers();
        this._formatTextDirty = !1
    }
}, handleTextRenderer: function (a, b, c, d) {
    var e = cc.LabelTTF.create(a, b, c), f = e.getContentSize().width;
    this._leftSpaceWidth -= f;
    0 > this._leftSpaceWidth ? (e = a.length * (1 - -this._leftSpaceWidth / f), f = a.substr(0, e), a = a.substr(e, a.length - 1), 0 < e && (e = cc.LabelTTF.create(f.substr(0, e), b, c), e.setColor(d), e.setOpacity(d.a), this.pushToContainer(e)), this.addNewLine(), this.handleTextRenderer(a,
        b, c, d)) : (e.setColor(d), e.setOpacity(d.a), this.pushToContainer(e))
}, handleImageRenderer: function (a, b, c) {
    a = cc.Sprite.create(a);
    this.handleCustomRenderer(a)
}, handleCustomRenderer: function (a) {
    var b = a.getContentSize();
    this._leftSpaceWidth -= b.width;
    0 > this._leftSpaceWidth ? (this.addNewLine(), this.pushToContainer(a), this._leftSpaceWidth -= b.width) : this.pushToContainer(a)
}, addNewLine: function () {
    this._leftSpaceWidth = this._customSize.width;
    this._elementRenders.push([])
}, formatRenderers: function () {
    var a = 0, b = this._elementRenderersContainer,
        c = this._elementRenders;
    if (this._ignoreSize) {
        for (var d = 0, e = c[0], f = 0, g = 0; g < e.length; g++) {
            var h = e[g];
            h.setAnchorPoint(cc.p(0, 0));
            h.setPosition(cc.p(f, 0));
            b.addChild(h, 1, g);
            c = h.getContentSize();
            d += c.width;
            a = Math.max(a, c.height);
            f += c.width
        }
        b.setContentSize(cc.size(d, a))
    } else {
        for (var d = [], k = 0; k < c.length; k++) {
            e = c[k];
            for (g = f = 0; g < e.length; g++)h = e[g], f = Math.max(h.getContentSize().height, f);
            d[k] = f;
            a += d[k]
        }
        a = this._customSize.height;
        for (k = 0; k < c.length; k++) {
            e = c[k];
            f = 0;
            a -= d[k] + this._verticalSpace;
            for (g = 0; g < e.length; g++)h =
                e[g], h.setAnchorPoint(cc.p(0, 0)), h.setPosition(cc.p(f, a)), b.addChild(h, 1, 10 * k + g), f += h.getContentSize().width
        }
        b.setContentSize(this._size)
    }
    this._elementRenders.length = 0;
    this._ignoreSize ? (e = this.getVirtualRendererSize(), this._size.width = e.width, this._size.height = e.height) : (this._size.width = this._customSize.width, this._size.height = this._customSize.height);
    this._updateContentSizeWithTextureSize(this._size);
    b.setPosition(0.5 * this._contentSize.width, 0.5 * this._contentSize.height)
}, pushToContainer: function (a) {
    0 >=
    this._elementRenders.length || this._elementRenders[this._elementRenders.length - 1].push(a)
}, visit: function (a) {
    this._enabled && (this.formatText(), ccui.Widget.prototype.visit.call(this, a))
}, setVerticalSpace: function (a) {
    this._verticalSpace = a
}, setAnchorPoint: function (a) {
    ccui.Widget.prototype.setAnchorPoint.call(this, a);
    this._elementRenderersContainer.setAnchorPoint(a)
}, getVirtualRendererSize: function () {
    return this._elementRenderersContainer.getContentSize()
}, getContentSize: function () {
    return this._elementRenderersContainer.getContentSize()
},
    ignoreContentAdaptWithSize: function (a) {
        this._ignoreSize != a && (this._formatTextDirty = !0, ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this, a))
    }, getDescription: function () {
        return"RichText"
    }});
ccui.RichText.create = function () {
    return new ccui.RichText
};
ccui.RichElement.TEXT = 0;
ccui.RichElement.IMAGE = 1;
ccui.RichElement.CUSTOM = 2;
ccui.ScrollView = ccui.Layout.extend({_innerContainer: null, direction: null, _autoScrollDir: null, _topBoundary: 0, _bottomBoundary: 0, _leftBoundary: 0, _rightBoundary: 0, _bounceTopBoundary: 0, _bounceBottomBoundary: 0, _bounceLeftBoundary: 0, _bounceRightBoundary: 0, _autoScroll: !1, _autoScrollAddUpTime: 0, _autoScrollOriginalSpeed: 0, _autoScrollAcceleration: 0, _isAutoScrollSpeedAttenuated: !1, _needCheckAutoScrollDestination: !1, _autoScrollDestination: null, _bePressed: !1, _slidTime: 0, _moveChildPoint: null, _childFocusCancelOffset: 0,
    _leftBounceNeeded: !1, _topBounceNeeded: !1, _rightBounceNeeded: !1, _bottomBounceNeeded: !1, bounceEnabled: !1, _bouncing: !1, _bounceDir: null, _bounceOriginalSpeed: 0, inertiaScrollEnabled: !1, _scrollViewEventListener: null, _scrollViewEventSelector: null, _className: "ScrollView", _eventCallback: null, ctor: function () {
        ccui.Layout.prototype.ctor.call(this);
        this.direction = ccui.ScrollView.DIR_NONE;
        this._autoScrollDir = cc.p(0, 0);
        this._bounceRightBoundary = this._bounceLeftBoundary = this._bounceBottomBoundary = this._bounceTopBoundary =
            this._rightBoundary = this._leftBoundary = this._bottomBoundary = this._topBoundary = 0;
        this._autoScroll = !1;
        this._autoScrollOriginalSpeed = this._autoScrollAddUpTime = 0;
        this._autoScrollAcceleration = -1E3;
        this._needCheckAutoScrollDestination = this._isAutoScrollSpeedAttenuated = !1;
        this._autoScrollDestination = cc.p(0, 0);
        this._bePressed = !1;
        this._slidTime = 0;
        this._moveChildPoint = cc.p(0, 0);
        this._childFocusCancelOffset = 5;
        this._bouncing = this.bounceEnabled = this._bottomBounceNeeded = this._rightBounceNeeded = this._topBounceNeeded =
            this._leftBounceNeeded = !1;
        this._bounceDir = cc.p(0, 0);
        this._bounceOriginalSpeed = 0;
        this.inertiaScrollEnabled = !0;
        this._scrollViewEventSelector = this._scrollViewEventListener = null
    }, init: function () {
        return ccui.Layout.prototype.init.call(this) ? (this.setClippingEnabled(!0), this._innerContainer.setTouchEnabled(!1), !0) : !1
    }, onEnter: function () {
        ccui.Layout.prototype.onEnter.call(this);
        this.scheduleUpdate(!0)
    }, findNextFocusedWidget: function (a, b) {
        return this.getLayoutType() == ccui.Layout.LINEAR_VERTICAL || this.getLayoutType() ==
            ccui.Layout.LINEAR_HORIZONTAL ? this._innerContainer.findNextFocusedWidget(a, b) : ccui.Widget.prototype.findNextFocusedWidget.call(this, a, b)
    }, initRenderer: function () {
        ccui.Layout.prototype.initRenderer.call(this);
        this._innerContainer = ccui.Layout.create();
        this.addProtectedChild(this._innerContainer, 1, 1)
    }, onSizeChanged: function () {
        ccui.Layout.prototype.onSizeChanged.call(this);
        var a = this._contentSize;
        this._topBoundary = a.height;
        this._rightBoundary = a.width;
        var b = a.width / 3, c = a.height / 3;
        this._bounceTopBoundary =
            a.height - c;
        this._bounceBottomBoundary = c;
        this._bounceLeftBoundary = b;
        this._bounceRightBoundary = this._contentSize.width - b;
        c = this._innerContainer.getContentSize();
        b = c.height;
        c = Math.max(c.width, a.width);
        b = Math.max(b, a.height);
        this._innerContainer.setContentSize(cc.size(c, b));
        this._innerContainer.setPosition(0, a.height - this._innerContainer.getContentSize().height)
    }, setInnerContainerSize: function (a) {
        var b = this._contentSize, c = b.width, d = b.height, e = this._innerContainer.getContentSize();
        a.width < b.width ? cc.log("Inner width \x3c\x3d scrollview width, it will be force sized!") :
            c = a.width;
        a.height < b.height ? cc.log("Inner height \x3c\x3d scrollview height, it will be force sized!") : d = a.height;
        this._innerContainer.setSize(cc.size(c, d));
        switch (this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
                a = this._innerContainer.getContentSize();
                e = e.height - a.height;
                this.scrollChildren(0, e);
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                this._innerContainer.getRightBoundary() <= b.width && (a = this._innerContainer.getContentSize(), e = e.width - a.width, this.scrollChildren(e, 0));
                break;
            case ccui.ScrollView.DIR_BOTH:
                a =
                    this._innerContainer.getContentSize(), c = e.height - a.height, d = 0, this._innerContainer.getRightBoundary() <= b.width && (d = e.width - a.width), this.scrollChildren(d, c)
        }
        e = this._innerContainer;
        a = e.getContentSize();
        c = e.getPosition();
        d = e.getAnchorPoint();
        0 < e.getLeftBoundary() && e.setPosition(d.x * a.width, c.y);
        e.getRightBoundary() < b.width && e.setPosition(b.width - (1 - d.x) * a.width, c.y);
        0 < c.y && e.setPosition(c.x, d.y * a.height);
        e.getTopBoundary() < b.height && e.setPosition(c.x, b.height - (1 - d.y) * a.height)
    }, _setInnerWidth: function (a) {
        var b =
            this._contentSize.width, c = b, d = this._innerContainer, e = d.width;
        a < b ? cc.log("Inner width \x3c\x3d scrollview width, it will be force sized!") : c = a;
        d.width = c;
        switch (this.direction) {
            case ccui.ScrollView.DIR_HORIZONTAL:
            case ccui.ScrollView.DIR_BOTH:
                d.getRightBoundary() <= b && this.scrollChildren(e - d.width, 0)
        }
        a = d.anchorX;
        0 < d.getLeftBoundary() && (d.x = a * c);
        d.getRightBoundary() < b && (d.x = b - (1 - a) * c)
    }, _setInnerHeight: function (a) {
        var b = this._contentSize.height, c = b, d = this._innerContainer, e = d.height;
        a < b ? cc.log("Inner height \x3c\x3d scrollview height, it will be force sized!") :
            c = a;
        d.height = c;
        switch (this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
            case ccui.ScrollView.DIR_BOTH:
                this.scrollChildren(0, e - c)
        }
        a = d.anchorY;
        0 < d.getLeftBoundary() && (d.y = a * c);
        d.getRightBoundary() < b && (d.y = b - (1 - a) * c)
    }, getInnerContainerSize: function () {
        return this._innerContainer.getContentSize()
    }, _getInnerWidth: function () {
        return this._innerContainer.width
    }, _getInnerHeight: function () {
        return this._innerContainer.height
    }, addChild: function (a, b, c) {
        if (!a)return!1;
        b = b || a.getLocalZOrder();
        c = c || a.getTag();
        return this._innerContainer.addChild(a,
            b, c)
    }, removeAllChildren: function () {
        this.removeAllChildrenWithCleanup(!0)
    }, removeAllChildrenWithCleanup: function (a) {
        this._innerContainer.removeAllChildrenWithCleanup(a)
    }, removeChild: function (a, b) {
        return this._innerContainer.removeChild(a, b)
    }, getChildren: function () {
        return this._innerContainer.getChildren()
    }, getChildrenCount: function () {
        return this._innerContainer.getChildrenCount()
    }, getChildByTag: function (a) {
        return this._innerContainer.getChildByTag(a)
    }, getChildByName: function (a) {
        return this._innerContainer.getChildByName(a)
    },
    addNode: function (a, b, c) {
        this._innerContainer.addNode(a, b, c)
    }, getNodeByTag: function (a) {
        return this._innerContainer.getNodeByTag(a)
    }, getNodes: function () {
        return this._innerContainer.getNodes()
    }, removeNode: function (a) {
        this._innerContainer.removeNode(a)
    }, removeNodeByTag: function (a) {
        this._innerContainer.removeNodeByTag(a)
    }, removeAllNodes: function () {
        this._innerContainer.removeAllNodes()
    }, moveChildren: function (a, b) {
        var c = this._innerContainer.getPosition();
        this._moveChildPoint.x = c.x + a;
        this._moveChildPoint.y =
            c.y + b;
        this._innerContainer.setPosition(this._moveChildPoint)
    }, autoScrollChildren: function (a) {
        var b = this._autoScrollAddUpTime;
        this._autoScrollAddUpTime += a;
        if (this._isAutoScrollSpeedAttenuated)0 >= this._autoScrollOriginalSpeed + this._autoScrollAcceleration * this._autoScrollAddUpTime ? (this.stopAutoScrollChildren(), this.checkNeedBounce()) : (b = (this._autoScrollOriginalSpeed + 0.5 * this._autoScrollAcceleration * (2 * b + a)) * a, this.scrollChildren(b * this._autoScrollDir.x, b * this._autoScrollDir.y) || (this.stopAutoScrollChildren(),
            this.checkNeedBounce())); else if (this._needCheckAutoScrollDestination) {
            var b = this._autoScrollDir.x * a * this._autoScrollOriginalSpeed, c = this._autoScrollDir.y * a * this._autoScrollOriginalSpeed;
            a = this.checkCustomScrollDestination(b, c);
            b = this.scrollChildren(b, c);
            if (!a || !b)this.stopAutoScrollChildren(), this.checkNeedBounce()
        } else this.scrollChildren(this._autoScrollDir.x * a * this._autoScrollOriginalSpeed, this._autoScrollDir.y * a * this._autoScrollOriginalSpeed) || (this.stopAutoScrollChildren(), this.checkNeedBounce())
    },
    bounceChildren: function (a) {
        var b = this._bounceOriginalSpeed, c = this._bounceDir;
        0 >= b && this.stopBounceChildren();
        this.bounceScrollChildren(c.x * a * b, c.y * a * b) || this.stopBounceChildren()
    }, checkNeedBounce: function () {
        if (!this.bounceEnabled)return!1;
        this.checkBounceBoundary();
        if (this._topBounceNeeded || this._bottomBounceNeeded || this._leftBounceNeeded || this._rightBounceNeeded) {
            var a, b;
            this._topBounceNeeded && this._leftBounceNeeded ? (a = cc.pSub(cc.p(0, this._contentSize.height), cc.p(this._innerContainer.getLeftBoundary(),
                this._innerContainer.getTopBoundary())), b = cc.pLength(a) / 0.2, this._bounceDir = cc.pNormalize(a), this.startBounceChildren(b)) : this._topBounceNeeded && this._rightBounceNeeded ? (a = cc.pSub(cc.p(this._contentSize.width, this._contentSize.height), cc.p(this._innerContainer.getRightBoundary(), this._innerContainer.getTopBoundary())), b = cc.pLength(a) / 0.2, this._bounceDir = cc.pNormalize(a), this.startBounceChildren(b)) : this._bottomBounceNeeded && this._leftBounceNeeded ? (a = cc.pSub(cc.p(0, 0), cc.p(this._innerContainer.getLeftBoundary(),
                this._innerContainer.getBottomBoundary())), b = cc.pLength(a) / 0.2, this._bounceDir = cc.pNormalize(a), this.startBounceChildren(b)) : this._bottomBounceNeeded && this._rightBounceNeeded ? (a = cc.pSub(cc.p(this._contentSize.width, 0), cc.p(this._innerContainer.getRightBoundary(), this._innerContainer.getBottomBoundary())), b = cc.pLength(a) / 0.2, this._bounceDir = cc.pNormalize(a), this.startBounceChildren(b)) : this._topBounceNeeded ? (a = cc.pSub(cc.p(0, this._contentSize.height), cc.p(0, this._innerContainer.getTopBoundary())),
                b = cc.pLength(a) / 0.2, this._bounceDir = cc.pNormalize(a), this.startBounceChildren(b)) : this._bottomBounceNeeded ? (a = cc.pSub(cc.p(0, 0), cc.p(0, this._innerContainer.getBottomBoundary())), b = cc.pLength(a) / 0.2, this._bounceDir = cc.pNormalize(a), this.startBounceChildren(b)) : this._leftBounceNeeded ? (a = cc.pSub(cc.p(0, 0), cc.p(this._innerContainer.getLeftBoundary(), 0)), b = cc.pLength(a) / 0.2, this._bounceDir = cc.pNormalize(a), this.startBounceChildren(b)) : this._rightBounceNeeded && (a = cc.pSub(cc.p(this._contentSize.width, 0),
                cc.p(this._innerContainer.getRightBoundary(), 0)), b = cc.pLength(a) / 0.2, this._bounceDir = cc.pNormalize(a), this.startBounceChildren(b));
            return!0
        }
        return!1
    }, checkBounceBoundary: function () {
        this._innerContainer.getBottomBoundary() > this._bottomBoundary ? (this.scrollToBottomEvent(), this._bottomBounceNeeded = !0) : this._bottomBounceNeeded = !1;
        this._innerContainer.getTopBoundary() < this._topBoundary ? (this.scrollToTopEvent(), this._topBounceNeeded = !0) : this._topBounceNeeded = !1;
        this._innerContainer.getRightBoundary() < this._rightBoundary ?
            (this.scrollToRightEvent(), this._rightBounceNeeded = !0) : this._rightBounceNeeded = !1;
        this._innerContainer.getLeftBoundary() > this._leftBoundary ? (this.scrollToLeftEvent(), this._leftBounceNeeded = !0) : this._leftBounceNeeded = !1
    }, startBounceChildren: function (a) {
        this._bounceOriginalSpeed = a;
        this._bouncing = !0
    }, stopBounceChildren: function () {
        this._bouncing = !1;
        this._bounceOriginalSpeed = 0;
        this._bottomBounceNeeded = this._topBounceNeeded = this._rightBounceNeeded = this._leftBounceNeeded = !1
    }, startAutoScrollChildrenWithOriginalSpeed: function (a, b, c, d) {
        this.stopAutoScrollChildren();
        this._autoScrollDir = a;
        this._isAutoScrollSpeedAttenuated = c;
        this._autoScrollOriginalSpeed = b;
        this._autoScroll = !0;
        this._autoScrollAcceleration = d
    }, startAutoScrollChildrenWithDestination: function (a, b, c) {
        this._needCheckAutoScrollDestination = !1;
        this._autoScrollDestination = a;
        var d = cc.pSub(a, this._innerContainer.getPosition());
        a = cc.pNormalize(d);
        var e = 0, f = -1E3, d = cc.pLength(d);
        c ? (f = -(2 * d) / (b * b), e = 2 * d / b) : (this._needCheckAutoScrollDestination = !0, e = d / b);
        this.startAutoScrollChildrenWithOriginalSpeed(a,
            e, c, f)
    }, jumpToDestination: function (a, b) {
        void 0 !== a.x && (b = a.y, a = a.x);
        var c = a, d = b;
        switch (this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
                0 >= b && (d = Math.max(b, this._contentSize.height - this._innerContainer.getContentSize().height));
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                0 >= a && (c = Math.max(a, this._contentSize.width - this._innerContainer.getContentSize().width));
                break;
            case ccui.ScrollView.DIR_BOTH:
                0 >= b && (d = Math.max(b, this._contentSize.height - this._innerContainer.getContentSize().height)), 0 >= a && (c = Math.max(a,
                        this._contentSize.width - this._innerContainer.getContentSize().width))
        }
        this._innerContainer.setPosition(c, d)
    }, stopAutoScrollChildren: function () {
        this._autoScroll = !1;
        this._autoScrollAddUpTime = this._autoScrollOriginalSpeed = 0
    }, bounceScrollChildren: function (a, b) {
        var c = !0, d, e, f;
        0 < a && 0 < b ? (d = a, e = b, f = this._innerContainer.getRightBoundary(), f + d >= this._rightBoundary && (d = this._rightBoundary - f, this.bounceRightEvent(), c = !1), f = this._innerContainer.getTopBoundary(), f + b >= this._topBoundary && (e = this._topBoundary - f, this.bounceTopEvent(),
            c = !1), this.moveChildren(d, e)) : 0 > a && 0 < b ? (d = a, e = b, f = this._innerContainer.getLeftBoundary(), f + d <= this._leftBoundary && (d = this._leftBoundary - f, this.bounceLeftEvent(), c = !1), f = this._innerContainer.getTopBoundary(), f + b >= this._topBoundary && (e = this._topBoundary - f, this.bounceTopEvent(), c = !1), this.moveChildren(d, e)) : 0 > a && 0 > b ? (d = a, e = b, f = this._innerContainer.getLeftBoundary(), f + d <= this._leftBoundary && (d = this._leftBoundary - f, this.bounceLeftEvent(), c = !1), f = this._innerContainer.getBottomBoundary(), f + b <= this._bottomBoundary &&
            (e = this._bottomBoundary - f, this.bounceBottomEvent(), c = !1), this.moveChildren(d, e)) : 0 < a && 0 > b ? (d = a, e = b, f = this._innerContainer.getRightBoundary(), f + d >= this._rightBoundary && (d = this._rightBoundary - f, this.bounceRightEvent(), c = !1), f = this._innerContainer.getBottomBoundary(), f + b <= this._bottomBoundary && (e = this._bottomBoundary - f, this.bounceBottomEvent(), c = !1), this.moveChildren(d, e)) : 0 == a && 0 < b ? (e = b, f = this._innerContainer.getTopBoundary(), f + b >= this._topBoundary && (e = this._topBoundary - f, this.bounceTopEvent(), c = !1),
            this.moveChildren(0, e)) : 0 == a && 0 > b ? (e = b, f = this._innerContainer.getBottomBoundary(), f + b <= this._bottomBoundary && (e = this._bottomBoundary - f, this.bounceBottomEvent(), c = !1), this.moveChildren(0, e)) : 0 < a && 0 == b ? (d = a, f = this._innerContainer.getRightBoundary(), f + d >= this._rightBoundary && (d = this._rightBoundary - f, this.bounceRightEvent(), c = !1), this.moveChildren(d, 0)) : 0 > a && 0 == b && (d = a, e = this._innerContainer.getLeftBoundary(), e + d <= this._leftBoundary && (d = this._leftBoundary - e, this.bounceLeftEvent(), c = !1), this.moveChildren(d,
            0));
        return c
    }, checkCustomScrollDestination: function (a, b) {
        var c = !0, d;
        switch (this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
                0 < this._autoScrollDir.y ? (d = this._innerContainer.getBottomBoundary(), d + b >= this._autoScrollDestination.y && (c = !1)) : (d = this._innerContainer.getBottomBoundary(), d + b <= this._autoScrollDestination.y && (c = !1));
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                0 < this._autoScrollDir.x ? (d = this._innerContainer.getLeftBoundary(), d + a >= this._autoScrollDestination.x && (c = !1)) : (d = this._innerContainer.getLeftBoundary(),
                    d + a <= this._autoScrollDestination.x && (c = !1));
                break;
            case ccui.ScrollView.DIR_BOTH:
                0 < a && 0 < b ? (d = this._innerContainer.getLeftBoundary(), d + a >= this._autoScrollDestination.x && (c = !1), d = this._innerContainer.getBottomBoundary(), d + b >= this._autoScrollDestination.y && (c = !1)) : 0 > a && 0 < b ? (d = this._innerContainer.getRightBoundary(), d + a <= this._autoScrollDestination.x && (c = !1), d = this._innerContainer.getBottomBoundary(), d + b >= this._autoScrollDestination.y && (c = !1)) : 0 > a && 0 > b ? (d = this._innerContainer.getRightBoundary(), d + a <= this._autoScrollDestination.x &&
                    (c = !1), d = this._innerContainer.getTopBoundary(), d + b <= this._autoScrollDestination.y && (c = !1)) : 0 < a && 0 > b ? (d = this._innerContainer.getLeftBoundary(), d + a >= this._autoScrollDestination.x && (c = !1), d = this._innerContainer.getTopBoundary(), d + b <= this._autoScrollDestination.y && (c = !1)) : 0 == a && 0 < b ? (d = this._innerContainer.getBottomBoundary(), d + b >= this._autoScrollDestination.y && (c = !1)) : 0 > a && 0 == b ? (d = this._innerContainer.getRightBoundary(), d + a <= this._autoScrollDestination.x && (c = !1)) : 0 == a && 0 > b ? (d = this._innerContainer.getTopBoundary(),
                    d + b <= this._autoScrollDestination.y && (c = !1)) : 0 < a && 0 == b && (d = this._innerContainer.getLeftBoundary(), d + a >= this._autoScrollDestination.x && (c = !1))
        }
        return c
    }, getCurAutoScrollDistance: function (a) {
        this._autoScrollOriginalSpeed -= this._autoScrollAcceleration * a;
        return this._autoScrollOriginalSpeed * a
    }, scrollChildren: function (a, b) {
        var c = !0;
        this.scrollingEvent();
        switch (this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
                c = this.scrollChildrenVertical(a, b);
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                c = this.scrollChildrenHorizontal(a,
                    b);
                break;
            case ccui.ScrollView.DIR_BOTH:
                c = this.scrollChildrenBoth(a, b)
        }
        return c
    }, scrollChildrenVertical: function (a, b) {
        var c = b, d = !0, e;
        this.bounceEnabled ? (e = this._innerContainer.getBottomBoundary(), e + b >= this._bounceBottomBoundary && (c = this._bounceBottomBoundary - e, this.scrollToBottomEvent(), d = !1), e = this._innerContainer.getTopBoundary(), e + b <= this._bounceTopBoundary && (c = this._bounceTopBoundary - e, this.scrollToTopEvent(), d = !1)) : (e = this._innerContainer.getBottomBoundary(), e + b >= this._bottomBoundary && (c = this._bottomBoundary -
            e, this.scrollToBottomEvent(), d = !1), e = this._innerContainer.getTopBoundary(), e + b <= this._topBoundary && (c = this._topBoundary - e, this.scrollToTopEvent(), d = !1));
        this.moveChildren(0, c);
        return d
    }, scrollChildrenHorizontal: function (a, b) {
        var c = !0, d = a, e;
        this.bounceEnabled ? (e = this._innerContainer.getRightBoundary(), e + a <= this._bounceRightBoundary && (d = this._bounceRightBoundary - e, this.scrollToRightEvent(), c = !1), e = this._innerContainer.getLeftBoundary(), e + a >= this._bounceLeftBoundary && (d = this._bounceLeftBoundary - e, this.scrollToLeftEvent(),
            c = !1)) : (e = this._innerContainer.getRightBoundary(), e + a <= this._rightBoundary && (d = this._rightBoundary - e, this.scrollToRightEvent(), c = !1), e = this._innerContainer.getLeftBoundary(), e + a >= this._leftBoundary && (d = this._leftBoundary - e, this.scrollToLeftEvent(), c = !1));
        this.moveChildren(d, 0);
        return c
    }, scrollChildrenBoth: function (a, b) {
        var c = !0, d = a, e = b, f;
        this.bounceEnabled ? 0 < a && 0 < b ? (f = this._innerContainer.getLeftBoundary(), f + a >= this._bounceLeftBoundary && (d = this._bounceLeftBoundary - f, this.scrollToLeftEvent(), c = !1),
            f = this._innerContainer.getBottomBoundary(), f + b >= this._bounceBottomBoundary && (e = this._bounceBottomBoundary - f, this.scrollToBottomEvent(), c = !1)) : 0 > a && 0 < b ? (f = this._innerContainer.getRightBoundary(), f + a <= this._bounceRightBoundary && (d = this._bounceRightBoundary - f, this.scrollToRightEvent(), c = !1), f = this._innerContainer.getBottomBoundary(), f + b >= this._bounceBottomBoundary && (e = this._bounceBottomBoundary - f, this.scrollToBottomEvent(), c = !1)) : 0 > a && 0 > b ? (f = this._innerContainer.getRightBoundary(), f + a <= this._bounceRightBoundary &&
            (d = this._bounceRightBoundary - f, this.scrollToRightEvent(), c = !1), f = this._innerContainer.getTopBoundary(), f + b <= this._bounceTopBoundary && (e = this._bounceTopBoundary - f, this.scrollToTopEvent(), c = !1)) : 0 < a && 0 > b ? (f = this._innerContainer.getLeftBoundary(), f + a >= this._bounceLeftBoundary && (d = this._bounceLeftBoundary - f, this.scrollToLeftEvent(), c = !1), f = this._innerContainer.getTopBoundary(), f + b <= this._bounceTopBoundary && (e = this._bounceTopBoundary - f, this.scrollToTopEvent(), c = !1)) : 0 == a && 0 < b ? (f = this._innerContainer.getBottomBoundary(),
            f + b >= this._bounceBottomBoundary && (e = this._bounceBottomBoundary - f, this.scrollToBottomEvent(), c = !1)) : 0 > a && 0 == b ? (f = this._innerContainer.getRightBoundary(), f + a <= this._bounceRightBoundary && (d = this._bounceRightBoundary - f, this.scrollToRightEvent(), c = !1)) : 0 == a && 0 > b ? (f = this._innerContainer.getTopBoundary(), f + b <= this._bounceTopBoundary && (e = this._bounceTopBoundary - f, this.scrollToTopEvent(), c = !1)) : 0 < a && 0 == b && (f = this._innerContainer.getLeftBoundary(), f + a >= this._bounceLeftBoundary && (d = this._bounceLeftBoundary -
            f, this.scrollToLeftEvent(), c = !1)) : 0 < a && 0 < b ? (f = this._innerContainer.getLeftBoundary(), f + a >= this._leftBoundary && (d = this._leftBoundary - f, this.scrollToLeftEvent(), c = !1), f = this._innerContainer.getBottomBoundary(), f + b >= this._bottomBoundary && (e = this._bottomBoundary - f, this.scrollToBottomEvent(), c = !1)) : 0 > a && 0 < b ? (f = this._innerContainer.getRightBoundary(), f + a <= this._rightBoundary && (d = this._rightBoundary - f, this.scrollToRightEvent(), c = !1), f = this._innerContainer.getBottomBoundary(), f + b >= this._bottomBoundary && (e =
            this._bottomBoundary - f, this.scrollToBottomEvent(), c = !1)) : 0 > a && 0 > b ? (f = this._innerContainer.getRightBoundary(), f + a <= this._rightBoundary && (d = this._rightBoundary - f, this.scrollToRightEvent(), c = !1), f = this._innerContainer.getTopBoundary(), f + b <= this._topBoundary && (e = this._topBoundary - f, this.scrollToTopEvent(), c = !1)) : 0 < a && 0 > b ? (f = this._innerContainer.getLeftBoundary(), f + a >= this._leftBoundary && (d = this._leftBoundary - f, this.scrollToLeftEvent(), c = !1), f = this._innerContainer.getTopBoundary(), f + b <= this._topBoundary &&
            (e = this._topBoundary - f, this.scrollToTopEvent(), c = !1)) : 0 == a && 0 < b ? (f = this._innerContainer.getBottomBoundary(), f + b >= this._bottomBoundary && (e = this._bottomBoundary - f, this.scrollToBottomEvent(), c = !1)) : 0 > a && 0 == b ? (f = this._innerContainer.getRightBoundary(), f + a <= this._rightBoundary && (d = this._rightBoundary - f, this.scrollToRightEvent(), c = !1)) : 0 == a && 0 > b ? (f = this._innerContainer.getTopBoundary(), f + b <= this._topBoundary && (e = this._topBoundary - f, this.scrollToTopEvent(), c = !1)) : 0 < a && 0 == b && (f = this._innerContainer.getLeftBoundary(),
            f + a >= this._leftBoundary && (d = this._leftBoundary - f, this.scrollToLeftEvent(), c = !1));
        this.moveChildren(d, e);
        return c
    }, scrollToBottom: function (a, b) {
        this.startAutoScrollChildrenWithDestination(cc.p(this._innerContainer.getPositionX(), 0), a, b)
    }, scrollToTop: function (a, b) {
        this.startAutoScrollChildrenWithDestination(cc.p(this._innerContainer.getPositionX(), this._contentSize.height - this._innerContainer.getContentSize().height), a, b)
    }, scrollToLeft: function (a, b) {
        this.startAutoScrollChildrenWithDestination(cc.p(0,
            this._innerContainer.getPositionY()), a, b)
    }, scrollToRight: function (a, b) {
        this.startAutoScrollChildrenWithDestination(cc.p(this._contentSize.width - this._innerContainer.getContentSize().width, this._innerContainer.getPositionY()), a, b)
    }, scrollToTopLeft: function (a, b) {
        this.direction != ccui.ScrollView.DIR_BOTH ? cc.log("Scroll direction is not both!") : this.startAutoScrollChildrenWithDestination(cc.p(0, this._contentSize.height - this._innerContainer.getContentSize().height), a, b)
    }, scrollToTopRight: function (a, b) {
        if (this.direction !=
            ccui.ScrollView.DIR_BOTH)cc.log("Scroll direction is not both!"); else {
            var c = this._innerContainer.getContentSize();
            this.startAutoScrollChildrenWithDestination(cc.p(this._contentSize.width - c.width, this._contentSize.height - c.height), a, b)
        }
    }, scrollToBottomLeft: function (a, b) {
        this.direction != ccui.ScrollView.DIR_BOTH ? cc.log("Scroll direction is not both!") : this.startAutoScrollChildrenWithDestination(cc.p(0, 0), a, b)
    }, scrollToBottomRight: function (a, b) {
        this.direction != ccui.ScrollView.DIR_BOTH ? cc.log("Scroll direction is not both!") :
            this.startAutoScrollChildrenWithDestination(cc.p(this._contentSize.width - this._innerContainer.getContentSize().width, 0), a, b)
    }, scrollToPercentVertical: function (a, b, c) {
        var d = this._contentSize.height - this._innerContainer.getContentSize().height, e = -d;
        this.startAutoScrollChildrenWithDestination(cc.p(this._innerContainer.getPositionX(), d + a * e / 100), b, c)
    }, scrollToPercentHorizontal: function (a, b, c) {
        var d = this._innerContainer.getContentSize().width - this._contentSize.width;
        this.startAutoScrollChildrenWithDestination(cc.p(-(a *
            d / 100), this._innerContainer.getPositionY()), b, c)
    }, scrollToPercentBothDirection: function (a, b, c) {
        if (this.direction == ccui.ScrollView.DIR_BOTH) {
            var d = this._contentSize.height - this._innerContainer.getContentSize().height, e = -d, f = this._innerContainer.getContentSize().width - this._contentSize.width;
            this.startAutoScrollChildrenWithDestination(cc.p(-(a.x * f / 100), d + a.y * e / 100), b, c)
        }
    }, jumpToBottom: function () {
        this.jumpToDestination(this._innerContainer.getPositionX(), 0)
    }, jumpToTop: function () {
        this.jumpToDestination(this._innerContainer.getPositionX(),
                this._contentSize.height - this._innerContainer.getContentSize().height)
    }, jumpToLeft: function () {
        this.jumpToDestination(0, this._innerContainer.getPositionY())
    }, jumpToRight: function () {
        this.jumpToDestination(this._contentSize.width - this._innerContainer.getContentSize().width, this._innerContainer.getPositionY())
    }, jumpToTopLeft: function () {
        this.direction != ccui.ScrollView.DIR_BOTH ? cc.log("Scroll direction is not both!") : this.jumpToDestination(0, this._contentSize.height - this._innerContainer.getContentSize().height)
    },
    jumpToTopRight: function () {
        if (this.direction != ccui.ScrollView.DIR_BOTH)cc.log("Scroll direction is not both!"); else {
            var a = this._innerContainer.getContentSize();
            this.jumpToDestination(this._contentSize.width - a.width, this._contentSize.height - a.height)
        }
    }, jumpToBottomLeft: function () {
        this.direction != ccui.ScrollView.DIR_BOTH ? cc.log("Scroll direction is not both!") : this.jumpToDestination(0, 0)
    }, jumpToBottomRight: function () {
        this.direction != ccui.ScrollView.DIR_BOTH ? cc.log("Scroll direction is not both!") : this.jumpToDestination(this._contentSize.width -
            this._innerContainer.getContentSize().width, 0)
    }, jumpToPercentVertical: function (a) {
        var b = this._contentSize.height - this._innerContainer.getContentSize().height, c = -b;
        this.jumpToDestination(this._innerContainer.getPositionX(), b + a * c / 100)
    }, jumpToPercentHorizontal: function (a) {
        var b = this._innerContainer.getContentSize().width - this._contentSize.width;
        this.jumpToDestination(-(a * b / 100), this._innerContainer.getPositionY())
    }, jumpToPercentBothDirection: function (a) {
        if (this.direction == ccui.ScrollView.DIR_BOTH) {
            var b =
                this._innerContainer.getContentSize(), c = this._contentSize.height - b.height;
            this.jumpToDestination(-(a.x * (b.width - this._contentSize.width) / 100), c + a.y * -c / 100)
        }
    }, startRecordSlidAction: function () {
        this._autoScroll && this.stopAutoScrollChildren();
        this._bouncing && this.stopBounceChildren();
        this._slidTime = 0
    }, endRecordSlidAction: function () {
        if (!this.checkNeedBounce() && this.inertiaScrollEnabled && !(0.016 >= this._slidTime)) {
            var a = 0, b;
            switch (this.direction) {
                case ccui.ScrollView.DIR_VERTICAL:
                    a = this._touchEndPosition.y -
                        this._touchBeganPosition.y;
                    b = 0 > a ? ccui.ScrollView.SCROLLDIR_DOWN : ccui.ScrollView.SCROLLDIR_UP;
                    break;
                case ccui.ScrollView.DIR_HORIZONTAL:
                    a = this._touchEndPosition.x - this._touchBeganPosition.x;
                    b = 0 > a ? ccui.ScrollView.SCROLLDIR_LEFT : ccui.ScrollView.SCROLLDIR_RIGHT;
                    break;
                case ccui.ScrollView.DIR_BOTH:
                    b = cc.pSub(this._touchEndPosition, this._touchBeganPosition), a = cc.pLength(b), b = cc.pNormalize(b)
            }
            a = Math.min(Math.abs(a) / this._slidTime, ccui.ScrollView.AUTO_SCROLL_MAX_SPEED);
            this.startAutoScrollChildrenWithOriginalSpeed(b,
                a, !0, -1E3);
            this._slidTime = 0
        }
    }, handlePressLogic: function (a) {
        this.startRecordSlidAction();
        this._bePressed = !0
    }, handleMoveLogic: function (a) {
        a = cc.pSub(a.getLocation(), a.getPreviousLocation());
        switch (this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
                this.scrollChildren(0, a.y);
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                this.scrollChildren(a.x, 0);
                break;
            case ccui.ScrollView.DIR_BOTH:
                this.scrollChildren(a.x, a.y)
        }
    }, handleReleaseLogic: function (a) {
        this.endRecordSlidAction();
        this._bePressed = !1
    }, onTouchBegan: function (a, b) {
        var c = ccui.Layout.prototype.onTouchBegan.call(this, a, b);
        this._hitted && this.handlePressLogic(a);
        return c
    }, onTouchMoved: function (a, b) {
        ccui.Layout.prototype.onTouchMoved.call(this, a, b);
        this.handleMoveLogic(a)
    }, onTouchEnded: function (a, b) {
        ccui.Layout.prototype.onTouchEnded.call(this, a, b);
        this.handleReleaseLogic(a)
    }, onTouchCancelled: function (a, b) {
        ccui.Layout.prototype.onTouchCancelled.call(this, a, b)
    }, update: function (a) {
        this._autoScroll && this.autoScrollChildren(a);
        this._bouncing && this.bounceChildren(a);
        this.recordSlidTime(a)
    }, recordSlidTime: function (a) {
        this._bePressed && (this._slidTime += a)
    }, interceptTouchEvent: function (a, b, c) {
        var d = c.getLocation();
        switch (a) {
            case ccui.Widget.TOUCH_BAGAN:
                this._touchBeganPosition.x = d.x;
                this._touchBeganPosition.y = d.y;
                this.handlePressLogic(c);
                break;
            case ccui.Widget.TOUCH_MOVED:
                cc.pLength(cc.pSub(b.getTouchBeganPosition(), d)) > this._childFocusCancelOffset && (b.setHighlighted(!1), this._touchMovePosition.x = d.x, this._touchMovePosition.y = d.y, this.handleMoveLogic(c));
                break;
            case ccui.Widget.TOUCH_CANCELED:
            case ccui.Widget.TOUCH_ENDED:
                this._touchEndPosition.x =
                    d.x, this._touchEndPosition.y = d.y, this.handleReleaseLogic(c)
        }
    }, scrollToTopEvent: function () {
        this._scrollViewEventListener && this._scrollViewEventSelector && this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_SCROLL_TO_TOP);
        this._eventCallback && this._eventCallback(this, ccui.ScrollView.EVENT_SCROLL_TO_TOP)
    }, scrollToBottomEvent: function () {
        this._scrollViewEventListener && this._scrollViewEventSelector && this._scrollViewEventSelector.call(this._scrollViewEventListener,
            this, ccui.ScrollView.EVENT_SCROLL_TO_BOTTOM);
        this._eventCallback && this._eventCallback(this, ccui.ScrollView.EVENT_SCROLL_TO_BOTTOM)
    }, scrollToLeftEvent: function () {
        this._scrollViewEventListener && this._scrollViewEventSelector && this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_SCROLL_TO_LEFT);
        this._eventCallback && this._eventCallback(this, ccui.ScrollView.EVENT_SCROLL_TO_LEFT)
    }, scrollToRightEvent: function () {
        this._scrollViewEventListener && this._scrollViewEventSelector &&
        this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_SCROLL_TO_RIGHT);
        this._eventCallback && this._eventCallback(this, ccui.ScrollView.EVENT_SCROLL_TO_RIGHT)
    }, scrollingEvent: function () {
        this._scrollViewEventListener && this._scrollViewEventSelector && this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_SCROLLING);
        this._eventCallback && this._eventCallback(this, ccui.ScrollView.EVENT_SCROLLING)
    }, bounceTopEvent: function () {
        this._scrollViewEventListener &&
        this._scrollViewEventSelector && this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_BOUNCE_TOP);
        this._eventCallback && this._eventCallback(this, ccui.ScrollView.EVENT_BOUNCE_TOP)
    }, bounceBottomEvent: function () {
        this._scrollViewEventListener && this._scrollViewEventSelector && this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_BOUNCE_BOTTOM);
        this._eventCallback && this._eventCallback(this, ccui.ScrollView.EVENT_BOUNCE_BOTTOM)
    }, bounceLeftEvent: function () {
        this._scrollViewEventListener &&
        this._scrollViewEventSelector && this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_BOUNCE_LEFT);
        this._eventCallback && this._eventCallback(this, ccui.ScrollView.EVENT_BOUNCE_LEFT)
    }, bounceRightEvent: function () {
        this._scrollViewEventListener && this._scrollViewEventSelector && this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_BOUNCE_RIGHT);
        this._eventCallback && this._eventCallback(this, ccui.ScrollView.EVENT_BOUNCE_RIGHT)
    }, addEventListenerScrollView: function (a, b) {
        this._scrollViewEventSelector = a;
        this._scrollViewEventListener = b
    }, addEventListener: function (a) {
        this._eventCallback = a
    }, setDirection: function (a) {
        this.direction = a
    }, getDirection: function () {
        return this.direction
    }, setBounceEnabled: function (a) {
        this.bounceEnabled = a
    }, isBounceEnabled: function () {
        return this.bounceEnabled
    }, setInertiaScrollEnabled: function (a) {
        this.inertiaScrollEnabled = a
    }, isInertiaScrollEnabled: function () {
        return this.inertiaScrollEnabled
    }, getInnerContainer: function () {
        return this._innerContainer
    },
    setLayoutType: function (a) {
        this._innerContainer.setLayoutType(a)
    }, getLayoutType: function () {
        return this._innerContainer.getLayoutType()
    }, _doLayout: function () {
        this._doLayoutDirty && (this._doLayoutDirty = !1)
    }, getDescription: function () {
        return"ScrollView"
    }, createCloneInstance: function () {
        return ccui.ScrollView.create()
    }, copyClonedWidgetChildren: function (a) {
        ccui.Layout.prototype.copyClonedWidgetChildren.call(this, a)
    }, copySpecialProperties: function (a) {
        a instanceof ccui.ScrollView && (ccui.Layout.prototype.copySpecialProperties.call(this,
            a), this.setInnerContainerSize(a.getInnerContainerSize()), this.setDirection(a.direction), this.setBounceEnabled(a.bounceEnabled), this.setInertiaScrollEnabled(a.inertiaScrollEnabled), this._scrollViewEventListener = a._scrollViewEventListener, this._scrollViewEventSelector = a._scrollViewEventSelector, this._eventCallback = a._eventCallback)
    }});
_p = ccui.ScrollView.prototype;
cc.defineGetterSetter(_p, "innerWidth", _p._getInnerWidth, _p._setInnerWidth);
cc.defineGetterSetter(_p, "innerHeight", _p._getInnerHeight, _p._setInnerHeight);
_p = null;
ccui.ScrollView.create = function () {
    return new ccui.ScrollView
};
ccui.ScrollView.DIR_NONE = 0;
ccui.ScrollView.DIR_VERTICAL = 1;
ccui.ScrollView.DIR_HORIZONTAL = 2;
ccui.ScrollView.DIR_BOTH = 3;
ccui.ScrollView.EVENT_SCROLL_TO_TOP = 0;
ccui.ScrollView.EVENT_SCROLL_TO_BOTTOM = 1;
ccui.ScrollView.EVENT_SCROLL_TO_LEFT = 2;
ccui.ScrollView.EVENT_SCROLL_TO_RIGHT = 3;
ccui.ScrollView.EVENT_SCROLLING = 4;
ccui.ScrollView.EVENT_BOUNCE_TOP = 5;
ccui.ScrollView.EVENT_BOUNCE_BOTTOM = 6;
ccui.ScrollView.EVENT_BOUNCE_LEFT = 7;
ccui.ScrollView.EVENT_BOUNCE_RIGHT = 8;
ccui.ScrollView.AUTO_SCROLL_MAX_SPEED = 1E3;
ccui.ScrollView.SCROLLDIR_UP = cc.p(0, 1);
ccui.ScrollView.SCROLLDIR_DOWN = cc.p(0, -1);
ccui.ScrollView.SCROLLDIR_LEFT = cc.p(-1, 0);
ccui.ScrollView.SCROLLDIR_RIGHT = cc.p(1, 0);
ccui.ListView = ccui.ScrollView.extend({_model: null, _items: null, _gravity: null, _itemsMargin: 0, _listViewEventListener: null, _listViewEventSelector: null, _curSelectedIndex: 0, _refreshViewDirty: !0, _className: "ListView", ctor: function () {
    ccui.ScrollView.prototype.ctor.call(this);
    this._model = null;
    this._items = [];
    this._gravity = ccui.ListView.GRAVITY_CENTER_HORIZONTAL;
    this._itemsMargin = 0;
    this._listViewEventSelector = this._listViewEventListener = null;
    this._curSelectedIndex = 0;
    this._refreshViewDirty = !0
}, init: function () {
    return ccui.ScrollView.prototype.init.call(this) ?
        (this.setLayoutType(ccui.Layout.LINEAR_VERTICAL), !0) : !1
}, setItemModel: function (a) {
    a && (this._model = a)
}, updateInnerContainerSize: function () {
    switch (this.direction) {
        case ccui.ScrollView.DIR_VERTICAL:
            for (var a = this._items.length, b = (a - 1) * this._itemsMargin, c = 0; c < a; c++)var d = this._items[c], b = b + d.getContentSize().height;
            a = this._contentSize.width;
            this.setInnerContainerSize(cc.size(a, b));
            break;
        case ccui.ScrollView.DIR_HORIZONTAL:
            a = this._items.length;
            b = (a - 1) * this._itemsMargin;
            for (c = 0; c < a; c++)d = this._items[c],
                b += d.getContentSize().width;
            a = this._contentSize.height;
            this.setInnerContainerSize(cc.size(b, a))
    }
}, remedyLayoutParameter: function (a) {
    if (a)switch (this.direction) {
        case ccui.ScrollView.DIR_VERTICAL:
            var b = a.getLayoutParameter();
            if (b)switch (0 == this.getIndex(a) ? b.setMargin(ccui.MarginZero()) : b.setMargin(new ccui.Margin(0, this._itemsMargin, 0, 0)), this._gravity) {
                case ccui.ListView.GRAVITY_LEFT:
                    b.setGravity(ccui.LinearLayoutParameter.LEFT);
                    break;
                case ccui.ListView.GRAVITY_RIGHT:
                    b.setGravity(ccui.LinearLayoutParameter.RIGHT);
                    break;
                case ccui.ListView.GRAVITY_CENTER_HORIZONTAL:
                    b.setGravity(ccui.LinearLayoutParameter.CENTER_HORIZONTAL)
            } else {
                b = ccui.LinearLayoutParameter.create();
                switch (this._gravity) {
                    case ccui.ListView.GRAVITY_LEFT:
                        b.setGravity(ccui.LinearLayoutParameter.LEFT);
                        break;
                    case ccui.ListView.GRAVITY_RIGHT:
                        b.setGravity(ccui.LinearLayoutParameter.RIGHT);
                        break;
                    case ccui.ListView.GRAVITY_CENTER_HORIZONTAL:
                        b.setGravity(ccui.LinearLayoutParameter.CENTER_HORIZONTAL)
                }
                0 == this.getIndex(a) ? b.setMargin(ccui.MarginZero()) : b.setMargin(new ccui.Margin(0,
                    this._itemsMargin, 0, 0));
                a.setLayoutParameter(b)
            }
            break;
        case ccui.ScrollView.DIR_HORIZONTAL:
            if (b = a.getLayoutParameter())switch (0 == this.getIndex(a) ? b.setMargin(ccui.MarginZero()) : b.setMargin(new ccui.Margin(this._itemsMargin, 0, 0, 0)), this._gravity) {
                case ccui.ListView.GRAVITY_TOP:
                    b.setGravity(ccui.LinearLayoutParameter.TOP);
                    break;
                case ccui.ListView.GRAVITY_BOTTOM:
                    b.setGravity(ccui.LinearLayoutParameter.BOTTOM);
                    break;
                case ccui.ListView.GRAVITY_CENTER_VERTICAL:
                    b.setGravity(ccui.LinearLayoutParameter.CENTER_VERTICAL)
            } else {
                b =
                    ccui.LinearLayoutParameter.create();
                switch (this._gravity) {
                    case ccui.ListView.GRAVITY_TOP:
                        b.setGravity(ccui.LinearLayoutParameter.TOP);
                        break;
                    case ccui.ListView.GRAVITY_BOTTOM:
                        b.setGravity(ccui.LinearLayoutParameter.BOTTOM);
                        break;
                    case ccui.ListView.GRAVITY_CENTER_VERTICAL:
                        b.setGravity(ccui.LinearLayoutParameter.CENTER_VERTICAL)
                }
                0 == this.getIndex(a) ? b.setMargin(ccui.MarginZero()) : b.setMargin(new ccui.Margin(this._itemsMargin, 0, 0, 0));
                a.setLayoutParameter(b)
            }
    }
}, pushBackDefaultItem: function () {
    if (this._model) {
        var a =
            this._model.clone();
        this.remedyLayoutParameter(a);
        this.addChild(a);
        this._refreshViewDirty = !0
    }
}, insertDefaultItem: function (a) {
    if (this._model) {
        var b = this._model.clone();
        this._items.splice(a, 0, b);
        ccui.ScrollView.prototype.addChild.call(this, b);
        this.remedyLayoutParameter(b);
        this._refreshViewDirty = !0
    }
}, pushBackCustomItem: function (a) {
    this.remedyLayoutParameter(a);
    this.addChild(a);
    this._refreshViewDirty = !0
}, addChild: function (a, b, c) {
    a && (b = b || a.getLocalZOrder(), c = c || a.getTag(), ccui.ScrollView.prototype.addChild.call(this,
        a, b, c), this._items.push(a))
}, removeChild: function (a, b) {
    if (a) {
        var c = this._items.indexOf(a);
        -1 < c && this._items.splice(c, 1);
        ccui.ScrollView.prototype.removeChild.call(this, a, b)
    }
}, removeAllChildren: function () {
    this.removeAllChildrenWithCleanup(!0)
}, removeAllChildrenWithCleanup: function (a) {
    ccui.ScrollView.prototype.removeAllChildrenWithCleanup.call(this, a);
    this._items = []
}, insertCustomItem: function (a, b) {
    this._items.splice(b, 0, a);
    ccui.ScrollView.prototype.addChild.call(this, a);
    this.remedyLayoutParameter(a);
    this._refreshViewDirty = !0
}, removeItem: function (a) {
    if (a = this.getItem(a))this.removeChild(a), this._refreshViewDirty = !0
}, removeLastItem: function () {
    this.removeItem(this._items.length - 1)
}, removeAllItems: function () {
    this.removeAllChildren()
}, getItem: function (a) {
    return 0 > a || a >= this._items.length ? null : this._items[a]
}, getItems: function () {
    return this._items
}, getIndex: function (a) {
    return this._items.indexOf(a)
}, setGravity: function (a) {
    this._gravity != a && (this._gravity = a, this._refreshViewDirty = !0)
}, setItemsMargin: function (a) {
    this._itemsMargin !=
    a && (this._itemsMargin = a, this._refreshViewDirty = !0)
}, getItemsMargin: function () {
    return this._itemsMargin
}, setDirection: function (a) {
    switch (a) {
        case ccui.ScrollView.DIR_VERTICAL:
            this.setLayoutType(ccui.Layout.LINEAR_VERTICAL);
            break;
        case ccui.ScrollView.DIR_HORIZONTAL:
            this.setLayoutType(ccui.Layout.LINEAR_HORIZONTAL);
            break;
        case ccui.ScrollView.DIR_BOTH:
            return;
        default:
            return
    }
    ccui.ScrollView.prototype.setDirection.call(this, a)
}, requestRefreshView: function () {
    this._refreshViewDirty = !0
}, refreshView: function () {
    for (var a =
        0; a < this._items.length; a++) {
        var b = this._items[a];
        b.setLocalZOrder(a);
        this.remedyLayoutParameter(b)
    }
    this.updateInnerContainerSize()
}, _doLayout: function () {
    ccui.Layout.prototype._doLayout.call(this);
    this._refreshViewDirty && (this.refreshView(), this._refreshViewDirty = !1)
}, addEventListenerListView: function (a, b) {
    this._listViewEventListener = b;
    this._listViewEventSelector = a
}, addEventListener: function (a) {
    this._eventCallback = a
}, selectedItemEvent: function (a) {
    a = a == ccui.Widget.TOUCH_BAGAN ? ccui.ListView.ON_SELECTED_ITEM_START :
        ccui.ListView.ON_SELECTED_ITEM_END;
    this._listViewEventListener && this._listViewEventSelector && this._listViewEventSelector.call(this._listViewEventListener, this, a);
    this._eventCallback && this._eventCallback(this, a)
}, interceptTouchEvent: function (a, b, c) {
    ccui.ScrollView.prototype.interceptTouchEvent.call(this, a, b, c);
    if (1 != a) {
        for (c = b; c;) {
            if (c && c.getParent() == this._innerContainer) {
                this._curSelectedIndex = this.getIndex(c);
                break
            }
            c = c.getParent()
        }
        b.isHighlighted() && this.selectedItemEvent(a)
    }
}, getCurSelectedIndex: function () {
    return this._curSelectedIndex
},
    onSizeChanged: function () {
        ccui.ScrollView.prototype.onSizeChanged.call(this);
        this._refreshViewDirty = !0
    }, getDescription: function () {
        return"ListView"
    }, createCloneInstance: function () {
        return ccui.ListView.create()
    }, copyClonedWidgetChildren: function (a) {
        a = a.getItems();
        for (var b = 0; b < a.length; b++)this.pushBackCustomItem(a[b].clone())
    }, copySpecialProperties: function (a) {
        ccui.ScrollView.prototype.copySpecialProperties.call(this, a);
        this.setItemModel(a._model);
        this.setItemsMargin(a._itemsMargin);
        this.setGravity(a._gravity);
        this._listViewEventListener = a._listViewEventListener;
        this._listViewEventSelector = a._listViewEventSelector;
        this._eventCallback = a._eventCallback
    }});
ccui.ListView.create = function () {
    return new ccui.ListView
};
ccui.ListView.EVENT_SELECTED_ITEM = 0;
ccui.ListView.ON_SELECTED_ITEM_START = 0;
ccui.ListView.ON_SELECTED_ITEM_END = 1;
ccui.ListView.GRAVITY_LEFT = 0;
ccui.ListView.GRAVITY_RIGHT = 1;
ccui.ListView.GRAVITY_CENTER_HORIZONTAL = 2;
ccui.ListView.GRAVITY_TOP = 3;
ccui.ListView.GRAVITY_BOTTOM = 4;
ccui.ListView.GRAVITY_CENTER_VERTICAL = 5;
ccui.PageView = ccui.Layout.extend({_curPageIdx: 0, _pages: null, _touchMoveDirection: null, _touchStartLocation: 0, _touchMoveStartLocation: 0, _movePagePoint: null, _leftBoundaryChild: null, _rightBoundaryChild: null, _leftBoundary: 0, _rightBoundary: 0, _isAutoScrolling: !1, _autoScrollDistance: 0, _autoScrollSpeed: 0, _autoScrollDirection: 0, _childFocusCancelOffset: 0, _pageViewEventListener: null, _pageViewEventSelector: null, _className: "PageView", _eventCallback: null, ctor: function () {
    ccui.Layout.prototype.ctor.call(this);
    this._curPageIdx =
        0;
    this._pages = [];
    this._touchMoveDirection = ccui.PageView.TOUCH_DIR_LEFT;
    this._touchMoveStartLocation = this._touchStartLocation = 0;
    this._rightBoundaryChild = this._leftBoundaryChild = this._movePagePoint = null;
    this._rightBoundary = this._leftBoundary = 0;
    this._isAutoScrolling = !1;
    this._autoScrollDirection = this._autoScrollSpeed = this._autoScrollDistance = 0;
    this._childFocusCancelOffset = 5;
    this._pageViewEventSelector = this._pageViewEventListener = null
}, init: function () {
    return ccui.Layout.prototype.init.call(this) ? (this.setClippingEnabled(!0),
        !0) : !1
}, onEnter: function () {
    ccui.Layout.prototype.onEnter.call(this);
    this.scheduleUpdate(!0)
}, addWidgetToPage: function (a, b, c) {
    if (a && !(0 > b)) {
        var d = this.getPageCount();
        b >= d ? c && (b > d && cc.log("pageIdx is %d, it will be added as page id [%d]", b, d), b = this.createPage(), b.addChild(a), this.addPage(b)) : (b = this._pages[b]) && b.addChild(a)
    }
}, createPage: function () {
    var a = ccui.Layout.create();
    a.setContentSize(this.getContentSize());
    return a
}, addPage: function (a) {
    a && -1 == this._pages.indexOf(a) && (this.addProtectedChild(a),
        this._pages.push(a), this._doLayoutDirty = !0)
}, insertPage: function (a, b) {
    if (!(0 > b || !a || -1 != this._pages.indexOf(a))) {
        var c = this.getPageCount();
        b >= c ? this.addPage(a) : (this._pages[b] = a, this.addProtectedChild(a));
        this._doLayoutDirty = !0
    }
}, removePage: function (a) {
    a && (this.removeProtectedChild(a), a = this._pages.indexOf(a), -1 < a && this._pages.splice(a, 1), this._doLayoutDirty = !0)
}, removePageAtIndex: function (a) {
    0 > a || a >= this._pages.length || (a = this._pages[a]) && this.removePage(a)
}, removeAllPages: function () {
    for (var a = this._pages,
             b = 0, c = a.length; b < c; b++)this.removeProtectedChild(a[b]);
    this._pages.length = 0
}, updateBoundaryPages: function () {
    0 >= this._pages.length ? this._rightBoundaryChild = this._leftBoundaryChild = null : (this._leftBoundaryChild = this._pages[0], this._rightBoundaryChild = this._pages[this._pages.length - 1])
}, getPageCount: function () {
    return this._pages.length
}, getPositionXByIndex: function (a) {
    return this.getSize().width * (a - this._curPageIdx)
}, onSizeChanged: function () {
    ccui.Layout.prototype.onSizeChanged.call(this);
    this._rightBoundary =
        this.getContentSize().width;
    this._doLayoutDirty = !0
}, updateAllPagesSize: function () {
    for (var a = this.getContentSize(), b = this._pages, c = 0, d = b.length; c < d; c++)b[c].setContentSize(a)
}, updateAllPagesPosition: function () {
    var a = this.getPageCount();
    if (0 >= a)this._curPageIdx = 0; else {
        this._curPageIdx >= a && (this._curPageIdx = a - 1);
        for (var b = this.getContentSize().width, c = this._pages, d = 0; d < a; d++)c[d].setPosition(cc.p((d - this._curPageIdx) * b, 0))
    }
}, scrollToPage: function (a) {
    0 > a || a >= this._pages.length || (this._curPageIdx = a, this._autoScrollDistance = -this._pages[a].getPosition().x, this._autoScrollSpeed = Math.abs(this._autoScrollDistance) / 0.2, this._autoScrollDirection = 0 < this._autoScrollDistance ? 1 : 0, this._isAutoScrolling = !0)
}, update: function (a) {
    this._isAutoScrolling && this.autoScroll(a)
}, autoScroll: function (a) {
    switch (this._autoScrollDirection) {
        case 0:
            a *= this._autoScrollSpeed;
            0 <= this._autoScrollDistance + a ? (a = -this._autoScrollDistance, this._autoScrollDistance = 0, this._isAutoScrolling = !1) : this._autoScrollDistance += a;
            this.scrollPages(-a);
            this._isAutoScrolling ||
            this.pageTurningEvent();
            break;
        case 1:
            a *= this._autoScrollSpeed, 0 >= this._autoScrollDistance - a ? (a = this._autoScrollDistance, this._autoScrollDistance = 0, this._isAutoScrolling = !1) : this._autoScrollDistance -= a, this.scrollPages(a), this._isAutoScrolling || this.pageTurningEvent()
    }
}, onTouchBegan: function (a, b) {
    var c = ccui.Layout.prototype.onTouchBegan.call(this, a, b);
    this._hitted && this.handlePressLogic(a);
    return c
}, onTouchMoved: function (a, b) {
    this.handleMoveLogic(a);
    var c = this.getWidgetParent();
    c && c.interceptTouchEvent(ccui.Widget.TOUCH_MOVED,
        this, a);
    this.moveEvent()
}, onTouchEnded: function (a, b) {
    ccui.Layout.prototype.onTouchEnded.call(this, a, b);
    this.handleReleaseLogic(a)
}, onTouchCancelled: function (a, b) {
    ccui.Layout.prototype.onTouchCancelled.call(this, a, b);
    this.handleReleaseLogic(a)
}, _doLayout: function () {
    this._doLayoutDirty && (this.updateAllPagesPosition(), this.updateAllPagesSize(), this.updateBoundaryPages(), this._doLayoutDirty = !1)
}, movePages: function (a) {
    for (var b = this._pages, c = b.length, d = 0; d < c; d++) {
        var e = b[d], f = e.getPosition();
        e.setPosition(f.x +
            a, f.y)
    }
}, scrollPages: function (a) {
    if (0 >= this._pages.length || !this._leftBoundaryChild || !this._rightBoundaryChild)return!1;
    var b = a;
    switch (this._touchMoveDirection) {
        case ccui.PageView.TOUCH_DIR_LEFT:
            if (this._rightBoundaryChild.getRightBoundary() + a <= this._rightBoundary)return b = this._rightBoundary - this._rightBoundaryChild.getRightBoundary(), this.movePages(b), !1;
            break;
        case ccui.PageView.TOUCH_DIR_RIGHT:
            if (this._leftBoundaryChild.getLeftBoundary() + a >= this._leftBoundary)return b = this._leftBoundary - this._leftBoundaryChild.getLeftBoundary(),
                this.movePages(b), !1
    }
    this.movePages(b);
    return!0
}, handlePressLogic: function (a) {
}, handleMoveLogic: function (a) {
    a = a.getLocation().x - a.getPreviousLocation().x;
    0 > a ? this._touchMoveDirection = ccui.PageView.TOUCH_DIR_LEFT : 0 < a && (this._touchMoveDirection = ccui.PageView.TOUCH_DIR_RIGHT);
    this.scrollPages(a)
}, handleReleaseLogic: function (a) {
    if (!(0 >= this._pages.length) && (a = this._pages[this._curPageIdx])) {
        var b = a.getPosition();
        a = this._pages.length;
        var b = b.x, c = this.getSize().width / 2;
        b <= -c ? this._curPageIdx >= a - 1 ? this.scrollPages(-b) :
            this.scrollToPage(this._curPageIdx + 1) : b >= c ? 0 >= this._curPageIdx ? this.scrollPages(-b) : this.scrollToPage(this._curPageIdx - 1) : this.scrollToPage(this._curPageIdx)
    }
}, interceptTouchEvent: function (a, b, c) {
    switch (a) {
        case 0:
            this.handlePressLogic(c);
            break;
        case 1:
            a = 0;
            a = Math.abs(b.getTouchBeganPosition().x - c.x);
            a > this._childFocusCancelOffset && (b.setFocused(!1), this.handleMoveLogic(c));
            break;
        case 2:
            this.handleReleaseLogic(c)
    }
}, pageTurningEvent: function () {
    this._pageViewEventListener && this._pageViewEventSelector &&
    this._pageViewEventSelector.call(this._pageViewEventListener, this, ccui.PageView.EVENT_TURNING);
    this._eventCallback && this._eventCallback(this, ccui.PageView.EVENT_TURNING)
}, addEventListenerPageView: function (a, b) {
    this._pageViewEventSelector = a;
    this._pageViewEventListener = b
}, addEventListener: function (a) {
    this._eventCallback = a
}, getCurPageIndex: function () {
    return this._curPageIdx
}, getPages: function () {
    return this._pages
}, getPage: function (a) {
    return 0 > a || a >= this.getPages().size() ? null : this._pages[a]
}, getDescription: function () {
    return"PageView"
},
    createCloneInstance: function () {
        return ccui.PageView.create()
    }, copyClonedWidgetChildren: function (a) {
        a = a.getPages();
        for (var b = 0; b < a.length; b++)this.addPage(a[b].clone())
    }, copySpecialProperties: function (a) {
        ccui.Layout.prototype.copySpecialProperties.call(this, a);
        this._eventCallback = a._eventCallback;
        this._pageViewEventListener = a._pageViewEventListener;
        this._pageViewEventSelector = a._pageViewEventSelector
    }});
ccui.PageView.create = function () {
    var a = new ccui.PageView;
    return a && a.init() ? a : null
};
ccui.PageView.EVENT_TURNING = 0;
ccui.PageView.TOUCH_DIR_LEFT = 0;
ccui.PageView.TOUCH_DIR_RIGHT = 1;cc.Component = cc.Class.extend({_owner: null, _name: "", _enabled: true, ctor: function () {
    this._owner = null;
    this._name = "";
    this._enabled = true
}, init: function () {
    return true
}, onEnter: function () {
}, onExit: function () {
}, update: function (delta) {
}, serialize: function (reader) {
}, isEnabled: function () {
    return this._enabled
}, setEnabled: function (enable) {
    this._enabled = enable
}, getName: function () {
    return this._name
}, setName: function (name) {
    this._name = name
}, setOwner: function (owner) {
    this._owner = owner
}, getOwner: function () {
    return this._owner
}});
cc.Component.create = function () {
    return new cc.Component
};
cc.ComponentContainer = cc.Class.extend({_components: null, _owner: null, ctor: function (node) {
    this._components = null;
    this._owner = node
}, getComponent: function (name) {
    if (!name)throw"cc.ComponentContainer.getComponent(): name should be non-null";
    name = name.trim();
    return this._components[name]
}, add: function (component) {
    if (!component)throw"cc.ComponentContainer.add(): component should be non-null";
    if (component.getOwner()) {
        cc.log("cc.ComponentContainer.add(): Component already added. It can't be added again");
        return false
    }
    if (this._components ==
        null) {
        this._components = {};
        this._owner.scheduleUpdate()
    }
    var oldComponent = this._components[component.getName()];
    if (oldComponent) {
        cc.log("cc.ComponentContainer.add(): Component already added. It can't be added again");
        return false
    }
    component.setOwner(this._owner);
    this._components[component.getName()] = component;
    component.onEnter();
    return true
}, remove: function (name) {
    if (!name)throw"cc.ComponentContainer.remove(): name should be non-null";
    if (!this._components)return false;
    if (name instanceof cc.Component)return this._removeByComponent(name);
    else {
        name = name.trim();
        return this._removeByComponent(this._components[name])
    }
}, _removeByComponent: function (component) {
    if (component)return false;
    component.onExit();
    component.setOwner(null);
    delete this._components[component.getName()];
    return true
}, removeAll: function () {
    if (!this._components)return;
    var locComponents = this._components;
    for (var selKey in locComponents) {
        var selComponent = locComponents[selKey];
        selComponent.onExit();
        selComponent.setOwner(null);
        delete locComponents[selKey]
    }
    this._owner.unscheduleUpdate();
    this._components = null
}, _alloc: function () {
    this._components = {}
}, visit: function (delta) {
    if (!this._components)return;
    var locComponents = this._components;
    for (var selKey in locComponents)locComponents[selKey].update(delta)
}, isEmpty: function () {
    if (!this._components)return true;
    for (var selkey in this._components)return false;
    return true
}});
var ccs = ccs || {};
ccs.Class = ccs.Class || cc.Class;
ccs.Class.extend = ccs.Class.extend || cc.Class.extend;
ccs.Node = ccs.Node || cc.Node;
ccs.Node.extend = ccs.Node.extend || cc.Node.extend;
ccs.NodeRGBA = ccs.NodeRGBA || cc.NodeRGBA;
ccs.NodeRGBA.extend = ccs.NodeRGBA.extend || cc.NodeRGBA.extend;
ccs.Sprite = ccs.Sprite || cc.Sprite;
ccs.Sprite.extend = ccs.Sprite.extend || cc.Sprite.extend;
ccs.Component = ccs.Component || cc.Component;
ccs.Component.extend = ccs.Component.extend || cc.Component.extend;
ccs.cocostudioVersion = "v1.3.0.0";
ccs.ActionManagerEx = ccs.Class.extend({initWithDictionary: function (jsonName, dic, root) {
    var path = jsonName;
    var pos = path.lastIndexOf("/");
    var fileName = path.substr(pos + 1, path.length());
    cc.log("filename \x3d\x3d %s", fileName.toString());
    var actionList = [];
    var actionCount = dic["actionlist"];
    for (var i = 0; i < actionCount; i++) {
        var action = new ActionObject;
        var actionDic = dic["actionlist"][i];
        action.initWithDictionary(actionDic, root);
        actionList.push(action)
    }
    this._actionDic[fileName] = actionList
}, getActionByName: function (jsonName, actionName) {
    var iterator = this._actionDic[jsonName];
    if (!iterator)return;
    var actionList = iterator;
    for (var i = 0; i < actionList.length; i++) {
        var action = actionList[i];
        if (actionName == action.getName())return action
    }
    return
}, playActionByName: function (jsonName, actionName) {
    var action = this.getActionByName(jsonName, actionName);
    if (action)action.play();
    return action
}, releaseActions: function () {
    var iter;
    for (iter in this._actionDic)delete this._actionDic[iter];
    this._actionDic = []
}});
ccs.VERSION_COMBINED = 0.3;
ccs.VERSION_CHANGE_ROTATION_RANGE = 1;
ccs.VERSION_COLOR_READING = 1.1;
ccs.MAX_VERTEXZ_VALUE = 5E6;
ccs.ARMATURE_MAX_CHILD = 50;
ccs.ARMATURE_MAX_ZORDER = 100;
ccs.ARMATURE_MAX_COUNT = ccs.MAX_VERTEXZ_VALUE / ccs.ARMATURE_MAX_CHILD / ccs.ARMATURE_MAX_ZORDER;
ccs.AUTO_ADD_SPRITE_FRAME_NAME_PREFIX = false;
ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT = false;
ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX = false;
ccs.armatureVersion = function () {
    return"v1.1.0.0"
};
ccs.CONST_VERSION = "version";
ccs.CONST_VERSION_2_0 = 2;
ccs.CONST_VERSION_COMBINED = 0.3;
ccs.CONST_SKELETON = "skeleton";
ccs.CONST_ARMATURES = "armatures";
ccs.CONST_ARMATURE = "armature";
ccs.CONST_BONE = "b";
ccs.CONST_DISPLAY = "d";
ccs.CONST_ANIMATIONS = "animations";
ccs.CONST_ANIMATION = "animation";
ccs.CONST_MOVEMENT = "mov";
ccs.CONST_FRAME = "f";
ccs.CONST_TEXTURE_ATLAS = "TextureAtlas";
ccs.CONST_SUB_TEXTURE = "SubTexture";
ccs.CONST_A_NAME = "name";
ccs.CONST_A_DURATION = "dr";
ccs.CONST_A_FRAME_INDEX = "fi";
ccs.CONST_A_DURATION_TO = "to";
ccs.CONST_A_DURATION_TWEEN = "drTW";
ccs.CONST_A_LOOP = "lp";
ccs.CONST_A_MOVEMENT_SCALE = "sc";
ccs.CONST_A_MOVEMENT_DELAY = "dl";
ccs.CONST_A_DISPLAY_INDEX = "dI";
ccs.CONST_A_VERT = "vert";
ccs.CONST_A_FRAG = "frag";
ccs.CONST_A_PLIST = "plist";
ccs.CONST_A_PARENT = "parent";
ccs.CONST_A_SKEW_X = "kX";
ccs.CONST_A_SKEW_Y = "kY";
ccs.CONST_A_SCALE_X = "cX";
ccs.CONST_A_SCALE_Y = "cY";
ccs.CONST_A_Z = "z";
ccs.CONST_A_EVENT = "evt";
ccs.CONST_A_SOUND = "sd";
ccs.CONST_A_SOUND_EFFECT = "sdE";
ccs.CONST_A_TWEEN_EASING = "twE";
ccs.CONST_A_TWEEN_ROTATION = "twR";
ccs.CONST_A_EASING_PARAM = "twEP";
ccs.CONST_A_IS_ARMATURE = "isArmature";
ccs.CONST_A_DISPLAY_TYPE = "displayType";
ccs.CONST_A_MOVEMENT = "mov";
ccs.CONST_A_BLEND_TYPE = "bd";
ccs.CONST_A_BLEND_SRC = "bd_src";
ccs.CONST_A_BLEND_DST = "bd_dst";
ccs.CONST_A_X = "x";
ccs.CONST_A_Y = "y";
ccs.CONST_A_COCOS2DX_X = "cocos2d_x";
ccs.CONST_A_COCOS2DX_Y = "cocos2d_y";
ccs.CONST_A_WIDTH = "width";
ccs.CONST_A_HEIGHT = "height";
ccs.CONST_A_PIVOT_X = "pX";
ccs.CONST_A_PIVOT_Y = "pY";
ccs.CONST_A_COCOS2D_PIVOT_X = "cocos2d_pX";
ccs.CONST_A_COCOS2D_PIVOT_Y = "cocos2d_pY";
ccs.CONST_A_ALPHA = "a";
ccs.CONST_A_RED = "r";
ccs.CONST_A_GREEN = "g";
ccs.CONST_A_BLUE = "b";
ccs.CONST_A_ALPHA_OFFSET = "aM";
ccs.CONST_A_RED_OFFSET = "rM";
ccs.CONST_A_GREEN_OFFSET = "gM";
ccs.CONST_A_BLUE_OFFSET = "bM";
ccs.CONST_A_COLOR_TRANSFORM = "colorTransform";
ccs.CONST_A_TWEEN_FRAME = "tweenFrame";
ccs.CONST_A_ROTATION = "rotation";
ccs.CONST_A_USE_COLOR_INFO = "uci";
ccs.CONST_CONTOUR = "con";
ccs.CONST_CONTOUR_VERTEX = "con_vt";
ccs.CONST_MOVEMENT_EVENT_FRAME = "movementEventFrame";
ccs.CONST_SOUND_FRAME = "soundFrame";
ccs.CONST_FL_NAN = "NaN";
ccs.CONST_FRAME_DATA = "frame_data";
ccs.CONST_MOVEMENT_BONE_DATA = "mov_bone_data";
ccs.CONST_MOVEMENT_FRAME_DATA = "mov_frame_data";
ccs.CONST_MOVEMENT_DATA = "mov_data";
ccs.CONST_ANIMATION_DATA = "animation_data";
ccs.CONST_DISPLAY_DATA = "display_data";
ccs.CONST_SKIN_DATA = "skin_data";
ccs.CONST_BONE_DATA = "bone_data";
ccs.CONST_ARMATURE_DATA = "armature_data";
ccs.CONST_CONTOUR_DATA = "contour_data";
ccs.CONST_TEXTURE_DATA = "texture_data";
ccs.CONST_VERTEX_POINT = "vertex";
ccs.CONST_COLOR_INFO = "color";
ccs.CONST_CONFIG_FILE_PATH = "config_file_path";
ccs.CONST_CONTENT_SCALE = "content_scale";
ccs.DataInfo = function () {
    this.asyncStruct = null;
    this.configFileQueue = [];
    this.contentScale = 1;
    this.filename = "";
    this.baseFilePath = "";
    this.flashToolVersion = 0;
    this.cocoStudioVersion = 0
};
ccs.dataReaderHelper = {_configFileList: [], _flashToolVersion: ccs.CONST_VERSION_2_0, _cocoStudioVersion: ccs.CONST_VERSION_COMBINED, _positionReadScale: 1, _asyncRefCount: 0, _asyncRefTotalCount: 0, setPositionReadScale: function (scale) {
    this._positionReadScale = scale
}, getPositionReadScale: function () {
    return this._positionReadScale
}, clear: function () {
    this._configFileList = [];
    this._asyncRefCount = 0;
    this._asyncRefTotalCount = 0
}, addDataFromFile: function (filePath, isLoadSpriteFrame) {
    if (this._configFileList.indexOf(filePath) != -1)return;
    this._configFileList.push(filePath);
    this._initBaseFilePath(filePath);
    var str = cc.path.extname(filePath).toLowerCase();
    var dataInfo = new ccs.DataInfo;
    dataInfo.filename = filePath;
    dataInfo.basefilePath = this._initBaseFilePath(filePath);
    if (str == ".xml")this.addDataFromXML(filePath, dataInfo); else if (str == ".json" || str == ".exportjson")this.addDataFromJson(filePath, dataInfo, isLoadSpriteFrame)
}, addDataFromFileAsync: function (filePath, target, selector, isLoadSpriteFrame) {
    if (this._configFileList.indexOf(filePath) != -1) {
        if (target && selector)if (this._asyncRefTotalCount == 0 && this._asyncRefCount == 0)this._asyncCallBack(target, selector, 1); else this._asyncCallBack(target, selector, (this._asyncRefTotalCount - this._asyncRefCount) / this._asyncRefTotalCount);
        return
    }
    this._asyncRefTotalCount++;
    this._asyncRefCount++;
    var self = this;
    var fun = function () {
        self.addDataFromFile(filePath, isLoadSpriteFrame);
        self._asyncRefCount--;
        self._asyncCallBack(target, selector, (self._asyncRefTotalCount - self._asyncRefCount) / self._asyncRefTotalCount)
    };
    cc.director.getScheduler().scheduleCallbackForTarget(this, fun, 0.1, false)
}, _asyncCallBack: function (target, selector, percent) {
    if (target && typeof selector == "string")target[selector](percent); else if (target && typeof selector == "function")selector.call(target, percent)
}, _initBaseFilePath: function (filePath) {
    var path = filePath;
    var pos = path.lastIndexOf("/");
    if (pos > -1)path = path.substr(0, pos + 1); else path = "";
    return path
}, addDataFromXML: function (xml, dataInfo) {
    var xmlStr = cc.loader.getRes(xml);
    if (!xmlStr)throw"Please load the resource first : " +
        xml;
    var skeletonXML = cc.saxParser.parse(xmlStr);
    var skeleton = skeletonXML.documentElement;
    if (skeleton)this.addDataFromCache(skeleton, dataInfo)
}, addDataFromCache: function (skeleton, dataInfo) {
    if (!skeleton) {
        cc.log("XML error  or  XML is empty.");
        return
    }
    dataInfo.flashToolVersion = parseFloat(skeleton.getAttribute(ccs.CONST_VERSION));
    var armaturesXML = skeleton.querySelectorAll(ccs.CONST_SKELETON + " \x3e " + ccs.CONST_ARMATURES + " \x3e  " + ccs.CONST_ARMATURE + "");
    var armatureDataManager = ccs.armatureDataManager;
    for (var i =
        0; i < armaturesXML.length; i++) {
        var armatureData = this.decodeArmature(armaturesXML[i], dataInfo);
        armatureDataManager.addArmatureData(armatureData.name, armatureData, dataInfo.filename)
    }
    var animationsXML = skeleton.querySelectorAll(ccs.CONST_SKELETON + " \x3e " + ccs.CONST_ANIMATIONS + " \x3e  " + ccs.CONST_ANIMATION + "");
    for (var i = 0; i < animationsXML.length; i++) {
        var animationData = this.decodeAnimation(animationsXML[i], dataInfo);
        armatureDataManager.addAnimationData(animationData.name, animationData, dataInfo.filename)
    }
    var texturesXML =
        skeleton.querySelectorAll(ccs.CONST_SKELETON + " \x3e " + ccs.CONST_TEXTURE_ATLAS + " \x3e  " + ccs.CONST_SUB_TEXTURE + "");
    for (var i = 0; i < texturesXML.length; i++) {
        var textureData = this.decodeTexture(texturesXML[i], dataInfo);
        armatureDataManager.addTextureData(textureData.name, textureData, dataInfo.filename)
    }
    skeleton = null
}, decodeArmature: function (armatureXML, dataInfo) {
    var name = armatureXML.getAttribute(ccs.CONST_A_NAME);
    var armatureData = new ccs.ArmatureData;
    armatureData.name = name;
    var bonesXML = armatureXML.querySelectorAll(ccs.CONST_ARMATURE +
        " \x3e " + ccs.CONST_BONE);
    for (var i = 0; i < bonesXML.length; i++) {
        var boneXML = bonesXML[i];
        var parentName = boneXML.getAttribute(ccs.CONST_A_PARENT);
        var parentXML = null;
        if (parentName)for (var j = 0; j < bonesXML.length; j++) {
            parentXML = bonesXML[j];
            if (parentName == bonesXML[j].getAttribute(ccs.CONST_A_NAME))break
        }
        var boneData = this.decodeBone(boneXML, parentXML, dataInfo);
        armatureData.addBoneData(boneData)
    }
    return armatureData
}, decodeBone: function (boneXML, parentXML, dataInfo) {
    var name = boneXML.getAttribute(ccs.CONST_A_NAME);
    if (name == "")return;
    var boneData = new ccs.BoneData;
    boneData.name = name;
    boneData.parentName = boneXML.getAttribute(ccs.CONST_A_PARENT) || "";
    boneData.zOrder = parseInt(boneXML.getAttribute(ccs.CONST_A_Z)) || 0;
    var displaysXML = boneXML.querySelectorAll(ccs.CONST_BONE + " \x3e " + ccs.CONST_DISPLAY);
    var displayXML;
    for (var i = 0; i < displaysXML.length; i++) {
        displayXML = displaysXML[i];
        var displayData = this.decodeBoneDisplay(displayXML, dataInfo);
        boneData.addDisplayData(displayData)
    }
    return boneData
}, decodeBoneDisplay: function (displayXML, dataInfo) {
    var isArmature = parseFloat(displayXML.getAttribute(ccs.CONST_A_IS_ARMATURE)) || 0;
    var displayData = null;
    if (isArmature == 1) {
        displayData = new ccs.ArmatureDisplayData;
        displayData.displayType = ccs.DISPLAY_TYPE_ARMATURE
    } else {
        displayData = new ccs.SpriteDisplayData;
        displayData.displayType = ccs.DISPLAY_TYPE_SPRITE
    }
    var displayName = displayXML.getAttribute(ccs.CONST_A_NAME) || "";
    if (displayName)displayData.displayName = displayName;
    return displayData
}, decodeAnimation: function (animationXML, dataInfo) {
    var name = animationXML.getAttribute(ccs.CONST_A_NAME);
    var aniData = new ccs.AnimationData;
    var armatureData = ccs.armatureDataManager.getArmatureData(name);
    aniData.name = name;
    var movementsXML = animationXML.querySelectorAll(ccs.CONST_ANIMATION + " \x3e " + ccs.CONST_MOVEMENT);
    var movementXML = null;
    for (var i = 0; i < movementsXML.length; i++) {
        movementXML = movementsXML[i];
        var movementData = this.decodeMovement(movementXML, armatureData, dataInfo);
        aniData.addMovement(movementData)
    }
    return aniData
}, decodeMovement: function (movementXML, armatureData, dataInfo) {
    var movName = movementXML.getAttribute(ccs.CONST_A_NAME);
    var movementData = new ccs.MovementData;
    movementData.name = movName;
    var duration, durationTo, durationTween, loop = 0, tweenEasing = 0;
    duration = parseFloat(movementXML.getAttribute(ccs.CONST_A_DURATION)) || 0;
    movementData.duration = duration;
    durationTo = parseFloat(movementXML.getAttribute(ccs.CONST_A_DURATION_TO)) || 0;
    movementData.durationTo = durationTo;
    durationTween = parseFloat(movementXML.getAttribute(ccs.CONST_A_DURATION_TWEEN)) || 0;
    movementData.durationTween = durationTween;
    loop = movementXML.getAttribute(ccs.CONST_A_LOOP);
    movementData.loop = loop ? Boolean(parseFloat(loop)) : true;
    var easing = movementXML.getAttribute(ccs.CONST_A_TWEEN_EASING);
    if (easing)if (easing != ccs.CONST_FL_NAN) {
        tweenEasing = parseFloat(easing) || 0;
        movementData.tweenEasing = tweenEasing == 2 ? ccs.TweenType.sineEaseInOut : tweenEasing
    } else movementData.tweenEasing = ccs.TweenType.linear;
    var movBonesXml = movementXML.querySelectorAll(ccs.CONST_MOVEMENT + " \x3e " + ccs.CONST_BONE);
    var movBoneXml = null;
    for (var i = 0; i < movBonesXml.length; i++) {
        movBoneXml = movBonesXml[i];
        var boneName =
            movBoneXml.getAttribute(ccs.CONST_A_NAME);
        if (movementData.getMovementBoneData(boneName))continue;
        var boneData = armatureData.getBoneData(boneName);
        var parentName = boneData.parentName;
        var parentXML = null;
        if (parentName != "")for (var j = 0; j < movBonesXml.length; j++) {
            parentXML = movBonesXml[j];
            if (parentName == parentXML.getAttribute(ccs.CONST_A_NAME))break
        }
        var moveBoneData = this.decodeMovementBone(movBoneXml, parentXML, boneData, dataInfo);
        movementData.addMovementBoneData(moveBoneData)
    }
    return movementData
}, decodeMovementBone: function (movBoneXml, parentXml, boneData, dataInfo) {
    var movBoneData = new ccs.MovementBoneData;
    var scale, delay;
    if (movBoneXml) {
        scale = parseFloat(movBoneXml.getAttribute(ccs.CONST_A_MOVEMENT_SCALE)) || 0;
        movBoneData.scale = scale;
        delay = parseFloat(movBoneXml.getAttribute(ccs.CONST_A_MOVEMENT_DELAY)) || 0;
        if (delay > 0)delay -= 1;
        movBoneData.delay = delay
    }
    var length = 0;
    var parentTotalDuration = 0;
    var currentDuration = 0;
    var parentFrameXML = null;
    var parentXMLList = [];
    if (parentXml != null) {
        var parentFramesXML = parentXml.querySelectorAll(ccs.CONST_BONE +
            " \x3e " + ccs.CONST_FRAME);
        for (var i = 0; i < parentFramesXML.length; i++)parentXMLList.push(parentFramesXML[i]);
        length = parentXMLList.length
    }
    var totalDuration = 0;
    var name = movBoneXml.getAttribute(ccs.CONST_A_NAME);
    movBoneData.name = name;
    var framesXML = movBoneXml.querySelectorAll(ccs.CONST_BONE + " \x3e " + ccs.CONST_FRAME);
    var j = 0;
    for (var ii = 0; ii < framesXML.length; ii++) {
        var frameXML = framesXML[ii];
        if (parentXml)while (j < length && (parentFrameXML ? totalDuration < parentTotalDuration || totalDuration >= parentTotalDuration + currentDuration :
            true)) {
            parentFrameXML = parentXMLList[j];
            parentTotalDuration += currentDuration;
            currentDuration = parseFloat(parentFrameXML.getAttribute(ccs.CONST_A_DURATION));
            j++
        }
        var frameData = this.decodeFrame(frameXML, parentFrameXML, boneData, dataInfo);
        movBoneData.addFrameData(frameData);
        frameData.frameID = totalDuration;
        totalDuration += frameData.duration;
        movBoneData.duration = totalDuration
    }
    var frames = movBoneData.frameList;
    var pi = Math.PI;
    for (var i = frames.length - 1; i >= 0; i--)if (i > 0) {
        var difSkewX = frames[i].skewX - frames[i - 1].skewX;
        var difSkewY = frames[i].skewY - frames[i - 1].skewY;
        if (difSkewX < -pi || difSkewX > pi)frames[i - 1].skewX = difSkewX < 0 ? frames[i - 1].skewX - 2 * pi : frames[i - 1].skewX + 2 * pi;
        if (difSkewY < -pi || difSkewY > pi)frames[i - 1].skewY = difSkewY < 0 ? frames[i - 1].skewY - 2 * pi : frames[i - 1].skewY + 2 * pi
    }
    if (movBoneData.frameList.length > 0) {
        var frameData = new ccs.FrameData;
        frameData.copy(movBoneData.frameList[movBoneData.frameList.length - 1]);
        frameData.frameID = movBoneData.duration;
        movBoneData.addFrameData(frameData)
    }
    return movBoneData
}, decodeFrame: function (frameXML, parentFrameXml, boneData, dataInfo) {
    var frameData = new ccs.FrameData;
    frameData.movement = frameXML.getAttribute(ccs.CONST_A_MOVEMENT) || "";
    frameData.event = frameXML.getAttribute(ccs.CONST_A_EVENT) || "";
    frameData.blendType = parseInt(frameXML.getAttribute(ccs.CONST_A_BLEND_TYPE)) || ccs.BLEND_TYPE_NORMAL;
    var blendFunc = frameData.blendFunc;
    switch (frameData.blendType) {
        case ccs.BLEND_TYPE_NORMAL:
            blendFunc.src = cc.BLEND_SRC;
            blendFunc.dst = cc.BLEND_DST;
            break;
        case ccs.BLEND_TYPE_ADD:
            blendFunc.src = cc.SRC_ALPHA;
            blendFunc.dst =
                cc.ONE;
            break;
        case ccs.BLEND_TYPE_MULTIPLY:
            blendFunc.src = cc.ONE_MINUS_SRC_ALPHA;
            blendFunc.dst = cc.ONE_MINUS_DST_COLOR;
            break;
        case ccs.BLEND_TYPE_SCREEN:
            blendFunc.src = cc.ONE;
            blendFunc.dst = cc.ONE_MINUS_DST_COLOR;
            break;
        default:
            break
    }
    frameData.sound = frameXML.getAttribute(ccs.CONST_A_SOUND) || "";
    frameData.soundEffect = frameXML.getAttribute(ccs.CONST_A_SOUND_EFFECT) || "";
    var isTween = frameXML.getAttribute(ccs.CONST_A_TWEEN_FRAME);
    if (isTween == null)isTween = true;
    frameData.isTween = Boolean(isTween);
    if (dataInfo.flashToolVersion >=
        ccs.CONST_VERSION_2_0) {
        frameData.x = parseFloat(frameXML.getAttribute(ccs.CONST_A_COCOS2DX_X)) || 0;
        frameData.y = -parseFloat(frameXML.getAttribute(ccs.CONST_A_COCOS2DX_Y)) || 0
    } else {
        frameData.x = parseFloat(frameXML.getAttribute(ccs.CONST_A_X)) || 0;
        frameData.y = -parseFloat(frameXML.getAttribute(ccs.CONST_A_Y)) || 0
    }
    frameData.x *= this._positionReadScale;
    frameData.y *= this._positionReadScale;
    frameData.scaleX = parseFloat(frameXML.getAttribute(ccs.CONST_A_SCALE_X)) || 0;
    frameData.scaleY = parseFloat(frameXML.getAttribute(ccs.CONST_A_SCALE_Y)) ||
        0;
    frameData.skewX = cc.degreesToRadians(parseFloat(frameXML.getAttribute(ccs.CONST_A_SKEW_X)) || 0);
    frameData.skewY = cc.degreesToRadians(-parseFloat(frameXML.getAttribute(ccs.CONST_A_SKEW_Y)) || 0);
    frameData.duration = parseFloat(frameXML.getAttribute(ccs.CONST_A_DURATION)) || 0;
    frameData.displayIndex = parseFloat(frameXML.getAttribute(ccs.CONST_A_DISPLAY_INDEX)) || 0;
    frameData.zOrder = parseFloat(frameXML.getAttribute(ccs.CONST_A_Z)) || 0;
    frameData.tweenRotate = parseFloat(frameXML.getAttribute(ccs.CONST_A_TWEEN_ROTATION)) ||
        0;
    var colorTransformXMLList = frameXML.querySelectorAll(ccs.CONST_FRAME + " \x3e " + ccs.CONST_A_COLOR_TRANSFORM);
    if (colorTransformXMLList.length > 0) {
        var colorTransformXML = colorTransformXMLList[0];
        var alpha = 0, red = 0, green = 0, blue = 0;
        var alphaOffset = 0, redOffset = 0, greenOffset = 0, blueOffset = 100;
        alpha = parseFloat(colorTransformXML.getAttribute(ccs.CONST_A_ALPHA)) || alpha;
        red = parseFloat(colorTransformXML.getAttribute(ccs.CONST_A_RED)) || red;
        green = parseFloat(colorTransformXML.getAttribute(ccs.CONST_A_GREEN)) || green;
        blue = parseFloat(colorTransformXML.getAttribute(ccs.CONST_A_BLUE)) || blue;
        var str_alphaOffset = colorTransformXML.getAttribute(ccs.CONST_A_ALPHA_OFFSET);
        if (str_alphaOffset)alphaOffset = parseFloat(str_alphaOffset);
        var str_redOffset = colorTransformXML.getAttribute(ccs.CONST_A_RED_OFFSET);
        if (str_redOffset)redOffset = parseFloat(str_redOffset);
        var str_greenOffset = colorTransformXML.getAttribute(ccs.CONST_A_GREEN_OFFSET);
        if (str_redOffset)greenOffset = parseFloat(str_greenOffset);
        var str_blueOffset = colorTransformXML.getAttribute(ccs.CONST_A_BLUE_OFFSET);
        if (str_blueOffset)blueOffset = parseFloat(str_blueOffset);
        frameData.a = 2.55 * alphaOffset + alpha;
        frameData.r = 2.55 * redOffset + red;
        frameData.g = 2.55 * greenOffset + green;
        frameData.b = 2.55 * blueOffset + blue;
        frameData.isUseColorInfo = true
    }
    if (frameData.displayIndex == -1)frameData.a = 0;
    var tweenEasing = frameXML.getAttribute(ccs.CONST_A_TWEEN_EASING);
    if (tweenEasing)if (tweenEasing != ccs.CONST_FL_NAN)frameData.tweenEasing = tweenEasing == 2 ? ccs.TweenType.sineEaseInOut : tweenEasing; else frameData.tweenEasing = ccs.TweenType.linear;
    if (parentFrameXml) {
        var helpNode = new ccs.BaseData;
        if (dataInfo.flashToolVersion >= ccs.CONST_VERSION_2_0) {
            helpNode.x = parseFloat(parentFrameXml.getAttribute(ccs.CONST_A_COCOS2DX_X)) || 0;
            helpNode.y = parseFloat(parentFrameXml.getAttribute(ccs.CONST_A_COCOS2DX_Y)) || 0
        } else {
            helpNode.x = parseFloat(parentFrameXml.getAttribute(ccs.CONST_A_X)) || 0;
            helpNode.y = parseFloat(parentFrameXml.getAttribute(ccs.CONST_A_Y)) || 0
        }
        helpNode.skewX = parseFloat(parentFrameXml.getAttribute(ccs.CONST_A_SKEW_X)) || 0;
        helpNode.skewY = parseFloat(parentFrameXml.getAttribute(ccs.CONST_A_SKEW_Y)) ||
            0;
        helpNode.y = -helpNode.y;
        helpNode.skewX = cc.degreesToRadians(helpNode.skewX);
        helpNode.skewY = cc.degreesToRadians(-helpNode.skewY);
        ccs.TransformHelp.transformFromParent(frameData, helpNode)
    }
    return frameData
}, decodeTexture: function (textureXML, dataInfo) {
    var textureData = new ccs.TextureData;
    if (textureXML.getAttribute(ccs.CONST_A_NAME))textureData.name = textureXML.getAttribute(ccs.CONST_A_NAME);
    var px, py, width, height = 0;
    if (dataInfo.flashToolVersion >= ccs.CONST_VERSION_2_0) {
        px = parseFloat(textureXML.getAttribute(ccs.CONST_A_COCOS2D_PIVOT_X)) ||
            0;
        py = parseFloat(textureXML.getAttribute(ccs.CONST_A_COCOS2D_PIVOT_Y)) || 0
    } else {
        px = parseFloat(textureXML.getAttribute(ccs.CONST_A_PIVOT_X)) || 0;
        py = parseFloat(textureXML.getAttribute(ccs.CONST_A_PIVOT_Y)) || 0
    }
    width = parseFloat(textureXML.getAttribute(ccs.CONST_A_WIDTH)) || 0;
    height = parseFloat(textureXML.getAttribute(ccs.CONST_A_HEIGHT)) || 0;
    var anchorPointX = px / width;
    var anchorPointY = (height - py) / height;
    textureData.pivotX = anchorPointX;
    textureData.pivotY = anchorPointY;
    var contoursXML = textureXML.querySelectorAll(ccs.CONST_SUB_TEXTURE +
        " \x3e " + ccs.CONST_CONTOUR);
    for (var i = 0; i < contoursXML.length; i++)this.decodeContour(contoursXML[i], dataInfo);
    return textureData
}, decodeContour: function (contourXML, dataInfo) {
    var contourData = new ccs.ContourData;
    var vertexDatasXML = contourXML.querySelectorAll(ccs.CONST_CONTOUR + " \x3e " + ccs.CONST_CONTOUR_VERTEX);
    var vertexDataXML;
    for (var i = 0; i < vertexDatasXML.length; i++) {
        vertexDataXML = vertexDatasXML[i];
        var vertex = cc.p(0, 0);
        vertex.x = parseFloat(vertexDataXML.getAttribute(ccs.CONST_A_X)) || 0;
        vertex.y = parseFloat(vertexDataXML.getAttribute(ccs.CONST_A_Y)) ||
            0;
        contourData.vertexList.push(vertex)
    }
    return contourData
}, addDataFromJson: function (filePath, dataInfo, isLoadSpriteFrame) {
    var fileContent = cc.loader.getRes(filePath);
    this.addDataFromJsonCache(fileContent, dataInfo, isLoadSpriteFrame)
}, addDataFromJsonCache: function (dic, dataInfo, isLoadSpriteFrame) {
    dataInfo.contentScale = dic[ccs.CONST_CONTENT_SCALE] || 1;
    var armatureDataArr = dic[ccs.CONST_ARMATURE_DATA] || [];
    var armatureData;
    for (var i = 0; i < armatureDataArr.length; i++) {
        armatureData = this.decodeArmatureFromJSON(armatureDataArr[i],
            dataInfo);
        ccs.armatureDataManager.addArmatureData(armatureData.name, armatureData, dataInfo.filename)
    }
    var animationDataArr = dic[ccs.CONST_ANIMATION_DATA] || [];
    var animationData;
    for (var i = 0; i < animationDataArr.length; i++) {
        animationData = this.decodeAnimationFromJson(animationDataArr[i], dataInfo);
        ccs.armatureDataManager.addAnimationData(animationData.name, animationData, dataInfo.filename)
    }
    var textureDataArr = dic[ccs.CONST_TEXTURE_DATA] || [];
    var textureData;
    for (var i = 0; i < textureDataArr.length; i++) {
        textureData =
            this.decodeTextureFromJson(textureDataArr[i], dataInfo);
        ccs.armatureDataManager.addTextureData(textureData.name, textureData, dataInfo.filename)
    }
    if (isLoadSpriteFrame) {
        var configFiles = dic[ccs.CONST_CONFIG_FILE_PATH] || [];
        var locFilePath, locPos, locPlistPath, locImagePath;
        for (var i = 0; i < configFiles.length; i++) {
            locFilePath = configFiles[i];
            locPos = locFilePath.lastIndexOf(".");
            locFilePath = locFilePath.substring(0, locPos);
            locPlistPath = dataInfo.basefilePath + locFilePath + ".plist";
            locImagePath = dataInfo.basefilePath +
                locFilePath + ".png";
            ccs.armatureDataManager.addSpriteFrameFromFile(locPlistPath, locImagePath, dataInfo.filename)
        }
    }
    armatureData = null;
    animationData = null
}, decodeArmatureFromJSON: function (json, dataInfo) {
    var armatureData = new ccs.ArmatureData;
    var name = json[ccs.CONST_A_NAME];
    if (name)armatureData.name = name;
    dataInfo.cocoStudioVersion = armatureData.dataVersion = json[ccs.CONST_VERSION] || 0.1;
    var boneDataList = json[ccs.CONST_BONE_DATA];
    for (var i = 0; i < boneDataList.length; i++)armatureData.addBoneData(this.decodeBoneFromJson(boneDataList[i],
        dataInfo));
    return armatureData
}, decodeBoneFromJson: function (json, dataInfo) {
    var boneData = new ccs.BoneData;
    this.decodeNodeFromJson(boneData, json, dataInfo);
    boneData.name = json[ccs.CONST_A_NAME] || "";
    boneData.parentName = json[ccs.CONST_A_PARENT] || "";
    var displayDataList = json[ccs.CONST_DISPLAY_DATA] || [];
    for (var i = 0; i < displayDataList.length; i++) {
        var locDisplayData = this.decodeBoneDisplayFromJson(displayDataList[i], dataInfo);
        boneData.addDisplayData(locDisplayData)
    }
    return boneData
}, decodeBoneDisplayFromJson: function (json, dataInfo) {
    var displayType = json[ccs.CONST_A_DISPLAY_TYPE] || ccs.DISPLAY_TYPE_SPRITE;
    var displayData = null;
    switch (displayType) {
        case ccs.DISPLAY_TYPE_SPRITE:
            displayData = new ccs.SpriteDisplayData;
            displayData.displayName = json[ccs.CONST_A_NAME] || "";
            var dicArray = json[ccs.CONST_SKIN_DATA] || [];
            var dic = dicArray[0];
            if (dic) {
                var skinData = displayData.skinData;
                skinData.x = (dic[ccs.CONST_A_X] || 0) * this._positionReadScale;
                skinData.y = (dic[ccs.CONST_A_Y] || 0) * this._positionReadScale;
                if (dic[ccs.CONST_A_SCALE_X] !== undefined)skinData.scaleX =
                    dic[ccs.CONST_A_SCALE_X];
                if (dic[ccs.CONST_A_SCALE_Y] !== undefined)skinData.scaleY = dic[ccs.CONST_A_SCALE_Y];
                skinData.skewX = dic[ccs.CONST_A_SKEW_X] || 0;
                skinData.skewY = dic[ccs.CONST_A_SKEW_Y] || 0;
                skinData.x *= dataInfo.contentScale;
                skinData.y *= dataInfo.contentScale;
                dic = null
            }
            break;
        case ccs.DISPLAY_TYPE_ARMATURE:
            displayData = new ccs.ArmatureDisplayData;
            displayData.displayName = json[ccs.CONST_A_NAME] || "";
            break;
        case ccs.DISPLAY_TYPE_PARTICLE:
            displayData = new ccs.ParticleDisplayData;
            displayData.displayName = dataInfo.basefilePath +
                json[ccs.CONST_A_PLIST] || "";
            break;
        default:
            displayData = new ccs.SpriteDisplayData;
            break
    }
    displayData.displayType = displayType;
    return displayData
}, decodeAnimationFromJson: function (json, dataInfo) {
    var aniData = new ccs.AnimationData;
    aniData.name = json[ccs.CONST_A_NAME] || "";
    var movementDataList = json[ccs.CONST_MOVEMENT_DATA] || [];
    for (var i = 0; i < movementDataList.length; i++) {
        var locMovementData = this.decodeMovementFromJson(movementDataList[i], dataInfo);
        aniData.addMovement(locMovementData)
    }
    return aniData
}, decodeMovementFromJson: function (json, dataInfo) {
    var movementData = new ccs.MovementData;
    movementData.loop = json[ccs.CONST_A_LOOP] || false;
    movementData.durationTween = json[ccs.CONST_A_DURATION_TWEEN] || 0;
    movementData.durationTo = json[ccs.CONST_A_DURATION_TO] || 0;
    movementData.duration = json[ccs.CONST_A_DURATION] || 0;
    if (json[ccs.CONST_A_MOVEMENT_SCALE] !== undefined)movementData.scale = json[ccs.CONST_A_MOVEMENT_SCALE];
    movementData.tweenEasing = json[ccs.CONST_A_TWEEN_EASING] || ccs.TweenType.linear;
    movementData.name = json[ccs.CONST_A_NAME] || "";
    var movementBoneList =
        json[ccs.CONST_MOVEMENT_BONE_DATA] || [];
    for (var i = 0; i < movementBoneList.length; i++) {
        var locMovementBoneData = this.decodeMovementBoneFromJson(movementBoneList[i], dataInfo);
        movementData.addMovementBoneData(locMovementBoneData)
    }
    return movementData
}, decodeMovementBoneFromJson: function (json, dataInfo) {
    var movementBoneData = new ccs.MovementBoneData;
    movementBoneData.delay = json[ccs.CONST_A_MOVEMENT_DELAY] || 0;
    if (json[ccs.CONST_A_MOVEMENT_SCALE] !== undefined)movementBoneData.scale = json[ccs.CONST_A_MOVEMENT_SCALE];
    movementBoneData.name = json[ccs.CONST_A_NAME] || "";
    var frameDataList = json[ccs.CONST_FRAME_DATA] || [];
    for (var i = 0; i < frameDataList.length; i++) {
        var frameData = this.decodeFrameFromJson(frameDataList[i], dataInfo);
        movementBoneData.addFrameData(frameData);
        if (dataInfo.cocoStudioVersion < ccs.CONST_VERSION_COMBINED) {
            frameData.frameID = movementBoneData.duration;
            movementBoneData.duration += frameData.duration
        }
    }
    if (dataInfo.cocoStudioVersion < ccs.VERSION_CHANGE_ROTATION_RANGE) {
        var frames = movementBoneData.frameList;
        var pi =
            Math.PI;
        for (var i = frames.length - 1; i >= 0; i--)if (i > 0) {
            var difSkewX = frames[i].skewX - frames[i - 1].skewX;
            var difSkewY = frames[i].skewY - frames[i - 1].skewY;
            if (difSkewX < -pi || difSkewX > pi)frames[i - 1].skewX = difSkewX < 0 ? frames[i - 1].skewX - 2 * pi : frames[i - 1].skewX + 2 * pi;
            if (difSkewY < -pi || difSkewY > pi)frames[i - 1].skewY = difSkewY < 0 ? frames[i - 1].skewY - 2 * pi : frames[i - 1].skewY + 2 * pi
        }
    }
    if (dataInfo.cocoStudioVersion < ccs.CONST_VERSION_COMBINED)if (movementBoneData.frameList.length > 0) {
        var frameData = new ccs.FrameData;
        frameData.copy(movementBoneData.frameList[movementBoneData.frameList.length -
            1]);
        movementBoneData.addFrameData(frameData);
        frameData.frameID = movementBoneData.duration
    }
    return movementBoneData
}, decodeFrameFromJson: function (json, dataInfo) {
    var frameData = new ccs.FrameData;
    this.decodeNodeFromJson(frameData, json, dataInfo);
    frameData.duration = json[ccs.CONST_A_DURATION] || 0;
    frameData.tweenEasing = json[ccs.CONST_A_TWEEN_EASING] || ccs.TweenType.linear;
    frameData.displayIndex = json[ccs.CONST_A_DISPLAY_INDEX] || 0;
    var bd_src = json[ccs.CONST_A_BLEND_SRC] || cc.BLEND_SRC;
    var bd_dst = json[ccs.CONST_A_BLEND_DST] ||
        cc.BLEND_DST;
    frameData.blendFunc.src = bd_src;
    frameData.blendFunc.dst = bd_dst;
    frameData.event = json[ccs.CONST_A_EVENT] || null;
    if (json[ccs.CONST_A_TWEEN_FRAME] !== undefined)frameData.isTween = json[ccs.CONST_A_TWEEN_FRAME];
    if (dataInfo.cocoStudioVersion < ccs.CONST_VERSION_COMBINED)frameData.duration = json[ccs.CONST_A_DURATION] || 0; else frameData.frameID = json[ccs.CONST_A_FRAME_INDEX] || 0;
    var twEPs = json[ccs.CONST_A_EASING_PARAM] || [];
    for (var i = 0; i < twEPs.length; i++) {
        var twEP = twEPs[i];
        frameData.easingParams[i] = twEP
    }
    return frameData
},
    decodeTextureFromJson: function (json) {
        var textureData = new ccs.TextureData;
        textureData.name = json[ccs.CONST_A_NAME] || "";
        textureData.width = json[ccs.CONST_A_WIDTH] || 0;
        textureData.height = json[ccs.CONST_A_HEIGHT] || 0;
        textureData.pivotX = json[ccs.CONST_A_PIVOT_X] || 0;
        textureData.pivotY = json[ccs.CONST_A_PIVOT_Y] || 0;
        var contourDataList = json[ccs.CONST_CONTOUR_DATA] || [];
        for (var i = 0; i < contourDataList.length; i++) {
            var locContourData = this.decodeContourFromJson(contourDataList[i]);
            textureData.contourDataList.push(locContourData)
        }
        return textureData
    },
    decodeContourFromJson: function (json) {
        var contourData = new ccs.ContourData;
        var vertexPointList = json[ccs.CONST_VERTEX_POINT] || [];
        for (var i = 0; i < vertexPointList.length; i++) {
            var dic = vertexPointList[i];
            var vertex = cc.p(0, 0);
            vertex.x = dic[ccs.CONST_A_X] || 0;
            vertex.y = dic[ccs.CONST_A_Y] || 0;
            contourData.vertexList.push(vertex)
        }
        return contourData
    }, decodeNodeFromJson: function (node, json, dataInfo) {
        node.x = json[ccs.CONST_A_X] || 0;
        node.y = json[ccs.CONST_A_Y] || 0;
        node.x *= dataInfo.contentScale;
        node.y *= dataInfo.contentScale;
        node.zOrder = json[ccs.CONST_A_Z] || 0;
        node.skewX = json[ccs.CONST_A_SKEW_X] || 0;
        node.skewY = json[ccs.CONST_A_SKEW_Y] || 0;
        if (json[ccs.CONST_A_SCALE_X] !== undefined)node.scaleX = json[ccs.CONST_A_SCALE_X];
        if (json[ccs.CONST_A_SCALE_Y] !== undefined)node.scaleY = json[ccs.CONST_A_SCALE_Y];
        var colorDic = json[ccs.CONST_COLOR_INFO] || null;
        if (colorDic) {
            if (dataInfo.cocoStudioVersion < ccs.VERSION_COLOR_READING)colorDic = colorDic[0];
            node.a = colorDic[ccs.CONST_A_ALPHA];
            node.r = colorDic[ccs.CONST_A_RED];
            node.g = colorDic[ccs.CONST_A_GREEN];
            node.b = colorDic[ccs.CONST_A_BLUE];
            node.isUseColorInfo = true;
            delete colorDic
        }
    }, removeConfigFile: function (configFile) {
        cc.arrayRemoveObject(this._configFileList, configFile)
    }};
ccs.spriteFrameCacheHelper = {_textureAtlasDic: {}, _imagePaths: [], addSpriteFrameFromFile: function (plistPath, imagePath) {
    cc.spriteFrameCache.addSpriteFrames(plistPath, imagePath)
}, getTexureAtlasWithTexture: function (texture) {
    return null;
    var textureName = texture.getName();
    var atlas = this._textureAtlasDic[textureName];
    if (atlas == null) {
        atlas = cc.TextureAtlas.create(texture, 20);
        this._textureAtlasDic[textureName] = atlas
    }
    return atlas
}, clear: function () {
    this._textureAtlasDic = {};
    this._imagePaths = []
}};
ccs.TransformHelp = ccs.TransformHelp || ccs.Class.extend({});
ccs.TransformHelp.helpMatrix1 = cc.AffineTransformMake(1, 0, 0, 1, 0, 0);
ccs.TransformHelp.helpMatrix2 = cc.AffineTransformMake(1, 0, 0, 1, 0, 0);
ccs.TransformHelp.helpPoint1 = cc.p(0, 0);
ccs.TransformHelp.helpPoint2 = cc.p(0, 0);
ccs.TransformHelp.transformFromParent = function (bone, parentBone) {
    this.nodeToMatrix(bone, this.helpMatrix1);
    this.nodeToMatrix(parentBone, this.helpMatrix2);
    this.helpMatrix2 = cc.AffineTransformInvert(this.helpMatrix2);
    this.helpMatrix1 = cc.AffineTransformConcat(this.helpMatrix1, this.helpMatrix2);
    this.matrixToNode(this.helpMatrix1, bone)
};
ccs.TransformHelp.nodeToMatrix = function (node, matrix) {
    if (node.skewX == -node.skewY) {
        var sine = Math.sin(node.skewX);
        var cosine = Math.cos(node.skewX);
        matrix.a = node.scaleX * cosine;
        matrix.b = node.scaleX * -sine;
        matrix.c = node.scaleY * sine;
        matrix.d = node.scaleY * cosine
    } else {
        matrix.a = node.scaleX * Math.cos(node.skewY);
        matrix.b = node.scaleX * Math.sin(node.skewY);
        matrix.c = node.scaleY * Math.sin(node.skewX);
        matrix.d = node.scaleY * Math.cos(node.skewY)
    }
    matrix.tx = node.x;
    matrix.ty = node.y
};
ccs.TransformHelp.matrixToNode = function (matrix, node) {
    this.helpPoint1.x = 0;
    this.helpPoint1.y = 1;
    this.helpPoint1 = cc.PointApplyAffineTransform(this.helpPoint1, matrix);
    this.helpPoint1.x -= matrix.tx;
    this.helpPoint1.y -= matrix.ty;
    this.helpPoint2.x = 1;
    this.helpPoint2.y = 0;
    this.helpPoint2 = cc.PointApplyAffineTransform(this.helpPoint2, matrix);
    this.helpPoint2.x -= matrix.tx;
    this.helpPoint2.y -= matrix.ty;
    node.skewX = -(Math.atan2(this.helpPoint1.y, this.helpPoint1.x) - 1.5707964);
    node.skewY = Math.atan2(this.helpPoint2.y, this.helpPoint2.x);
    node.scaleX = Math.sqrt(matrix.a * matrix.a + matrix.b * matrix.b);
    node.scaleY = Math.sqrt(matrix.c * matrix.c + matrix.d * matrix.d);
    node.x = matrix.tx;
    node.y = matrix.ty
};
ccs.TransformHelp.nodeConcat = function (target, source) {
    target.x += source.x;
    target.y += source.y;
    target.skewX += source.skewX;
    target.skewY += source.skewY;
    target.scaleX += source.scaleX;
    target.scaleY += source.scaleY
};
ccs.TransformHelp.nodeSub = function (target, source) {
    target.x -= source.x;
    target.y -= source.y;
    target.skewX -= source.skewX;
    target.skewY -= source.skewY;
    target.scaleX -= source.scaleX;
    target.scaleY -= source.scaleY
};
ccs.TweenType = {customEasing: -1, linear: 0, sineEaseIn: 1, sineEaseOut: 2, sineEaseInOut: 3, quadEaseIn: 4, quadEaseOut: 5, quadEaseInOut: 6, cubicEaseIn: 7, cubicEaseOut: 8, cubicEaseInOut: 9, quartEaseIn: 10, quartEaseOut: 11, quartEaseInOut: 12, quintEaseIn: 13, quintEaseOut: 14, quintEaseInOut: 15, expoEaseIn: 16, expoEaseOut: 17, expoEaseInOut: 18, circEaseIn: 19, eircEaseOut: 20, circEaseInOut: 21, elasticEaseIn: 22, elasticEaseOut: 23, elasticEaseInOut: 24, backEaseIn: 25, backEaseOut: 26, backEaseInOut: 27, bounceEaseIn: 28, bounceEaseOut: 29, bounceEaseInOut: 30,
    tweenEasingMax: 1E4};
ccs.TweenFunction = ccs.TweenFunction || ccs.Class.extend({});
ccs.M_PI_X_2 = Math.PI * 2;
ccs.M_PI_2 = Math.PI / 2;
ccs.M_PI = Math.PI;
ccs.TweenFunction.tweenTo = function (time, type, easingParam) {
    var delta = 0;
    switch (type) {
        case ccs.TweenType.customEasing:
            delta = this.customEase(time, easingParam);
            break;
        case ccs.TweenType.linear:
            delta = this.linear(time);
            break;
        case ccs.TweenType.sineEaseIn:
            delta = this.sineEaseIn(time);
            break;
        case ccs.TweenType.sineEaseOut:
            delta = this.sineEaseOut(time);
            break;
        case ccs.TweenType.sineEaseInOut:
            delta = this.sineEaseInOut(time);
            break;
        case ccs.TweenType.quadEaseIn:
            delta = this.quadEaseIn(time);
            break;
        case ccs.TweenType.quadEaseOut:
            delta =
                this.quadEaseOut(time);
            break;
        case ccs.TweenType.quadEaseInOut:
            delta = this.quadEaseInOut(time);
            break;
        case ccs.TweenType.cubicEaseIn:
            delta = this.cubicEaseIn(time);
            break;
        case ccs.TweenType.cubicEaseOut:
            delta = this.cubicEaseOut(time);
            break;
        case ccs.TweenType.cubicEaseInOut:
            delta = this.cubicEaseInOut(time);
            break;
        case ccs.TweenType.quartEaseIn:
            delta = this.quartEaseIn(time);
            break;
        case ccs.TweenType.quartEaseOut:
            delta = this.quartEaseOut(time);
            break;
        case ccs.TweenType.quartEaseInOut:
            delta = this.quartEaseInOut(time);
            break;
        case ccs.TweenType.quintEaseIn:
            delta = this.quintEaseIn(time);
            break;
        case ccs.TweenType.quintEaseOut:
            delta = this.quintEaseOut(time);
            break;
        case ccs.TweenType.quintEaseInOut:
            delta = this.quintEaseInOut(time);
            break;
        case ccs.TweenType.expoEaseIn:
            delta = this.expoEaseIn(time);
            break;
        case ccs.TweenType.expoEaseOut:
            delta = this.expoEaseOut(time);
            break;
        case ccs.TweenType.expoEaseInOut:
            delta = this.expoEaseInOut(time);
            break;
        case ccs.TweenType.circEaseIn:
            delta = this.circEaseIn(time);
            break;
        case ccs.TweenType.eircEaseOut:
            delta =
                this.circEaseOut(time);
            break;
        case ccs.TweenType.circEaseInOut:
            delta = this.circEaseInOut(time);
            break;
        case ccs.TweenType.elasticEaseIn:
            delta = this.elasticEaseIn(time, easingParam);
            break;
        case ccs.TweenType.elasticEaseOut:
            delta = this.elasticEaseOut(time, easingParam);
            break;
        case ccs.TweenType.elasticEaseInOut:
            delta = this.elasticEaseInOut(time, easingParam);
            break;
        case ccs.TweenType.backEaseIn:
            delta = this.backEaseIn(time);
            break;
        case ccs.TweenType.backEaseOut:
            delta = this.backEaseOut(time);
            break;
        case ccs.TweenType.backEaseInOut:
            delta =
                this.backEaseInOut(time);
            break;
        case ccs.TweenType.bounceEaseIn:
            delta = this.bounceEaseIn(time);
            break;
        case ccs.TweenType.bounceEaseOut:
            delta = this.bounceEaseOut(time);
            break;
        case ccs.TweenType.bounceEaseInOut:
            delta = this.bounceEaseInOut(time);
            break;
        default:
            delta = this.sineEaseInOut(time);
            break
    }
    return delta
};
ccs.TweenFunction.linear = function (time) {
    return time
};
ccs.TweenFunction.sineEaseIn = function (time) {
    return-1 * Math.cos(time * ccs.M_PI_2) + 1
};
ccs.TweenFunction.sineEaseOut = function (time) {
    return Math.sin(time * ccs.M_PI_2)
};
ccs.TweenFunction.sineEaseInOut = function (time) {
    return-0.5 * (Math.cos(ccs.M_PI * time) - 1)
};
ccs.TweenFunction.quadEaseIn = function (time) {
    return time * time
};
ccs.TweenFunction.quadEaseOut = function (time) {
    return-1 * time * (time - 2)
};
ccs.TweenFunction.quadEaseInOut = function (time) {
    time = time * 2;
    if (time < 1)return 0.5 * time * time;
    --time;
    return-0.5 * (time * (time - 2) - 1)
};
ccs.TweenFunction.cubicEaseIn = function (time) {
    return time * time * time
};
ccs.TweenFunction.cubicEaseOut = function (time) {
    time -= 1;
    return time * time * time + 1
};
ccs.TweenFunction.cubicEaseInOut = function (time) {
    time = time * 2;
    if (time < 1)return 0.5 * time * time * time;
    time -= 2;
    return 0.5 * (time * time * time + 2)
};
ccs.TweenFunction.quartEaseIn = function (time) {
    return time * time * time * time
};
ccs.TweenFunction.quartEaseOut = function (time) {
    time -= 1;
    return-(time * time * time * time - 1)
};
ccs.TweenFunction.quartEaseInOut = function (time) {
    time = time * 2;
    if (time < 1)return 0.5 * time * time * time * time;
    time -= 2;
    return-0.5 * (time * time * time * time - 2)
};
ccs.TweenFunction.quintEaseIn = function (time) {
    return time * time * time * time * time
};
ccs.TweenFunction.quintEaseOut = function (time) {
    time -= 1;
    return time * time * time * time * time + 1
};
ccs.TweenFunction.quintEaseInOut = function (time) {
    time = time * 2;
    if (time < 1)return 0.5 * time * time * time * time * time;
    time -= 2;
    return 0.5 * (time * time * time * time * time + 2)
};
ccs.TweenFunction.expoEaseIn = function (time) {
    return time == 0 ? 0 : Math.pow(2, 10 * (time - 1)) - 0.001
};
ccs.TweenFunction.expoEaseOut = function (time) {
    return time == 1 ? 1 : -Math.pow(2, -10 * time) + 1
};
ccs.TweenFunction.expoEaseInOut = function (time) {
    time /= 0.5;
    if (time < 1)time = 0.5 * Math.pow(2, 10 * (time - 1)); else time = 0.5 * (-Math.pow(2, -10 * (time - 1)) + 2);
    return time
};
ccs.TweenFunction.circEaseIn = function (time) {
    return-1 * (Math.sqrt(1 - time * time) - 1)
};
ccs.TweenFunction.circEaseOut = function (time) {
    time = time - 1;
    return Math.sqrt(1 - time * time)
};
ccs.TweenFunction.circEaseInOut = function (time) {
    time = time * 2;
    if (time < 1)return-0.5 * (Math.sqrt(1 - time * time) - 1);
    time -= 2;
    return 0.5 * (Math.sqrt(1 - time * time) + 1)
};
ccs.TweenFunction.elasticEaseIn = function (time, easingParam) {
    var period = 0.3;
    if (easingParam.length > 0)period = easingParam[0];
    var newT = 0;
    if (time == 0 || time == 1)newT = time; else {
        var s = period / 4;
        time = time - 1;
        newT = -Math.pow(2, 10 * time) * Math.sin((time - s) * ccs.M_PI_X_2 / period)
    }
    return newT
};
ccs.TweenFunction.elasticEaseOut = function (time, easingParam) {
    var period = 0.3;
    if (easingParam.length > 0)period = easingParam[0];
    var newT = 0;
    if (time == 0 || time == 1)newT = time; else {
        var s = period / 4;
        newT = Math.pow(2, -10 * time) * Math.sin((time - s) * ccs.M_PI_X_2 / period) + 1
    }
    return newT
};
ccs.TweenFunction.elasticEaseInOut = function (time, easingParam) {
    var period = 0.3;
    if (easingParam.length > 0)period = easingParam[0];
    var newT = 0;
    if (time == 0 || time == 1)newT = time; else {
        time = time * 2;
        if (!period)period = 0.3 * 1.5;
        var s = period / 4;
        time = time - 1;
        if (time < 0)newT = -0.5 * Math.pow(2, 10 * time) * Math.sin((time - s) * ccs.M_PI_X_2 / period); else newT = Math.pow(2, -10 * time) * Math.sin((time - s) * ccs.M_PI_X_2 / period) * 0.5 + 1
    }
    return newT
};
ccs.TweenFunction.backEaseIn = function (time) {
    var overshoot = 1.70158;
    return time * time * ((overshoot + 1) * time - overshoot)
};
ccs.TweenFunction.backEaseOut = function (time) {
    var overshoot = 1.70158;
    time = time - 1;
    return time * time * ((overshoot + 1) * time + overshoot) + 1
};
ccs.TweenFunction.backEaseInOut = function (time) {
    var overshoot = 1.70158 * 1.525;
    time = time * 2;
    if (time < 1)return time * time * ((overshoot + 1) * time - overshoot) / 2; else {
        time = time - 2;
        return time * time * ((overshoot + 1) * time + overshoot) / 2 + 1
    }
};
ccs.bounceTime = function (time) {
    if (time < 1 / 2.75)return 7.5625 * time * time; else if (time < 2 / 2.75) {
        time -= 1.5 / 2.75;
        return 7.5625 * time * time + 0.75
    } else if (time < 2.5 / 2.75) {
        time -= 2.25 / 2.75;
        return 7.5625 * time * time + 0.9375
    }
    time -= 2.625 / 2.75;
    return 7.5625 * time * time + 0.984375
};
ccs.TweenFunction.bounceEaseIn = function (time) {
    return 1 - ccs.bounceTime(1 - time)
};
ccs.TweenFunction.bounceEaseOut = function (time) {
    return ccs.bounceTime(time)
};
ccs.TweenFunction.bounceEaseInOut = function (time) {
    var newT = 0;
    if (time < 0.5) {
        time = time * 2;
        newT = (1 - ccs.bounceTime(1 - time)) * 0.5
    } else newT = ccs.bounceTime(time * 2 - 1) * 0.5 + 0.5;
    return newT
};
ccs.TweenFunction.customEase = function (time, easingParam) {
    if (easingParam.length > 0) {
        var tt = 1 - time;
        return easingParam[1] * tt * tt * tt + 3 * easingParam[3] * time * tt * tt + 3 * easingParam[5] * time * time * tt + easingParam[7] * time * time * time
    }
    return time
};
var ENABLE_PHYSICS_DETECT = false;
ccs.fmodf = function (x, y) {
    while (x > y)x -= y;
    return x
};
var CC_SAFE_RELEASE = function (obj) {
    if (obj && obj.release)obj.release()
};
ccs.isSpriteContainPoint = function (sprite, point, outPoint) {
    var p = cc.p(0, 0);
    if (outPoint)p = sprite.convertToNodeSpace(point);
    var s = sprite.getContentSize();
    var r = cc.rect(0, 0, s.width, s.height);
    return cc.rectContainsPoint(r, p)
};
ccs.SPRITE_CONTAIN_POINT = ccs.isSpriteContainPoint;
ccs.SPRITE_CONTAIN_POINT_WITH_RETURN = ccs.isSpriteContainPoint;
ccs.extBezierTo = function (t, point1, point2, point3, point4) {
    var p = cc.p(0, 0);
    if (point3 && !point4) {
        p.x = Math.pow(1 - t, 2) * point1.x + 2 * t * (1 - t) * point2.x + Math.pow(t, 2) * point3.x;
        p.y = Math.pow(1 - t, 2) * point1.y + 2 * t * (1 - t) * point2.y + Math.pow(t, 2) * point3.y
    }
    if (point4) {
        p.x = point1.x * Math.pow(1 - t, 3) + 3 * t * point2.x * Math.pow(1 - t, 2) + 3 * point3.x * Math.pow(t, 2) * (1 - t) + point4.x * Math.pow(t, 3);
        p.y = point1.y * Math.pow(1 - t, 3) + 3 * t * point2.y * Math.pow(1 - t, 2) + 3 * point3.y * Math.pow(t, 2) * (1 - t) + point4.y * Math.pow(t, 3)
    }
    return p
};
ccs.extCircleTo = function (t, center, radius, fromRadian, radianDif) {
    var p = cc.p(0, 0);
    p.x = center.x + radius * Math.cos(fromRadian + radianDif * t);
    p.y = center.y + radius * Math.sin(fromRadian + radianDif * t);
    return p
};
ccs.RelativeData = function () {
    this.plistFiles = [];
    this.armatures = [];
    this.animations = [];
    this.textures = []
};
ccs.armatureDataManager = {_animationDatas: {}, _armarureDatas: {}, _textureDatas: {}, _autoLoadSpriteFile: false, _relativeDatas: {}, removeArmatureFileInfo: function (configFilePath) {
    var data = this.getRelativeData(configFilePath);
    for (var i = 0; i < data.armatures.length; i++) {
        var obj = data.armatures[i];
        this.removeArmatureData(obj)
    }
    for (var i = 0; i < data.animations.length; i++) {
        var obj = data.animations[i];
        this.removeAnimationData(obj)
    }
    for (var i = 0; i < data.textures.length; i++) {
        var obj = data.textures[i];
        this.removeTextureData(obj)
    }
    for (var i =
        0; i < data.plistFiles.length; i++) {
        var obj = data.plistFiles[i];
        cc.spriteFrameCache.removeSpriteFramesFromFile(obj)
    }
    delete this._relativeDatas[configFilePath];
    ccs.dataReaderHelper.removeConfigFile(configFilePath)
}, addArmatureData: function (id, armatureData, configFilePath) {
    if (this._armarureDatas) {
        var data = this.getRelativeData(configFilePath);
        data.armatures.push(id);
        this._armarureDatas[id] = armatureData
    }
}, removeArmatureData: function (id) {
    if (this._armarureDatas[id])delete this._armarureDatas[id]
}, getArmatureData: function (id) {
    var armatureData =
        null;
    if (this._armarureDatas)armatureData = this._armarureDatas[id];
    return armatureData
}, getArmatureDatas: function () {
    return this._armarureDatas
}, addAnimationData: function (id, animationData, configFilePath) {
    if (this._animationDatas) {
        var data = this.getRelativeData(configFilePath);
        data.animations.push(id);
        this._animationDatas[id] = animationData
    }
}, removeAnimationData: function (id) {
    if (this._animationDatas[id])delete this._animationDatas[id]
}, getAnimationData: function (id) {
    var animationData = null;
    if (this._animationDatas[id])animationData =
        this._animationDatas[id];
    return animationData
}, getAnimationDatas: function () {
    return this._animationDatas
}, addTextureData: function (id, textureData, configFilePath) {
    if (this._textureDatas) {
        var data = this.getRelativeData(configFilePath);
        data.textures.push(id);
        this._textureDatas[id] = textureData
    }
}, removeTextureData: function (id) {
    if (this._textureDatas[id])delete this._textureDatas[id]
}, getTextureData: function (id) {
    var textureData = null;
    if (this._textureDatas)textureData = this._textureDatas[id];
    return textureData
},
    getTextureDatas: function () {
        return this._textureDatas
    }, addArmatureFileInfo: function () {
        var imagePath, plistPath, configFilePath;
        var isLoadSpriteFrame = false;
        if (arguments.length == 1) {
            configFilePath = arguments[0];
            isLoadSpriteFrame = true;
            this.addRelativeData(configFilePath)
        } else if (arguments.length == 3) {
            imagePath = arguments[0];
            plistPath = arguments[1];
            configFilePath = arguments[2];
            this.addRelativeData(configFilePath);
            this.addSpriteFrameFromFile(plistPath, imagePath, configFilePath)
        }
        ccs.dataReaderHelper.addDataFromFile(configFilePath,
            isLoadSpriteFrame)
    }, addArmatureFileInfoAsync: function () {
        var imagePath, plistPath, configFilePath, target, selector;
        var isLoadSpriteFrame = false;
        if (arguments.length == 3) {
            configFilePath = arguments[0];
            selector = arguments[1];
            target = arguments[2];
            isLoadSpriteFrame = true;
            this.addRelativeData(configFilePath)
        } else if (arguments.length == 5) {
            imagePath = arguments[0];
            plistPath = arguments[1];
            configFilePath = arguments[2];
            selector = arguments[3];
            target = arguments[4];
            this.addRelativeData(configFilePath);
            this.addSpriteFrameFromFile(plistPath,
                imagePath, configFilePath)
        }
        ccs.dataReaderHelper.addDataFromFileAsync(configFilePath, target, selector, isLoadSpriteFrame)
    }, addSpriteFrameFromFile: function (plistPath, imagePath, configFilePath) {
        var data = this.getRelativeData(configFilePath);
        data.plistFiles.push(plistPath);
        ccs.spriteFrameCacheHelper.addSpriteFrameFromFile(plistPath, imagePath)
    }, isAutoLoadSpriteFile: function () {
        return this._autoLoadSpriteFile
    }, addRelativeData: function (configFilePath) {
        if (!this._relativeDatas[configFilePath])this._relativeDatas[configFilePath] =
            new ccs.RelativeData
    }, getRelativeData: function (configFilePath) {
        return this._relativeDatas[configFilePath]
    }, clear: function () {
        this._animationDatas = {};
        this._armarureDatas = {};
        this._textureDatas = {};
        ccs.spriteFrameCacheHelper.clear();
        ccs.dataReaderHelper.clear()
    }};
ccs.BLEND_TYPE_NORMAL = 0;
ccs.BLEND_TYPE_LAYER = 1;
ccs.BLEND_TYPE_DARKEN = 2;
ccs.BLEND_TYPE_MULTIPLY = 3;
ccs.BLEND_TYPE_LIGHTEN = 4;
ccs.BLEND_TYPE_SCREEN = 5;
ccs.BLEND_TYPE_OVERLAY = 6;
ccs.BLEND_TYPE_HIGHLIGHT = 7;
ccs.BLEND_TYPE_ADD = 8;
ccs.BLEND_TYPE_SUBTRACT = 9;
ccs.BLEND_TYPE_DIFFERENCE = 10;
ccs.BLEND_TYPE_INVERT = 11;
ccs.BLEND_TYPE_ALPHA = 12;
ccs.BLEND_TYPE_ERASE = 13;
ccs.DISPLAY_TYPE_SPRITE = 0;
ccs.DISPLAY_TYPE_ARMATURE = 1;
ccs.DISPLAY_TYPE_PARTICLE = 2;
ccs.DISPLAY_TYPE_MAX = 3;
ccs.BaseData = ccs.Class.extend({x: 0, y: 0, zOrder: 0, skewX: 0, skewY: 0, scaleX: 1, scaleY: 1, tweenRotate: 0, isUseColorInfo: false, r: 255, g: 255, b: 255, a: 255, ctor: function () {
    this.x = 0;
    this.y = 0;
    this.zOrder = 0;
    this.skewX = 0;
    this.skewY = 0;
    this.scaleX = 1;
    this.scaleY = 1;
    this.tweenRotate = 0;
    this.isUseColorInfo = false;
    this.r = 255;
    this.g = 255;
    this.b = 255;
    this.a = 255
}, copy: function (node) {
    this.x = node.x;
    this.y = node.y;
    this.zOrder = node.zOrder;
    this.scaleX = node.scaleX;
    this.scaleY = node.scaleY;
    this.skewX = node.skewX;
    this.skewY = node.skewY;
    this.tweenRotate =
        node.tweenRotate;
    this.isUseColorInfo = node.isUseColorInfo;
    this.r = node.r;
    this.g = node.g;
    this.b = node.b;
    this.a = node.a
}, setColor: function (color) {
    this.r = color.r;
    this.g = color.g;
    this.b = color.b;
    this.a = color.a
}, getColor: function () {
    return cc.color(this.r, this.g, this.b, this.a)
}, subtract: function (from, to, limit) {
    this.x = to.x - from.x;
    this.y = to.y - from.y;
    this.scaleX = to.scaleX - from.scaleX;
    this.scaleY = to.scaleY - from.scaleY;
    this.skewX = to.skewX - from.skewX;
    this.skewY = to.skewY - from.skewY;
    if (this.isUseColorInfo || from.isUseColorInfo ||
        to.isUseColorInfo) {
        this.a = to.a - from.a;
        this.r = to.r - from.r;
        this.g = to.g - from.g;
        this.b = to.b - from.b;
        this.isUseColorInfo = true
    } else {
        this.a = this.r = this.g = this.b = 0;
        this.isUseColorInfo = false
    }
    if (limit) {
        if (this.skewX > cc.PI)this.skewX -= ccs.M_PI_X_2;
        if (this.skewX < -cc.PI)this.skewX += ccs.M_PI_X_2;
        if (this.skewY > cc.PI)this.skewY -= ccs.M_PI_X_2;
        if (this.skewY < -cc.PI)this.skewY += ccs.M_PI_X_2
    }
    if (to.tweenRotate) {
        this.skewX += to.tweenRotate * ccs.M_PI_X_2;
        this.skewY -= to.tweenRotate * ccs.M_PI_X_2
    }
}});
ccs.DisplayData = ccs.Class.extend({displayType: ccs.DISPLAY_TYPE_MAX, displayName: "", ctor: function () {
    this.displayType = ccs.DISPLAY_TYPE_MAX
}, changeDisplayToTexture: function (displayName) {
    var textureName = displayName;
    var startPos = textureName.lastIndexOf(".");
    if (startPos != -1)textureName = textureName.substring(0, startPos);
    return textureName
}, copy: function (displayData) {
    this.displayName = displayData.displayName;
    this.displayType = displayData.displayType
}});
ccs.SpriteDisplayData = ccs.DisplayData.extend({skinData: null, ctor: function () {
    this.skinData = new ccs.BaseData;
    this.displayType = ccs.DISPLAY_TYPE_SPRITE
}, copy: function (displayData) {
    ccs.DisplayData.prototype.copy.call(this, displayData);
    this.skinData = displayData.skinData
}});
ccs.ArmatureDisplayData = ccs.DisplayData.extend({displayName: "", ctor: function () {
    this.displayName = "";
    this.displayType = ccs.DISPLAY_TYPE_ARMATURE
}});
ccs.ParticleDisplayData = ccs.DisplayData.extend({ctor: function () {
    this.displayType = ccs.DISPLAY_TYPE_PARTICLE
}});
ccs.BoneData = ccs.BaseData.extend({displayDataList: null, name: "", parentName: "", boneDataTransform: null, ctor: function () {
    this.displayDataList = [];
    this.name = "";
    this.parentName = "";
    this.boneDataTransform = null
}, init: function () {
}, addDisplayData: function (displayData) {
    this.displayDataList.push(displayData)
}, getDisplayData: function (index) {
    return this.displayDataList[index]
}});
ccs.ArmatureData = ccs.Class.extend({boneDataDic: null, name: "", dataVersion: 0.1, ctor: function () {
    this.boneDataDic = {};
    this.name = "";
    this.dataVersion = 0.1
}, init: function () {
    return true
}, addBoneData: function (boneData) {
    this.boneDataDic[boneData.name] = boneData
}, getBoneDataDic: function () {
    return this.boneDataDic
}, getBoneData: function (boneName) {
    return this.boneDataDic[boneName]
}});
ccs.FrameData = ccs.BaseData.extend({duration: 0, tweenEasing: 0, easingParamNumber: 0, easingParams: null, displayIndex: -1, movement: "", event: "", sound: "", soundEffect: "", blendFunc: 0, frameID: 0, isTween: true, ctor: function () {
    ccs.BaseData.prototype.ctor.call(this);
    this.duration = 1;
    this.tweenEasing = ccs.TweenType.linear;
    this.easingParamNumber = 0;
    this.easingParams = [];
    this.displayIndex = 0;
    this.movement = "";
    this.event = "";
    this.sound = "";
    this.soundEffect = "";
    this.blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
    this.frameID =
        0;
    this.isTween = true
}, copy: function (frameData) {
    ccs.BaseData.prototype.copy.call(this, frameData);
    this.duration = frameData.duration;
    this.tweenEasing = frameData.tweenEasing;
    this.displayIndex = frameData.displayIndex;
    this.movement = frameData.movement;
    this.event = frameData.event;
    this.sound = frameData.sound;
    this.soundEffect = frameData.soundEffect;
    this.blendFunc = frameData.blendFunc;
    this.isTween = frameData.isTween;
    this.easingParamNumber = frameData.easingParamNumber;
    this.easingParams = [];
    if (this.easingParamNumber != 0)for (var i =
        0; i < this.easingParamNumber; i++)this.easingParams[i] = frameData.easingParams[i]
}});
ccs.MovementBoneData = ccs.Class.extend({delay: 0, scale: 1, duration: 0, frameList: null, name: "", ctor: function () {
    this.delay = 0;
    this.scale = 1;
    this.duration = 0;
    this.frameList = [];
    this.name = ""
}, init: function () {
    this.frameList = []
}, addFrameData: function (frameData) {
    this.frameList.push(frameData)
}, getFrameData: function (index) {
    return this.frameList[index]
}});
ccs.MovementData = ccs.Class.extend({movBoneDataDic: null, duration: 0, scale: 1, durationTo: 0, durationTween: ccs.TweenType.linear, loop: true, tweenEasing: 2, name: "", ctor: function () {
    this.name = "";
    this.duration = 0;
    this.scale = 1;
    this.durationTo = 0;
    this.durationTween = 0;
    this.loop = true;
    this.tweenEasing = ccs.TweenType.linear;
    this.movBoneDataDic = {}
}, addMovementBoneData: function (movBoneData) {
    this.movBoneDataDic[movBoneData.name] = movBoneData
}, getMovementBoneData: function (boneName) {
    return this.movBoneDataDic[boneName]
}});
ccs.AnimationData = ccs.Class.extend({moveDataDic: null, movementNames: null, name: "", ctor: function () {
    this.moveDataDic = {};
    this.movementNames = []
}, addMovement: function (moveData) {
    this.moveDataDic[moveData.name] = moveData;
    this.movementNames.push(moveData.name)
}, getMovement: function (moveName) {
    return this.moveDataDic[moveName]
}, getMovementCount: function () {
    return Object.keys(this.moveDataDic).length
}});
ccs.ContourVertex2 = function (x, y) {
    this.x = x || 0;
    this.y = y || 0
};
ccs.ContourData = ccs.Class.extend({vertexList: null, ctor: function () {
    this.vertexList = []
}, init: function () {
    this.vertexList = [];
    return true
}, addVertex: function (p) {
    var v = ccs.ContourVertex2(p.x, p.y);
    this.vertexList.push(v)
}});
ccs.TextureData = ccs.Class.extend({height: 0, width: 0, pivotX: 0, pivotY: 0, name: "", contourDataList: null, ctor: function () {
    this.height = 0;
    this.width = 0;
    this.pivotX = 0.5;
    this.pivotY = 0.5;
    this.name = "";
    this.contourDataList = []
}, init: function () {
    this.contourDataList = []
}, addContourData: function (contourData) {
    this.contourDataList.push(contourData)
}, getContourData: function (index) {
    return this.contourDataList[index]
}});
ccs.DecorativeDisplay = ccs.Class.extend({_display: null, _colliderDetector: null, _displayData: null, ctor: function () {
    this._display = null;
    this._colliderDetector = null;
    this._displayData = null
}, init: function () {
    return true
}, setDisplay: function (display) {
    this._display = display
}, getDisplay: function () {
    return this._display
}, setColliderDetector: function (colliderDetector) {
    this._colliderDetector = colliderDetector
}, getColliderDetector: function () {
    return this._colliderDetector
}, setDisplayData: function (displayData) {
    this._displayData =
        displayData
}, getDisplayData: function () {
    return this._displayData
}, release: function () {
    CC_SAFE_RELEASE(this._display);
    this._display = null;
    CC_SAFE_RELEASE(this._displayData);
    this._displayData = null;
    CC_SAFE_RELEASE(this._colliderDetector);
    this._colliderDetector = null
}});
ccs.DecorativeDisplay.create = function () {
    var decorativeDisplay = new ccs.DecorativeDisplay;
    if (decorativeDisplay && decorativeDisplay.init())return decorativeDisplay;
    return null
};
ccs.DisplayFactory = ccs.DisplayFactory || ccs.Class.extend({});
ccs.DisplayFactory.addDisplay = function (bone, decoDisplay, displayData) {
    switch (displayData.displayType) {
        case ccs.DISPLAY_TYPE_SPRITE:
            this.addSpriteDisplay(bone, decoDisplay, displayData);
            break;
        case ccs.DISPLAY_TYPE_PARTICLE:
            this.addParticleDisplay(bone, decoDisplay, displayData);
            break;
        case ccs.DISPLAY_TYPE_ARMATURE:
            this.addArmatureDisplay(bone, decoDisplay, displayData);
            break;
        default:
            break
    }
};
ccs.DisplayFactory.createDisplay = function (bone, decoDisplay) {
    switch (decoDisplay.getDisplayData().displayType) {
        case ccs.DISPLAY_TYPE_SPRITE:
            this.createSpriteDisplay(bone, decoDisplay);
            break;
        case ccs.DISPLAY_TYPE_PARTICLE:
            this.createParticleDisplay(bone, decoDisplay);
            break;
        case ccs.DISPLAY_TYPE_ARMATURE:
            this.createArmatureDisplay(bone, decoDisplay);
            break;
        default:
            break
    }
};
ccs.DisplayFactory._helpTransform = {a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0};
ccs.DisplayFactory.updateDisplay = function (bone, dt, dirty) {
    var display = bone.getDisplayRenderNode();
    if (!display)return;
    switch (bone.getDisplayRenderNodeType()) {
        case ccs.DISPLAY_TYPE_SPRITE:
            if (dirty)display.updateArmatureTransform();
            break;
        case ccs.DISPLAY_TYPE_PARTICLE:
            this.updateParticleDisplay(bone, display, dt);
            break;
        case ccs.DISPLAY_TYPE_ARMATURE:
            this.updateArmatureDisplay(bone, display, dt);
            break;
        default:
            var transform = bone.getNodeToArmatureTransform();
            display.setAdditionalTransform(transform);
            break
    }
    if (ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT ||
        ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX)if (dirty) {
        var decoDisplay = bone.getDisplayManager().getCurrentDecorativeDisplay();
        var detector = decoDisplay.getColliderDetector();
        if (detector) {
            var node = decoDisplay.getDisplay();
            var displayTransform = node.nodeToParentTransform();
            var helpTransform = this._helpTransform;
            helpTransform.a = displayTransform.a;
            helpTransform.b = displayTransform.b;
            helpTransform.c = displayTransform.c;
            helpTransform.d = displayTransform.d;
            helpTransform.tx = displayTransform.tx;
            helpTransform.ty = displayTransform.ty;
            var anchorPoint = node.getAnchorPointInPoints();
            anchorPoint = cc.PointApplyAffineTransform(anchorPoint, helpTransform);
            helpTransform.tx = anchorPoint.x;
            helpTransform.ty = anchorPoint.y;
            var t = cc.AffineTransformConcat(helpTransform, bone.getArmature().nodeToParentTransform());
            detector.updateTransform(t)
        }
    }
};
ccs.DisplayFactory.addSpriteDisplay = function (bone, decoDisplay, displayData) {
    var sdp = new ccs.SpriteDisplayData;
    sdp.copy(displayData);
    decoDisplay.setDisplayData(sdp);
    this.createSpriteDisplay(bone, decoDisplay)
};
ccs.DisplayFactory.createSpriteDisplay = function (bone, decoDisplay) {
    var skin = null;
    var displayData = decoDisplay.getDisplayData();
    var textureName = displayData.displayName;
    var startPos = textureName.lastIndexOf(".");
    if (startPos != -1)textureName = textureName.substring(0, startPos);
    if (textureName == "")skin = ccs.Skin.create(); else skin = ccs.Skin.createWithSpriteFrameName(textureName + ".png");
    decoDisplay.setDisplay(skin);
    skin.setBone(bone);
    this.initSpriteDisplay(bone, decoDisplay, displayData.displayName, skin);
    var armature =
        bone.getArmature();
    if (armature)if (armature.getArmatureData().dataVersion >= ccs.CONST_VERSION_COMBINED)skin.setSkinData(displayData.skinData); else skin.setSkinData(bone.getBoneData())
};
ccs.DisplayFactory.initSpriteDisplay = function (bone, decoDisplay, displayName, skin) {
    var textureName = displayName;
    var startPos = textureName.lastIndexOf(".");
    if (startPos != -1)textureName = textureName.substring(0, startPos);
    var textureData = ccs.armatureDataManager.getTextureData(textureName);
    if (textureData)skin.setAnchorPoint(textureData.pivotX, textureData.pivotY);
    if (ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT || ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX)if (textureData && textureData.contourDataList.length > 0) {
        var colliderDetector =
            ccs.ColliderDetector.create(bone);
        colliderDetector.addContourDataList(textureData.contourDataList);
        decoDisplay.setColliderDetector(colliderDetector)
    }
};
ccs.DisplayFactory.addArmatureDisplay = function (bone, decoDisplay, displayData) {
    var adp = new ccs.ArmatureDisplayData;
    adp.copy(displayData);
    decoDisplay.setDisplayData(adp);
    this.createArmatureDisplay(bone, decoDisplay)
};
ccs.DisplayFactory.createArmatureDisplay = function (bone, decoDisplay) {
    var displayData = decoDisplay.getDisplayData();
    var armature = ccs.Armature.create(displayData.displayName, bone);
    decoDisplay.setDisplay(armature)
};
ccs.DisplayFactory.updateArmatureDisplay = function (bone, armature, dt) {
    if (armature) {
        armature.sortAllChildren();
        armature.update(dt)
    }
};
ccs.DisplayFactory.addParticleDisplay = function (bone, decoDisplay, displayData) {
    var adp = new ccs.ParticleDisplayData;
    adp.copy(displayData);
    decoDisplay.setDisplayData(adp);
    this.createParticleDisplay(bone, decoDisplay)
};
ccs.DisplayFactory.createParticleDisplay = function (bone, decoDisplay) {
    var displayData = decoDisplay.getDisplayData();
    var system = cc.ParticleSystem.create(displayData.displayName);
    system.removeFromParent();
    system.cleanup();
    var armature = bone.getArmature();
    if (armature)system.setParent(bone.getArmature());
    decoDisplay.setDisplay(system)
};
ccs.DisplayFactory.updateParticleDisplay = function (bone, particleSystem, dt) {
    var node = new ccs.BaseData;
    ccs.TransformHelp.matrixToNode(bone.nodeToArmatureTransform(), node);
    particleSystem.setPosition(node.x, node.y);
    particleSystem.setScaleX(node.scaleX);
    particleSystem.setScaleY(node.scaleY);
    particleSystem.update(dt)
};
ccs.DisplayManager = ccs.Class.extend({_decoDisplayList: null, _currentDecoDisplay: null, _displayRenderNode: null, _displayIndex: -1, _forceChangeDisplay: false, _bone: null, _visible: true, _displayType: null, ctor: function () {
    this._decoDisplayList = [];
    this._currentDecoDisplay = null;
    this._displayRenderNode = null;
    this._displayIndex = -1;
    this._forceChangeDisplay = false;
    this._bone = null;
    this._visible = true;
    this._displayType = ccs.DISPLAY_TYPE_MAX
}, init: function (bone) {
    this._bone = bone;
    this.initDisplayList(bone.getBoneData());
    return true
},
    addDisplay: function (display, index) {
        var decoDisplay = null;
        if (index >= 0 && index < this._decoDisplayList.length)decoDisplay = this._decoDisplayList[index]; else {
            decoDisplay = ccs.DecorativeDisplay.create();
            this._decoDisplayList.push(decoDisplay)
        }
        var displayData = null;
        if (display instanceof ccs.Skin) {
            var skin = display;
            skin.setBone(this._bone);
            displayData = new ccs.SpriteDisplayData;
            ccs.DisplayFactory.initSpriteDisplay(this._bone, decoDisplay, skin.getDisplayName(), skin);
            var spriteDisplayData = decoDisplay.getDisplayData();
            if (spriteDisplayData instanceof ccs.SpriteDisplayData) {
                skin.setSkinData(spriteDisplayData.skinData);
                displayData.skinData = spriteDisplayData.skinData
            } else {
                var find = false;
                for (var i = this._decoDisplayList.length - 2; i >= 0; i--) {
                    var dd = this._decoDisplayList[i];
                    var sdd = dd.getDisplayData();
                    if (sdd instanceof ccs.SpriteDisplayData) {
                        find = true;
                        skin.setSkinData(sdd.skinData);
                        displayData.skinData = sdd.skinData;
                        break
                    }
                }
            }
        } else if (display instanceof cc.ParticleSystem) {
            displayData = new ccs.ParticleDisplayData;
            display.removeFromParent();
            display.cleanup();
            var armature = this._bone.getArmature();
            if (armature)display.setParent(armature)
        } else if (display instanceof ccs.Armature) {
            var armature = display;
            displayData = new ccs.ArmatureDisplayData;
            displayData.displayName = armature.getName();
            armature.setParentBone(this._bone)
        } else displayData = new ccs.DisplayData;
        decoDisplay.setDisplay(display);
        decoDisplay.setDisplayData(displayData);
        if (index == this._displayIndex) {
            this._displayIndex = -1;
            this.changeDisplayWithIndex(index, false)
        }
    }, _addDisplayOther: function (decoDisplay, display) {
        var displayData = null;
        if (display instanceof ccs.Skin) {
            var skin = display;
            skin.setBone(this._bone);
            displayData = new ccs.SpriteDisplayData;
            displayData.displayName = skin.getDisplayName();
            ccs.DisplayFactory.initSpriteDisplay(this._bone, decoDisplay, skin.getDisplayName(), skin);
            var spriteDisplayData = decoDisplay.getDisplayData();
            if (spriteDisplayData instanceof ccs.SpriteDisplayData)skin.setSkinData(spriteDisplayData.skinData); else {
                var find = false;
                for (var i = this._decoDisplayList.length - 2; i >= 0; i--) {
                    var dd =
                        this._decoDisplayList[i];
                    var sdd = dd.getDisplayData();
                    if (sdd) {
                        find = true;
                        skin.setSkinData(sdd.skinData);
                        displayData.skinData = sdd.skinData;
                        break
                    }
                }
                if (!find)skin.setSkinData(new ccs.BaseData);
                skin.setSkinData(new ccs.BaseData)
            }
        } else if (display instanceof cc.ParticleSystem) {
            displayData = new ccs.ParticleDisplayData;
            displayData.displayName = display._plistFile
        } else if (display instanceof ccs.Armature) {
            displayData = new ccs.ArmatureDisplayData;
            displayData.displayName = display.getName();
            display.setParentBone(this._bone)
        } else displayData =
            new ccs.DisplayData;
        decoDisplay.setDisplay(display);
        decoDisplay.setDisplayData(displayData)
    }, removeDisplay: function (index) {
        this._decoDisplayList.splice(index, 1);
        if (index == this._displayIndex)this.setCurrentDecorativeDisplay(null)
    }, getDecorativeDisplayList: function () {
        return this._decoDisplayList
    }, changeDisplayWithIndex: function (index, force) {
        if (index >= this._decoDisplayList.length) {
            cc.log("the index value is out of range");
            return
        }
        this._forceChangeDisplay = force;
        if (index < 0) {
            this._displayIndex = index;
            if (this._displayRenderNode) {
                this._displayRenderNode.removeFromParent(true);
                this.setCurrentDecorativeDisplay(null);
                this._displayRenderNode = null
            }
            return
        }
        if (this._displayIndex == index)return;
        this._displayIndex = index;
        var decoDisplay = this._decoDisplayList[this._displayIndex];
        if (!decoDisplay)return;
        this.setCurrentDecorativeDisplay(decoDisplay)
    }, changeDisplayWithName: function (name, force) {
        for (var i = 0; i < this._decoDisplayList.length; i++)if (this._decoDisplayList[i].getDisplayData().displayName == name) {
            this.changeDisplayWithIndex(i, force);
            break
        }
    }, setCurrentDecorativeDisplay: function (decoDisplay) {
        var locCurrentDecoDisplay =
            this._currentDecoDisplay;
        if (ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT || ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX)if (locCurrentDecoDisplay && locCurrentDecoDisplay.getColliderDetector())locCurrentDecoDisplay.getColliderDetector().setActive(false);
        this._currentDecoDisplay = decoDisplay;
        locCurrentDecoDisplay = this._currentDecoDisplay;
        if (ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT || ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX)if (locCurrentDecoDisplay && locCurrentDecoDisplay.getColliderDetector())locCurrentDecoDisplay.getColliderDetector().setActive(true);
        var displayRenderNode = locCurrentDecoDisplay == null ? null : locCurrentDecoDisplay.getDisplay();
        if (this._displayRenderNode) {
            if (this._displayRenderNode instanceof ccs.Armature)this._bone.setChildArmature(null);
            this._displayRenderNode.removeFromParent(true);
            this._displayRenderNode = null
        }
        this._displayRenderNode = displayRenderNode;
        if (displayRenderNode) {
            if (displayRenderNode instanceof ccs.Armature)this._bone.setChildArmature(displayRenderNode); else if (displayRenderNode instanceof cc.ParticleSystem)displayRenderNode.resetSystem();
            if (displayRenderNode.RGBAProtocol) {
                displayRenderNode.setColor(this._bone.getDisplayedColor());
                displayRenderNode.setOpacity(this._bone.getDisplayedOpacity())
            }
            displayRenderNode.retain();
            this._displayType = this._currentDecoDisplay.getDisplayData().displayType
        } else this._displayType = ccs.DISPLAY_TYPE_MAX
    }, getDisplayRenderNode: function () {
        return this._displayRenderNode
    }, getDisplayRenderNodeType: function () {
        return this._displayType
    }, getCurrentDisplayIndex: function () {
        return this._displayIndex
    }, getCurrentDecorativeDisplay: function () {
        return this._currentDecoDisplay
    },
    getDecorativeDisplayByIndex: function (index) {
        return this._decoDisplayList[index]
    }, initDisplayList: function (boneData) {
        this._decoDisplayList = [];
        if (!boneData)return;
        var displayList = boneData.displayDataList;
        for (var i = 0; i < displayList.length; i++) {
            var displayData = displayList[i];
            var decoDisplay = ccs.DecorativeDisplay.create();
            decoDisplay.setDisplayData(displayData);
            ccs.DisplayFactory.createDisplay(this._bone, decoDisplay);
            this._decoDisplayList.push(decoDisplay)
        }
    }, containPoint: function (point, y) {
        var p = cc.p(0,
            0);
        if (y === undefined) {
            p.x = point.x;
            p.y = point.y
        } else {
            p.x = point;
            p.y = y
        }
        if (!this._visible || this._displayIndex < 0)return false;
        var ret = false;
        switch (this._currentDecoDisplay.getDisplayData().displayType) {
            case ccs.DISPLAY_TYPE_SPRITE:
                var outPoint = cc.p(0, 0);
                var sprite = this._currentDecoDisplay.getDisplay();
                sprite = sprite.getChildByTag(0);
                ret = ccs.SPRITE_CONTAIN_POINT_WITH_RETURN(sprite, p, outPoint);
                break;
            default:
                break
        }
        return ret
    }, setVisible: function (visible) {
        if (!this._displayRenderNode)return;
        this._visible = visible;
        this._displayRenderNode.setVisible(visible)
    }, isVisible: function () {
        return this._visible
    }, getContentSize: function () {
        if (!this._displayRenderNode)return cc.size(0, 0);
        return this._displayRenderNode.getContentSize()
    }, getBoundingBox: function () {
        if (!this._displayRenderNode)return cc.rect(0, 0, 0, 0);
        return this._displayRenderNode.getBoundingBox()
    }, getAnchorPoint: function () {
        if (!this._displayRenderNode)return cc.p(0, 0);
        return this._displayRenderNode.getAnchorPoint()
    }, getAnchorPointInPoints: function () {
        if (!this._displayRenderNode)return cc.p(0,
            0);
        return this._displayRenderNode.getAnchorPointInPoints()
    }, getForceChangeDisplay: function () {
        return this._forceChangeDisplay
    }, release: function () {
        this._decoDisplayList = [];
        if (this._displayRenderNode) {
            this._displayRenderNode.removeFromParent(true);
            this._displayRenderNode = null
        }
    }});
ccs.DisplayManager.create = function (bone) {
    var displayManager = new ccs.DisplayManager;
    if (displayManager && displayManager.init(bone))return displayManager;
    return null
};
ccs.Skin = ccs.Sprite.extend({_skinData: null, bone: null, _skinTransform: null, _displayName: "", _armature: null, _className: "Skin", ctor: function () {
    cc.Sprite.prototype.ctor.call(this);
    this._skinData = null;
    this.bone = null;
    this._displayName = "";
    this._skinTransform = cc.AffineTransformIdentity();
    this._armature = null
}, initWithSpriteFrameName: function (spriteFrameName) {
    var ret = cc.Sprite.prototype.initWithSpriteFrameName.call(this, spriteFrameName);
    this._displayName = spriteFrameName;
    return ret
}, initWithFile: function (fileName) {
    var ret =
        cc.Sprite.prototype.initWithFile.call(this, fileName);
    this._displayName = fileName;
    return ret
}, setSkinData: function (skinData) {
    this._skinData = skinData;
    this.setScaleX(skinData.scaleX);
    this.setScaleY(skinData.scaleY);
    this.setRotationX(cc.radiansToDegrees(skinData.skewX));
    this.setRotationY(cc.radiansToDegrees(-skinData.skewY));
    this.setPosition(skinData.x, skinData.y);
    var localTransform = this.nodeToParentTransform();
    var skinTransform = this._skinTransform;
    skinTransform.a = localTransform.a;
    skinTransform.b = localTransform.b;
    skinTransform.c = localTransform.c;
    skinTransform.d = localTransform.d;
    skinTransform.tx = localTransform.tx;
    skinTransform.ty = localTransform.ty;
    this.updateArmatureTransform()
}, getSkinData: function () {
    return this._skinData
}, setBone: function (bone) {
    this.bone = bone
}, getBone: function () {
    return this.bone
}, updateArmatureTransform: function () {
    this._transform = cc.AffineTransformConcat(this._skinTransform, this.bone.nodeToArmatureTransform());
    var locTransform = this._transform;
    var locArmature = this._armature;
    if (locArmature &&
        locArmature.getBatchNode())this._transform = cc.AffineTransformConcat(locTransform, locArmature.nodeToParentTransform());
    if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
        locTransform = this._transform;
        locTransform.b *= -1;
        locTransform.c *= -1;
        locTransform.b = [locTransform.c, locTransform.c = locTransform.b][0]
    }
}, getBoundingBox: function () {
    var rect = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
    var transForm = this.nodeToParentTransform();
    if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
        transForm.b *= -1;
        transForm.c *= -1;
        transForm.b = [transForm.c, transForm.c = transForm.b][0]
    }
    return cc.RectApplyAffineTransform(rect, transForm)
}, getDisplayName: function () {
    return this._displayName
}, nodeToWorldTransform: function () {
    return cc.AffineTransformConcat(this._transform, this.bone.getArmature().nodeToWorldTransform())
}, nodeToWorldTransformAR: function () {
    var displayTransform = this._transform;
    var anchorPoint = this._anchorPointInPoints;
    anchorPoint = cc.PointApplyAffineTransform(anchorPoint, displayTransform);
    displayTransform.tx = anchorPoint.x;
    displayTransform.ty = anchorPoint.y;
    return cc.AffineTransformConcat(displayTransform, this.bone.getArmature().nodeToWorldTransform())
}});
ccs.Skin.prototype.nodeToParentTransform = cc.Node.prototype._nodeToParentTransformForWebGL;
var _p = ccs.Skin.prototype;
_p.skinData;
cc.defineGetterSetter(_p, "skinData", _p.getSkinData, _p.setSkinData);
_p.displayName;
cc.defineGetterSetter(_p, "displayName", _p.getDisplayName);
_p = null;
ccs.Skin.create = function (fileName, rect) {
    var argnum = arguments.length;
    var sprite = new ccs.Skin;
    if (argnum === 0) {
        if (sprite.init())return sprite
    } else if (sprite && sprite.initWithFile(fileName, rect))return sprite;
    return null
};
ccs.Skin.createWithSpriteFrameName = function (pszSpriteFrameName) {
    var skin = new ccs.Skin;
    if (skin && skin.initWithSpriteFrameName(pszSpriteFrameName))return skin;
    return null
};
ccs.ANIMATION_TYPE_SINGLE_FRAME = -4;
ccs.ANIMATION_TYPE_NO_LOOP = -3;
ccs.ANIMATION_TYPE_TO_LOOP_FRONT = -2;
ccs.ANIMATION_TYPE_TO_LOOP_BACK = -1;
ccs.ANIMATION_TYPE_LOOP_FRONT = 0;
ccs.ANIMATION_TYPE_LOOP_BACK = 1;
ccs.ANIMATION_TYPE_MAX = 2;
ccs.ProcessBase = ccs.Class.extend({_processScale: 1, _isComplete: true, _isPause: true, _isPlaying: false, _currentPercent: 0, _rawDuration: 0, _loopType: 0, _tweenEasing: 0, animationInternal: null, _currentFrame: 0, _durationTween: 0, _nextFrameIndex: 0, _curFrameIndex: null, _isLoopBack: false, ctor: function () {
    this._processScale = 1;
    this._isComplete = true;
    this._isPause = true;
    this._isPlaying = false;
    this._currentFrame = 0;
    this._currentPercent = 0;
    this._durationTween = 0;
    this._rawDuration = 0;
    this._loopType = ccs.ANIMATION_TYPE_LOOP_BACK;
    this._tweenEasing =
        ccs.TweenType.linear;
    this.animationInternal = 1 / 60;
    this._curFrameIndex = 0;
    this._durationTween = 0;
    this._isLoopBack = false
}, pause: function () {
    this._isPause = true;
    this._isPlaying = false
}, resume: function () {
    this._isPause = false;
    this._isPlaying = true
}, stop: function () {
    this._isComplete = true;
    this._isPlaying = false
}, play: function (durationTo, tweenEasing) {
    this._isComplete = false;
    this._isPause = false;
    this._isPlaying = true;
    this._currentFrame = 0;
    this._nextFrameIndex = durationTo;
    this._tweenEasing = tweenEasing
}, update: function (dt) {
    if (this._isComplete ||
        this._isPause)return false;
    if (this._rawDuration <= 0)return false;
    var locNextFrameIndex = this._nextFrameIndex;
    var locCurrentFrame = this._currentFrame;
    if (locNextFrameIndex <= 0) {
        this._currentPercent = 1;
        locCurrentFrame = 0
    } else {
        locCurrentFrame += this._processScale * (dt / this.animationInternal);
        this._currentPercent = locCurrentFrame / locNextFrameIndex;
        locCurrentFrame = ccs.fmodf(locCurrentFrame, locNextFrameIndex)
    }
    this._currentFrame = locCurrentFrame;
    this.updateHandler();
    return true
}, updateHandler: function () {
}, gotoFrame: function (frameIndex) {
    var locLoopType =
        this._loopType;
    if (locLoopType == ccs.ANIMATION_TYPE_NO_LOOP)locLoopType = ccs.ANIMATION_TYPE_MAX; else if (locLoopType == ccs.ANIMATION_TYPE_TO_LOOP_FRONT)locLoopType = ccs.ANIMATION_TYPE_LOOP_FRONT;
    this._loopType = locLoopType;
    this._curFrameIndex = frameIndex;
    this._nextFrameIndex = this._durationTween
}, getCurrentFrameIndex: function () {
    this._curFrameIndex = (this._rawDuration - 1) * this._currentPercent;
    return this._curFrameIndex
}, isPause: function () {
    return this._isPause
}, isComplete: function () {
    return this._isComplete
}, getCurrentPercent: function () {
    return this._currentPercent
},
    getRawDuration: function () {
        return this._rawDuration
    }, getLoop: function () {
        return this._loopType
    }, getTweenEasing: function () {
        return this._tweenEasing
    }, getAnimationInternal: function () {
        return this.animationInternal
    }, setAnimationInternal: function (animationInternal) {
        this.animationInternal = animationInternal
    }, getProcessScale: function () {
        return this._processScale
    }, setProcessScale: function (processScale) {
        this._processScale = processScale
    }, isPlaying: function () {
        return this._isPlaying
    }});
var _p = ccs.ProcessBase.prototype;
_p.currentFrameIndex;
cc.defineGetterSetter(_p, "currentFrameIndex", _p.getCurrentFrameIndex);
_p.paused;
cc.defineGetterSetter(_p, "paused", _p.isPause);
_p.completed;
cc.defineGetterSetter(_p, "completed", _p.isComplete);
_p.currentPercent;
cc.defineGetterSetter(_p, "currentPercent", _p.getCurrentPercent);
_p.rawDuration;
cc.defineGetterSetter(_p, "rawDuration", _p.getRawDuration);
_p.loop;
cc.defineGetterSetter(_p, "loop", _p.getLoop);
_p.tweenEasing;
cc.defineGetterSetter(_p, "tweenEasing", _p.getTweenEasing);
_p.playing;
cc.defineGetterSetter(_p, "playing", _p.isPlaying);
_p = null;
ccs.MovementEventType = {start: 0, complete: 1, loopComplete: 2};
ccs.AnimationEvent = ccs.Class.extend({_arguments: null, _callFunc: null, _selectorTarget: null, ctor: function (target, callFunc, data) {
    this._data = data;
    this._callFunc = callFunc;
    this._selectorTarget = target
}, call: function () {
    if (this._callFunc)this._callFunc.apply(this._selectorTarget, this._arguments)
}, setArguments: function (args) {
    this._arguments = args
}});
ccs.MovementEvent = function () {
    this.armature = null;
    this.movementType = "";
    this.movementID = ""
};
ccs.FrameEvent = function () {
    this.bone = null;
    this.frameEventName = "";
    this.originFrameIndex = 0;
    this.currentFrameIndex = 0
};
ccs.ArmatureAnimation = ccs.ProcessBase.extend({animationData: null, _movementData: null, _armature: null, _movementID: "", _prevFrameIndex: 0, _toIndex: 0, _tweenList: null, _frameEvent: null, _movementEvent: null, _speedScale: 1, ignoreFrameEvent: false, _frameEventQueue: null, _movementEventQueue: null, userObject: null, _movementList: null, _onMovementList: false, _movementListLoop: false, _movementIndex: 0, ctor: function () {
    ccs.ProcessBase.prototype.ctor.call(this);
    this.animationData = null;
    this._movementData = null;
    this._movementID =
        "";
    this._armature = null;
    this._prevFrameIndex = 0;
    this._toIndex = 0;
    this._tweenList = [];
    this._frameEvent = null;
    this._movementEvent = null;
    this._speedScale = 1;
    this.ignoreFrameEvent = false;
    this._frameEventQueue = [];
    this._movementEventQueue = [];
    this.userObject = null;
    this._movementList = [];
    this._onMovementList = false;
    this._movementListLoop = false;
    this._movementIndex = 0
}, init: function (armature) {
    this._armature = armature;
    this._tweenList = [];
    return true
}, pause: function () {
    for (var i = 0; i < this._tweenList.length; i++)this._tweenList[i].pause();
    ccs.ProcessBase.prototype.pause.call(this)
}, resume: function () {
    for (var i = 0; i < this._tweenList.length; i++)this._tweenList[i].resume();
    ccs.ProcessBase.prototype.resume.call(this)
}, stop: function () {
    for (var i = 0; i < this._tweenList.length; i++)this._tweenList[i].stop();
    this._tweenList = [];
    ccs.ProcessBase.prototype.stop.call(this)
}, setSpeedScale: function (speedScale) {
    if (speedScale == this._speedScale)return;
    this._speedScale = speedScale;
    this._processScale = !this._movementData ? this._speedScale : this._speedScale * this._movementData.scale;
    var dict = this._armature.getBoneDic();
    for (var key in dict) {
        var bone = dict[key];
        bone.getTween().setProcessScale(this._processScale);
        if (bone.getChildArmature())bone.getChildArmature().getAnimation().setProcessScale(this._processScale)
    }
}, getSpeedScale: function () {
    return this._speedScale
}, getAnimationScale: function () {
    return this.getSpeedScale()
}, setAnimationScale: function (animationScale) {
    return this.setSpeedScale(animationScale)
}, play: function (animationName, durationTo, loop) {
    if (this.animationData == null) {
        cc.log("this.animationData can not be null");
        return
    }
    this._movementData = this.animationData.getMovement(animationName);
    if (this._movementData == null) {
        cc.log("this._movementData can not be null");
        return
    }
    if (durationTo === undefined)durationTo = -1;
    if (loop === undefined)loop = -1;
    var locMovementData = this._movementData;
    this._rawDuration = locMovementData.duration;
    this._movementID = animationName;
    this._processScale = this._speedScale * locMovementData.scale;
    durationTo = durationTo == -1 ? locMovementData.durationTo : durationTo;
    var durationTween = locMovementData.durationTween;
    durationTween = durationTween == 0 ? this._rawDuration : durationTween;
    var tweenEasing = locMovementData.tweenEasing;
    if (loop < 0)loop = locMovementData.loop; else loop = Boolean(loop);
    this._onMovementList = false;
    ccs.ProcessBase.prototype.play.call(this, durationTo, tweenEasing);
    if (this._rawDuration == 0)this._loopType = ccs.ANIMATION_TYPE_SINGLE_FRAME; else {
        if (loop)this._loopType = ccs.ANIMATION_TYPE_TO_LOOP_FRONT; else this._loopType = ccs.ANIMATION_TYPE_NO_LOOP;
        this._durationTween = durationTween
    }
    this._tweenList = [];
    var movementBoneData;
    var dict = this._armature.getBoneDic();
    for (var key in dict) {
        var bone = dict[key];
        movementBoneData = locMovementData.getMovementBoneData(bone.getName());
        var tween = bone.getTween();
        if (movementBoneData && movementBoneData.frameList.length > 0) {
            this._tweenList.push(tween);
            movementBoneData.duration = locMovementData.duration;
            tween.play(movementBoneData, durationTo, durationTween, loop, tweenEasing);
            tween.setProcessScale(this._processScale);
            if (bone.getChildArmature())bone.getChildArmature().getAnimation().setProcessScale(this._processScale)
        } else if (!bone.getIgnoreMovementBoneData()) {
            bone.getDisplayManager().changeDisplayWithIndex(-1,
                false);
            tween.stop()
        }
    }
    this._armature.update(0)
}, playWithNames: function (movementNames, durationTo, loop) {
    this._movementList = [];
    this._movementListLoop = loop;
    this._onMovementList = true;
    this._movementIndex = 0;
    for (var i = 0; i < movementNames.length; i++)this._movementList.push({name: movementNames[i], durationTo: durationTo});
    this.updateMovementList()
}, updateMovementList: function () {
    if (this._onMovementList) {
        if (this._movementListLoop) {
            var movementObj = this._movementList[this._movementIndex];
            this.play(movementObj.name,
                movementObj.durationTo, -1, 0);
            this._movementIndex++;
            if (this._movementIndex >= this._movementList.length)this._movementIndex = 0
        } else if (this._movementIndex < this._movementList.length) {
            var movementObj = this._movementList[this._movementIndex];
            this.play(movementObj.name, movementObj.durationTo, -1, 0);
            this._movementIndex++
        } else this._onMovementList = false;
        this._onMovementList = true
    }
}, gotoAndPlay: function (frameIndex) {
    if (!this._movementData || frameIndex < 0 || frameIndex >= this._movementData.duration) {
        cc.log("Please ensure you have played a movement, and the frameIndex is in the range.");
        return
    }
    var ignoreFrameEvent = this.ignoreFrameEvent;
    this.ignoreFrameEvent = true;
    this._isPlaying = true;
    this._isComplete = this._isPause = false;
    ccs.ProcessBase.prototype.gotoFrame.call(this, frameIndex);
    this._currentPercent = this._curFrameIndex / (this._movementData.duration - 1);
    this._currentFrame = this._nextFrameIndex * this._currentPercent;
    for (var i = 0; i < this._tweenList.length; i++) {
        var tween = this._tweenList[i];
        tween.gotoAndPlay(frameIndex)
    }
    this._armature.update(0);
    this.ignoreFrameEvent = ignoreFrameEvent
}, gotoAndPause: function (frameIndex) {
    this.gotoAndPlay(frameIndex);
    this.pause()
}, playWithIndex: function (animationIndex, durationTo, durationTween, loop, tweenEasing) {
    if (typeof durationTo == "undefined")durationTo = -1;
    if (typeof loop == "undefined")loop = -1;
    var moveNames = this.animationData.movementNames;
    if (animationIndex < -1 || animationIndex >= moveNames.length)return;
    var animationName = moveNames[animationIndex];
    this.play(animationName, durationTo, loop, 0)
}, playByIndex: function (animationIndex, durationTo, durationTween, loop, tweenEasing) {
    cc.log("playByIndex is deprecated. Use playWithIndex instead.");
    this.playWithIndex(animationIndex, durationTo, durationTween, loop, tweenEasing)
}, playWithIndexes: function (movementIndexes, durationTo, loop) {
    this._movementList = [];
    this._movementListLoop = loop;
    this._onMovementList = true;
    this._movementIndex = 0;
    var movName = this.animationData.movementNames;
    for (var i = 0; i < movementIndexes.length; i++) {
        var name = movName[movementIndexes[i]];
        this._movementList.push({name: name, durationTo: durationTo})
    }
    this.updateMovementList()
}, getMovementCount: function () {
    return this.animationData.getMovementCount()
},
    update: function (dt) {
        if (ccs.ProcessBase.prototype.update.call(this, dt))for (var i = 0; i < this._tweenList.length; i++)this._tweenList[i].update(dt);
        var frameEvents = this._frameEventQueue;
        while (frameEvents.length > 0) {
            var frameEvent = frameEvents.shift();
            this.ignoreFrameEvent = true;
            this.callFrameEvent([frameEvent.bone, frameEvent.frameEventName, frameEvent.originFrameIndex, frameEvent.currentFrameIndex]);
            this.ignoreFrameEvent = false
        }
        var movementEvents = this._movementEventQueue;
        while (movementEvents.length > 0) {
            var movEvent =
                movementEvents.shift();
            this.callMovementEvent([movEvent.armature, movEvent.movementType, movEvent.movementID])
        }
    }, updateHandler: function () {
        var locCurrentPercent = this._currentPercent;
        if (locCurrentPercent >= 1) {
            switch (this._loopType) {
                case ccs.ANIMATION_TYPE_NO_LOOP:
                    this._loopType = ccs.ANIMATION_TYPE_MAX;
                    this._currentFrame = (locCurrentPercent - 1) * this._nextFrameIndex;
                    locCurrentPercent = this._currentFrame / this._durationTween;
                    if (locCurrentPercent < 1) {
                        this._nextFrameIndex = this._durationTween;
                        this.movementEvent(this._armature,
                            ccs.MovementEventType.start, this._movementID);
                        break
                    }
                case ccs.ANIMATION_TYPE_MAX:
                case ccs.ANIMATION_TYPE_SINGLE_FRAME:
                    locCurrentPercent = 1;
                    this._isComplete = true;
                    this._isPlaying = false;
                    this.movementEvent(this._armature, ccs.MovementEventType.complete, this._movementID);
                    this.updateMovementList();
                    break;
                case ccs.ANIMATION_TYPE_TO_LOOP_FRONT:
                    this._loopType = ccs.ANIMATION_TYPE_LOOP_FRONT;
                    locCurrentPercent = ccs.fmodf(locCurrentPercent, 1);
                    this._currentFrame = this._nextFrameIndex == 0 ? 0 : ccs.fmodf(this._currentFrame,
                        this._nextFrameIndex);
                    this._nextFrameIndex = this._durationTween > 0 ? this._durationTween : 1;
                    this.movementEvent(this, ccs.MovementEventType.start, this._movementID);
                    break;
                default:
                    this._currentFrame = ccs.fmodf(this._currentFrame, this._nextFrameIndex);
                    this._toIndex = 0;
                    this.movementEvent(this._armature, ccs.MovementEventType.loopComplete, this._movementID);
                    break
            }
            this._currentPercent = locCurrentPercent
        }
    }, getCurrentMovementID: function () {
        if (this._isComplete)return"";
        return this._movementID
    }, setMovementEventCallFunc: function (callFunc, target) {
        this._movementEvent = new ccs.AnimationEvent(target, callFunc)
    }, callMovementEvent: function (args) {
        if (this._movementEvent) {
            this._movementEvent.setArguments(args);
            this._movementEvent.call()
        }
    }, setFrameEventCallFunc: function (callFunc, target) {
        this._frameEvent = new ccs.AnimationEvent(target, callFunc)
    }, callFrameEvent: function (args) {
        if (this._frameEvent) {
            this._frameEvent.setArguments(args);
            this._frameEvent.call()
        }
    }, movementEvent: function (armature, movementType, movementID) {
        if (this._movementEvent) {
            var event =
                new ccs.MovementEvent;
            event.armature = armature;
            event.movementType = movementType;
            event.movementID = movementID;
            this._movementEventQueue.push(event)
        }
    }, frameEvent: function (bone, frameEventName, originFrameIndex, currentFrameIndex) {
        if (this._frameEvent) {
            var frameEvent = new ccs.FrameEvent;
            frameEvent.bone = bone;
            frameEvent.frameEventName = frameEventName;
            frameEvent.originFrameIndex = originFrameIndex;
            frameEvent.currentFrameIndex = currentFrameIndex;
            this._frameEventQueue.push(frameEvent)
        }
    }, setAnimationData: function (aniData) {
        this.animationData =
            aniData
    }, getAnimationData: function () {
        return this.animationData
    }, setUserObject: function (userObject) {
        this.userObject = userObject
    }, getUserObject: function () {
        return this.userObject
    }, isIgnoreFrameEvent: function () {
        return this.ignoreFrameEvent
    }, setIgnoreFrameEvent: function (bool) {
        this.ignoreFrameEvent = bool
    }});
var _p = ccs.ArmatureAnimation.prototype;
_p.speedScale;
cc.defineGetterSetter(_p, "speedScale", _p.getSpeedScale, _p.setSpeedScale);
_p.animationScale;
cc.defineGetterSetter(_p, "animationScale", _p.getAnimationScale, _p.setAnimationScale);
_p = null;
ccs.ArmatureAnimation.create = function (armature) {
    var animation = new ccs.ArmatureAnimation;
    if (animation && animation.init(armature))return animation;
    return null
};
ccs.Tween = ccs.ProcessBase.extend({_tweenData: null, _to: null, _from: null, _between: null, _movementBoneData: null, _bone: null, _frameTweenEasing: 0, _betweenDuration: 0, _totalDuration: 0, _toIndex: 0, _fromIndex: 0, animation: null, _passLastFrame: false, ctor: function () {
    ccs.ProcessBase.prototype.ctor.call(this);
    this._tweenData = null;
    this._to = null;
    this._from = null;
    this._between = null;
    this._bone = null;
    this._movementBoneData = null;
    this._frameTweenEasing = ccs.TweenType.linear;
    this._toIndex = 0;
    this._fromIndex = 0;
    this.animation = null;
    this._passLastFrame = false
}, init: function (bone) {
    this._from = new ccs.FrameData;
    this._between = new ccs.FrameData;
    this._bone = bone;
    this._tweenData = this._bone.getTweenData();
    this._tweenData.displayIndex = -1;
    var armature = bone.getArmature();
    if (armature)this.animation = armature.getAnimation();
    return true
}, play: function (movementBoneData, durationTo, durationTween, loop, tweenEasing) {
    ccs.ProcessBase.prototype.play.call(this, durationTo, tweenEasing);
    if (loop)this._loopType = ccs.ANIMATION_TYPE_TO_LOOP_FRONT; else this._loopType =
        ccs.ANIMATION_TYPE_NO_LOOP;
    this._totalDuration = 0;
    this._betweenDuration = 0;
    this._fromIndex = this._toIndex = 0;
    var difMovement = movementBoneData != this._movementBoneData;
    this._movementBoneData = movementBoneData;
    this._rawDuration = this._movementBoneData.duration;
    var nextKeyFrame = this._movementBoneData.getFrameData(0);
    this._tweenData.displayIndex = nextKeyFrame.displayIndex;
    if (this._bone.getArmature().getArmatureData().dataVersion >= ccs.CONST_VERSION_COMBINED) {
        ccs.TransformHelp.nodeSub(this._tweenData, this._bone.getBoneData());
        this._tweenData.scaleX += 1;
        this._tweenData.scaleY += 1
    }
    if (this._rawDuration == 0 || this._movementBoneData.frameList.length == 1) {
        this._loopType = ccs.ANIMATION_TYPE_SINGLE_FRAME;
        if (durationTo == 0)this.setBetween(nextKeyFrame, nextKeyFrame); else this.setBetween(this._tweenData, nextKeyFrame);
        this._frameTweenEasing = ccs.TweenType.linear
    } else if (this._movementBoneData.frameList.length > 1) {
        this._durationTween = durationTween * this._movementBoneData.scale;
        if (loop && this._movementBoneData.delay != 0)this.setBetween(this._tweenData,
            this.tweenNodeTo(this.updateFrameData(1 - this._movementBoneData.delay), this._between)); else if (!difMovement || durationTo == 0)this.setBetween(nextKeyFrame, nextKeyFrame); else this.setBetween(this._tweenData, nextKeyFrame)
    }
    this.tweenNodeTo(0)
}, gotoAndPlay: function (frameIndex) {
    ccs.ProcessBase.prototype.gotoFrame.call(this, frameIndex);
    this._totalDuration = 0;
    this._betweenDuration = 0;
    this._fromIndex = this._toIndex = 0;
    this._isPlaying = true;
    this._isComplete = this._isPause = false;
    this._currentPercent = this._curFrameIndex /
        (this._rawDuration - 1);
    this._currentFrame = this._nextFrameIndex * this._currentPercent
}, gotoAndPause: function (frameIndex) {
    this.gotoAndPlay(frameIndex);
    this.pause()
}, updateHandler: function () {
    var locCurrentPercent = this._currentPercent;
    var locLoopType = this._loopType;
    if (locCurrentPercent >= 1)switch (locLoopType) {
        case ccs.ANIMATION_TYPE_SINGLE_FRAME:
            locCurrentPercent = 1;
            this._isComplete = true;
            this._isPlaying = false;
            break;
        case ccs.ANIMATION_TYPE_NO_LOOP:
            locLoopType = ccs.ANIMATION_TYPE_MAX;
            if (this._durationTween <=
                0)locCurrentPercent = 1; else locCurrentPercent = (locCurrentPercent - 1) * this._nextFrameIndex / this._durationTween;
            if (locCurrentPercent >= 1) {
                locCurrentPercent = 1;
                this._isComplete = true;
                this._isPlaying = false;
                break
            } else {
                this._nextFrameIndex = this._durationTween;
                this._currentFrame = locCurrentPercent * this._nextFrameIndex;
                this._totalDuration = 0;
                this._betweenDuration = 0;
                this._fromIndex = this._toIndex = 0;
                break
            }
        case ccs.ANIMATION_TYPE_TO_LOOP_FRONT:
            locLoopType = ccs.ANIMATION_TYPE_LOOP_FRONT;
            this._nextFrameIndex = this._durationTween >
                0 ? this._durationTween : 1;
            if (this._movementBoneData.delay != 0) {
                this._currentFrame = (1 - this._movementBoneData.delay) * this._nextFrameIndex;
                locCurrentPercent = this._currentFrame / this._nextFrameIndex
            } else {
                locCurrentPercent = 0;
                this._currentFrame = 0
            }
            this._totalDuration = 0;
            this._betweenDuration = 0;
            this._fromIndex = this._toIndex = 0;
            break;
        case ccs.ANIMATION_TYPE_MAX:
            locCurrentPercent = 1;
            this._isComplete = true;
            this._isPlaying = false;
            break;
        default:
            this._currentFrame = ccs.fmodf(this._currentFrame, this._nextFrameIndex);
            this._totalDuration =
                0;
            this._betweenDuration = 0;
            break
    }
    if (locCurrentPercent < 1 && locLoopType < ccs.ANIMATION_TYPE_TO_LOOP_BACK)locCurrentPercent = Math.sin(locCurrentPercent * cc.PI / 2);
    this._currentPercent = locCurrentPercent;
    this._loopType = locLoopType;
    if (locLoopType > ccs.ANIMATION_TYPE_TO_LOOP_BACK)locCurrentPercent = this.updateFrameData(locCurrentPercent);
    if (this._frameTweenEasing != ccs.TweenType.tweenEasingMax)this.tweenNodeTo(locCurrentPercent)
}, setBetween: function (from, to, limit) {
    if (typeof limit == "undefined")limit = true;
    do {
        if (from.displayIndex <
            0 && to.displayIndex >= 0) {
            this._from.copy(to);
            this._between.subtract(to, to, limit);
            break
        }
        if (to.displayIndex < 0 && from.displayIndex >= 0) {
            this._from.copy(from);
            this._between.subtract(to, to, limit);
            break
        }
        this._from.copy(from);
        this._between.subtract(from, to, limit)
    } while (0);
    if (!from.isTween) {
        this._tweenData.copy(from);
        this._tweenData.isTween = true
    }
    this.arriveKeyFrame(from)
}, arriveKeyFrame: function (keyFrameData) {
    if (keyFrameData) {
        var locBone = this._bone;
        var displayIndex = keyFrameData.displayIndex;
        var displayManager =
            locBone.getDisplayManager();
        if (!displayManager.getForceChangeDisplay()) {
            displayManager.changeDisplayWithIndex(displayIndex, false);
            var locRenderNode = displayManager.getDisplayRenderNode();
            if (locRenderNode)locRenderNode.setBlendFunc(keyFrameData.blendFunc)
        }
        this._tweenData.zOrder = keyFrameData.zOrder;
        locBone.updateZOrder();
        var childAramture = locBone.getChildArmature();
        if (childAramture)if (keyFrameData.movement != "")childAramture.getAnimation().play(keyFrameData.movement)
    }
}, tweenNodeTo: function (percent, node) {
    if (!node)node =
        this._tweenData;
    var locFrom = this._from;
    var locBetween = this._between;
    if (!locFrom.isTween)percent = 0;
    node.x = locFrom.x + percent * locBetween.x;
    node.y = locFrom.y + percent * locBetween.y;
    node.scaleX = locFrom.scaleX + percent * locBetween.scaleX;
    node.scaleY = locFrom.scaleY + percent * locBetween.scaleY;
    node.skewX = locFrom.skewX + percent * locBetween.skewX;
    node.skewY = locFrom.skewY + percent * locBetween.skewY;
    this._bone.setTransformDirty(true);
    if (node && locBetween.isUseColorInfo)this.tweenColorTo(percent, node);
    return node
}, tweenColorTo: function (percent, node) {
    var locFrom = this._from;
    var locBetween = this._between;
    node.a = locFrom.a + percent * locBetween.a;
    node.r = locFrom.r + percent * locBetween.r;
    node.g = locFrom.g + percent * locBetween.g;
    node.b = locFrom.b + percent * locBetween.b;
    this._bone.updateColor()
}, updateFrameData: function (currentPercent) {
    if (currentPercent > 1 && this._movementBoneData.delay != 0)currentPercent = ccs.fmodf(currentPercent, 1);
    var playedTime = (this._rawDuration - 1) * currentPercent;
    var from, to;
    var locTotalDuration = this._totalDuration, locBetweenDuration = this._betweenDuration,
        locToIndex = this._toIndex;
    if (playedTime < locTotalDuration || playedTime >= locTotalDuration + locBetweenDuration) {
        var length = this._movementBoneData.frameList.length;
        var frames = this._movementBoneData.frameList;
        if (playedTime < frames[0].frameID) {
            from = to = frames[0];
            this.setBetween(from, to);
            return currentPercent
        } else if (playedTime >= frames[length - 1].frameID) {
            if (this._passLastFrame) {
                from = to = frames[length - 1];
                this.setBetween(from, to);
                return currentPercent
            }
            this._passLastFrame = true
        } else this._passLastFrame = false;
        do {
            this._fromIndex =
                locToIndex;
            from = frames[this._fromIndex];
            locTotalDuration = from.frameID;
            locToIndex = this._fromIndex + 1;
            if (locToIndex >= length)locToIndex = 0;
            to = frames[locToIndex];
            if (from.event && !this.animation.isIgnoreFrameEvent())this.animation.frameEvent(this._bone, from.event, from.frameID, playedTime);
            if (playedTime == from.frameID || this._passLastFrame && this._fromIndex == length - 1)break
        } while (playedTime < from.frameID || playedTime >= to.frameID);
        locBetweenDuration = to.frameID - from.frameID;
        this._frameTweenEasing = from.tweenEasing;
        this.setBetween(from, to, false);
        this._totalDuration = locTotalDuration;
        this._betweenDuration = locBetweenDuration;
        this._toIndex = locToIndex
    }
    currentPercent = locBetweenDuration == 0 ? 0 : (playedTime - locTotalDuration) / locBetweenDuration;
    var tweenType = this._frameTweenEasing != ccs.TweenType.linear ? this._frameTweenEasing : this._tweenEasing;
    if (tweenType != ccs.TweenType.tweenEasingMax && tweenType != ccs.TweenType.linear && !this._passLastFrame)currentPercent = ccs.TweenFunction.tweenTo(currentPercent, tweenType, this._from.easingParams);
    return currentPercent
}, setAnimation: function (animation) {
    this.animation = animation
}, getAnimation: function () {
    return this.animation
}, release: function () {
    this._from = null;
    this._between = null
}});
ccs.Tween.create = function (bone) {
    var tween = new ccs.Tween;
    if (tween && tween.init(bone))return tween;
    return null
};
ccs.PT_RATIO = 32;
ccs.ColliderFilter = ccs.Class.extend({_collisionType: 0, _group: 0, ctor: function (collisionType, group) {
    this._collisionType = collisionType || 0;
    this._group = group || 0
}, updateShape: function (shape) {
    shape.collision_type = this._collisionType;
    shape.group = this._group
}});
ccs.ColliderBody = ccs.Class.extend({shape: null, coutourData: null, colliderFilter: null, _calculatedVertexList: null, ctor: function (contourData) {
    this.shape = null;
    this.coutourData = contourData;
    this.colliderFilter = new ccs.ColliderFilter;
    if (ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX)this._calculatedVertexList = []
}, getContourData: function () {
    return this.coutourData
}, setContourData: function (contourData) {
    this.coutourData = contourData
}, getShape: function () {
    return this.shape
}, setShape: function (shape) {
    this.shape = shape
},
    getColliderFilter: function () {
        return this.colliderFilter
    }, setColliderFilter: function (colliderFilter) {
        this.colliderFilter = colliderFilter
    }, getCalculatedVertexList: function () {
        return this._calculatedVertexList
    }});
ccs.ColliderDetector = ccs.Class.extend({_colliderBodyList: null, _bone: null, _body: null, _active: false, _filter: null, ctor: function () {
    this._colliderBodyList = [];
    this._bone = null;
    this._body = null;
    this._active = false;
    this._filter = null
}, init: function (bone) {
    this._colliderBodyList = [];
    if (bone)this._bone = bone;
    this._filter = new ccs.ColliderFilter;
    return true
}, addContourData: function (contourData) {
    var colliderBody = new ccs.ColliderBody(contourData);
    this._colliderBodyList.push(colliderBody);
    if (ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) {
        var calculatedVertexList =
            colliderBody.getCalculatedVertexList();
        var vertexList = contourData.vertexList;
        for (var i = 0; i < vertexList.length; i++) {
            var newVertex = new ccs.ContourVertex2(0, 0);
            calculatedVertexList.push(newVertex)
        }
    }
}, addContourDataList: function (contourDataList) {
    for (var i = 0; i < contourDataList.length; i++)this.addContourData(contourDataList[i])
}, removeContourData: function (contourData) {
    var locColliderBodyList = this._colliderBodyList;
    for (var i = 0; i < locColliderBodyList.length; i++)if (locColliderBodyList[i].getContourData() == contourData) {
        locColliderBodyList.splice(i,
            1);
        return
    }
}, removeAll: function () {
    this._colliderBodyList = []
}, setColliderFilter: function (filter) {
    this._filter = filter;
    for (var i = 0; i < this._colliderBodyList.length; i++) {
        var colliderBody = this._colliderBodyList[i];
        colliderBody.setColliderFilter(filter);
        if (ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT)if (colliderBody.getShape())colliderBody.getColliderFilter().updateShape(colliderBody.getShape())
    }
}, getColliderFilter: function () {
    return this._filter
}, setActive: function (active) {
    if (this._active == active)return;
    this._active =
        active;
    var locBody = this._body;
    var locShape;
    if (locBody) {
        var colliderBody = null;
        if (this._active)for (var i = 0; i < this._colliderBodyList.length; i++) {
            colliderBody = this._colliderBodyList[i];
            locShape = colliderBody.getShape();
            locBody.space.addShape(locShape)
        } else for (var i = 0; i < this._colliderBodyList.length; i++) {
            colliderBody = this._colliderBodyList[i];
            locShape = colliderBody.getShape();
            locBody.space.removeShape(locShape)
        }
    }
}, getActive: function () {
    return this._active
}, getColliderBodyList: function () {
    return this._colliderBodyList
},
    helpPoint: cc.p(0, 0), updateTransform: function (t) {
        if (!this._active)return;
        var colliderBody = null;
        var locBody = this._body;
        var locHelpPoint = this.helpPoint;
        for (var i = 0; i < this._colliderBodyList.length; i++) {
            colliderBody = this._colliderBodyList[i];
            var contourData = colliderBody.getContourData();
            var shape = null;
            if (locBody)shape = colliderBody.getShape();
            var vs = contourData.vertexList;
            var cvs = colliderBody.getCalculatedVertexList();
            for (var j = 0; j < vs.length; j++) {
                locHelpPoint.x = vs[j].x;
                locHelpPoint.y = vs[j].y;
                locHelpPoint =
                    cc.PointApplyAffineTransform(locHelpPoint, t);
                if (shape) {
                    shape.verts[j * 2] = locHelpPoint.x;
                    shape.verts[j * 2 + 1] = locHelpPoint.y
                }
                if (ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) {
                    var v = cc.p(0, 0);
                    v.x = locHelpPoint.x;
                    v.y = locHelpPoint.y;
                    cvs[j] = v
                }
            }
            if (shape)for (var j = 0; j < vs.length; j++) {
                var b = shape.verts[(j + 1) % shape.verts.length];
                var n = cp.v.normalize(cp.v.perp(cp.v.sub(b, shape.verts[j])));
                shape.axes[j].n = n;
                shape.axes[j].d = cp.v.dot(n, shape.verts[j])
            }
        }
    }, getBody: function () {
        return this._body
    }, setBody: function (body) {
        this._body =
            body;
        var colliderBody;
        for (var i = 0; i < this._colliderBodyList.length; i++) {
            colliderBody = this._colliderBodyList[i];
            var contourData = colliderBody.getContourData();
            var verts = [];
            var vs = contourData.vertexList;
            for (var i = 0; i < vs.length; i++) {
                var v = vs[i];
                verts.push(v.x);
                verts.push(v.y)
            }
            var shape = new cp.PolyShape(this._body, verts, cp.vzero);
            shape.sensor = true;
            shape.data = this._bone;
            if (this._active)this._body.space.addShape(shape);
            colliderBody.setShape(shape);
            colliderBody.getColliderFilter().updateShape(shape)
        }
    }});
var _p = ccs.ColliderDetector.prototype;
_p.colliderFilter;
cc.defineGetterSetter(_p, "colliderFilter", _p.getColliderFilter, _p.setColliderFilter);
_p.active;
cc.defineGetterSetter(_p, "active", _p.getActive, _p.setActive);
_p.body;
cc.defineGetterSetter(_p, "body", _p.getBody, _p.setBody);
_p = null;
ccs.ColliderDetector.create = function (bone) {
    var colliderDetector = new ccs.ColliderDetector;
    if (colliderDetector && colliderDetector.init(bone))return colliderDetector;
    return null
};
ccs.Armature = ccs.NodeRGBA.extend({animation: null, armatureData: null, batchNode: null, name: "", _textureAtlas: null, _parentBone: null, _boneDic: null, _topBoneList: null, _armatureIndexDic: null, _offsetPoint: null, version: 0, _armatureTransformDirty: true, _body: null, _textureAtlasDic: null, _blendFunc: null, _className: "Armature", ctor: function (name, parentBone) {
    cc.NodeRGBA.prototype.ctor.call(this);
    this.animation = null;
    this.armatureData = null;
    this.batchNode = null;
    this.name = "";
    this._textureAtlas = null;
    this._parentBone = null;
    this._boneDic =
        null;
    this._topBoneList = null;
    this._armatureIndexDic = {};
    this._offsetPoint = cc.p(0, 0);
    this.version = 0;
    this._armatureTransformDirty = true;
    this._body = null;
    this._textureAtlasDic = null;
    this._blendFunc = null;
    parentBone && ccs.Armature.prototype.init.call(this, name, parentBone)
}, init: function (name, parentBone) {
    cc.NodeRGBA.prototype.init.call(this);
    if (parentBone)this._parentBone = parentBone;
    this.removeAllChildren();
    this.animation = new ccs.ArmatureAnimation;
    this.animation.init(this);
    this._boneDic = {};
    this._topBoneList =
        [];
    this._textureAtlasDic = {};
    this._blendFunc = {src: cc.BLEND_SRC, dst: cc.BLEND_DST};
    this.name = !name ? "" : name;
    var armatureDataManager = ccs.armatureDataManager;
    if (name != "") {
        var animationData = armatureDataManager.getAnimationData(name);
        if (!animationData) {
            cc.log("AnimationData not exist! ");
            return false
        }
        this.animation.setAnimationData(animationData);
        var armatureData = armatureDataManager.getArmatureData(name);
        this.armatureData = armatureData;
        var boneDataDic = armatureData.getBoneDataDic();
        for (var key in boneDataDic) {
            var bone =
                this.createBone(String(key));
            do {
                var movData = animationData.getMovement(animationData.movementNames[0]);
                if (!movData)break;
                var _movBoneData = movData.getMovementBoneData(bone.getName());
                if (!_movBoneData || _movBoneData.frameList.length <= 0)break;
                var frameData = _movBoneData.getFrameData(0);
                if (!frameData)break;
                bone.getTweenData().copy(frameData);
                bone.changeDisplayWithIndex(frameData.displayIndex, false)
            } while (0)
        }
        this.update(0);
        this.updateOffsetPoint()
    } else {
        this.name = "new_armature";
        this.armatureData = new ccs.ArmatureData;
        this.armatureData.name = this.name;
        var animationData = new ccs.AnimationData;
        animationData.name = this.name;
        armatureDataManager.addArmatureData(this.name, this.armatureData);
        armatureDataManager.addAnimationData(this.name, animationData);
        this.animation.setAnimationData(animationData)
    }
    if (cc._renderType === cc._RENDER_TYPE_WEBGL)this.setShaderProgram(cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE_UCOLOR));
    this.setCascadeOpacityEnabled(true);
    this.setCascadeColorEnabled(true);
    return true
}, onEnter: function () {
    cc.NodeRGBA.prototype.onEnter.call(this);
    this.scheduleUpdate()
}, onExit: function () {
    cc.NodeRGBA.prototype.onExit.call(this);
    this.unscheduleUpdate()
}, createBone: function (boneName) {
    var existedBone = this.getBone(boneName);
    if (existedBone)return existedBone;
    var boneData = this.armatureData.getBoneData(boneName);
    var parentName = boneData.parentName;
    var bone = null;
    if (parentName != "") {
        this.createBone(parentName);
        bone = ccs.Bone.create(boneName);
        this.addBone(bone, parentName)
    } else {
        bone = ccs.Bone.create(boneName);
        this.addBone(bone, "")
    }
    bone.setBoneData(boneData);
    bone.getDisplayManager().changeDisplayWithIndex(-1, false);
    return bone
}, addBone: function (bone, parentName) {
    if (!bone) {
        cc.log("Argument must be non-nil");
        return
    }
    if (this._boneDic[bone.getName()]) {
        cc.log("bone already added. It can't be added again");
        return
    }
    if (parentName) {
        var boneParent = this._boneDic[parentName];
        if (boneParent)boneParent.addChildBone(bone); else this._topBoneList.push(bone)
    } else this._topBoneList.push(bone);
    bone.setArmature(this);
    this._boneDic[bone.getName()] = bone;
    this.addChild(bone)
}, removeBone: function (bone, recursion) {
    if (!bone) {
        cc.log("bone must be added to the bone dictionary!");
        return
    }
    bone.setArmature(null);
    bone.removeFromParent(recursion);
    cc.arrayRemoveObject(this._topBoneList, bone);
    delete this._boneDic[bone.getName()];
    this.removeChild(bone, true)
}, getBone: function (name) {
    return this._boneDic[name]
}, changeBoneParent: function (bone, parentName) {
    if (!bone) {
        cc.log("bone must be added to the bone dictionary!");
        return
    }
    var parentBone = bone.getParentBone();
    if (parentBone) {
        cc.arrayRemoveObject(parentBone.getChildrenBone(),
            bone);
        bone.setParentBone(null)
    }
    if (parentName) {
        var boneParent = this._boneDic[parentName];
        if (boneParent) {
            boneParent.addChildBone(bone);
            cc.arrayRemoveObject(this._topBoneList, bone)
        } else this._topBoneList.push(bone)
    }
}, getBoneDic: function () {
    return this._boneDic
}, updateOffsetPoint: function () {
    var rect = this.boundingBox();
    this.setContentSize(rect);
    var locOffsetPoint = this._offsetPoint;
    locOffsetPoint.x = -rect.x;
    locOffsetPoint.y = -rect.y;
    if (rect.width != 0 && rect.height != 0)this.setAnchorPoint(locOffsetPoint.x / rect.width,
            locOffsetPoint.y / rect.height)
}, update: function (dt) {
    this.animation.update(dt);
    var locTopBoneList = this._topBoneList;
    for (var i = 0; i < locTopBoneList.length; i++)locTopBoneList[i].update(dt);
    this._armatureTransformDirty = false
}, nodeToParentTransform: null, _nodeToParentTransformForWebGL: function () {
    if (this._transformDirty) {
        this._armatureTransformDirty = true;
        var x = this._position.x;
        var y = this._position.y;
        var apx = this._anchorPointInPoints.x, napx = -apx;
        var apy = this._anchorPointInPoints.y, napy = -apy;
        var scx = this._scaleX,
            scy = this._scaleY;
        if (this._ignoreAnchorPointForPosition) {
            x += apx;
            y += apy
        }
        var cx = 1, sx = 0, cy = 1, sy = 0;
        if (this._rotationX !== 0 || this._rotationY !== 0) {
            cx = Math.cos(-this._rotationRadiansX);
            sx = Math.sin(-this._rotationRadiansX);
            cy = Math.cos(-this._rotationRadiansY);
            sy = Math.sin(-this._rotationRadiansY)
        }
        x += cy * this._offsetPoint.x * this._scaleX + -sx * this._offsetPoint.y * this._scaleY;
        y += sy * this._offsetPoint.x * this._scaleX + cx * this._offsetPoint.y * this._scaleY;
        var needsSkewMatrix = this._skewX || this._skewY;
        if (!needsSkewMatrix &&
            (apx !== 0 || apy !== 0)) {
            x += cy * napx * scx + -sx * napy * scy;
            y += sy * napx * scx + cx * napy * scy
        }
        var t = {a: cy * scx, b: sy * scx, c: -sx * scy, d: cx * scy, tx: x, ty: y};
        if (needsSkewMatrix) {
            t = cc.AffineTransformConcat({a: 1, b: Math.tan(cc.degreesToRadians(this._skewY)), c: Math.tan(cc.degreesToRadians(this._skewX)), d: 1, tx: 0, ty: 0}, t);
            if (apx !== 0 || apy !== 0)t = cc.AffineTransformTranslate(t, napx, napy)
        }
        if (this._additionalTransformDirty) {
            t = cc.AffineTransformConcat(t, this._additionalTransform);
            this._additionalTransformDirty = false
        }
        this._transform = t;
        this._transformDirty =
            false
    }
    return this._transform
}, _nodeToParentTransformForCanvas: function () {
    if (!this._transform)this._transform = {a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0};
    if (this._transformDirty) {
        this._armatureTransformDirty = true;
        var t = this._transform;
        t.tx = this._position.x;
        t.ty = this._position.y;
        var Cos = 1, Sin = 0;
        if (this._rotationX) {
            Cos = Math.cos(-this._rotationRadiansX);
            Sin = Math.sin(-this._rotationRadiansX)
        }
        t.a = t.d = Cos;
        t.c = -Sin;
        t.b = Sin;
        var lScaleX = this._scaleX, lScaleY = this._scaleY;
        var appX = this._anchorPointInPoints.x, appY = this._anchorPointInPoints.y;
        var sx = lScaleX < 1E-6 && lScaleX > -1E-6 ? 1E-6 : lScaleX, sy = lScaleY < 1E-6 && lScaleY > -1E-6 ? 1E-6 : lScaleY;
        t.tx += Cos * this._offsetPoint.x * lScaleX + -Sin * this._offsetPoint.y * lScaleY;
        t.ty += Sin * this._offsetPoint.x * lScaleX + Cos * this._offsetPoint.y * lScaleY;
        if (this._skewX || this._skewY) {
            var skx = Math.tan(-this._skewX * Math.PI / 180);
            var sky = Math.tan(-this._skewY * Math.PI / 180);
            var xx = appY * skx * sx;
            var yy = appX * sky * sy;
            t.a = Cos + -Sin * sky;
            t.c = Cos * skx + -Sin;
            t.b = Sin + Cos * sky;
            t.d = Sin * skx + Cos;
            t.tx += Cos * xx + -Sin * yy;
            t.ty += Sin * xx + Cos * yy
        }
        if (lScaleX !==
            1 || lScaleY !== 1) {
            t.a *= sx;
            t.b *= sx;
            t.c *= sy;
            t.d *= sy
        }
        t.tx += Cos * -appX * sx + -Sin * -appY * sy;
        t.ty += Sin * -appX * sx + Cos * -appY * sy;
        if (this._ignoreAnchorPointForPosition) {
            t.tx += appX;
            t.ty += appY
        }
        if (this._additionalTransformDirty) {
            this._transform = cc.AffineTransformConcat(this._transform, this._additionalTransform);
            this._additionalTransformDirty = false
        }
        t.tx = t.tx | 0;
        t.ty = t.ty | 0;
        this._transformDirty = false
    }
    return this._transform
}, draw: function () {
}, setBlendFunc: function (blendFunc) {
    this._blendFunc = blendFunc
}, getBlendFunc: function () {
    return this._blendFunc
},
    boundingBox: function () {
        var minx = 0, miny = 0, maxx = 0, maxy = 0;
        var first = true;
        var boundingBox = cc.rect(0, 0, 0, 0);
        for (var i = 0; i < this._children.length; i++) {
            var bone = this._children[i];
            if (bone instanceof ccs.Bone) {
                var r = bone.getDisplayManager().getBoundingBox();
                if (first) {
                    minx = cc.rectGetMinX(r);
                    miny = cc.rectGetMinY(r);
                    maxx = cc.rectGetMaxX(r);
                    maxy = cc.rectGetMaxY(r);
                    first = false
                } else {
                    minx = cc.rectGetMinX(r) < cc.rectGetMinX(boundingBox) ? cc.rectGetMinX(r) : cc.rectGetMinX(boundingBox);
                    miny = cc.rectGetMinY(r) < cc.rectGetMinY(boundingBox) ?
                        cc.rectGetMinY(r) : cc.rectGetMinY(boundingBox);
                    maxx = cc.rectGetMaxX(r) > cc.rectGetMaxX(boundingBox) ? cc.rectGetMaxX(r) : cc.rectGetMaxX(boundingBox);
                    maxy = cc.rectGetMaxY(r) > cc.rectGetMaxY(boundingBox) ? cc.rectGetMaxY(r) : cc.rectGetMaxY(boundingBox)
                }
                boundingBox = cc.rect(minx, miny, maxx - minx, maxy - miny)
            }
        }
        return cc.RectApplyAffineTransform(boundingBox, this.nodeToParentTransform())
    }, getBoneAtPoint: function (x, y) {
        for (var i = this._children.length - 1; i >= 0; i--) {
            var child = this._children[i];
            if (child instanceof ccs.Bone)if (child.getDisplayManager().containPoint(x,
                y))return child
        }
        return null
    }, getTexureAtlasWithTexture: function () {
        return null
    }, setParentBone: function (parentBone) {
        this._parentBone = parentBone;
        for (var key in this._boneDic) {
            var bone = this._boneDic[key];
            bone.setArmature(this)
        }
    }, setColliderFilter: function (filter) {
        for (var key in this._boneDic) {
            var bone = this._boneDic[key];
            bone.setColliderFilter(filter)
        }
    }, drawContour: function () {
        cc._drawingUtil.setDrawColor(255, 255, 255, 255);
        cc._drawingUtil.setLineWidth(1);
        for (var key in this._boneDic) {
            var bone = this._boneDic[key];
            var bodyList = bone.getColliderBodyList();
            for (var i = 0; i < bodyList.length; i++) {
                var body = bodyList[i];
                var vertexList = body.getCalculatedVertexList();
                cc._drawingUtil.drawPoly(vertexList, vertexList.length, true)
            }
        }
    }, getParentBone: function () {
        return this._parentBone
    }, getAnimation: function () {
        return this.animation
    }, setAnimation: function (animation) {
        this.animation = animation
    }, getArmatureData: function () {
        return this.armatureData
    }, setArmatureData: function (armatureData) {
        this.armatureData = armatureData
    }, getName: function () {
        return this.name
    },
    setName: function (name) {
        this.name = name
    }, getBatchNode: function () {
        return this.batchNode
    }, setBatchNode: function (batchNode) {
        this.batchNode = batchNode
    }, getVersion: function () {
        return this.version
    }, setVersion: function (version) {
        this.version = version
    }, getArmatureTransformDirty: function () {
        return this._armatureTransformDirty
    }, getBody: function () {
        return this._body
    }, setBody: function (body) {
        if (this._body == body)return;
        this._body = body;
        this._body.data = this;
        var child, displayObject;
        for (var i = 0; i < this._children.length; i++) {
            child =
                this._children[i];
            if (child instanceof ccs.Bone) {
                var displayList = child.getDisplayManager().getDecorativeDisplayList();
                for (var j = 0; j < displayList.length; j++) {
                    displayObject = displayList[j];
                    var detector = displayObject.getColliderDetector();
                    if (detector)detector.setBody(this._body)
                }
            }
        }
    }, getShapeList: function () {
        if (this._body)return this._body.shapeList;
        return[]
    }});
if (cc._renderType == cc._RENDER_TYPE_WEBGL)ccs.Armature.prototype.nodeToParentTransform = ccs.Armature.prototype._nodeToParentTransformForWebGL; else ccs.Armature.prototype.nodeToParentTransform = ccs.Armature.prototype._nodeToParentTransformForCanvas;
var _p = ccs.Armature.prototype;
_p.parentBone;
cc.defineGetterSetter(_p, "parentBone", _p.getParentBone, _p.setParentBone);
_p.body;
cc.defineGetterSetter(_p, "body", _p.getBody, _p.setBody);
_p.colliderFilter;
cc.defineGetterSetter(_p, "colliderFilter", null, _p.setColliderFilter);
_p = null;
ccs.Armature.create = function (name, parentBone) {
    var armature = new ccs.Armature;
    if (armature && armature.init(name, parentBone))return armature;
    return null
};
ccs.Bone = ccs.NodeRGBA.extend({_boneData: null, _armature: null, _childArmature: null, displayManager: null, ignoreMovementBoneData: false, _tween: null, _tweenData: null, name: "", _childrenBone: null, parentBone: null, boneTransformDirty: false, _worldTransform: null, _blendFunc: 0, blendDirty: false, _worldInfo: null, _armatureParentBone: null, _dataVersion: 0, _className: "Bone", ctor: function () {
    cc.NodeRGBA.prototype.ctor.call(this);
    this._boneData = null;
    this._armature = null;
    this._childArmature = null;
    this.displayManager = null;
    this.ignoreMovementBoneData =
        false;
    this._tween = null;
    this._tweenData = null;
    this.name = "";
    this._childrenBone = [];
    this.parentBone = null;
    this.boneTransformDirty = true;
    this._worldTransform = cc.AffineTransformMake(1, 0, 0, 1, 0, 0);
    this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
    this.blendDirty = false
}, release: function () {
    CC_SAFE_RELEASE(this._tweenData);
    for (var i = 0; i < this._childrenBone.length; i++)CC_SAFE_RELEASE(this._childrenBone[i]);
    this._childrenBone = [];
    CC_SAFE_RELEASE(this._tween);
    CC_SAFE_RELEASE(this.displayManager);
    CC_SAFE_RELEASE(this._boneData);
    CC_SAFE_RELEASE(this._childArmature)
}, init: function (name) {
    cc.NodeRGBA.prototype.init.call(this);
    if (name)this.name = name;
    this._tweenData = new ccs.FrameData;
    this._tween = new ccs.Tween;
    this._tween.init(this);
    this.displayManager = new ccs.DisplayManager;
    this.displayManager.init(this);
    this._worldInfo = new ccs.BaseData;
    this._boneData = new ccs.BaseData;
    return true
}, setBoneData: function (boneData) {
    if (!boneData) {
        cc.log("boneData must not be null");
        return
    }
    this._boneData = boneData;
    this.name = this._boneData.name;
    this.setLocalZOrder(this._boneData.zOrder);
    this.displayManager.initDisplayList(boneData)
}, getBoneData: function () {
    return this._boneData
}, setArmature: function (armature) {
    this._armature = armature;
    if (armature) {
        this._tween.setAnimation(this._armature.getAnimation());
        this._dataVersion = this._armature.getArmatureData().dataVersion;
        this._armatureParentBone = this._armature.getParentBone()
    } else this._armatureParentBone = null
}, getArmature: function () {
    return this._armature
}, update: function (dt) {
    var locParentBone = this.parentBone;
    var locArmature = this._armature;
    var locTweenData = this._tweenData;
    var locWorldTransform = this._worldTransform;
    var locWorldInfo = this._worldInfo;
    var locArmatureParentBone = this._armatureParentBone;
    if (locParentBone)this.boneTransformDirty = this.boneTransformDirty || locParentBone.isTransformDirty();
    if (locArmatureParentBone && !this.boneTransformDirty)this.boneTransformDirty = locArmatureParentBone.isTransformDirty();
    if (this.boneTransformDirty) {
        if (this._dataVersion >= ccs.CONST_VERSION_COMBINED) {
            var locBoneData = this._boneData;
            locTweenData.x += locBoneData.x;
            locTweenData.y += locBoneData.y;
            locTweenData.skewX += locBoneData.skewX;
            locTweenData.skewY += locBoneData.skewY;
            locTweenData.scaleX += locBoneData.scaleX;
            locTweenData.scaleY += locBoneData.scaleY;
            locTweenData.scaleX -= 1;
            locTweenData.scaleY -= 1
        }
        locWorldInfo.x = locTweenData.x + this._position.x;
        locWorldInfo.y = locTweenData.y + this._position.y;
        locWorldInfo.scaleX = locTweenData.scaleX * this._scaleX;
        locWorldInfo.scaleY = locTweenData.scaleY * this._scaleY;
        locWorldInfo.skewX = locTweenData.skewX + this._skewX + this._rotationX;
        locWorldInfo.skewY =
            locTweenData.skewY + this._skewY - this._rotationY;
        if (this.parentBone)this.applyParentTransform(this.parentBone); else if (locArmatureParentBone)this.applyParentTransform(locArmatureParentBone);
        ccs.TransformHelp.nodeToMatrix(locWorldInfo, locWorldTransform);
        if (locArmatureParentBone)this._worldTransform = cc.AffineTransformConcat(locWorldTransform, locArmature.nodeToParentTransform())
    }
    ccs.DisplayFactory.updateDisplay(this, dt, this.boneTransformDirty || locArmature.getArmatureTransformDirty());
    var locChildrenBone =
        this._childrenBone;
    for (var i = 0; i < locChildrenBone.length; i++)locChildrenBone[i].update(dt);
    this.boneTransformDirty = false
}, applyParentTransform: function (parent) {
    var locWorldInfo = this._worldInfo;
    var locParentWorldTransform = parent._worldTransform;
    var locParentWorldInfo = parent._worldInfo;
    var x = locWorldInfo.x;
    var y = locWorldInfo.y;
    locWorldInfo.x = x * locParentWorldTransform.a + y * locParentWorldTransform.c + locParentWorldInfo.x;
    locWorldInfo.y = x * locParentWorldTransform.b + y * locParentWorldTransform.d + locParentWorldInfo.y;
    locWorldInfo.scaleX = locWorldInfo.scaleX * locParentWorldInfo.scaleX;
    locWorldInfo.scaleY = locWorldInfo.scaleY * locParentWorldInfo.scaleY;
    locWorldInfo.skewX = locWorldInfo.skewX + locParentWorldInfo.skewX;
    locWorldInfo.skewY = locWorldInfo.skewY + locParentWorldInfo.skewY
}, visit: function (ctx) {
    if (!this._visible)return;
    var node = this.getDisplayManager().getDisplayRenderNode();
    if (node)node.visit(ctx)
}, updateDisplayedColor: function (color) {
    this._realColor = cc.color(255, 255, 255);
    cc.NodeRGBA.prototype.updateDisplayedColor.call(this,
        color);
    this.updateColor()
}, updateDisplayedOpacity: function (opacity) {
    this._realOpacity = 255;
    cc.NodeRGBA.prototype.updateDisplayedOpacity.call(this, opacity);
    this.updateColor()
}, setColor: function (color) {
    cc.NodeRGBA.prototype.setColor.call(this, color);
    this.updateColor()
}, setOpacity: function (opacity) {
    cc.NodeRGBA.prototype.setOpacity.call(this, opacity);
    this.updateColor()
}, updateColor: function () {
    var display = this.displayManager.getDisplayRenderNode();
    if (display && display.RGBAProtocol) {
        var locDisplayedColor =
            this._displayedColor;
        var locTweenData = this._tweenData;
        var locOpacity = this._displayedOpacity * locTweenData.a / 255;
        var locColor = cc.color(locDisplayedColor.r * locTweenData.r / 255, locDisplayedColor.g * locTweenData.g / 255, locDisplayedColor.b * locTweenData.b / 255);
        display.setOpacity(locOpacity);
        display.setColor(locColor)
    }
}, updateZOrder: function () {
    if (this._armature.getArmatureData().dataVersion >= ccs.CONST_VERSION_COMBINED) {
        var zorder = this._tweenData.zOrder + this._boneData.zOrder;
        this.setLocalZOrder(zorder)
    } else this.setLocalZOrder(this._tweenData.zOrder)
},
    addChildBone: function (child) {
        if (!child) {
            cc.log("Argument must be non-nil");
            return
        }
        if (child.parentBone) {
            cc.log("child already added. It can't be added again");
            return
        }
        if (this._childrenBone.indexOf(child) < 0) {
            this._childrenBone.push(child);
            child.setParentBone(this)
        }
    }, removeChildBone: function (bone, recursion) {
        for (var i = 0; i < this._childrenBone.length; i++)if (this._childrenBone[i] == bone) {
            if (recursion) {
                var ccbones = bone._childrenBone;
                for (var j = 0; j < ccbones.length; j++)bone.removeChildBone(ccbones[j], recursion)
            }
            bone.setParentBone(null);
            bone.displayManager.setCurrentDecorativeDisplay(null);
            cc.arrayRemoveObject(this._childrenBone, bone)
        }
    }, removeFromParent: function (recursion) {
        if (this.parentBone)this.parentBone.removeChildBone(this, recursion)
    }, setParentBone: function (parent) {
        this.parentBone = parent
    }, getParentBone: function () {
        return this.parentBone
    }, setChildArmature: function (armature) {
        if (this._childArmature != armature) {
            if (armature == null && this._childArmature)this._childArmature.setParentBone(null);
            this._childArmature = armature
        }
    }, getChildArmature: function () {
        return this._childArmature
    },
    getChildrenBone: function () {
        return this._childrenBone
    }, getTween: function () {
        return this._tween
    }, setLocalZOrder: function (zOrder) {
        if (this._zOrder != zOrder)cc.Node.prototype.setLocalZOrder.call(this, zOrder)
    }, setTransformDirty: function (dirty) {
        this.boneTransformDirty = dirty
    }, isTransformDirty: function () {
        return this.boneTransformDirty
    }, nodeToArmatureTransform: function () {
        return this._worldTransform
    }, nodeToWorldTransform: function () {
        return cc.AffineTransformConcat(this._worldTransform, this._armature.nodeToWorldTransform())
    },
    getDisplayRenderNode: function () {
        return this.displayManager.getDisplayRenderNode()
    }, getDisplayRenderNodeType: function () {
        return this.displayManager.getDisplayRenderNodeType()
    }, addDisplay: function (displayData, index) {
        index = index || 0;
        return this.displayManager.addDisplay(displayData, index)
    }, removeDisplay: function (index) {
        this.displayManager.removeDisplay(index)
    }, addSkin: function (skin, index) {
        index = index || 0;
        return this.displayManager.addSkin(skin, index)
    }, changeDisplayByIndex: function (index, force) {
        cc.log("changeDisplayByIndex is deprecated. Use changeDisplayWithIndex instead.");
        this.changeDisplayWithIndex(index, force)
    }, changeDisplayWithIndex: function (index, force) {
        this.displayManager.changeDisplayWithIndex(index, force)
    }, changeDisplayWithName: function (name, force) {
        this.displayManager.changeDisplayWithName(name, force)
    }, getColliderBodyList: function () {
        var decoDisplay = this.displayManager.getCurrentDecorativeDisplay();
        if (decoDisplay) {
            var detector = decoDisplay.getColliderDetector();
            if (detector)return detector.getColliderBodyList()
        }
        return[]
    }, setColliderFilter: function (filter) {
        var displayList =
            this.displayManager.getDecorativeDisplayList();
        for (var i = 0; i < displayList.length; i++) {
            var locDecoDisplay = displayList[i];
            var locDetector = locDecoDisplay.getColliderDetector();
            if (locDetector)locDetector.setColliderFilter(filter)
        }
    }, getColliderFilter: function () {
        var decoDisplay = this.displayManager.getCurrentDecorativeDisplay();
        if (decoDisplay) {
            var detector = decoDisplay.getColliderDetector();
            if (detector)return detector.getColliderFilter()
        }
        return null
    }, setDisplayManager: function (displayManager) {
        this.displayManager =
            displayManager
    }, getDisplayManager: function () {
        return this.displayManager
    }, setIgnoreMovementBoneData: function (bool) {
        this.ignoreMovementBoneData = bool
    }, getIgnoreMovementBoneData: function () {
        return this.ignoreMovementBoneData
    }, getTweenData: function () {
        return this._tweenData
    }, setName: function (name) {
        this.name = name
    }, getName: function () {
        return this.name
    }, setBlendFunc: function (blendFunc) {
        if (this._blendFunc.src != blendFunc.src || this._blendFunc.dst != blendFunc.dst) {
            this._blendFunc = blendFunc;
            this.blendDirty = true
        }
    },
    getBlendFunc: function () {
        return this._blendFunc
    }, setBlendDirty: function (dirty) {
        this.blendDirty = dirty
    }, isBlendDirty: function () {
        return this.blendDirty
    }});
var _p = ccs.Bone.prototype;
_p.boneData;
cc.defineGetterSetter(_p, "boneData", _p.getBoneData, _p.setBoneData);
_p.armature;
cc.defineGetterSetter(_p, "armature", _p.getArmature, _p.setArmature);
_p.childArmature;
cc.defineGetterSetter(_p, "childArmature", _p.getChildArmature, _p.setChildArmature);
_p.childrenBone;
cc.defineGetterSetter(_p, "childrenBone", _p.getChildrenBone);
_p.tween;
cc.defineGetterSetter(_p, "tween", _p.getTween);
_p.tweenData;
cc.defineGetterSetter(_p, "tweenData", _p.getTweenData);
_p.colliderFilter;
cc.defineGetterSetter(_p, "colliderFilter", _p.getColliderFilter, _p.setColliderFilter);
_p = null;
ccs.Bone.create = function (name) {
    var bone = new ccs.Bone;
    if (bone && bone.init(name))return bone;
    return null
};
ccs.FRAME_TYPE_MOVE = 0;
ccs.FRAME_TYPE_SCALE = 1;
ccs.FRAME_TYPE_ROTATE = 2;
ccs.FRAME_TYPE_TINT = 3;
ccs.FRAME_TYPE_FADE = 4;
ccs.FRAME_TYPE_MAX = 5;
ccs.FrameEaseType = {Custom: -1, Linear: 0, Sine_EaseIn: 1, Sine_EaseOut: 2, Sine_EaseInOut: 3, Quad_EaseIn: 4, Quad_EaseOut: 5, Quad_EaseInOut: 6, Cubic_EaseIn: 7, Cubic_EaseOut: 8, Cubic_EaseInOut: 9, Quart_EaseIn: 10, Quart_EaseOut: 11, Quart_EaseInOut: 12, Quint_EaseIn: 13, Quint_EaseOut: 14, Quint_EaseInOut: 15, Expo_EaseIn: 16, Expo_EaseOut: 17, Expo_EaseInOut: 18, Circ_EaseIn: 19, Circ_EaseOut: 20, Circ_EaseInOut: 21, Elastic_EaesIn: 22, Elastic_EaesOut: 23, Elastic_EaesInOut: 24, Back_EaseIn: 25, Back_EaseOut: 26, Back_EaseInOut: 27, Bounce_EaseIn: 28,
    Bounce_EaseOut: 29, Bounce_EaseInOut: 30};
ccs.ActionFrame = ccs.Class.extend({frameType: 0, easingType: 0, frameIndex: 0, frameTweenParameter: null, time: 0, ctor: function () {
    this.frameType = 0;
    this.easingType = 0;
    this.frameIndex = 0;
    this.time = 0
}, getAction: function (duration) {
    return null
}, _getEasingAction: function (action) {
    if (action === null) {
        console.error("Action cannot be null!");
        return null
    }
    var resultAction;
    switch (this.easingType) {
        case ccs.FrameEaseType.Custom:
            break;
        case ccs.FrameEaseType.Linear:
            resultAction = action;
            break;
        case ccs.FrameEaseType.Sine_EaseIn:
            resultAction =
                action.easing(cc.easeSineIn());
            break;
        case ccs.FrameEaseType.Sine_EaseOut:
            resultAction = action.easing(cc.easeSineOut());
            break;
        case ccs.FrameEaseType.Sine_EaseInOut:
            resultAction = action.easing(cc.easeSineInOut());
            break;
        case ccs.FrameEaseType.Quad_EaseIn:
            resultAction = action.easing(cc.easeQuadraticActionIn());
            break;
        case ccs.FrameEaseType.Quad_EaseOut:
            resultAction = action.easing(cc.easeQuadraticActionOut());
            break;
        case ccs.FrameEaseType.Quad_EaseInOut:
            resultAction = action.easing(cc.easeQuadraticActionInOut());
            break;
        case ccs.FrameEaseType.Cubic_EaseIn:
            resultAction = action.easing(cc.easeCubicActionIn());
            break;
        case ccs.FrameEaseType.Cubic_EaseOut:
            resultAction = action.easing(cc.easeCubicActionOut());
            break;
        case ccs.FrameEaseType.Cubic_EaseInOut:
            resultAction = action.easing(cc.easeCubicActionInOut());
            break;
        case ccs.FrameEaseType.Quart_EaseIn:
            resultAction = action.easing(cc.easeQuarticActionIn());
            break;
        case ccs.FrameEaseType.Quart_EaseOut:
            resultAction = action.easing(cc.easeQuarticActionOut());
            break;
        case ccs.FrameEaseType.Quart_EaseInOut:
            resultAction =
                action.easing(cc.easeQuarticActionInOut());
            break;
        case ccs.FrameEaseType.Quint_EaseIn:
            resultAction = action.easing(cc.easeQuinticActionIn());
            break;
        case ccs.FrameEaseType.Quint_EaseOut:
            resultAction = action.easing(cc.easeQuinticActionOut());
            break;
        case ccs.FrameEaseType.Quint_EaseInOut:
            resultAction = action.easing(cc.easeQuinticActionInOut());
            break;
        case ccs.FrameEaseType.Expo_EaseIn:
            resultAction = action.easing(cc.easeExponentialIn());
            break;
        case ccs.FrameEaseType.Expo_EaseOut:
            resultAction = action.easing(cc.easeExponentialOut());
            break;
        case ccs.FrameEaseType.Expo_EaseInOut:
            resultAction = action.easing(cc.easeExponentialInOut());
            break;
        case ccs.FrameEaseType.Circ_EaseIn:
            resultAction = action.easing(cc.easeCircleActionIn());
            break;
        case ccs.FrameEaseType.Circ_EaseOut:
            resultAction = action.easing(cc.easeCircleActionOut());
            break;
        case ccs.FrameEaseType.Circ_EaseInOut:
            resultAction = action.easing(cc.easeCircleActionInOut());
            break;
        case ccs.FrameEaseType.Elastic_EaesIn:
            resultAction = action.easing(cc.easeElasticIn());
            break;
        case ccs.FrameEaseType.Elastic_EaesOut:
            resultAction =
                action.easing(cc.easeElasticOut());
            break;
        case ccs.FrameEaseType.Elastic_EaesInOut:
            resultAction = action.easing(cc.easeElasticInOut());
            break;
        case ccs.FrameEaseType.Back_EaseIn:
            resultAction = action.easing(cc.easeBackIn());
            break;
        case ccs.FrameEaseType.Back_EaseOut:
            resultAction = action.easing(cc.easeBackOut());
            break;
        case ccs.FrameEaseType.Back_EaseInOut:
            resultAction = action.easing(cc.easeBackInOut());
            break;
        case ccs.FrameEaseType.Bounce_EaseIn:
            resultAction = action.easing(cc.easeBounceIn());
            break;
        case ccs.FrameEaseType.Bounce_EaseOut:
            resultAction =
                action.easing(cc.easeBounceOut());
            break;
        case ccs.FrameEaseType.Bounce_EaseInOut:
            resultAction = action.easing(cc.easeBounceInOut());
            break
    }
    return resultAction
}, setEasingParameter: function (parameter) {
    this._Parameter = [];
    for (var i = 0; i < parameter.length; i++)this._Parameter.push(parameter[i])
}, setEasingType: function (easingType) {
    this._easingType = easingType
}});
ccs.ActionMoveFrame = ccs.ActionFrame.extend({_position: null, ctor: function () {
    ccs.ActionFrame.prototype.ctor.call(this);
    this._position = cc.p(0, 0);
    this.frameType = ccs.FRAME_TYPE_MOVE
}, setPosition: function (pos, y) {
    if (y === undefined) {
        this._position.x = pos.x;
        this._position.y = pos.y
    } else {
        this._position.x = pos;
        this._position.y = y
    }
}, getPosition: function () {
    return this._position
}, getAction: function (duration) {
    var action = cc.MoveTo.create(duration, this._position);
    action.easingType = this.easingType || ccs.FrameEaseType.Linear;
    return this._getEasingAction(action)
}});
ccs.ActionScaleFrame = ccs.ActionFrame.extend({_scaleX: 1, _scaleY: 1, ctor: function () {
    ccs.ActionFrame.prototype.ctor.call(this);
    this._scaleX = 1;
    this._scaleY = 1;
    this.frameType = ccs.FRAME_TYPE_SCALE
}, setScaleX: function (scaleX) {
    this._scaleX = scaleX
}, getScaleX: function () {
    return this._scaleX
}, setScaleY: function (scaleY) {
    this._scaleY = scaleY
}, getScaleY: function () {
    return this._scaleY
}, getAction: function (duration) {
    var action = cc.ScaleTo.create(duration, this._scaleX, this._scaleY);
    action.easingType = this.easingType || ccs.FrameEaseType.Linear;
    return this._getEasingAction(action)
}});
ccs.ActionRotationFrame = ccs.ActionFrame.extend({_rotation: 0, ctor: function () {
    ccs.ActionFrame.prototype.ctor.call(this);
    this._rotation = 0;
    this.frameType = ccs.FRAME_TYPE_ROTATE
}, setRotation: function (rotation) {
    this._rotation = rotation
}, getRotation: function () {
    return this._rotation
}, getAction: function (duration) {
    var action = cc.RotateTo.create(duration, this._rotation);
    action.easingType = this.easingType || ccs.FrameEaseType.Linear;
    return this._getEasingAction(action)
}});
ccs.ActionFadeFrame = ccs.ActionFrame.extend({_opacity: 255, ctor: function () {
    ccs.ActionFrame.prototype.ctor.call(this);
    this._opacity = 255;
    this.frameType = ccs.FRAME_TYPE_FADE
}, setOpacity: function (opacity) {
    this._opacity = opacity
}, getOpacity: function () {
    return this._opacity
}, getAction: function (duration) {
    var action = cc.FadeTo.create(duration, this._opacity);
    action.easingType = this.easingType || ccs.FrameEaseType.Linear;
    return this._getEasingAction(action)
}});
ccs.ActionTintFrame = ccs.ActionFrame.extend({_color: null, ctor: function () {
    ccs.ActionFrame.prototype.ctor.call(this);
    this._color = cc.color(255, 255, 255, 255);
    this.frameType = ccs.FRAME_TYPE_TINT
}, setColor: function (color) {
    var locColor = this._color;
    locColor.r = color.r;
    locColor.g = color.g;
    locColor.b = color.b
}, getColor: function () {
    var locColor = this._color;
    return cc.color(locColor.r, locColor.g, locColor.b, locColor.a)
}, getAction: function (duration) {
    var action = cc.TintTo.create(duration, this._color.r, this._color.g, this._color.b);
    action.easingType = this.easingType || ccs.FrameEaseType.Linear;
    return this._getEasingAction(action)
}});
ccs.actionManager = {_actionDic: {}, initWithDictionary: function (jsonName, dic, root) {
    var path = jsonName;
    var pos = path.lastIndexOf("/");
    var fileName = path.substr(pos + 1, path.length);
    var actionList = dic["actionlist"];
    var locActionList = [];
    for (var i = 0; i < actionList.length; i++) {
        var locAction = new ccs.ActionObject;
        var locActionDic = actionList[i];
        locAction.initWithDictionary(locActionDic, root);
        locActionList.push(locAction)
    }
    this._actionDic[fileName] = locActionList
}, getActionByName: function (jsonName, actionName) {
    var actionList =
        this._actionDic[jsonName];
    if (!actionList)return null;
    for (var i = 0; i < actionList.length; i++) {
        var locAction = actionList[i];
        if (actionName == locAction.getName())return locAction
    }
    return null
}, playActionByName: function (jsonName, actionName, fun) {
    var action = this.getActionByName(jsonName, actionName);
    if (action)action.play(fun)
}, releaseActions: function () {
    this._actionDic = {}
}, clear: function () {
    this._actionDic = {}
}};
ccs.ActionNode = ccs.Class.extend({_currentFrameIndex: 0, _destFrameIndex: 0, _unitTime: 0, _actionTag: 0, _bject: null, _actionSpawn: null, _action: null, _frameArray: null, _frameArrayNum: 0, ctor: function () {
    this._currentFrameIndex = 0;
    this._destFrameIndex = 0;
    this._unitTime = 0.1;
    this._actionTag = 0;
    this._bject = null;
    this._actionSpawn = null;
    this._action = null;
    this._frameArray = [];
    this._frameArrayNum = ccs.FRAME_TYPE_MAX;
    for (var i = 0; i < this._frameArrayNum; i++)this._frameArray.push([])
}, initWithDictionary: function (dic, root) {
    this.setActionTag(dic["ActionTag"]);
    var actionframelist = dic["actionframelist"];
    for (var i = 0; i < actionframelist.length; i++) {
        var actionFrameDic = actionframelist[i];
        var frameInex = actionFrameDic["frameid"];
        var frameTweenType = actionFrameDic["tweenType"];
        var frameTweenParameterNum = actionFrameDic["tweenParameter"];
        var frameTweenParameter = [];
        for (var j = 0; j < frameTweenParameterNum; j++) {
            var value = actionFrameDic["tweenParameter"][j];
            frameTweenParameter.push(value)
        }
        if (actionFrameDic["positionx"] !== undefined) {
            var positionX = actionFrameDic["positionx"];
            var positionY = actionFrameDic["positiony"];
            var actionFrame = new ccs.ActionMoveFrame;
            actionFrame.setEasingType(frameTweenType);
            actionFrame.setEasingParameter(frameTweenParameter);
            actionFrame.setPosition(positionX, positionY);
            var actionArray = this._frameArray[ccs.FRAME_TYPE_MOVE];
            actionArray.push(actionFrame)
        }
        if (actionFrameDic["scalex"] !== undefined) {
            var scaleX = actionFrameDic["scalex"];
            var scaleY = actionFrameDic["scaley"];
            var actionFrame = new ccs.ActionScaleFrame;
            actionFrame.setEasingType(frameTweenType);
            actionFrame.setEasingParameter(frameTweenParameter);
            actionFrame.setScaleX(scaleX);
            actionFrame.setScaleY(scaleY);
            var actionArray = this._frameArray[ccs.FRAME_TYPE_SCALE];
            actionArray.push(actionFrame)
        }
        if (actionFrameDic["rotation"] !== undefined) {
            var rotation = actionFrameDic["rotation"];
            var actionFrame = new ccs.ActionRotationFrame;
            actionFrame.setEasingType(frameTweenType);
            actionFrame.setEasingParameter(frameTweenParameter);
            actionFrame.setRotation(rotation);
            var actionArray = this._frameArray[ccs.FRAME_TYPE_ROTATE];
            actionArray.push(actionFrame)
        }
        if (actionFrameDic["opacity"] !== undefined) {
            var opacity = actionFrameDic["opacity"];
            var actionFrame = new ccs.ActionFadeFrame;
            actionFrame.setEasingType(frameTweenType);
            actionFrame.setEasingParameter(frameTweenParameter);
            actionFrame.setOpacity(opacity);
            var actionArray = this._frameArray[ccs.FRAME_TYPE_FADE];
            actionArray.push(actionFrame)
        }
        if (actionFrameDic["colorr"] !== undefined) {
            var colorR = actionFrameDic["colorr"];
            var colorG = actionFrameDic["colorg"];
            var colorB = actionFrameDic["colorb"];
            var actionFrame = new ccs.ActionTintFrame;
            actionFrame.setEasingType(frameTweenType);
            actionFrame.setEasingParameter(frameTweenParameter);
            actionFrame.setColor(cc.color(colorR, colorG, colorB));
            var actionArray = this._frameArray[ccs.FRAME_TYPE_TINT];
            actionArray.push(actionFrame)
        }
        actionFrameDic = null
    }
    this.initActionNodeFromRoot(root)
}, initActionNodeFromRoot: function (root) {
    if (root instanceof ccui.Widget) {
        var widget = ccui.helper.seekActionWidgetByActionTag(root, this.getActionTag());
        if (widget)this.setObject(widget)
    }
},
    setUnitTime: function (time) {
        this._unitTime = time;
        this.refreshActionProperty()
    }, getUnitTime: function () {
        return this._unitTime
    }, setActionTag: function (tag) {
        this._actionTag = tag
    }, getActionTag: function () {
        return this._actionTag
    }, setObject: function (node) {
        this._object = node
    }, getObject: function () {
        return this._object
    }, getActionNode: function () {
        if (this._object instanceof cc.Node)return this._object; else if (this._object instanceof ccui.Widget)return this._object;
        return null
    }, insertFrame: function (index, frame) {
        if (frame ==
            null)return;
        var frameType = frame.frameType;
        var array = this._frameArray[frameType];
        array.splice(index, 0, frame)
    }, addFrame: function (frame) {
        if (!frame)return;
        var frameType = frame.frameType;
        var array = this._frameArray[frameType];
        array.push(frame)
    }, deleteFrame: function (frame) {
        if (frame == null)return;
        var frameType = frame.frameType;
        var array = this._frameArray[frameType];
        cc.arrayRemoveObject(array, frame)
    }, clearAllFrame: function () {
        for (var i = 0; i < this._frameArrayNum; i++)this._frameArray[i] = []
    }, refreshActionProperty: function () {
        if (this._object ==
            null)return null;
        var locSpawnArray = [];
        for (var i = 0; i < this._frameArrayNum; i++) {
            var locArray = this._frameArray[i];
            if (locArray.length <= 0)continue;
            var locSequenceArray = [];
            for (var j = 0; j < locArray.length; j++) {
                var locFrame = locArray[j];
                if (j != 0) {
                    var locSrcFrame = locArray[j - 1];
                    var locDuration = (locFrame.frameIndex - locSrcFrame.frameIndex) * this.getUnitTime();
                    var locAction = locFrame.getAction(locDuration);
                    if (locAction)locSequenceArray.push(locAction)
                }
            }
            if (locSequenceArray) {
                var locSequence = cc.Sequence.create(locSequenceArray);
                if (locSequence != null)locSpawnArray.push(locSequence)
            }
        }
        this._action = null;
        this._actionSpawn = cc.Spawn.create(locSpawnArray);
        return this._actionSpawn
    }, playAction: function (fun) {
        if (this._object == null || this._actionSpawn == null)return;
        if (fun)this._action = cc.Sequence.create(this._actionSpawn, fun); else this._action = cc.Sequence.create(this._actionSpawn);
        this.runAction()
    }, runAction: function () {
        var node = this.getActionNode();
        if (node != null && this._action != null)node.runAction(this._action)
    }, stopAction: function () {
        var node =
            this.getActionNode();
        if (node != null && this._action != null)if (!this._action.isDone())node.stopAction(this._action)
    }, getFirstFrameIndex: function () {
        var locFrameindex = 99999;
        var locIsFindFrame = false;
        for (var i = 0; i < this._frameArrayNum; i++) {
            var locArray = this._frameArray[i];
            if (locArray.length <= 0)continue;
            locIsFindFrame = true;
            var locFrame = locArray[0];
            var locFrameIndex = locFrame.frameIndex;
            locFrameindex = locFrameindex > locFrameIndex ? locFrameIndex : locFrameindex
        }
        if (!locIsFindFrame)locFrameindex = 0;
        return locFrameindex
    },
    getLastFrameIndex: function () {
        var locFrameindex = -1;
        var locIsFindFrame = false;
        for (var i = 0; i < this._frameArrayNum; i++) {
            var locArray = this._frameArray[i];
            if (locArray.length <= 0)continue;
            locIsFindFrame = true;
            var locFrame = locArray[locArray.length - 1];
            var locFrameIndex = locFrame.frameIndex;
            locFrameindex = locFrameindex < locFrameIndex ? locFrameIndex : locFrameindex
        }
        if (!locIsFindFrame)locFrameindex = 0;
        return locFrameindex
    }, updateActionToTimeLine: function (time) {
        var locIsFindFrame = false;
        var locUnitTime = this.getUnitTime();
        for (var i = 0; i < this._frameArrayNum; i++) {
            var locArray = this._frameArray[i];
            if (locArray == null)continue;
            for (var j = 0; j < locArray.length; j++) {
                var locFrame = locArray[j];
                if (locFrame.frameIndex * locUnitTime == time) {
                    this.easingToFrame(1, 1, locFrame);
                    locIsFindFrame = true;
                    break
                } else if (locFrame.frameIndex * locUnitTime > time) {
                    if (j == 0) {
                        this.easingToFrame(1, 1, locFrame);
                        locIsFindFrame = false
                    } else {
                        var locSrcFrame = locArray[j - 1];
                        var locDuration = (locFrame.frameIndex - locSrcFrame.frameIndex) * locUnitTime;
                        var locDelaytime = time - locSrcFrame.frameIndex *
                            locUnitTime;
                        this.easingToFrame(locDuration, 1, locSrcFrame);
                        this.easingToFrame(locDuration, locDelaytime / locDuration, locFrame);
                        locIsFindFrame = true
                    }
                    break
                }
            }
        }
        return locIsFindFrame
    }, easingToFrame: function (duration, delayTime, destFrame) {
        var action = destFrame.getAction(duration);
        var node = this.getActionNode();
        if (action == null || node == null)return;
        action.startWithTarget(node);
        action.update(delayTime)
    }, isActionDoneOnce: function () {
        if (this._action == null)return true;
        return this._action.isDone()
    }});
ccs.ActionObject = ccs.Class.extend({_actionNodeList: null, _name: "", _loop: false, _pause: false, _playing: false, _unitTime: 0, _currentTime: 0, _scheduler: null, _fTotalTime: 0, ctor: function () {
    this._actionNodeList = [];
    this._name = "";
    this._loop = false;
    this._pause = false;
    this._playing = false;
    this._unitTime = 0.1;
    this._currentTime = 0;
    this._fTotalTime = 0;
    this._scheduler = new cc.Scheduler;
    cc.director.getScheduler().scheduleUpdateForTarget(this._scheduler, 0, false)
}, setName: function (name) {
    this._name = name
}, getName: function () {
    return this._name
},
    setLoop: function (loop) {
        this._loop = loop
    }, getLoop: function () {
        return this._loop
    }, setUnitTime: function (time) {
        this._unitTime = time;
        var frameNum = this._actionNodeList.length;
        for (var i = 0; i < frameNum; i++) {
            var locActionNode = this._actionNodeList[i];
            locActionNode.setUnitTime(this._unitTime)
        }
    }, getUnitTime: function () {
        return this._unitTime
    }, getCurrentTime: function () {
        return this._currentTime
    }, setCurrentTime: function (time) {
        this._currentTime = time
    }, getTotalTime: function () {
        return this._fTotalTime
    }, isPlaying: function () {
        return this._playing
    },
    initWithDictionary: function (dic, root) {
        this.setName(dic["name"]);
        this.setLoop(dic["loop"]);
        this.setUnitTime(dic["unittime"]);
        var actionNodeList = dic["actionnodelist"];
        var maxLength = 0;
        for (var i = 0; i < actionNodeList.length; i++) {
            var actionNode = new ccs.ActionNode;
            var actionNodeDic = actionNodeList[i];
            actionNode.initWithDictionary(actionNodeDic, root);
            actionNode.setUnitTime(this.getUnitTime());
            this._actionNodeList.push(actionNode);
            var length = actionNode.getLastFrameIndex() - actionNode.getFirstFrameIndex();
            if (length >
                maxLength)maxLength = length
        }
        this._fTotalTime = maxLength * this._unitTime
    }, addActionNode: function (node) {
        if (!node)return;
        this._actionNodeList.push(node);
        node.setUnitTime(this._unitTime)
    }, removeActionNode: function (node) {
        if (node == null)return;
        cc.arrayRemoveObject(this._actionNodeList, node)
    }, play: function (fun) {
        this.stop();
        this.updateToFrameByTime(0);
        var frameNum = this._actionNodeList.length;
        for (var i = 0; i < frameNum; i++) {
            var locActionNode = this._actionNodeList[i];
            locActionNode.playAction(fun)
        }
        if (this._loop)this._scheduler.scheduleCallbackForTarget(this,
            this.simulationActionUpdate, 0, cc.REPEAT_FOREVER, 0, false)
    }, pause: function () {
        this._pause = true
    }, stop: function () {
        for (var i = 0; i < this._actionNodeList.length; i++) {
            var locActionNode = this._actionNodeList[i];
            locActionNode.stopAction()
        }
        this._scheduler.unscheduleCallbackForTarget(this, this.simulationActionUpdate);
        this._pause = false
    }, updateToFrameByTime: function (time) {
        this._currentTime = time;
        for (var i = 0; i < this._actionNodeList.length; i++) {
            var locActionNode = this._actionNodeList[i];
            locActionNode.updateActionToTimeLine(time)
        }
    },
    simulationActionUpdate: function (dt) {
        if (this._loop) {
            var isEnd = true;
            var actionNodeList = this._actionNodeList;
            for (var i = 0; i < actionNodeList.length; i++) {
                var actionNode = actionNodeList[i];
                if (actionNode.isActionDoneOnce() == false) {
                    isEnd = false;
                    break
                }
            }
            if (isEnd)this.play()
        }
    }});
ccs.ComAttribute = ccs.Component.extend({_jsonDict: null, _filePath: "", ctor: function () {
    cc.Component.prototype.ctor.call(this);
    this._jsonDict = {};
    this._filePath = "";
    this._name = "CCComAttribute"
}, init: function () {
    this._jsonDict = {};
    return true
}, setInt: function (key, value) {
    if (!key) {
        cc.log("Argument must be non-nil");
        return
    }
    this._jsonDict[key] = value
}, setDouble: function (key, value) {
    if (!key) {
        cc.log("Argument must be non-nil");
        return
    }
    this._jsonDict[key] = value
}, setFloat: function (key, value) {
    if (!key) {
        cc.log("Argument must be non-nil");
        return
    }
    this._jsonDict[key] = value
}, setBool: function (key, value) {
    if (!key) {
        cc.log("Argument must be non-nil");
        return
    }
    this._jsonDict[key] = value
}, setString: function (key, value) {
    if (!key) {
        cc.log("Argument must be non-nil");
        return
    }
    this._jsonDict[key] = value
}, setObject: function (key, value) {
    if (!key) {
        cc.log("Argument must be non-nil");
        return
    }
    this._jsonDict[key] = value
}, getInt: function (key) {
    var ret = this._jsonDict[key];
    return parseInt(ret || 0)
}, getDouble: function (key) {
    var ret = this._jsonDict[key];
    return parseFloat(ret ||
        0)
}, getFloat: function (key) {
    var ret = this._jsonDict[key];
    return parseFloat(ret || 0)
}, getBool: function (key) {
    var ret = this._jsonDict[key];
    return Boolean(ret || false)
}, getString: function (key) {
    var ret = this._jsonDict[key];
    return ret || ""
}, getObject: function (key) {
    return this._jsonDict[key]
}, parse: function (path) {
    this._jsonDict = cc.loader.getRes(path)
}});
ccs.ComAttribute.create = function () {
    var com = new ccs.ComAttribute;
    if (com && com.init())return com;
    return null
};
ccs.ComAudio = ccs.Component.extend({_filePath: "", _loop: false, ctor: function () {
    cc.Component.prototype.ctor.call(this);
    this._name = "Audio"
}, init: function () {
    return true
}, onEnter: function () {
}, onExit: function () {
    this.stopBackgroundMusic(true);
    this.stopAllEffects()
}, end: function () {
    cc.audioEngine.end()
}, preloadBackgroundMusic: function (pszFilePath) {
    cc.loader.load(pszFilePath)
}, playBackgroundMusic: function (pszFilePath, loop) {
    if (pszFilePath)cc.audioEngine.playMusic(pszFilePath, loop); else cc.audioEngine.playMusic(this._filePath,
        this._loop)
}, stopBackgroundMusic: function (releaseData) {
    cc.audioEngine.stopMusic(releaseData)
}, pauseBackgroundMusic: function () {
    cc.audioEngine.pauseMusic()
}, resumeBackgroundMusic: function () {
    cc.audioEngine.resumeMusic()
}, rewindBackgroundMusic: function () {
    cc.audioEngine.rewindMusic()
}, willPlayBackgroundMusic: function () {
    return cc.audioEngine.willPlayMusic()
}, isBackgroundMusicPlaying: function () {
    return cc.audioEngine.isMusicPlaying()
}, getBackgroundMusicVolume: function () {
    return cc.audioEngine.getMusicVolume()
},
    setBackgroundMusicVolume: function (volume) {
        cc.audioEngine.setMusicVolume(volume)
    }, getEffectsVolume: function () {
        return cc.audioEngine.getEffectsVolume()
    }, setEffectsVolume: function (volume) {
        cc.audioEngine.setEffectsVolume(volume)
    }, playEffect: function (pszFilePath, loop) {
        if (pszFilePath)return cc.audioEngine.playEffect(pszFilePath, loop); else return cc.audioEngine.playEffect(this._filePath, this._loop)
    }, pauseEffect: function (soundId) {
        cc.audioEngine.pauseEffect(soundId)
    }, pauseAllEffects: function () {
        cc.audioEngine.pauseAllEffects()
    },
    resumeEffect: function (soundId) {
        cc.audioEngine.resumeEffect(soundId)
    }, resumeAllEffects: function () {
        cc.audioEngine.resumeAllEffects()
    }, stopEffect: function (soundId) {
        cc.audioEngine.stopEffect(soundId)
    }, stopAllEffects: function () {
        cc.audioEngine.stopAllEffects()
    }, preloadEffect: function (pszFilePath) {
        cc.loader.getRes(pszFilePath);
        this.setFile(pszFilePath);
        this.setLoop(false)
    }, unloadEffect: function (pszFilePath) {
        cc.audioEngine.unloadEffect(pszFilePath)
    }, setFile: function (pszFilePath) {
        this._filePath = pszFilePath
    },
    setLoop: function (loop) {
        this._loop = loop
    }, getFile: function () {
        return this._filePath
    }, isLoop: function () {
        return this._loop
    }});
ccs.ComAudio.create = function () {
    var com = new ccs.ComAudio;
    if (com && com.init())return com;
    return null
};
ccs.ComController = ccs.Component.extend({ctor: function () {
    cc.Component.prototype.ctor.call(this);
    this._name = "ComController"
}, init: function () {
    return true
}, onEnter: function () {
    if (this._owner != null)this._owner.scheduleUpdate()
}, onExit: function () {
}, update: function (dt) {
}, isEnabled: function () {
    return this._enabled
}, setEnabled: function (bool) {
    this._enabled = b
}});
ccs.ComController.create = function () {
    var com = new ccs.ComController;
    if (com && com.init())return com;
    return null
};
ccs.ComRender = ccs.Component.extend({_render: null, ctor: function (node, comName) {
    cc.Component.prototype.ctor.call(this);
    this._render = node;
    this._name = comName;
    this.isRenderer = true
}, onEnter: function () {
    if (this._owner)this._owner.addChild(this._render)
}, onExit: function () {
    if (this._owner) {
        this._owner.removeChild(this._render, true);
        this._render = null
    }
}, getNode: function () {
    return this._render
}, setNode: function (node) {
    this._render = node
}});
ccs.ComRender.create = function (node, comName) {
    var com = new ccs.ComRender(node, comName);
    if (com && com.init())return com;
    return null
};
ccs.objectFactory = {_typeMap: {}, destroyInstance: function () {
    this._instance = null
}, createObject: function (className) {
    var o = null;
    var t = this._typeMap[className];
    if (t)o = new t._fun;
    return o
}, registerType: function (t) {
    this._typeMap[t._className] = t
}, createGUI: function (name) {
    var object = null;
    if (name === "Panel")name = "Layout"; else if (name === "TextArea")name = "Label"; else if (name === "TextButton")name = "Button";
    var t = this._typeMap[name];
    if (t && t._fun)object = t._fun;
    return object
}, createWidgetReaderProtocol: function (name) {
    var object =
        null;
    var t = this._typeMap[name];
    if (t && t._fun)object = t._fun;
    return object
}};
ccs.TInfo = ccs.Class.extend({_className: "", _fun: null, ctor: function (c, f) {
    if (f) {
        this._className = c;
        this._fun = f
    } else {
        this._className = c._className;
        this._fun = c._fun
    }
    ccs.objectFactory.registerType(this)
}});
ccs.sendEvent = function (event) {
    var triggerObjArr = ccs.triggerManager.get(event);
    if (triggerObjArr == null)return;
    for (var i = 0; i < triggerObjArr.length; i++) {
        var triObj = triggerObjArr[i];
        if (triObj != null && triObj.detect())triObj.done()
    }
};
ccs.registerTriggerClass = function (className, func) {
    new ccs.TInfo(className, func)
};
ccs.triggerManager = {_eventTriggers: {}, _triggerObjs: {}, _movementDispatches: [], destroyInstance: function () {
    this.removeAll();
    this._instance = null
}, parse: function (triggers) {
    for (var i = 0; i < triggers.length; ++i) {
        var subDict = triggers[i];
        var triggerObj = ccs.TriggerObj.create();
        triggerObj.serialize(subDict);
        var events = triggerObj.getEvents();
        for (var j = 0; j < events.length; j++) {
            var event = events[j];
            this.add(event, triggerObj)
        }
        this._triggerObjs[triggerObj.getId()] = triggerObj
    }
}, get: function (event) {
    return this._eventTriggers[event]
},
    getTriggerObj: function (id) {
        return this._triggerObjs[id]
    }, add: function (event, triggerObj) {
        var eventTriggers = this._eventTriggers[event];
        if (!eventTriggers)eventTriggers = [];
        if (eventTriggers.indexOf(triggerObj) == -1) {
            eventTriggers.push(triggerObj);
            this._eventTriggers[event] = eventTriggers
        }
    }, removeAll: function () {
        for (var key in this._eventTriggers) {
            var triObjArr = this._eventTriggers[key];
            for (var j = 0; j < triObjArr.length; j++) {
                var obj = triObjArr[j];
                obj.removeAll()
            }
        }
        this._eventTriggers = {}
    }, remove: function (event, Obj) {
        if (Obj)return this._removeObj(event,
            Obj);
        var bRet = false;
        do {
            var triObjects = this._eventTriggers[event];
            if (!triObjects)break;
            for (var i = 0; i < triObjects.length; i++) {
                var triObject = triObjects[i];
                if (triObject)triObject.removeAll()
            }
            delete this._eventTriggers[event];
            bRet = true
        } while (0);
        return bRet
    }, _removeObj: function (event, Obj) {
        var bRet = false;
        do {
            var triObjects = this._eventTriggers[event];
            if (!triObjects)break;
            for (var i = 0; i < triObjects.length; i++) {
                var triObject = triObjects[i];
                if (triObject && triObject == Obj) {
                    triObject.removeAll();
                    triObjects.splice(i,
                        1);
                    break
                }
            }
            bRet = true
        } while (0);
        return bRet
    }, removeTriggerObj: function (id) {
        var obj = this.getTriggerObj(id);
        if (!obj)return false;
        var events = obj.getEvents();
        for (var i = 0; i < events.length; i++) {
            var event = events[i];
            this.remove(event, obj)
        }
        return true
    }, isEmpty: function () {
        return!this._eventTriggers || this._eventTriggers.length <= 0
    }, addArmatureMovementCallBack: function (armature, callFunc, target) {
        if (armature == null || target == null || callFunc == null)return;
        var locAmd, hasADD = false;
        for (var i = 0; i < this._movementDispatches.length; i++) {
            locAmd =
                this._movementDispatches[i];
            if (locAmd && locAmd[0] == armature) {
                locAmd.addAnimationEventCallBack(callFunc, target);
                hasADD = true
            }
        }
        if (!hasADD) {
            var newAmd = new ccs.ArmatureMovementDispatcher;
            armature.getAnimation().setMovementEventCallFunc(newAmd.animationEvent, newAmd);
            newAmd.addAnimationEventCallBack(callFunc, target);
            this._movementDispatches.push([armature, newAmd])
        }
    }, removeArmatureMovementCallBack: function (armature, target, callFunc) {
        if (armature == null || target == null || callFunc == null)return;
        var locAmd;
        for (var i =
            0; i < this._movementDispatches.length; i++) {
            locAmd = this._movementDispatches[i];
            if (locAmd && locAmd[0] == armature)locAmd.removeAnimationEventCallBack(callFunc, target)
        }
    }, removeArmatureAllMovementCallBack: function (armature) {
        if (armature == null)return;
        var locAmd;
        for (var i = 0; i < this._movementDispatches.length; i++) {
            locAmd = this._movementDispatches[i];
            if (locAmd && locAmd[0] == armature) {
                this._movementDispatches.splice(i, 1);
                break
            }
        }
    }, removeAllArmatureMovementCallBack: function () {
        this._movementDispatches = []
    }, version: function () {
        return"1.2.0.0"
    }};
ccs.ArmatureMovementDispatcher = ccs.Class.extend({_mapEventAnimation: null, ctor: function () {
    this._mapEventAnimation = []
}, animationEvent: function (armature, movementType, movementID) {
    var locEventAni, locTarget, locFunc;
    for (var i = 0; i < this._mapEventAnimation.length; i++) {
        locEventAni = this._mapEventAnimation[i];
        locTarget = locEventAni[0];
        locFunc = locEventAni[1];
        if (locFunc)locFunc.call(locTarget, armature, movementType, movementID)
    }
}, addAnimationEventCallBack: function (callFunc, target) {
    this._mapEventAnimation.push([target,
        callFunc])
}, removeAnimationEventCallBack: function (callFunc, target) {
    var locEventAni;
    for (var i = 0; i < this._mapEventAnimation.length; i++) {
        locEventAni = this._mapEventAnimation[i];
        if (locEventAni[0] == target)this._mapEventAnimation.splice(i, 1)
    }
}});
ccs.BaseTriggerCondition = ccs.Class.extend({ctor: function () {
}, init: function () {
    return true
}, detect: function () {
    return true
}, serialize: function (jsonVal) {
}, removeAll: function () {
}});
ccs.BaseTriggerAction = ccs.Class.extend({ctor: function () {
}, init: function () {
    return true
}, done: function () {
}, serialize: function (jsonVal) {
}, removeAll: function () {
}});
ccs.TriggerObj = ccs.Class.extend({_cons: null, _acts: null, _id: 0, _enable: true, _vInt: null, ctor: function () {
    this._id = 0;
    this._enable = true
}, init: function () {
    this._cons = [];
    this._acts = [];
    this._vInt = [];
    return true
}, detect: function () {
    if (!this._enable || this._cons.length == 0)return true;
    var ret = true;
    var obj = null;
    for (var i = 0; i < this._cons.length; i++) {
        obj = this._cons[i];
        if (obj && obj.detect)ret = ret && obj.detect()
    }
    return ret
}, done: function () {
    if (!this._enable || this._acts.length == 0)return;
    var obj;
    for (var i = 0; i < this._acts.length; i++) {
        obj =
            this._acts[i];
        if (obj && obj.done)obj.done()
    }
}, removeAll: function () {
    var obj = null;
    for (var i = 0; i < this._cons.length; i++) {
        obj = this._cons[i];
        if (obj)obj.removeAll()
    }
    this._cons = [];
    for (var i = 0; i < this._acts.length; i++) {
        obj = this._acts[i];
        if (obj)obj.removeAll()
    }
    this._acts = []
}, serialize: function (jsonVal) {
    this._id = jsonVal["id"] || 0;
    var conditions = jsonVal["conditions"] || [];
    for (var i = 0; i < conditions.length; i++) {
        var subDict = conditions[i];
        var classname = subDict["classname"];
        var con = ccs.objectFactory.createObject(classname);
        if (!con) {
            cc.log("class named classname(" + classname + ") can not implement!");
            continue
        }
        con.serialize(subDict);
        con.init();
        this._cons.push(con)
    }
    var actions = jsonVal["actions"] || [];
    for (var i = 0; i < actions.length; i++) {
        var subDict = actions[i];
        var classname = subDict["classname"];
        var act = ccs.objectFactory.createObject(classname);
        if (!act) {
            cc.log("class named classname(" + classname + ") can not implement!");
            continue
        }
        act.serialize(subDict);
        act.init();
        this._acts.push(act)
    }
    var events = jsonVal["events"] || [];
    for (var i = 0; i <
        events.length; i++) {
        var subDict = events[i];
        var event = subDict["id"];
        if (event < 0)continue;
        this._vInt.push(event)
    }
}, getId: function () {
    return this._id
}, setEnable: function (enable) {
    this._enable = enable
}, getEvents: function () {
    return this._vInt
}});
ccs.TriggerObj.create = function () {
    var ret = new ccs.TriggerObj;
    if (ret.init())return ret;
    return null
};
ccs.uiReader = {_filePath: "", _olderVersion: false, _fileDesignSizes: {}, _mapObject: {}, _mapParseSelector: {}, getVersionInteger: function (str) {
    if (!str)return 0;
    var strVersion = str;
    var versionLength = strVersion.length;
    if (versionLength < 7)return 0;
    var pos = strVersion.indexOf(".");
    var t = strVersion.substr(0, pos);
    strVersion = strVersion.substr(pos + 1, versionLength - 1);
    pos = strVersion.indexOf(".");
    var h = strVersion.substr(0, pos);
    strVersion = strVersion.substr(pos + 1, versionLength - 1);
    pos = strVersion.indexOf(".");
    var te = strVersion.substr(0,
        pos);
    strVersion = strVersion.substr(pos + 1, versionLength - 1);
    pos = strVersion.indexOf(".");
    var s;
    if (pos == -1)s = strVersion; else s = strVersion.substr(0, pos);
    var it = parseInt(t);
    var ih = parseInt(h);
    var ite = parseInt(te);
    var is = parseInt(s);
    var version = it * 1E3 + ih * 100 + ite * 10 + is;
    return version
}, storeFileDesignSize: function (fileName, size) {
    this._fileDesignSizes[fileName] = size
}, getFileDesignSize: function (fileName) {
    return this._fileDesignSizes[fileName]
}, widgetFromJsonFile: function (fileName) {
    var jsonDict = cc.loader.getRes(fileName);
    if (!jsonDict)throw"Please load the resource first : " + fileName;
    var tempFilePath = cc.path.dirname(fileName);
    this._filePath = tempFilePath == "" ? tempFilePath : tempFilePath + "/";
    var fileVersion = jsonDict["version"];
    var pReader, widget;
    var versionInteger = this.getVersionInteger(fileVersion);
    if (fileVersion)if (versionInteger < 250) {
        pReader = new ccs.WidgetPropertiesReader0250;
        widget = pReader.createWidget(jsonDict, this._filePath, fileName)
    } else {
        pReader = new ccs.WidgetPropertiesReader0300;
        widget = pReader.createWidget(jsonDict,
            this._filePath, fileName)
    } else {
        pReader = new ccs.WidgetPropertiesReader0250;
        widget = pReader.createWidget(jsonDict, this._filePath, fileName)
    }
    if (!fileVersion || versionInteger < 250)this._olderVersion = true;
    jsonDict = null;
    return widget
}, clear: function () {
    this._filePath = "";
    this._olderVersion = false;
    this._fileDesignSizes = {}
}, registerTypeAndCallBack: function (classType, ins, object, callback) {
    var factoryCreate = ccs.objectFactory;
    var t = new ccs.TInfo(classType, object);
    factoryCreate.registerType(t);
    if (object)this._mapObject[classType] =
        object;
    if (callback)this._mapParseSelector[classType] = callback
}, getFilePath: function () {
    return this._filePath
}, getParseObjectMap: function () {
    return this._mapObject
}, getParseCallBackMap: function () {
    return this._mapParseSelector
}};
ccs.WidgetPropertiesReader = ccs.Class.extend({_filePath: "", createWidget: function (jsonDict, fullPath, fileName) {
}, widgetFromJsonDictionary: function (data) {
}});
ccs.WidgetPropertiesReader0250 = ccs.WidgetPropertiesReader.extend({createWidget: function (jsonDict, fullPath, fileName) {
    this._filePath = fullPath == "" ? fullPath : cc.path.join(fullPath, "/");
    var textures = jsonDict["textures"];
    for (var i = 0; i < textures.length; i++) {
        var file = textures[i];
        var tp = fullPath;
        tp += file;
        cc.spriteFrameCache.addSpriteFrames(tp)
    }
    var fileDesignWidth = jsonDict["designWidth"];
    var fileDesignHeight = jsonDict["designHeight"];
    if (fileDesignWidth <= 0 || fileDesignHeight <= 0) {
        cc.log("Read design size error!");
        var winSize = cc.director.getWinSize();
        ccs.uiReader.storeFileDesignSize(fileName, winSize)
    } else ccs.uiReader.storeFileDesignSize(fileName, cc.size(fileDesignWidth, fileDesignHeight));
    var widgetTree = jsonDict["widgetTree"];
    var widget = this.widgetFromJsonDictionary(widgetTree);
    var size = widget.getContentSize();
    if (size.width == 0 && size.height == 0)widget.setSize(cc.size(fileDesignWidth, fileDesignHeight));
    var actions = jsonDict["animation"];
    var rootWidget = widget;
    ccs.actionManager.initWithDictionary(fileName, actions,
        rootWidget);
    widgetTree = null;
    actions = null;
    return widget
}, widgetFromJsonDictionary: function (data) {
    var widget = null;
    var classname = data["classname"];
    var uiOptions = data["options"];
    if (classname == "Button") {
        widget = ccui.Button.create();
        this.setPropsForButtonFromJsonDictionary(widget, uiOptions)
    } else if (classname == "CheckBox") {
        widget = ccui.CheckBox.create();
        this.setPropsForCheckBoxFromJsonDictionary(widget, uiOptions)
    } else if (classname == "Label") {
        widget = ccui.Text.create();
        this.setPropsForLabelFromJsonDictionary(widget,
            uiOptions)
    } else if (classname == "LabelAtlas") {
        widget = ccui.TextAtlas.create();
        this.setPropsForLabelAtlasFromJsonDictionary(widget, uiOptions)
    } else if (classname == "LoadingBar") {
        widget = ccui.LoadingBar.create();
        this.setPropsForLoadingBarFromJsonDictionary(widget, uiOptions)
    } else if (classname == "ScrollView") {
        widget = ccui.ScrollView.create();
        this.setPropsForScrollViewFromJsonDictionary(widget, uiOptions)
    } else if (classname == "TextArea") {
        widget = ccui.Text.create();
        this.setPropsForLabelFromJsonDictionary(widget, uiOptions)
    } else if (classname ==
        "TextButton") {
        widget = ccui.Button.create();
        this.setPropsForButtonFromJsonDictionary(widget, uiOptions)
    } else if (classname == "TextField") {
        widget = ccui.TextField.create();
        this.setPropsForTextFieldFromJsonDictionary(widget, uiOptions)
    } else if (classname == "ImageView") {
        widget = ccui.ImageView.create();
        this.setPropsForImageViewFromJsonDictionary(widget, uiOptions)
    } else if (classname == "Panel") {
        widget = ccui.Layout.create();
        this.setPropsForLayoutFromJsonDictionary(widget, uiOptions)
    } else if (classname == "Slider") {
        widget =
            ccui.Slider.create();
        this.setPropsForSliderFromJsonDictionary(widget, uiOptions)
    } else if (classname == "LabelBMFont") {
        widget = ccui.TextBMFont.create();
        this.setPropsForLabelBMFontFromJsonDictionary(widget, uiOptions)
    } else if (classname == "DragPanel") {
        widget = ccui.ScrollView.create();
        this.setPropsForScrollViewFromJsonDictionary(widget, uiOptions)
    }
    var children = data["children"];
    for (var i = 0; i < children.length; i++) {
        var subData = children[i];
        var child = this.widgetFromJsonDictionary(subData);
        if (child)widget.addChild(child);
        subData = null
    }
    uiOptions = null;
    return widget
}, setPropsForWidgetFromJsonDictionary: function (widget, options) {
    if (options["ignoreSize"] !== undefined)widget.ignoreContentAdaptWithSize(options["ignoreSize"]);
    var w = options["width"];
    var h = options["height"];
    widget.setSize(cc.size(w, h));
    widget.setTag(options["tag"]);
    widget.setActionTag(options["actiontag"]);
    widget.setTouchEnabled(options["touchAble"]);
    var name = options["name"];
    var widgetName = name ? name : "default";
    widget.setName(widgetName);
    var x = options["x"];
    var y =
        options["y"];
    widget.setPosition(cc.p(x, y));
    if (options["scaleX"] !== undefined)widget.setScaleX(options["scaleX"]);
    if (options["scaleY"] !== undefined)widget.setScaleY(options["scaleY"]);
    if (options["rotation"] !== undefined)widget.setRotation(options["rotation"]);
    if (options["visible"] !== undefined)widget.setVisible(options["visible"]);
    var z = options["ZOrder"];
    widget.setLocalZOrder(z)
}, setPropsForAllWidgetFromJsonDictionary: function () {
}, setPropsForAllCustomWidgetFromJsonDictionary: function () {
}, setColorPropsForWidgetFromJsonDictionary: function (widget, options) {
    if (options["opacity"] !== undefined)widget.setOpacity(options["opacity"]);
    var colorR = options["colorR"] !== undefined ? options["colorR"] : 255;
    var colorG = options["colorG"] !== undefined ? options["colorG"] : 255;
    var colorB = options["colorB"] !== undefined ? options["colorB"] : 255;
    widget.setColor(cc.color(colorR, colorG, colorB));
    var apx = options["anchorPointX"] !== undefined ? options["anchorPointX"] : widget.getWidgetType() == ccui.Widget.TYPE_WIDGET ? 0.5 : 0;
    var apy = options["anchorPointY"] !== undefined ? options["anchorPointY"] :
            widget.getWidgetType() == ccui.Widget.TYPE_WIDGET ? 0.5 : 0;
    widget.setAnchorPoint(apx, apy);
    var flipX = options["flipX"];
    var flipY = options["flipY"];
    widget.setFlippedX(flipX);
    widget.setFlippedY(flipY)
}, setPropsForButtonFromJsonDictionary: function (widget, options) {
    this.setPropsForWidgetFromJsonDictionary(widget, options);
    var button = widget;
    var scale9Enable = options["scale9Enable"];
    button.setScale9Enabled(scale9Enable);
    var normalFileName = options["normal"];
    var pressedFileName = options["pressed"];
    var disabledFileName =
        options["disabled"];
    var normalFileName_tp = normalFileName ? this._filePath + normalFileName : null;
    var pressedFileName_tp = pressedFileName ? this._filePath + pressedFileName : null;
    var disabledFileName_tp = disabledFileName ? this._filePath + disabledFileName : null;
    var useMergedTexture = options["useMergedTexture"];
    if (scale9Enable) {
        var cx = options["capInsetsX"];
        var cy = options["capInsetsY"];
        var cw = options["capInsetsWidth"];
        var ch = options["capInsetsHeight"];
        if (useMergedTexture)button.loadTextures(normalFileName, pressedFileName,
            disabledFileName, ccui.Widget.PLIST_TEXTURE); else button.loadTextures(normalFileName_tp, pressedFileName_tp, disabledFileName_tp);
        if (options["scale9Width"] !== undefined && options["scale9Height"] !== undefined) {
            var swf = options["scale9Width"];
            var shf = options["scale9Height"];
            button.setSize(cc.size(swf, shf))
        }
    } else if (useMergedTexture)button.loadTextures(normalFileName, pressedFileName, disabledFileName, ccui.Widget.PLIST_TEXTURE); else button.loadTextures(normalFileName_tp, pressedFileName_tp, disabledFileName_tp);
    if (options["text"] !== undefined) {
        var text = options["text"] || "";
        if (text)button.setTitleText(text)
    }
    if (options["fontSize"] !== undefined)button.setTitleFontSize(options["fontSize"]);
    if (options["fontName"] !== undefined)button.setTitleFontName(options["fontName"]);
    var cr = options["textColorR"] !== undefined ? options["textColorR"] : 255;
    var cg = options["textColorG"] !== undefined ? options["textColorG"] : 255;
    var cb = options["textColorB"] !== undefined ? options["textColorB"] : 255;
    var tc = cc.color(cr, cg, cb);
    button.setTitleColor(tc);
    this.setColorPropsForWidgetFromJsonDictionary(widget, options)
}, setPropsForCheckBoxFromJsonDictionary: function (widget, options) {
    this.setPropsForWidgetFromJsonDictionary(widget, options);
    var checkBox = widget;
    var backGroundFileName = options["backGroundBox"];
    var backGroundSelectedFileName = options["backGroundBoxSelected"];
    var frontCrossFileName = options["frontCross"];
    var backGroundDisabledFileName = options["backGroundBoxDisabled"];
    var frontCrossDisabledFileName = options["frontCrossDisabled"];
    var locFilePath =
        this._filePath;
    var backGroundFileName_tp = backGroundFileName ? locFilePath + backGroundFileName : null;
    var backGroundSelectedFileName_tp = backGroundSelectedFileName ? locFilePath + backGroundSelectedFileName : null;
    var frontCrossFileName_tp = frontCrossFileName ? locFilePath + frontCrossFileName : null;
    var backGroundDisabledFileName_tp = backGroundDisabledFileName ? locFilePath + backGroundDisabledFileName : null;
    var frontCrossDisabledFileName_tp = frontCrossDisabledFileName ? locFilePath + frontCrossDisabledFileName : null;
    var useMergedTexture =
        options["useMergedTexture"];
    if (useMergedTexture)checkBox.loadTextures(backGroundFileName, backGroundSelectedFileName, frontCrossFileName, backGroundDisabledFileName, frontCrossDisabledFileName, ccui.Widget.PLIST_TEXTURE); else checkBox.loadTextures(backGroundFileName_tp, backGroundSelectedFileName_tp, frontCrossFileName_tp, backGroundDisabledFileName_tp, frontCrossDisabledFileName_tp);
    checkBox.setSelectedState(options["selectedState"] || false);
    this.setColorPropsForWidgetFromJsonDictionary(widget, options)
}, setPropsForImageViewFromJsonDictionary: function (widget, options) {
    this.setPropsForWidgetFromJsonDictionary(widget, options);
    var imageView = widget;
    var imageFileName = options["fileName"];
    var scale9Enable = options["scale9Enable"] || false;
    imageView.setScale9Enabled(scale9Enable);
    var tp_i = this._filePath;
    var imageFileName_tp = null;
    if (imageFileName)imageFileName_tp = tp_i + imageFileName;
    var useMergedTexture = options["useMergedTexture"];
    if (scale9Enable) {
        if (useMergedTexture)imageView.loadTexture(imageFileName, ccui.Widget.PLIST_TEXTURE); else imageView.loadTexture(imageFileName_tp);
        if (options["scale9Width"] !== undefined && options["scale9Height"] !== undefined) {
            var swf = options["scale9Width"];
            var shf = options["scale9Height"];
            imageView.setSize(cc.size(swf, shf))
        }
        var cx = options["capInsetsX"];
        var cy = options["capInsetsY"];
        var cw = options["capInsetsWidth"];
        var ch = options["capInsetsHeight"];
        imageView.setCapInsets(cc.rect(cx, cy, cw, ch))
    } else if (useMergedTexture)imageView.loadTexture(imageFileName, ccui.Widget.PLIST_TEXTURE); else imageView.loadTexture(imageFileName_tp);
    this.setColorPropsForWidgetFromJsonDictionary(widget,
        options)
}, setPropsForLabelFromJsonDictionary: function (widget, options) {
    this.setPropsForWidgetFromJsonDictionary(widget, options);
    var label = widget;
    var touchScaleChangeAble = options["touchScaleEnable"];
    label.setTouchScaleChangeEnabled(touchScaleChangeAble);
    var text = options["text"];
    label.setString(text);
    if (options["fontSize"] !== undefined)label.setFontSize(options["fontSize"]);
    if (options["fontName"] !== undefined)label.setFontName(options["fontName"]);
    if (options["areaWidth"] !== undefined && options["areaHeight"] !==
        undefined) {
        var size = cc.size(options["areaWidth"], options["areaHeight"]);
        label.setTextAreaSize(size)
    }
    if (options["hAlignment"])label.setTextHorizontalAlignment(options["hAlignment"]);
    if (options["vAlignment"])label.setTextVerticalAlignment(options["vAlignment"]);
    this.setColorPropsForWidgetFromJsonDictionary(widget, options)
}, setPropsForLabelAtlasFromJsonDictionary: function (widget, options) {
    this.setPropsForWidgetFromJsonDictionary(widget, options);
    var labelAtlas = widget;
    var sv = options["stringValue"] !== undefined;
    var cmf = options["charMapFile"] !== undefined;
    var iw = options["itemWidth"] !== undefined;
    var ih = options["itemHeight"] !== undefined;
    var scm = options["startCharMap"] !== undefined;
    if (sv && cmf && iw && ih && scm && options["charMapFile"]) {
        var cmft = options["charMapFile"];
        var cmf_tp = this._filePath + cmft;
        labelAtlas.setProperty(options["stringValue"], cmf_tp, options["itemWidth"], options["itemHeight"], options["startCharMap"])
    }
    this.setColorPropsForWidgetFromJsonDictionary(widget, options)
}, setPropsForLayoutFromJsonDictionary: function (widget, options) {
    this.setPropsForWidgetFromJsonDictionary(widget, options);
    var containerWidget = widget;
    if (!(containerWidget instanceof ccui.ScrollView) && !(containerWidget instanceof ccui.ListView))containerWidget.setClippingEnabled(options["clipAble"]);
    var panel = widget;
    var backGroundScale9Enable = options["backGroundScale9Enable"];
    panel.setBackGroundImageScale9Enabled(backGroundScale9Enable);
    var cr = options["bgColorR"];
    var cg = options["bgColorG"];
    var cb = options["bgColorB"];
    var scr = options["bgStartColorR"];
    var scg =
        options["bgStartColorG"];
    var scb = options["bgStartColorB"];
    var ecr = options["bgEndColorR"];
    var ecg = options["bgEndColorG"];
    var ecb = options["bgEndColorB"];
    var bgcv1 = options["vectorX"];
    var bgcv2 = options["vectorY"];
    panel.setBackGroundColorVector(cc.p(bgcv1, bgcv2));
    var co = options["bgColorOpacity"];
    var colorType = options["colorType"];
    panel.setBackGroundColorType(colorType);
    panel.setBackGroundColor(cc.color(scr, scg, scb), cc.color(ecr, ecg, ecb));
    panel.setBackGroundColor(cc.color(cr, cg, cb));
    panel.setBackGroundColorOpacity(co);
    var imageFileName = options["backGroundImage"];
    var imageFileName_tp = imageFileName ? this._filePath + imageFileName : null;
    var useMergedTexture = options["useMergedTexture"];
    if (useMergedTexture)panel.setBackGroundImage(imageFileName, ccui.Widget.PLIST_TEXTURE); else panel.setBackGroundImage(imageFileName_tp);
    if (backGroundScale9Enable) {
        var cx = options["capInsetsX"];
        var cy = options["capInsetsY"];
        var cw = options["capInsetsWidth"];
        var ch = options["capInsetsHeight"];
        panel.setBackGroundImageCapInsets(cc.rect(cx, cy, cw, ch))
    }
    this.setColorPropsForWidgetFromJsonDictionary(widget,
        options)
}, setPropsForScrollViewFromJsonDictionary: function (widget, options) {
    this.setPropsForLayoutFromJsonDictionary(widget, options);
    var scrollView = widget;
    var innerWidth = options["innerWidth"];
    var innerHeight = options["innerHeight"];
    scrollView.setInnerContainerSize(cc.size(innerWidth, innerHeight));
    var direction = options["direction"];
    scrollView.setDirection(direction);
    scrollView.setBounceEnabled(options["bounceEnable"]);
    this.setColorPropsForWidgetFromJsonDictionary(widget, options)
}, setPropsForContainerWidgetFromJsonDictionary: function (widget, options) {
    this.setPropsForWidgetFromJsonDictionary(widget, options);
    var containerWidget = widget;
    if (containerWidget instanceof ccui.ScrollView || containerWidget instanceof ccui.ListView)containerWidget.setClippingEnabled(options["clipAble"]);
    this.setColorPropsForWidgetFromJsonDictionary(widget, options)
}, setPropsForSliderFromJsonDictionary: function (widget, options) {
    this.setPropsForWidgetFromJsonDictionary(widget, options);
    var slider = widget;
    var barTextureScale9Enable = options["barTextureScale9Enable"] || false;
    slider.setScale9Enabled(barTextureScale9Enable);
    var barLength = options["length"];
    var useMergedTexture = options["useMergedTexture"];
    var bt = options["barFileName"] !== undefined;
    if (bt)if (barTextureScale9Enable) {
        var imageFileName = options["barFileName"];
        var imageFileName_tp = imageFileName ? this._filePath + imageFileName : null;
        if (useMergedTexture)slider.loadBarTexture(imageFileName, ccui.Widget.PLIST_TEXTURE); else slider.loadBarTexture(imageFileName_tp);
        slider.setSize(cc.size(barLength, slider.getContentSize().height))
    } else {
        var imageFileName =
            options["barFileName"];
        var imageFileName_tp = imageFileName ? this._filePath + imageFileName : null;
        if (useMergedTexture)slider.loadBarTexture(imageFileName, ccui.Widget.PLIST_TEXTURE); else slider.loadBarTexture(imageFileName_tp)
    }
    var normalFileName = options["ballNormal"];
    var pressedFileName = options["ballPressed"];
    var disabledFileName = options["ballDisabled"];
    var normalFileName_tp = normalFileName ? this._filePath + normalFileName : null;
    var pressedFileName_tp = pressedFileName ? this._filePath + pressedFileName : null;
    var disabledFileName_tp =
        disabledFileName ? this._filePath + disabledFileName : null;
    if (useMergedTexture)slider.loadSlidBallTextures(normalFileName, pressedFileName, disabledFileName, ccui.Widget.PLIST_TEXTURE); else slider.loadSlidBallTextures(normalFileName_tp, pressedFileName_tp, disabledFileName_tp);
    slider.setPercent(options["percent"]);
    var imageFileName = options["progressBarFileName"];
    var imageFileName_tp = imageFileName ? this._filePath + imageFileName : null;
    if (useMergedTexture)slider.loadProgressBarTexture(imageFileName, ccui.Widget.PLIST_TEXTURE);
    else slider.loadProgressBarTexture(imageFileName_tp);
    this.setColorPropsForWidgetFromJsonDictionary(widget, options)
}, setPropsForTextAreaFromJsonDictionary: function (widget, options) {
    this.setPropsForWidgetFromJsonDictionary(widget, options);
    var textArea = widget;
    textArea.setString(options["text"]);
    if (options["fontSize"] !== undefined)textArea.setFontSize(options["fontSize"]);
    var cr = options["colorR"];
    var cg = options["colorG"];
    var cb = options["colorB"];
    textArea.setColor(cc.color(cr, cg, cb));
    textArea.setFontName(options["fontName"]);
    if (options["areaWidth"] !== undefined && options["areaHeight"] !== undefined) {
        var size = cc.size(options["areaWidth"], options["areaHeight"]);
        textArea.setTextAreaSize(size)
    }
    if (options["hAlignment"])textArea.setTextHorizontalAlignment(options["hAlignment"]);
    if (options["vAlignment"])textArea.setTextVerticalAlignment(options["vAlignment"]);
    this.setColorPropsForWidgetFromJsonDictionary(widget, options)
}, setPropsForTextButtonFromJsonDictionary: function (widget, options) {
    this.setPropsForButtonFromJsonDictionary(widget,
        options);
    var textButton = widget;
    textButton.setTitleText(options["text"] || "");
    var cri = options["textColorR"] !== undefined ? options["textColorR"] : 255;
    var cgi = options["textColorG"] !== undefined ? options["textColorG"] : 255;
    var cbi = options["textColorB"] !== undefined ? options["textColorB"] : 255;
    textButton.setTitleColor(cc.color(cri, cgi, cbi));
    if (options["fontSize"] !== undefined)textButton.setTitleFontSize(options["fontSize"]);
    if (options["fontName"] !== undefined)textButton.setTitleFontName(options["fontName"]);
    this.setColorPropsForWidgetFromJsonDictionary(widget,
        options)
}, setPropsForTextFieldFromJsonDictionary: function (widget, options) {
    this.setPropsForWidgetFromJsonDictionary(widget, options);
    var textField = widget;
    if (options["placeHolder"] !== undefined)textField.setPlaceHolder(options["placeHolder"]);
    textField.setString(options["text"]);
    if (options["fontSize"] !== undefined)textField.setFontSize(options["fontSize"]);
    if (options["fontName"] !== undefined)textField.setFontName(options["fontName"]);
    if (options["touchSizeWidth"] !== undefined && options["touchSizeHeight"] !==
        undefined)textField.setTouchSize(cc.size(options["touchSizeWidth"], options["touchSizeHeight"]));
    var dw = options["width"];
    var dh = options["height"];
    if (dw > 0 || dh > 0);
    var maxLengthEnable = options["maxLengthEnable"];
    textField.setMaxLengthEnabled(maxLengthEnable);
    if (maxLengthEnable) {
        var maxLength = options["maxLength"];
        textField.setMaxLength(maxLength)
    }
    var passwordEnable = options["passwordEnable"];
    textField.setPasswordEnabled(passwordEnable);
    if (passwordEnable)textField.setPasswordStyleText(options["passwordStyleText"]);
    this.setColorPropsForWidgetFromJsonDictionary(widget, options)
}, setPropsForLoadingBarFromJsonDictionary: function (widget, options) {
    this.setPropsForWidgetFromJsonDictionary(widget, options);
    var loadingBar = widget;
    var useMergedTexture = options["useMergedTexture"];
    var imageFileName = options["texture"];
    var imageFileName_tp = imageFileName ? this._filePath + imageFileName : null;
    if (useMergedTexture)loadingBar.loadTexture(imageFileName, ccui.Widget.PLIST_TEXTURE); else loadingBar.loadTexture(imageFileName_tp);
    loadingBar.setDirection(options["direction"]);
    loadingBar.setPercent(options["percent"]);
    this.setColorPropsForWidgetFromJsonDictionary(widget, options)
}, setPropsForListViewFromJsonDictionary: function (widget, options) {
    this.setPropsForLayoutFromJsonDictionary(widget, options)
}, setPropsForPageViewFromJsonDictionary: function (widget, options) {
    this.setPropsForLayoutFromJsonDictionary(widget, options)
}, setPropsForLabelBMFontFromJsonDictionary: function (widget, options) {
    this.setPropsForWidgetFromJsonDictionary(widget, options);
    var labelBMFont = widget;
    var cmft =
        options["fileName"];
    var cmf_tp = this._filePath + cmft;
    labelBMFont.setFntFile(cmf_tp);
    var text = options["text"];
    labelBMFont.setString(text);
    this.setColorPropsForWidgetFromJsonDictionary(widget, options)
}});
ccs.WidgetPropertiesReader0300 = ccs.WidgetPropertiesReader.extend({createWidget: function (jsonDict, fullPath, fileName) {
    this._filePath = fullPath == "" ? fullPath : cc.path.join(fullPath, "/");
    var textures = jsonDict["textures"];
    for (var i = 0; i < textures.length; i++) {
        var file = textures[i];
        var tp = fullPath;
        tp += file;
        cc.spriteFrameCache.addSpriteFrames(tp)
    }
    var fileDesignWidth = jsonDict["designWidth"];
    var fileDesignHeight = jsonDict["designHeight"];
    if (fileDesignWidth <= 0 || fileDesignHeight <= 0) {
        cc.log("Read design size error!");
        var winSize = cc.director.getWinSize();
        ccs.uiReader.storeFileDesignSize(fileName, winSize)
    } else ccs.uiReader.storeFileDesignSize(fileName, cc.size(fileDesignWidth, fileDesignHeight));
    var widgetTree = jsonDict["widgetTree"];
    var widget = this.widgetFromJsonDictionary(widgetTree);
    var size = widget.getContentSize();
    if (size.width == 0 && size.height == 0)widget.setSize(cc.size(fileDesignWidth, fileDesignHeight));
    var actions = jsonDict["animation"];
    var rootWidget = widget;
    ccs.actionManager.initWithDictionary(fileName, actions,
        rootWidget);
    widgetTree = null;
    actions = null;
    return widget
}, setPropsForAllWidgetFromJsonDictionary: function (reader, widget, options) {
    reader.setPropsFromJsonDictionary(widget, options)
}, setPropsForAllCustomWidgetFromJsonDictionary: function (classType, widget, customOptions) {
    var guiReader = ccs.uiReader;
    var object_map = guiReader.getParseObjectMap();
    var object = object_map[classType];
    var selector_map = guiReader.getParseCallBackMap();
    var selector = selector_map[classType];
    if (object && selector)object.selector.call(this,
        classType, widget, customOptions)
}, widgetFromJsonDictionary: function (data) {
    var widget = null;
    var classname = data["classname"];
    var uiOptions = data["options"];
    if (classname == "Button")widget = ccui.Button.create(); else if (classname == "CheckBox")widget = ccui.CheckBox.create(); else if (classname == "Label")widget = ccui.Text.create(); else if (classname == "LabelAtlas")widget = ccui.TextAtlas.create(); else if (classname == "LoadingBar")widget = ccui.LoadingBar.create(); else if (classname == "ScrollView")widget = ccui.ScrollView.create();
    else if (classname == "TextArea")widget = ccui.Text.create(); else if (classname == "TextButton")widget = ccui.Button.create(); else if (classname == "TextField")widget = ccui.TextField.create(); else if (classname == "ImageView")widget = ccui.ImageView.create(); else if (classname == "Panel")widget = ccui.Layout.create(); else if (classname == "Slider")widget = ccui.Slider.create(); else if (classname == "LabelBMFont")widget = ccui.TextBMFont.create(); else if (classname == "DragPanel")widget = ccui.ScrollView.create(); else if (classname == "ListView")widget =
        ccui.ListView.create(); else if (classname == "PageView")widget = ccui.PageView.create(); else if (classname == "Widget")widget = ccui.Widget.create();
    var readerName = classname;
    switch (readerName) {
        case "Panel":
            readerName = "Layout";
            break;
        case "TextArea":
            readerName = "Label";
            break;
        case "TextButton":
            readerName = "Button";
            break
    }
    readerName += "Reader";
    var reader = ccs.objectFactory.createWidgetReaderProtocol(readerName);
    if (reader)this.setPropsForAllWidgetFromJsonDictionary(reader, widget, uiOptions); else {
        var render;
        if (widget instanceof
            ccui.Button)render = ccs.ButtonReader; else if (widget instanceof ccui.CheckBox)render = ccs.CheckBoxReader; else if (widget instanceof ccui.ImageView)render = ccs.ImageViewReader; else if (widget instanceof ccui.TextAtlas)render = ccs.LabelAtlasReader; else if (widget instanceof ccui.LabelBMFont)render = ccs.LabelBMFontReader; else if (widget instanceof ccui.Text)render = ccs.LabelReader; else if (widget instanceof ccui.LoadingBar)render = ccs.LoadingBarReader; else if (widget instanceof ccui.Slider)render = ccs.SliderReader;
        else if (widget instanceof ccui.TextField)render = ccs.TextFieldReader; else if (widget instanceof ccui.ListView)render = ccs.ListViewReader; else if (widget instanceof ccui.ScrollView)render = ccs.ScrollViewReader; else if (widget instanceof ccui.PageView)render = ccs.PageViewReader; else if (widget instanceof ccui.Layout)render = ccs.LayoutReader; else if (widget instanceof ccui.Widget)render = ccs.WidgetReader;
        this.setPropsForAllWidgetFromJsonDictionary(render, widget, uiOptions);
        var customProperty = uiOptions["customProperty"];
        var customJsonDict = uiOptions;
        if (!uiOptions)cc.log("GetParseError");
        this.setPropsForAllCustomWidgetFromJsonDictionary(classname, widget, customJsonDict)
    }
    var childrenItem = data["children"];
    for (var i = 0; i < childrenItem.length; i++) {
        var child = this.widgetFromJsonDictionary(childrenItem[i]);
        if (child)if (widget instanceof ccui.PageView)widget.addPage(child); else if (widget instanceof ccui.ListView)widget.pushBackCustomItem(child); else {
            if (widget instanceof ccui.Layout) {
                if (child.getPositionType() == ccui.Widget.POSITION_PERCENT) {
                    var position =
                        child.getPosition();
                    var anchor = widget.getAnchorPoint();
                    child.setPositionPercent(cc.p(position.x + anchor.x, position.y + anchor.y))
                }
                var AnchorPointIn = widget.getAnchorPointInPoints();
                child.setPosition(cc.p(child.getPositionX() + AnchorPointIn.x, child.getPositionY() + AnchorPointIn.y))
            }
            widget.addChild(child)
        }
    }
    return widget
}, setPropsForWidgetFromJsonDictionary: function (widget, options) {
    var name = options["name"];
    var widgetName = name ? name : "default";
    widget.setName(widgetName);
    if (options["ignoreSize"] !== undefined)widget.ignoreContentAdaptWithSize(options["ignoreSize"]);
    widget.setSizeType(options["sizeType"]);
    widget.setPositionType(options["positionType"]);
    widget.setSizePercent(cc.p(options["sizePercentX"], options["sizePercentY"]));
    widget.setPositionPercent(cc.p(options["positionPercentX"], options["positionPercentY"]));
    var w = options["width"];
    var h = options["height"];
    widget.setSize(cc.size(w, h));
    widget.setTag(options["tag"]);
    widget.setActionTag(options["actiontag"]);
    widget.setTouchEnabled(options["touchAble"]);
    var x = options["x"];
    var y = options["y"];
    widget.setPosition(cc.p(x,
        y));
    if (options["scaleX"] !== undefined)widget.setScaleX(options["scaleX"]);
    if (options["scaleY"] !== undefined)widget.setScaleY(options["scaleY"]);
    if (options["rotation"] !== undefined)widget.setRotation(options["rotation"]);
    if (options["visible"] !== undefined)widget.setVisible(options["visible"]);
    widget.setLocalZOrder(options["ZOrder"]);
    var layoutParameterDic = options["layoutParameter"];
    if (layoutParameterDic) {
        var paramType = layoutParameterDic["type"];
        var parameter;
        switch (paramType) {
            case 0:
                break;
            case 1:
                parameter =
                    ccui.LinearLayoutParameter.create();
                var gravity = layoutParameterDic["gravity"];
                parameter.setGravity(gravity);
                break;
            case 2:
                parameter = ccui.RelativeLayoutParameter.create();
                var relativeName = layoutParameterDic["relativeName"];
                parameter.setRelativeName(relativeName);
                var relativeToName = layoutParameterDic["relativeToName"];
                parameter.setRelativeToWidgetName(relativeToName);
                parameter.setAlign(layoutParameterDic["align"]);
                break;
            default:
                break
        }
        var mgl = layoutParameterDic["marginLeft"];
        var mgt = layoutParameterDic["marginTop"];
        var mgr = layoutParameterDic["marginRight"];
        var mgb = layoutParameterDic["marginDown"];
        parameter.setMargin(new ccui.Margin(mgl, mgt, mgr, mgb));
        widget.setLayoutParameter(parameter)
    }
}, setColorPropsForWidgetFromJsonDictionary: function (widget, options) {
    if (options["opacity"] !== undefined)widget.setOpacity(options["opacity"]);
    var colorR = options["colorR"] !== undefined ? options["colorR"] : 255;
    var colorG = options["colorG"] !== undefined ? options["colorG"] : 255;
    var colorB = options["colorB"] !== undefined ? options["colorB"] : 255;
    widget.setColor(cc.color(colorR, colorG, colorB));
    var apx = options["anchorPointX"] !== undefined ? options["anchorPointX"] : widget.getWidgetType() == ccui.Widget.TYPE_WIDGET ? 0.5 : 0;
    var apy = options["anchorPointY"] !== undefined ? options["anchorPointY"] : widget.getWidgetType() == ccui.Widget.TYPE_WIDGET ? 0.5 : 0;
    widget.setAnchorPoint(apx, apy);
    var flipX = options["flipX"];
    var flipY = options["flipY"];
    widget.setFlippedX(flipX);
    widget.setFlippedY(flipY)
}, setPropsForButtonFromJsonDictionary: function (widget, options) {
    this.setPropsForWidgetFromJsonDictionary(widget,
        options);
    var button = widget;
    var scale9Enable = options["scale9Enable"];
    button.setScale9Enabled(scale9Enable);
    var normalDic = options["normalData"];
    var normalType = normalDic["resourceType"];
    switch (normalType) {
        case 0:
            var normalFileName = normalDic["path"];
            var normalFileName_tp = normalFileName ? this._filePath + normalFileName : null;
            button.loadTextureNormal(normalFileName_tp);
            break;
        case 1:
            var normalFileName = normalDic["path"];
            button.loadTextureNormal(normalFileName, ccui.Widget.PLIST_TEXTURE);
            break;
        default:
            break
    }
    normalDic =
        null;
    var pressedDic = options["pressedData"];
    var pressedType = pressedDic["resourceType"];
    switch (pressedType) {
        case 0:
            var pressedFileName = pressedDic["path"];
            var pressedFileName_tp = pressedFileName ? this._filePath + pressedFileName : null;
            button.loadTexturePressed(pressedFileName_tp);
            break;
        case 1:
            var pressedFileName = pressedDic["path"];
            button.loadTexturePressed(pressedFileName, ccui.Widget.PLIST_TEXTURE);
            break;
        default:
            break
    }
    pressedDic = null;
    var disabledDic = options["disabledData"];
    var disabledType = disabledDic["resourceType"];
    switch (disabledType) {
        case 0:
            var disabledFileName = disabledDic["path"];
            var disabledFileName_tp = disabledFileName ? this._filePath + disabledFileName : null;
            button.loadTextureDisabled(disabledFileName_tp);
            break;
        case 1:
            var disabledFileName = disabledDic["path"];
            button.loadTextureDisabled(disabledFileName, ccui.Widget.PLIST_TEXTURE);
            break;
        default:
            break
    }
    disabledDic = null;
    if (scale9Enable) {
        var cx = options["capInsetsX"];
        var cy = options["capInsetsY"];
        var cw = options["capInsetsWidth"];
        var ch = options["capInsetsHeight"];
        button.setCapInsets(cc.rect(cx,
            cy, cw, ch));
        if (options["scale9Width"] !== undefined && options["scale9Height"] !== undefined) {
            var swf = options["scale9Width"];
            var shf = options["scale9Height"];
            button.setSize(cc.size(swf, shf))
        }
    }
    if (options["text"] !== undefined) {
        var text = options["text"] || "";
        if (text)button.setTitleText(text)
    }
    if (options["fontSize"] !== undefined)button.setTitleFontSize(options["fontSize"]);
    if (options["fontName"] !== undefined)button.setTitleFontName(options["fontName"]);
    var cr = options["textColorR"] !== undefined ? options["textColorR"] :
        255;
    var cg = options["textColorG"] !== undefined ? options["textColorG"] : 255;
    var cb = options["textColorB"] !== undefined ? options["textColorB"] : 255;
    var tc = cc.color(cr, cg, cb);
    button.setTitleColor(tc);
    this.setColorPropsForWidgetFromJsonDictionary(widget, options)
}, setPropsForCheckBoxFromJsonDictionary: function (widget, options) {
    this.setPropsForWidgetFromJsonDictionary(widget, options);
    var checkBox = widget;
    var backGroundDic = options["backGroundBoxData"];
    var backGroundType = backGroundDic["resourceType"];
    switch (backGroundType) {
        case 0:
            var backGroundFileName =
                backGroundDic["path"];
            var backGroundFileName_tp = backGroundFileName ? this._filePath + backGroundFileName : null;
            checkBox.loadTextureBackGround(backGroundFileName_tp);
            break;
        case 1:
            var backGroundFileName = backGroundDic["path"];
            checkBox.loadTextureBackGround(backGroundFileName, ccui.Widget.PLIST_TEXTURE);
            break;
        default:
            break
    }
    backGroundDic = null;
    var backGroundSelectedDic = options["backGroundBoxSelectedData"];
    var backGroundSelectedType = backGroundSelectedDic["resourceType"];
    switch (backGroundSelectedType) {
        case 0:
            var backGroundSelectedFileName =
                backGroundSelectedDic["path"];
            var backGroundSelectedFileName_tp = backGroundSelectedFileName ? this._filePath + backGroundSelectedFileName : null;
            checkBox.loadTextureBackGroundSelected(backGroundSelectedFileName_tp);
            break;
        case 1:
            var backGroundSelectedFileName = backGroundSelectedDic["path"];
            checkBox.loadTextureBackGroundSelected(backGroundSelectedFileName, ccui.Widget.PLIST_TEXTURE);
            break;
        default:
            break
    }
    backGroundSelectedDic = null;
    var frontCrossDic = options["frontCrossData"];
    var frontCrossType = frontCrossDic["resourceType"];
    switch (frontCrossType) {
        case 0:
            var frontCrossFileName = frontCrossDic["path"];
            var frontCrossFileName_tp = frontCrossFileName ? this._filePath + frontCrossFileName : null;
            checkBox.loadTextureFrontCross(frontCrossFileName_tp);
            break;
        case 1:
            var frontCrossFileName = frontCrossDic["path"];
            checkBox.loadTextureFrontCross(frontCrossFileName, ccui.Widget.PLIST_TEXTURE);
            break;
        default:
            break
    }
    frontCrossDic = null;
    var backGroundDisabledDic = options["backGroundBoxDisabledData"];
    var backGroundDisabledType = backGroundDisabledDic["resourceType"];
    switch (backGroundDisabledType) {
        case 0:
            var backGroundDisabledFileName = backGroundDisabledDic["path"];
            var backGroundDisabledFileName_tp = backGroundDisabledFileName ? this._filePath + backGroundDisabledFileName : null;
            checkBox.loadTextureBackGroundDisabled(backGroundDisabledFileName_tp);
            break;
        case 1:
            var backGroundDisabledFileName = backGroundDisabledDic["path"];
            checkBox.loadTextureBackGroundDisabled(backGroundDisabledFileName, ccui.Widget.PLIST_TEXTURE);
            break;
        default:
            break
    }
    backGroundDisabledDic = null;
    var frontCrossDisabledDic =
        options["frontCrossDisabledData"];
    var frontCrossDisabledType = frontCrossDisabledDic["resourceType"];
    switch (frontCrossDisabledType) {
        case 0:
            var frontCrossDisabledFileName = options["path"];
            var frontCrossDisabledFileName_tp = frontCrossDisabledFileName ? this._filePath + frontCrossDisabledFileName : null;
            checkBox.loadTextureFrontCrossDisabled(frontCrossDisabledFileName_tp);
            break;
        case 1:
            var frontCrossDisabledFileName = options["path"];
            checkBox.loadTextureFrontCrossDisabled(frontCrossDisabledFileName, ccui.Widget.PLIST_TEXTURE);
            break;
        default:
            break
    }
    frontCrossDisabledDic = null;
    var selectedState = options["selectedState"] || false;
    widget.setSelectedState(selectedState);
    checkBox.setSelectedState(options, "selectedState");
    this.setColorPropsForWidgetFromJsonDictionary(widget, options)
}, setPropsForImageViewFromJsonDictionary: function (widget, options) {
    this.setPropsForWidgetFromJsonDictionary(widget, options);
    var imageView = widget;
    var imageFileNameDic = options["fileNameData"];
    var imageFileNameType = imageFileNameDic["resourceType"];
    switch (imageFileNameType) {
        case 0:
            var tp_i =
                this._filePath;
            var imageFileName = imageFileNameDic["path"];
            var imageFileName_tp = null;
            if (imageFileName) {
                imageFileName_tp = tp_i + imageFileName;
                imageView.loadTexture(imageFileName_tp)
            }
            break;
        case 1:
            var imageFileName = imageFileNameDic["path"];
            imageView.loadTexture(imageFileName, ccui.Widget.PLIST_TEXTURE);
            break;
        default:
            break
    }
    imageFileNameDic = null;
    var scale9Enable = options["scale9Enable"] || false;
    imageView.setScale9Enabled(scale9Enable);
    if (scale9Enable) {
        if (options["scale9Width"] !== undefined && options["scale9Height"] !==
            undefined) {
            var swf = options["scale9Width"];
            var shf = options["scale9Height"];
            imageView.setSize(cc.size(swf, shf))
        }
        var cx = options["capInsetsX"];
        var cy = options["capInsetsY"];
        var cw = options["capInsetsWidth"];
        var ch = options["capInsetsHeight"];
        imageView.setCapInsets(cc.rect(cx, cy, cw, ch))
    }
    this.setColorPropsForWidgetFromJsonDictionary(widget, options)
}, setPropsForLabelFromJsonDictionary: function (widget, options) {
    this.setPropsForWidgetFromJsonDictionary(widget, options);
    var label = widget;
    var touchScaleChangeAble =
        options["touchScaleEnable"];
    label.setTouchScaleChangeEnabled(touchScaleChangeAble);
    var text = options["text"];
    label.setString(text);
    if (options["fontSize"] !== undefined)label.setFontSize(options["fontSize"]);
    if (options["fontName"] !== undefined)label.setFontName(options["fontName"]);
    if (options["areaWidth"] !== undefined && options["areaHeight"] !== undefined) {
        var size = cc.size(options["areaWidth"], options["areaHeight"]);
        label.setTextAreaSize(size)
    }
    if (options["hAlignment"])label.setTextHorizontalAlignment(options["hAlignment"]);
    if (options["vAlignment"])label.setTextVerticalAlignment(options["vAlignment"]);
    this.setColorPropsForWidgetFromJsonDictionary(widget, options)
}, setPropsForLabelAtlasFromJsonDictionary: function (widget, options) {
    this.setPropsForWidgetFromJsonDictionary(widget, options);
    var labelAtlas = widget;
    var sv = options["stringValue"] !== undefined;
    var cmf = options["charMapFile"] !== undefined;
    var iw = options["itemWidth"] !== undefined;
    var ih = options["itemHeight"] !== undefined;
    var scm = options["startCharMap"] !== undefined;
    if (sv &&
        cmf && iw && ih && scm) {
        var cmftDic = options["charMapFileData"];
        var cmfType = cmftDic["resourceType"];
        switch (cmfType) {
            case 0:
                var cmfPath = cmftDic["path"];
                var cmf_tp = this._filePath + cmfPath;
                labelAtlas.setProperty(options["stringValue"], cmf_tp, options["itemWidth"], options["itemHeight"], options["startCharMap"]);
                break;
            case 1:
                cc.log("Wrong res type of LabelAtlas!");
                break;
            default:
                break
        }
        cmftDic = null
    }
    this.setColorPropsForWidgetFromJsonDictionary(widget, options)
}, setPropsForLayoutFromJsonDictionary: function (widget, options) {
    this.setPropsForWidgetFromJsonDictionary(widget,
        options);
    var panel = widget;
    if (!(panel instanceof ccui.ScrollView) && !(panel instanceof ccui.ListView))panel.setClippingEnabled(options["clipAble"]);
    var backGroundScale9Enable = options["backGroundScale9Enable"];
    panel.setBackGroundImageScale9Enabled(backGroundScale9Enable);
    var cr = options["bgColorR"];
    var cg = options["bgColorG"];
    var cb = options["bgColorB"];
    var scr = options["bgStartColorR"];
    var scg = options["bgStartColorG"];
    var scb = options["bgStartColorB"];
    var ecr = options["bgEndColorR"];
    var ecg = options["bgEndColorG"];
    var ecb = options["bgEndColorB"];
    var bgcv1 = options["vectorX"];
    var bgcv2 = options["vectorY"];
    panel.setBackGroundColorVector(cc.p(bgcv1, bgcv2));
    var co = options["bgColorOpacity"];
    var colorType = options["colorType"];
    panel.setBackGroundColorType(colorType);
    panel.setBackGroundColor(cc.color(scr, scg, scb), cc.color(ecr, ecg, ecb));
    panel.setBackGroundColor(cc.color(cr, cg, cb));
    panel.setBackGroundColorOpacity(co);
    var imageFileNameDic = options["backGroundImageData"] || {};
    var imageFileNameType = imageFileNameDic["resourceType"];
    switch (imageFileNameType) {
        case 0:
            var imageFileName = imageFileNameDic["path"];
            var imageFileName_tp = imageFileName ? this._filePath + imageFileName : null;
            panel.setBackGroundImage(imageFileName_tp);
            break;
        case 1:
            var imageFileName = imageFileNameDic["path"];
            panel.setBackGroundImage(imageFileName, ccui.Widget.PLIST_TEXTURE);
            break;
        default:
            break
    }
    imageFileNameDic = null;
    if (backGroundScale9Enable) {
        var cx = options["capInsetsX"];
        var cy = options["capInsetsY"];
        var cw = options["capInsetsWidth"];
        var ch = options["capInsetsHeight"];
        panel.setBackGroundImageCapInsets(cc.rect(cx, cy, cw, ch))
    }
    panel.setLayoutType(options["layoutType"]);
    this.setColorPropsForWidgetFromJsonDictionary(widget, options)
}, setPropsForScrollViewFromJsonDictionary: function (widget, options) {
    this.setPropsForLayoutFromJsonDictionary(widget, options);
    var scrollView = widget;
    var innerWidth = options["innerWidth"];
    var innerHeight = options["innerHeight"];
    scrollView.setInnerContainerSize(cc.size(innerWidth, innerHeight));
    var direction = options["direction"];
    scrollView.setDirection(direction);
    scrollView.setBounceEnabled(options["bounceEnable"]);
    this.setColorPropsForWidgetFromJsonDictionary(widget, options)
}, setPropsForSliderFromJsonDictionary: function (widget, options) {
    this.setPropsForWidgetFromJsonDictionary(widget, options);
    var slider = widget;
    var barTextureScale9Enable = options["barTextureScale9Enable"] || false;
    slider.setScale9Enabled(barTextureScale9Enable);
    var barLength = options["length"];
    var bt = options["barFileName"] !== undefined;
    if (bt)if (barTextureScale9Enable) {
        var imageFileNameDic = options["barFileNameData"];
        var imageFileType = imageFileNameDic["resourceType"];
        switch (imageFileType) {
            case 0:
                var imageFileName = imageFileNameDic["path"];
                var imageFileName_tp = imageFileName ? this._filePath + imageFileName : null;
                slider.loadBarTexture(imageFileName_tp);
                break;
            case 1:
                var imageFileName = imageFileNameDic["path"];
                slider.loadBarTexture(imageFileName, ccui.Widget.PLIST_TEXTURE);
                break;
            default:
                break
        }
        slider.setSize(cc.size(barLength, slider.getContentSize().height));
        imageFileNameDic = null
    } else {
        var imageFileNameDic = options["barFileNameData"];
        var imageFileType = imageFileNameDic["resourceType"];
        switch (imageFileType) {
            case 0:
                var imageFileName = imageFileNameDic["path"];
                var imageFileName_tp = imageFileName ? this._filePath + imageFileName : null;
                slider.loadBarTexture(imageFileName_tp);
                break;
            case 1:
                var imageFileName = imageFileNameDic["path"];
                slider.loadBarTexture(imageFileName, ccui.Widget.PLIST_TEXTURE);
                break;
            default:
                break
        }
        imageFileNameDic = null
    }
    var normalDic = options["ballNormalData"];
    var normalType = normalDic["resourceType"];
    switch (normalType) {
        case 0:
            var normalFileName =
                normalDic["path"];
            var normalFileName_tp = normalFileName ? this._filePath + normalFileName : null;
            slider.loadSlidBallTextureNormal(normalFileName_tp);
            break;
        case 1:
            var normalFileName = normalDic["path"];
            slider.loadSlidBallTextureNormal(normalFileName, ccui.Widget.PLIST_TEXTURE);
            break;
        default:
            break
    }
    normalDic = null;
    var pressedDic = options["ballPressedData"];
    var pressedType = pressedDic["resourceType"];
    switch (pressedType) {
        case 0:
            var pressedFileName = pressedDic["path"];
            var pressedFileName_tp = pressedFileName ? this._filePath +
                pressedFileName : null;
            slider.loadSlidBallTexturePressed(pressedFileName_tp);
            break;
        case 1:
            var pressedFileName = pressedDic["path"];
            slider.loadSlidBallTexturePressed(pressedFileName, ccui.Widget.PLIST_TEXTURE);
            break;
        default:
            break
    }
    pressedDic = null;
    var disabledDic = options["ballDisabledData"];
    var disabledType = disabledDic["resourceType"];
    switch (disabledType) {
        case 0:
            var disabledFileName = disabledDic["path"];
            var disabledFileName_tp = disabledFileName ? this._filePath + disabledFileName : null;
            slider.loadSlidBallTextureDisabled(disabledFileName_tp);
            break;
        case 1:
            var disabledFileName = disabledDic["path"];
            slider.loadSlidBallTextureDisabled(disabledFileName, ccui.Widget.PLIST_TEXTURE);
            break;
        default:
            break
    }
    disabledDic = null;
    var progressBarDic = options["progressBarData"];
    var progressBarType = progressBarDic["resourceType"];
    switch (progressBarType) {
        case 0:
            var imageFileName = progressBarDic["path"];
            var imageFileName_tp = imageFileName ? this._filePath + imageFileName : null;
            slider.loadProgressBarTexture(imageFileName_tp);
            break;
        case 1:
            var imageFileName = progressBarDic["path"];
            slider.loadProgressBarTexture(imageFileName, ccui.Widget.PLIST_TEXTURE);
            break;
        default:
            break
    }
    this.setColorPropsForWidgetFromJsonDictionary(widget, options);
    slider.setPercent(options["percent"])
}, setPropsForTextAreaFromJsonDictionary: function (widget, options) {
    this.setPropsForWidgetFromJsonDictionary(widget, options);
    var textArea = widget;
    textArea.setString(options["text"]);
    if (options["fontSize"] !== undefined)textArea.setFontSize(options["fontSize"]);
    var cr = options["colorR"];
    var cg = options["colorG"];
    var cb =
        options["colorB"];
    textArea.setColor(cc.color(cr, cg, cb));
    textArea.setFontName(options["fontName"]);
    if (options["areaWidth"] !== undefined && options["areaHeight"] !== undefined) {
        var size = cc.size(options["areaWidth"], options["areaHeight"]);
        textArea.setTextAreaSize(size)
    }
    if (options["hAlignment"])textArea.setTextHorizontalAlignment(options["hAlignment"]);
    if (options["vAlignment"])textArea.setTextVerticalAlignment(options["vAlignment"]);
    this.setColorPropsForWidgetFromJsonDictionary(widget, options)
}, setPropsForTextButtonFromJsonDictionary: function (widget, options) {
    this.setPropsForButtonFromJsonDictionary(widget, options);
    var textButton = widget;
    textButton.setTitleText(options["text"] || "");
    var cri = options["textColorR"] !== undefined ? options["textColorR"] : 255;
    var cgi = options["textColorG"] !== undefined ? options["textColorG"] : 255;
    var cbi = options["textColorB"] !== undefined ? options["textColorB"] : 255;
    textButton.setTitleColor(cc.color(cri, cgi, cbi));
    if (options["fontSize"] !== undefined)textButton.setTitleFontSize(options["fontSize"]);
    if (options["fontName"] !== undefined)textButton.setTitleFontName(options["fontName"]);
    this.setColorPropsForWidgetFromJsonDictionary(widget, options)
}, setPropsForTextFieldFromJsonDictionary: function (widget, options) {
    this.setPropsForWidgetFromJsonDictionary(widget, options);
    var textField = widget;
    if (options["placeHolder"] !== undefined)textField.setPlaceHolder(options["placeHolder"]);
    textField.setString(options["text"]);
    if (options["fontSize"] !== undefined)textField.setFontSize(options["fontSize"]);
    if (options["fontName"] !== undefined)textField.setFontName(options["fontName"]);
    if (options["touchSizeWidth"] !==
        undefined && options["touchSizeHeight"] !== undefined)textField.setTouchSize(cc.size(options["touchSizeWidth"], options["touchSizeHeight"]));
    var dw = options["width"];
    var dh = options["height"];
    if (dw > 0 || dh > 0);
    var maxLengthEnable = options["maxLengthEnable"];
    textField.setMaxLengthEnabled(maxLengthEnable);
    if (maxLengthEnable) {
        var maxLength = options["maxLength"];
        textField.setMaxLength(maxLength)
    }
    var passwordEnable = options["passwordEnable"];
    textField.setPasswordEnabled(passwordEnable);
    if (passwordEnable)textField.setPasswordStyleText(options["passwordStyleText"]);
    this.setColorPropsForWidgetFromJsonDictionary(widget, options)
}, setPropsForLoadingBarFromJsonDictionary: function (widget, options) {
    this.setPropsForWidgetFromJsonDictionary(widget, options);
    var loadingBar = widget;
    var imageFileNameDic = options["textureData"];
    var imageFileNameType = imageFileNameDic["resourceType"];
    switch (imageFileNameType) {
        case 0:
            var tp_i = this._filePath;
            var imageFileName = imageFileNameDic["path"];
            var imageFileName_tp = null;
            if (imageFileName) {
                imageFileName_tp = tp_i + imageFileName;
                loadingBar.loadTexture(imageFileName_tp)
            }
            break;
        case 1:
            var imageFileName = imageFileNameDic["path"];
            loadingBar.loadTexture(imageFileName, ccui.Widget.PLIST_TEXTURE);
            break;
        default:
            break
    }
    imageFileNameDic = null;
    var scale9Enable = options["scale9Enable"];
    loadingBar.setScale9Enabled(scale9Enable);
    if (scale9Enable) {
        var cx = options["capInsetsX"];
        var cy = options["capInsetsY"];
        var cw = options["capInsetsWidth"];
        var ch = options["capInsetsHeight"];
        loadingBar.setCapInsets(cc.rect(cx, cy, cw, ch));
        var width = options["width"];
        var height = options["height"];
        loadingBar.setSize(cc.size(width,
            height))
    }
    loadingBar.setDirection(options["direction"]);
    loadingBar.setPercent(options["percent"]);
    this.setColorPropsForWidgetFromJsonDictionary(widget, options)
}, setPropsForListViewFromJsonDictionary: function (widget, options) {
    this.setPropsForLayoutFromJsonDictionary(widget, options);
    var innerWidth = options["innerWidth"] || 0;
    var innerHeight = options["innerHeight"] || 0;
    widget.setInnerContainerSize(cc.size(innerWidth, innerHeight));
    widget.setDirection(options["direction"] || 0);
    widget.setGravity(options["gravity"] ||
        0);
    widget.setItemsMargin(options["itemMargin"] || 0)
}, setPropsForPageViewFromJsonDictionary: function (widget, options) {
    this.setPropsForLayoutFromJsonDictionary(widget, options)
}, setPropsForLabelBMFontFromJsonDictionary: function (widget, options) {
    this.setPropsForWidgetFromJsonDictionary(widget, options);
    var labelBMFont = widget;
    var cmftDic = options["fileNameData"];
    var cmfType = cmftDic["resourceType"];
    switch (cmfType) {
        case 0:
            var cmfPath = cmftDic["path"];
            var cmf_tp = this._filePath + cmfPath;
            labelBMFont.setFntFile(cmf_tp);
            break;
        case 1:
            cc.log("Wrong res type of LabelAtlas!");
            break;
        default:
            break
    }
    cmftDic = null;
    var text = options["text"];
    labelBMFont.setString(text);
    this.setColorPropsForWidgetFromJsonDictionary(widget, options)
}});
ccs.sceneReader = {_baseBath: "", _listener: null, _selector: null, _node: null, createNodeWithSceneFile: function (pszFileName) {
    this._node = null;
    do {
        this._baseBath = cc.path.dirname(pszFileName);
        var jsonDict = cc.loader.getRes(pszFileName);
        if (!jsonDict)throw"Please load the resource first : " + pszFileName;
        this._node = this.createObject(jsonDict, null);
        ccs.triggerManager.parse(jsonDict["Triggers"] || [])
    } while (0);
    return this._node
}, createObject: function (inputFiles, parenet) {
    var className = inputFiles["classname"];
    if (className ==
        "CCNode") {
        var gb = null;
        if (!parenet)gb = cc.Node.create(); else {
            gb = cc.Node.create();
            parenet.addChild(gb)
        }
        this.setPropertyFromJsonDict(gb, inputFiles);
        var components = inputFiles["components"];
        for (var i = 0; i < components.length; i++) {
            var subDict = components[i];
            if (!subDict)break;
            var className = subDict["classname"];
            var comName = subDict["name"];
            var fileData = subDict["fileData"];
            var path = "", plistFile = "";
            var resType = 0;
            if (fileData != null) {
                if (fileData["resourceType"] !== undefined)resType = fileData["resourceType"]; else resType = -1;
                path = cc.path.join(this._baseBath, fileData["path"]);
                plistFile = fileData["plistFile"]
            }
            var pathExtname = cc.path.extname(path);
            if (className == "CCSprite") {
                var sprite = null;
                if (resType == 0) {
                    if (pathExtname != ".png")continue;
                    sprite = cc.Sprite.create(path)
                } else if (resType == 1) {
                    if (pathExtname != ".plist")continue;
                    plistFile = cc.path.join(this._baseBath, plistFile);
                    var pngFile = cc.path.changeExtname(plistFile, ".png");
                    cc.spriteFrameCache.addSpriteFrames(plistFile, pngFile);
                    sprite = cc.Sprite.create("#" + fileData["path"])
                } else continue;
                var render = ccs.ComRender.create(sprite, "CCSprite");
                if (comName != null)render.setName(comName);
                gb.addComponent(render);
                this._callSelector(sprite, subDict)
            } else if (className == "CCTMXTiledMap") {
                var tmx = null;
                if (resType == 0) {
                    if (pathExtname != ".tmx")continue;
                    tmx = cc.TMXTiledMap.create(path)
                } else continue;
                var render = ccs.ComRender.create(tmx, "CCTMXTiledMap");
                if (comName != null)render.setName(comName);
                gb.addComponent(render);
                this._callSelector(tmx, subDict)
            } else if (className == "CCParticleSystemQuad") {
                if (pathExtname !=
                    ".plist")continue;
                var particle = null;
                if (resType == 0)particle = cc.ParticleSystem.create(path); else {
                    cc.log("unknown resourcetype on CCParticleSystemQuad!");
                    continue
                }
                particle.setPosition(0, 0);
                var render = ccs.ComRender.create(particle, "CCParticleSystemQuad");
                if (comName != null)render.setName(comName);
                gb.addComponent(render);
                this._callSelector(particle, subDict)
            } else if (className == "CCArmature") {
                if (resType != 0)continue;
                var jsonDict = cc.loader.getRes(path);
                if (!jsonDict)cc.log("Please load the resource [%s] first!",
                    path);
                var armature_data = jsonDict["armature_data"];
                var subData = armature_data[0];
                var name = subData["name"];
                ccs.armatureDataManager.addArmatureFileInfo(path);
                var armature = ccs.Armature.create(name);
                var render = ccs.ComRender.create(armature, "CCArmature");
                if (comName != null)render.setName(comName);
                gb.addComponent(render);
                var actionName = subDict["selectedactionname"];
                if (actionName && armature.getAnimation())armature.getAnimation().play(actionName);
                jsonDict = null;
                subData = null;
                this._callSelector(armature, subDict)
            } else if (className ==
                "CCComAudio") {
                var audio = null;
                if (resType == 0)audio = ccs.ComAudio.create(); else continue;
                audio.preloadEffect(path);
                if (comName)audio.setName(comName);
                gb.addComponent(audio);
                this._callSelector(audio, subDict)
            } else if (className == "CCComAttribute") {
                var attribute = null;
                if (resType == 0) {
                    attribute = ccs.ComAttribute.create();
                    if (path != "")attribute.parse(path)
                } else {
                    cc.log("unknown resourcetype on CCComAttribute!");
                    continue
                }
                if (comName)attribute.setName(comName);
                gb.addComponent(attribute);
                this._callSelector(attribute,
                    subDict)
            } else if (className == "CCBackgroundAudio") {
                if (!pathExtname)continue;
                if (resType != 0)continue;
                var audio = ccs.ComAudio.create();
                audio.preloadBackgroundMusic(path);
                audio.setFile(path);
                var bLoop = Boolean(subDict["loop"] || 0);
                audio.setLoop(bLoop);
                if (comName)audio.setName(comName);
                gb.addComponent(audio);
                audio.playBackgroundMusic(path, bLoop);
                this._callSelector(audio, subDict)
            } else if (className == "GUIComponent") {
                var widget = ccs.uiReader.widgetFromJsonFile(path);
                var render = ccs.ComRender.create(widget, "GUIComponent");
                if (comName != null)render.setName(comName);
                gb.addComponent(render);
                this._callSelector(audio, subDict)
            }
            subDict = null
        }
        var gameobjects = inputFiles["gameobjects"];
        for (var i = 0; i < gameobjects.length; i++) {
            var subDict = gameobjects[i];
            if (!subDict)break;
            this.createObject(subDict, gb);
            subDict = null
        }
        return gb
    }
    return null
}, nodeByTag: function (parent, tag) {
    if (parent == null)return null;
    var retNode = null;
    var children = parent.getChildren();
    for (var i = 0; i < children.length; i++) {
        var child = children[i];
        if (child && child.getTag() == tag) {
            retNode =
                child;
            break
        } else {
            retNode = this.nodeByTag(child, tag);
            if (retNode)break
        }
    }
    return retNode
}, getNodeByTag: function (tag) {
    if (this._node == null)return null;
    if (this._node.getTag() == tag)return this._node;
    return this.nodeByTag(this._node, tag)
}, setPropertyFromJsonDict: function (node, dict) {
    var x = typeof dict["x"] === "undefined" ? 0 : dict["x"];
    var y = typeof dict["y"] === "undefined" ? 0 : dict["y"];
    node.setPosition(x, y);
    var bVisible = Boolean(typeof dict["visible"] === "undefined" ? 1 : dict["visible"]);
    node.setVisible(bVisible);
    var nTag =
            typeof dict["objecttag"] === "undefined" ? -1 : dict["objecttag"];
    node.setTag(nTag);
    var nZorder = typeof dict["zorder"] === "undefined" ? 0 : dict["zorder"];
    node.setLocalZOrder(nZorder);
    var fScaleX = typeof dict["scalex"] === "undefined" ? 1 : dict["scalex"];
    var fScaleY = typeof dict["scaley"] === "undefined" ? 1 : dict["scaley"];
    node.setScaleX(fScaleX);
    node.setScaleY(fScaleY);
    var fRotationZ = typeof dict["rotation"] === "undefined" ? 0 : dict["rotation"];
    node.setRotation(fRotationZ)
}, setTarget: function (selector, listener) {
    this._listener =
        listener;
    this._selector = selector
}, _callSelector: function (obj, subDict) {
    if (this._selector)this._selector.call(this._listener, obj, subDict)
}, version: function () {
    return"1.2.0.0"
}, clear: function () {
    ccs.triggerManager.removeAll();
    cc.audioEngine.end()
}};
ccs.WidgetReaderProtocol = ccs.Class.extend({setPropsFromJsonDictionary: function (widget, options) {
}});
ccs.WidgetReader = {getInstance: function () {
    return ccs.WidgetReader
}, setPropsFromJsonDictionary: function (widget, options) {
    var ignoreSizeExsit = options["ignoreSize"];
    if (ignoreSizeExsit)widget.ignoreContentAdaptWithSize(ignoreSizeExsit);
    widget.setSizeType(options["sizeType"]);
    widget.setPositionType(options["positionType"]);
    widget.setSizePercent(cc.p(options["sizePercentX"], options["sizePercentY"]));
    widget.setPositionPercent(cc.p(options["positionPercentX"], options["positionPercentY"]));
    var w = options["width"];
    var h = options["height"];
    widget.setSize(cc.size(w, h));
    widget.setTag(options["tag"]);
    widget.setActionTag(options["actiontag"]);
    widget.setTouchEnabled(options["touchAble"]);
    var name = options["name"];
    var widgetName = name ? name : "default";
    widget.setName(widgetName);
    var x = options["x"];
    var y = options["y"];
    widget.setPosition(cc.p(x, y));
    var sx = options["scalex"];
    if (sx)widget.setScaleX(sx);
    var sy = options["scaleY"];
    if (sy)widget.setScaleY(sy);
    var rt = options["rotation"];
    if (rt)widget.setRotation(rt);
    var vb = options["visible"];
    if (vb)widget.setVisible(vb);
    widget.setLocalZOrder(options["ZOrder"]);
    var layout = options["layoutParameter"];
    if (layout) {
        var layoutParameterDic = options["layoutParameter"];
        var paramType = layoutParameterDic["type"];
        var parameter = null;
        switch (paramType) {
            case 0:
                break;
            case 1:
                parameter = new ccui.LinearLayoutParameter;
                var gravity = layoutParameterDic["gravity"];
                parameter.setGravity(gravity);
                break;
            case 2:
                parameter = new ccui.RelativeLayoutParameter;
                var rParameter = parameter;
                var relativeName = layoutParameterDic["relativeName"];
                rParameter.setRelativeName(relativeName);
                var relativeToName = layoutParameterDic["relativeToName"];
                rParameter.setRelativeToWidgetName(relativeToName);
                var align = layoutParameterDic["align"];
                rParameter.setAlign(align);
                break;
            default:
                break
        }
        if (parameter) {
            var mgl = layoutParameterDic["marginLeft"];
            var mgt = layoutParameterDic["marginTop"];
            var mgr = layoutParameterDic["marginRight"];
            var mgb = layoutParameterDic["marginDown"];
            parameter.setMargin(mgl, mgt, mgr, mgb);
            widget.setLayoutParameter(parameter)
        }
    }
}, setColorPropsFromJsonDictionary: function (widget, options) {
    var op = options["opacity"];
    if (op)widget.setOpacity(op);
    var colorR = options["colorR"] || 255;
    var colorG = options["colorG"] || 255;
    var colorB = options["colorB"] || 255;
    widget.setColor(cc.color(colorR, colorG, colorB));
    var apx = options["anchorPointX"];
    var apxf = apx || (widget.getWidgetType() === ccs.WidgetType ? 0.5 : 0);
    var apy = options["anchorPointY"];
    var apyf = apy || (widget.getWidgetType() === ccs.WidgetType ? 0.5 : 0);
    widget.setAnchorPoint(cc.p(apxf, apyf))
}};
ccs.ButtonReader = {getInstance: function () {
    return ccs.ButtonReader
}, setPropsFromJsonDictionary: function (widget, options) {
    ccs.WidgetReader.setPropsFromJsonDictionary.call(this, widget, options);
    var jsonPath = ccs.uiReader.getFilePath();
    var button = widget;
    var scale9Enable = options["scale9Enable"];
    button.setScale9Enabled(scale9Enable);
    var normalDic = options["normalData"];
    var normalType = normalDic["resourceType"];
    switch (normalType) {
        case 0:
            var tp_n = jsonPath;
            var normalFileName = normalDic["path"];
            var normalFileName_tp =
                    normalFileName && normalFileName !== "" ? tp_n + normalFileName : null;
            button.loadTextureNormal(normalFileName_tp);
            break;
        case 1:
            var normalFileName = normalDic["path"];
            button.loadTextureNormal(normalFileName, 1);
            break;
        default:
            break
    }
    var pressedDic = options["pressedData"];
    var pressedType = pressedDic["resourceType"];
    switch (pressedType) {
        case 0:
            var tp_p = jsonPath;
            var pressedFileName = pressedDic["path"];
            var pressedFileName_tp = pressedFileName && pressedFileName !== "" ? tp_p + pressedFileName : null;
            button.loadTexturePressed(pressedFileName_tp);
            break;
        case 1:
            var pressedFileName = pressedDic["path"];
            button.loadTexturePressed(pressedFileName, 1);
            break;
        default:
            break
    }
    var disabledDic = options["disabledData"];
    var disabledType = disabledDic["resourceType"];
    switch (disabledType) {
        case 0:
            var tp_d = jsonPath;
            var disabledFileName = disabledDic["path"];
            var disabledFileName_tp = disabledFileName && disabledFileName !== "" ? tp_d + disabledFileName : null;
            button.loadTextureDisabled(disabledFileName_tp);
            break;
        case 1:
            var disabledFileName = disabledDic["path"];
            button.loadTextureDisabled(disabledFileName,
                1);
            break;
        default:
            break
    }
    if (scale9Enable) {
        var cx = options["capInsetsX"];
        var cy = options["capInsetsY"];
        var cw = options["capInsetsWidth"];
        var ch = options["capInsetsHeight"];
        button.setCapInsets(cc.rect(cx, cy, cw, ch));
        var sw = options["scale9Width"];
        var sh = options["scale9Height"];
        if (sw && sh) {
            var swf = options["scale9Width"];
            var shf = options["scale9Height"];
            button.setSize(cc.size(swf, shf))
        }
    }
    var tt = options["text"];
    if (tt) {
        var text = options["text"];
        if (text)button.setTitleText(text)
    }
    var cr = options["textColorR"];
    var cg =
        options["textColorG"];
    var cb = options["textColorB"];
    var cri = cr ? options["textColorR"] : 255;
    var cgi = cg ? options["textColorG"] : 255;
    var cbi = cb ? options["textColorB"] : 255;
    button.setTitleColor(cc.color(cri, cgi, cbi));
    var fs = options["fontSize"];
    if (fs)button.setTitleFontSize(options["fontSize"]);
    var fn = options["fontName"];
    if (fn)button.setTitleFontName(options["fontName"]);
    ccs.WidgetReader.setColorPropsFromJsonDictionary.call(this, widget, options)
}};
ccs.CheckBoxReader = {getInstance: function () {
    return ccs.CheckBoxReader
}, setPropsFromJsonDictionary: function (widget, options) {
    ccs.WidgetReader.setPropsFromJsonDictionary.call(this, widget, options);
    var jsonPath = ccs.uiReader.getFilePath();
    var checkBox = widget;
    var backGroundDic = options["backGroundBoxData"];
    var backGroundType = backGroundDic["resourceType"];
    switch (backGroundType) {
        case 0:
            var tp_b = jsonPath;
            var backGroundFileName = backGroundDic["path"];
            var backGroundFileName_tp = backGroundFileName && backGroundFileName !==
                "" ? tp_b + backGroundFileName : null;
            checkBox.loadTextureBackGround(backGroundFileName_tp);
            break;
        case 1:
            var backGroundFileName = backGroundDic["path"];
            checkBox.loadTextureBackGround(backGroundFileName, 1);
            break;
        default:
            break
    }
    var backGroundSelectedDic = options["backGroundBoxSelectedData"];
    var backGroundSelectedType = backGroundSelectedDic["resourceType"];
    switch (backGroundSelectedType) {
        case 0:
            var tp_bs = jsonPath;
            var backGroundSelectedFileName = backGroundSelectedDic["path"];
            var backGroundSelectedFileName_tp = backGroundSelectedFileName &&
                backGroundSelectedFileName !== "" ? tp_bs + backGroundSelectedFileName : null;
            checkBox.loadTextureBackGroundSelected(backGroundSelectedFileName_tp);
            break;
        case 1:
            var backGroundSelectedFileName = backGroundSelectedDic["path"];
            checkBox.loadTextureBackGroundSelected(backGroundSelectedFileName, 1);
            break;
        default:
            break
    }
    var frontCrossDic = options["frontCrossData"];
    var frontCrossType = frontCrossDic["resourceType"];
    switch (frontCrossType) {
        case 0:
            var tp_c = jsonPath;
            var frontCrossFileName = frontCrossDic["path"];
            var frontCrossFileName_tp =
                    frontCrossFileName && frontCrossFileName !== "" ? tp_c + frontCrossFileName : null;
            checkBox.loadTextureFrontCross(frontCrossFileName_tp);
            break;
        case 1:
            var frontCrossFileName = frontCrossDic["path"];
            checkBox.loadTextureFrontCross(frontCrossFileName, 1);
            break;
        default:
            break
    }
    var backGroundDisabledDic = options["backGroundBoxDisabledData"];
    var backGroundDisabledType = backGroundDisabledDic["resourceType"];
    switch (backGroundDisabledType) {
        case 0:
            var tp_bd = jsonPath;
            var backGroundDisabledFileName = backGroundDisabledDic["path"];
            var backGroundDisabledFileName_tp = backGroundDisabledFileName && backGroundDisabledFileName !== "" ? tp_bd + backGroundDisabledFileName : null;
            checkBox.loadTextureBackGroundDisabled(backGroundDisabledFileName_tp);
            break;
        case 1:
            var backGroundDisabledFileName = backGroundDisabledDic["path"];
            checkBox.loadTextureBackGroundDisabled(backGroundDisabledFileName, 1);
            break;
        default:
            break
    }
    var frontCrossDisabledDic = options["frontCrossDisabledData"];
    var frontCrossDisabledType = frontCrossDisabledDic["resourceType"];
    switch (frontCrossDisabledType) {
        case 0:
            var tp_cd =
                jsonPath;
            var frontCrossDisabledFileName = options["path"];
            var frontCrossDisabledFileName_tp = frontCrossDisabledFileName && frontCrossDisabledFileName !== "" ? tp_cd + frontCrossDisabledFileName : null;
            checkBox.loadTextureFrontCrossDisabled(frontCrossDisabledFileName_tp);
            break;
        case 1:
            var frontCrossDisabledFileName = options["path"];
            checkBox.loadTextureFrontCrossDisabled(frontCrossDisabledFileName, 1);
            break;
        default:
            break
    }
    ccs.WidgetReader.setColorPropsFromJsonDictionary.call(this, widget, options)
}};
ccs.ImageViewReader = {getInstance: function () {
    return ccs.ImageViewReader
}, setPropsFromJsonDictionary: function (widget, options) {
    ccs.WidgetReader.setPropsFromJsonDictionary.call(this, widget, options);
    var jsonPath = ccs.uiReader.getFilePath();
    var imageView = widget;
    var imageFileNameDic = options["fileNameData"];
    var imageFileNameType = imageFileNameDic["resourceType"];
    switch (imageFileNameType) {
        case 0:
            var tp_i = jsonPath;
            var imageFileName = imageFileNameDic["path"];
            var imageFileName_tp = null;
            if (imageFileName && imageFileName !==
                "") {
                imageFileName_tp = tp_i + imageFileName;
                imageView.loadTexture(imageFileName_tp)
            }
            break;
        case 1:
            var imageFileName = imageFileNameDic["path"];
            imageView.loadTexture(imageFileName, 1);
            break;
        default:
            break
    }
    var scale9EnableExist = options["scale9Enable"];
    var scale9Enable = false;
    if (scale9EnableExist)scale9Enable = options["scale9Enable"];
    imageView.setScale9Enabled(scale9Enable);
    if (scale9Enable) {
        var sw = options["scale9Width"];
        var sh = options["scale9Height"];
        if (sw && sh) {
            var swf = options["scale9Width"];
            var shf = options["scale9Height"];
            imageView.setSize(cc.size(swf, shf))
        }
        var cx = options["capInsetsX"];
        var cy = options["capInsetsY"];
        var cw = options["capInsetsWidth"];
        var ch = options["capInsetsHeight"];
        imageView.setCapInsets(cc.rect(cx, cy, cw, ch))
    }
    ccs.WidgetReader.setColorPropsFromJsonDictionary.call(this, widget, options)
}};
ccs.LabelAtlasReader = {getInstance: function () {
    return ccs.LabelAtlasReader
}, setPropsFromJsonDictionary: function (widget, options) {
    ccs.WidgetReader.setPropsFromJsonDictionary.call(this, widget, options);
    var jsonPath = ccs.uiReader.getFilePath();
    var labelAtlas = widget;
    var sv = options["stringValue"];
    var cmf = options["charMapFileData"] || options["charMapFile"];
    var iw = options["itemWidth"];
    var ih = options["itemHeight"];
    var scm = options["startCharMap"];
    if (sv && cmf && iw && ih && scm) {
        var cmftDic = options["charMapFileData"];
        var cmfType =
            cmftDic["resourceType"];
        switch (cmfType) {
            case 0:
                var tp_c = jsonPath;
                var cmfPath = cmftDic["path"];
                var cmf_tp = tp_c + cmfPath;
                labelAtlas.setProperty(options["stringValue"], cmf_tp, options["itemWidth"], options["itemHeight"], options["startCharMap"]);
                break;
            case 1:
                cc.log("Wrong res type of LabelAtlas!");
                break;
            default:
                break
        }
    }
    ccs.WidgetReader.setColorPropsFromJsonDictionary.call(this, widget, options)
}};
ccs.LabelBMFontReader = {getInstance: function () {
    return ccs.LabelBMFontReader
}, setPropsFromJsonDictionary: function (widget, options) {
    ccs.WidgetReader.setPropsFromJsonDictionary.call(this, widget, options);
    var jsonPath = ccs.uiReader.getFilePath();
    var labelBMFont = widget;
    var cmftDic = options["fileNameData"];
    var cmfType = cmftDic["resourceType"];
    switch (cmfType) {
        case 0:
            var tp_c = jsonPath;
            var cmfPath = cmftDic["path"];
            var cmf_tp = tp_c + cmfPath;
            labelBMFont.setFntFile(cmf_tp);
            break;
        case 1:
            cc.log("Wrong res type of LabelAtlas!");
            break;
        default:
            break
    }
    var text = options["text"];
    labelBMFont.setText(text);
    ccs.WidgetReader.setColorPropsFromJsonDictionary.call(this, widget, options)
}};
ccs.LabelReader = {getInstance: function () {
    return ccs.LabelReader
}, setPropsFromJsonDictionary: function (widget, options) {
    ccs.WidgetReader.setPropsFromJsonDictionary.call(this, widget, options);
    var jsonPath = ccs.uiReader.getFilePath();
    var label = widget;
    var touchScaleChangeAble = options["touchScaleEnable"];
    label.setTouchScaleChangeEnabled(touchScaleChangeAble);
    var text = options["text"];
    label.setString(text);
    var fs = options["fontSize"];
    if (fs)label.setFontSize(options["fontSize"]);
    var fn = options["fontName"];
    if (fn)label.setFontName(options["fontName"]);
    var aw = options["areaWidth"];
    var ah = options["areaHeight"];
    if (aw && ah) {
        var size = cc.size(options["areaWidth"], options["areaHeight"]);
        label.setTextAreaSize(size)
    }
    var ha = options["hAlignment"];
    if (ha)label.setTextHorizontalAlignment(options["hAlignment"]);
    var va = options["vAlignment"];
    if (va)label.setTextVerticalAlignment(options["vAlignment"]);
    ccs.WidgetReader.setColorPropsFromJsonDictionary.call(this, widget, options)
}};
ccs.LayoutReader = {getInstance: function () {
    return ccs.LayoutReader
}, setPropsFromJsonDictionary: function (widget, options) {
    ccs.WidgetReader.setPropsFromJsonDictionary.call(this, widget, options);
    var jsonPath = ccs.uiReader.getFilePath();
    var panel = widget;
    var w = 0, h = 0;
    var adaptScreen = options["adaptScreen"];
    if (adaptScreen) {
        var screenSize = cc.director.getWinSize();
        w = screenSize.width;
        h = screenSize.height
    } else {
        w = options["width"];
        h = options["height"]
    }
    panel.setSize(cc.size(w, h));
    panel.setClippingEnabled(options["clipAble"]);
    var backGroundScale9Enable = options["backGroundScale9Enable"];
    panel.setBackGroundImageScale9Enabled(backGroundScale9Enable);
    var cr = options["bgColorR"];
    var cg = options["bgColorG"];
    var cb = options["bgColorB"];
    var scr = options["bgStartColorR"];
    var scg = options["bgStartColorG"];
    var scb = options["bgStartColorB"];
    var ecr = options["bgEndColorR"];
    var ecg = options["bgEndColorG"];
    var ecb = options["bgEndColorB"];
    var bgcv1 = options["vectorX"];
    var bgcv2 = options["vectorY"];
    panel.setBackGroundColorVector(cc.p(bgcv1, bgcv2));
    var co = options["bgColorOpacity"];
    var colorType = options["colorType"];
    panel.setBackGroundColorType(colorType);
    panel.setBackGroundColor(cc.color(scr, scg, scb), cc.color(ecr, ecg, ecb));
    panel.setBackGroundColor(cc.color(cr, cg, cb));
    panel.setBackGroundColorOpacity(co);
    var imageFileNameDic = options["backGroundImageData"];
    if (imageFileNameDic) {
        var imageFileNameType = imageFileNameDic["resourceType"];
        switch (imageFileNameType) {
            case 0:
                var tp_b = jsonPath;
                var imageFileName = imageFileNameDic["path"];
                var imageFileName_tp =
                        imageFileName && imageFileName !== "" ? tp_b + imageFileName : null;
                panel.setBackGroundImage(imageFileName_tp);
                break;
            case 1:
                var imageFileName = imageFileNameDic["path"];
                panel.setBackGroundImage(imageFileName, 1);
                break;
            default:
                break
        }
    }
    if (backGroundScale9Enable) {
        var cx = options["capInsetsX"];
        var cy = options["capInsetsY"];
        var cw = options["capInsetsWidth"];
        var ch = options["capInsetsHeight"];
        panel.setBackGroundImageCapInsets(cc.rect(cx, cy, cw, ch))
    }
    panel.setLayoutType(options["layoutType"]);
    ccs.WidgetReader.setColorPropsFromJsonDictionary.call(this,
        widget, options)
}};
ccs.ScrollViewReader = {getInstance: function () {
    return ccs.ScrollViewReader
}, setPropsFromJsonDictionary: function (widget, options) {
    ccs.LayoutReader.setPropsFromJsonDictionary.call(this, widget, options);
    var scrollView = widget;
    var innerWidth = options["innerWidth"];
    var innerHeight = options["innerHeight"];
    scrollView.setInnerContainerSize(cc.size(innerWidth, innerHeight));
    var direction = options["direction"];
    scrollView.setDirection(direction);
    scrollView.setBounceEnabled(options["bounceEnable"]);
    ccs.WidgetReader.setColorPropsFromJsonDictionary.call(this,
        widget, options)
}};
ccs.ListViewReader = {getInstance: function () {
    return ccs.ListViewReader
}, setPropsFromJsonDictionary: function (widget, options) {
    ccs.ScrollViewReader.setPropsFromJsonDictionary.call(this, widget, options);
    var listView = widget;
    var direction = options["direction"];
    listView.setDirection(direction);
    var gravity = options["gravity"];
    listView.setGravity(gravity);
    var itemMargin = options["itemMargin"];
    listView.setItemsMargin(itemMargin)
}};
ccs.LoadingBarReader = {getInstance: function () {
    return ccs.LoadingBarReader
}, setPropsFromJsonDictionary: function (widget, options) {
    ccs.WidgetReader.setPropsFromJsonDictionary.call(this, widget, options);
    var jsonPath = ccs.uiReader.getFilePath();
    var loadingBar = widget;
    var imageFileNameDic = options["textureData"];
    var imageFileNameType = imageFileNameDic["resourceType"];
    switch (imageFileNameType) {
        case 0:
            var tp_i = jsonPath;
            var imageFileName = imageFileNameDic["path"];
            var imageFileName_tp = null;
            if (imageFileName && imageFileName !==
                "") {
                imageFileName_tp = tp_i + imageFileName;
                loadingBar.loadTexture(imageFileName_tp)
            }
            break;
        case 1:
            var imageFileName = imageFileNameDic["path"];
            loadingBar.loadTexture(imageFileName, 1);
            break;
        default:
            break
    }
    var scale9Enable = options["scale9Enable"];
    loadingBar.setScale9Enabled(scale9Enable);
    if (scale9Enable) {
        var cx = options["capInsetsX"];
        var cy = options["capInsetsY"];
        var cw = options["capInsetsWidth"];
        var ch = options["capInsetsHeight"];
        loadingBar.setCapInsets(cc.rect(cx, cy, cw, ch));
        var width = options["width"];
        var height =
            options["height"];
        loadingBar.setSize(cc.size(width, height))
    }
    loadingBar.setDirection(options["direction"]);
    loadingBar.setPercent(options["percent"]);
    ccs.WidgetReader.setColorPropsFromJsonDictionary.call(this, widget, options)
}};
ccs.PageViewReader = {instancePageViewReader: null, getInstance: function () {
    return ccs.PageViewReader
}, setPropsFromJsonDictionary: function (widget, options) {
    ccs.LayoutReader.setPropsFromJsonDictionary.call(this, widget, options)
}};
ccs.SliderReader = {getInstance: function () {
    return ccs.SliderReader
}, setPropsFromJsonDictionary: function (widget, options) {
    ccs.WidgetReader.setPropsFromJsonDictionary.call(this, widget, options);
    var jsonPath = ccs.uiReader.getFilePath();
    var slider = widget;
    var barTextureScale9Enable = options["scale9Enable"];
    slider.setScale9Enabled(barTextureScale9Enable);
    var bt = options["barFileName"];
    var barLength = options["length"];
    if (bt) {
        if (barTextureScale9Enable) {
            var imageFileNameDic = options["barFileNameData"];
            var imageFileType =
                options["resourceType"];
            switch (imageFileType) {
                case 0:
                    var tp_b = jsonPath;
                    var imageFileName = imageFileNameDic["path"];
                    var imageFileName_tp = imageFileName && imageFileName !== "" ? tp_b + imageFileName : null;
                    slider.loadBarTexture(imageFileName_tp);
                    break;
                case 1:
                    var imageFileName = imageFileNameDic["path"];
                    slider.loadBarTexture(imageFileName, 1);
                    break;
                default:
                    break
            }
            slider.setSize(cc.size(barLength, slider.getContentSize().height))
        }
    } else {
        var imageFileNameDic = options["barFileNameData"];
        var imageFileType = imageFileNameDic["resourceType"];
        switch (imageFileType) {
            case 0:
                var tp_b = jsonPath;
                var imageFileName = imageFileNameDic["path"];
                var imageFileName_tp = imageFileName && imageFileName !== "" ? tp_b + imageFileName : null;
                slider.loadBarTexture(imageFileName_tp);
                break;
            case 1:
                var imageFileName = imageFileNameDic["path"];
                slider.loadBarTexture(imageFileName, 1);
                break;
            default:
                break
        }
    }
    var normalDic = options["ballNormalData"];
    var normalType = normalDic["resourceType"];
    switch (normalType) {
        case 0:
            var tp_n = jsonPath;
            var normalFileName = normalDic["path"];
            var normalFileName_tp =
                    normalFileName && normalFileName !== "" ? tp_n + normalFileName : null;
            slider.loadSlidBallTextureNormal(normalFileName_tp);
            break;
        case 1:
            var normalFileName = normalDic["path"];
            slider.loadSlidBallTextureNormal(normalFileName, 1);
            break;
        default:
            break
    }
    var pressedDic = options["ballPressedData"];
    var pressedType = pressedDic["resourceType"];
    switch (pressedType) {
        case 0:
            var tp_p = jsonPath;
            var pressedFileName = pressedDic["path"];
            var pressedFileName_tp = pressedFileName && pressedFileName !== "" ? tp_p + pressedFileName : null;
            slider.loadSlidBallTexturePressed(pressedFileName_tp);
            break;
        case 1:
            var pressedFileName = pressedDic["path"];
            slider.loadSlidBallTexturePressed(pressedFileName, 1);
            break;
        default:
            break
    }
    var disabledDic = options["ballDisabledData"];
    var disabledType = disabledDic["resourceType"];
    switch (disabledType) {
        case 0:
            var tp_d = jsonPath;
            var disabledFileName = disabledDic["path"];
            var disabledFileName_tp = disabledFileName && disabledFileName !== "" ? tp_d + disabledFileName : null;
            slider.loadSlidBallTextureDisabled(disabledFileName_tp);
            break;
        case 1:
            var disabledFileName = disabledDic["path"];
            slider.loadSlidBallTextureDisabled(disabledFileName, 1);
            break;
        default:
            break
    }
    var progressBarDic = options["progressBarData"];
    var progressBarType = progressBarDic["resourceType"];
    switch (progressBarType) {
        case 0:
            var tp_b = jsonPath;
            var imageFileName = progressBarDic["path"];
            var imageFileName_tp = imageFileName && imageFileName !== "" ? tp_b + imageFileName : null;
            slider.loadProgressBarTexture(imageFileName_tp);
            break;
        case 1:
            var imageFileName = progressBarDic["path"];
            slider.loadProgressBarTexture(imageFileName, 1);
            break;
        default:
            break
    }
    ccs.WidgetReader.setColorPropsFromJsonDictionary.call(this,
        widget, options)
}};
ccs.TextFieldReader = {getInstance: function () {
    return ccs.TextFieldReader
}, setPropsFromJsonDictionary: function (widget, options) {
    ccs.WidgetReader.setPropsFromJsonDictionary.call(this, widget, options);
    var textField = widget;
    var ph = options["placeHolder"];
    if (ph)textField.setPlaceHolder(ph);
    textField.setString(options["text"]);
    var fs = options["fontSize1"];
    if (fs)textField.setFontSize(fs);
    var fn = options["fontName"];
    if (fn)textField.setFontName(fn);
    var tsw = options["touchSizeWidth"];
    var tsh = options["touchSizeHeight"];
    if (tsw && tsh)textField.setTouchSize(tsw, tsh);
    var dw = options["width"];
    var dh = options["height"];
    if (dw > 0 || dh > 0);
    var maxLengthEnable = options["maxLengthEnable"];
    textField.setMaxLengthEnabled(maxLengthEnable);
    if (maxLengthEnable) {
        var maxLength = options["maxLength"];
        textField.setMaxLength(maxLength)
    }
    var passwordEnable = options["passwordEnable"];
    textField.setPasswordEnabled(passwordEnable);
    if (passwordEnable)textField.setPasswordStyleText(options["passwordStyleText"]);
    var aw = options["areaWidth"];
    var ah = options["areaHeight"];
    if (aw && ah) {
        var size = cc.size(aw, ah);
        textField.setTextAreaSize(size)
    }
    var ha = options["hAlignment"];
    if (ha)textField.setTextHorizontalAlignment(ha);
    var va = options["vAlignment"];
    if (va)textField.setTextVerticalAlignment(va);
    ccs.WidgetReader.setColorPropsFromJsonDictionary.call(this, widget, options)
}};(function (w) {
    if (cc === undefined)return;
    var config = cc.game.config.plugin || {};
    var SDK = {user: null, share: null, social: null};
    var Plugin = {getSDK: function () {
        return SDK
    }, isSupportFunction: function (name) {
        if (typeof this[name] === "function")return true; else return false
    }, getUserPlugin: function () {
        return{callStringFuncWithParam: function () {
            return this.callFuncWithParam.apply(this, arguments)
        }, callFuncWithParam: function (name, opt) {
            if (config["common"] && config["common"]["user"] && pluginList[config["common"]["user"]]) {
                var _plugin =
                    pluginList[config["common"]["user"]];
                if (typeof _plugin.user[name] == "function")return _plugin.user[name](opt); else if (typeof _plugin[name] == "function")return _plugin[name](opt)
            }
        }}
    }, getSharePlugin: function () {
        return{callStringFuncWithParam: function () {
            return this.callFuncWithParam.apply(this, arguments)
        }, callFuncWithParam: function (name, opt) {
            if (config["common"] && config["common"]["share"] && pluginList[config["common"]["share"]]) {
                var _plugin = pluginList[config["common"]["share"]];
                if (typeof _plugin.share[name] ==
                    "function")return _plugin.share[name](opt); else if (typeof _plugin[name] == "function")return _plugin[name](opt)
            }
        }}
    }};
    var pluginList = {};
    Plugin.extend = function (name, method) {
        var use = false;
        for (var p in config["common"])if (config["common"][p] == name) {
            for (var o in method[p])Plugin[o] = method[p][o];
            use = true;
            SDK[p] = name
        }
        if (use)method.init(config[name]);
        pluginList[name] = method
    };
    var pluginManager = {loadPlugin: function (pluginName) {
        if (!pluginName) {
            cc.log("PliginManager - PluginName error");
            return null
        }
        var info = pluginName.match(/[A-Z][a-z]+/g);
        if (info.length !== 2) {
            cc.log("PliginManager - PluginName error");
            return null
        }
        var pluginObj = {setDebugMode: function () {
        }, startSession: function () {
        }, setCaptureUncaughtException: function () {
        }, callFuncWithParam: function (funName) {
            if (!pluginList[pluginN])return;
            var _fun = pluginList[pluginN]["common"][funName];
            if (_fun) {
                var _arg = Array.prototype.slice.call(arguments, 1);
                return _fun.apply(_fun, _arg)
            }
            return
        }, getPluginName: function () {
            return pluginN
        }, getPluginVersion: function () {
            return"1.0"
        }, callStringFuncWithParam: function () {
            return pluginObj.callFuncWithParam.apply(pluginObj,
                arguments)
        }};
        var moduleN = info[0].toLowerCase();
        var pluginN = info[1].toLowerCase();
        if (!pluginList[pluginN]) {
            cc.log("Plugin does not exist");
            return pluginObj
        }
        pluginList[pluginN].init();
        for (var p in pluginList[pluginN][moduleN])pluginObj[p] = pluginList[pluginN][moduleN][p];
        return pluginObj
    }};
    w["plugin"] = {extend: Plugin.extend, agentManager: Plugin, AgentManager: {getInstance: function () {
        return plugin.agentManager
    }}, PluginManager: {getInstance: function () {
        return pluginManager
    }}};
    plugin.PluginParam = function (type, value) {
        var paramType = plugin.PluginParam.ParamType, tmpValue;
        switch (type) {
            case paramType.TypeInt:
                tmpValue = parseInt(value);
                break;
            case paramType.TypeFloat:
                tmpValue = parseFloat(value);
                break;
            case paramType.TypeBool:
                tmpValue = Boolean(value);
                break;
            case paramType.TypeString:
                tmpValue = String(value);
                break;
            case paramType.TypeStringMap:
                tmpValue = value;
                break;
            default:
                tmpValue = value
        }
        return tmpValue
    };
    plugin.PluginParam.ParamType = {TypeInt: 1, TypeFloat: 2, TypeBool: 3, TypeString: 4, TypeStringMap: 5};
    plugin.PluginParam.AdsResultCode =
    {AdsReceived: 0, FullScreenViewShown: 1, FullScreenViewDismissed: 2, PointsSpendSucceed: 3, PointsSpendFailed: 4, NetworkError: 5, UnknownError: 6};
    plugin.PluginParam.PayResultCode = {PaySuccess: 0, PayFail: 1, PayCancel: 2, PayTimeOut: 3};
    plugin.PluginParam.ShareResultCode = {ShareSuccess: 0, ShareFail: 1, ShareCancel: 2, ShareTimeOut: 3}
})(window);(function () {
    var box2dAPI = {_ignoreBodyRotation: false, _body: null, _PTMRatio: 32, _rotation: 1, ctor: function (fileName, rect) {
        cc.Sprite.prototype.ctor.call(this);
        if (fileName === undefined)cc.PhysicsSprite.prototype.init.call(this); else if (typeof fileName === "string")if (fileName[0] === "#") {
            var frameName = fileName.substr(1, fileName.length - 1);
            var spriteFrame = cc.spriteFrameCache.getSpriteFrame(frameName);
            this.initWithSpriteFrame(spriteFrame)
        } else this.init(fileName, rect); else if (typeof fileName === "object")if (fileName instanceof
            cc.Texture2D)this.initWithTexture(fileName, rect); else if (fileName instanceof cc.SpriteFrame)this.initWithSpriteFrame(fileName)
    }, setBody: function (body) {
        this._body = body
    }, getBody: function () {
        return this._body
    }, setPTMRatio: function (r) {
        this._PTMRatio = r
    }, getPTMRatio: function () {
        return this._PTMRatio
    }, getPosition: function () {
        var pos = this._body.GetPosition();
        var locPTMRatio = this._PTMRatio;
        return cc.p(pos.x * locPTMRatio, pos.y * locPTMRatio)
    }, setPosition: function (p) {
        var angle = this._body.GetAngle();
        var locPTMRatio =
            this._PTMRatio;
        this._body.setTransform(Box2D.b2Vec2(p.x / locPTMRatio, p.y / locPTMRatio), angle);
        this.setNodeDirty()
    }, getRotation: function () {
        return this._ignoreBodyRotation ? cc.radiansToDegrees(this._rotationRadians) : cc.radiansToDegrees(this._body.GetAngle())
    }, setRotation: function (r) {
        if (this._ignoreBodyRotation)this._rotation = r; else {
            var locBody = this._body;
            var p = locBody.GetPosition();
            locBody.SetTransform(p, cc.degreesToRadians(r))
        }
        this.setNodeDirty()
    }, _syncPosition: function () {
        var pos = this._body.GetPosition();
        this._position.x = pos.x * this._PTMRatio;
        this._position.y = pos.y * this._PTMRatio;
        this._rotationRadians = this._rotation * (Math.PI / 180)
    }, _syncRotation: function () {
        this._rotationRadians = this._body.GetAngle()
    }, visit: function () {
        if (this._body && this._PTMRatio) {
            this._syncPosition();
            if (!this._ignoreBodyRotation)this._syncRotation()
        } else cc.log("PhysicsSprite body or PTIMRatio was not set");
        this._super()
    }, setIgnoreBodyRotation: function (b) {
        this._ignoreBodyRotation = b
    }};
    var chipmunkAPI = {_ignoreBodyRotation: false, _body: null,
        _rotation: 1, ctor: function (fileName, rect) {
            cc.Sprite.prototype.ctor.call(this);
            if (fileName === undefined)cc.PhysicsSprite.prototype.init.call(this); else if (typeof fileName === "string")if (fileName[0] === "#") {
                var frameName = fileName.substr(1, fileName.length - 1);
                var spriteFrame = cc.spriteFrameCache.getSpriteFrame(frameName);
                this.initWithSpriteFrame(spriteFrame)
            } else this.init(fileName, rect); else if (typeof fileName === "object")if (fileName instanceof cc.Texture2D)this.initWithTexture(fileName, rect); else if (fileName instanceof
                cc.SpriteFrame)this.initWithSpriteFrame(fileName)
        }, setBody: function (body) {
            this._body = body
        }, getBody: function () {
            return this._body
        }, getPosition: function () {
            var locBody = this._body;
            return{x: locBody.p.x, y: locBody.p.y}
        }, getPositionX: function () {
            return this._body.p.x
        }, getPositionY: function () {
            return this._body.p.y
        }, setPosition: function (newPosOrxValue, yValue) {
            if (yValue === undefined) {
                this._body.p.x = newPosOrxValue.x;
                this._body.p.y = newPosOrxValue.y
            } else {
                this._body.p.x = newPosOrxValue;
                this._body.p.y = yValue
            }
        }, setPositionX: function (xValue) {
            this._body.p.x =
                xValue
        }, setPositionY: function (yValue) {
            this._body.p.y = yValue
        }, _syncPosition: function () {
            var locPosition = this._position, locBody = this._body;
            if (locPosition.x != locBody.p.x || locPosition.y != locBody.p.y)cc.Sprite.prototype.setPosition.call(this, locBody.p.x, locBody.p.y)
        }, getRotation: function () {
            return this._ignoreBodyRotation ? cc.radiansToDegrees(this._rotationRadiansX) : -cc.radiansToDegrees(this._body.a)
        }, setRotation: function (r) {
            if (this._ignoreBodyRotation)cc.Sprite.prototype.setRotation.call(this, r); else this._body.a = -cc.degreesToRadians(r)
        }, _syncRotation: function () {
            if (this._rotationRadiansX != -this._body.a)cc.Sprite.prototype.setRotation.call(this, -cc.radiansToDegrees(this._body.a))
        }, nodeToParentTransform: function () {
            if (cc._renderType === cc._RENDER_TYPE_CANVAS)return this._nodeToParentTransformForCanvas();
            var locBody = this._body, locAnchorPIP = this._anchorPointInPoints, locScaleX = this._scaleX, locScaleY = this._scaleY;
            var x = locBody.p.x;
            var y = locBody.p.y;
            if (this._ignoreAnchorPointForPosition) {
                x += locAnchorPIP.x;
                y += locAnchorPIP.y
            }
            var radians =
                locBody.a;
            var c = Math.cos(radians);
            var s = Math.sin(radians);
            if (!cc._rectEqualToZero(locAnchorPIP)) {
                x += c * -locAnchorPIP.x * locScaleX + -s * -locAnchorPIP.y * locScaleY;
                y += s * -locAnchorPIP.x * locScaleX + c * -locAnchorPIP.y * locScaleY
            }
            this._transform = cc.AffineTransformMake(c * locScaleX, s * locScaleX, -s * locScaleY, c * locScaleY, x, y);
            return this._transform
        }, _nodeToParentTransformForCanvas: function () {
            if (this.dirty) {
                var t = this._transform;
                var locBody = this._body, locScaleX = this._scaleX, locScaleY = this._scaleY, locAnchorPIP = this._anchorPointInPoints;
                t.tx = locBody.p.x;
                t.ty = locBody.p.y;
                var radians = -locBody.a;
                var Cos = 1, Sin = 0;
                if (radians) {
                    Cos = Math.cos(radians);
                    Sin = Math.sin(radians)
                }
                t.a = t.d = Cos;
                t.b = -Sin;
                t.c = Sin;
                if (locScaleX !== 1 || locScaleY !== 1) {
                    t.a *= locScaleX;
                    t.c *= locScaleX;
                    t.b *= locScaleY;
                    t.d *= locScaleY
                }
                t.tx += Cos * -locAnchorPIP.x * locScaleX + -Sin * locAnchorPIP.y * locScaleY;
                t.ty -= Sin * -locAnchorPIP.x * locScaleX + Cos * locAnchorPIP.y * locScaleY;
                if (this._ignoreAnchorPointForPosition) {
                    t.tx += locAnchorPIP.x;
                    t.ty += locAnchorPIP.y
                }
                this._transformDirty = false
            }
            return this._transform
        },
        isDirty: function () {
            return!this._body.isSleeping()
        }, setDirty: function () {
        }, setIgnoreBodyRotation: function (b) {
            this._ignoreBodyRotation = b
        }};
    cc.PhysicsSprite = cc.Sprite.extend(chipmunkAPI);
    cc.PhysicsSprite._className = "PhysicsSprite";
    var _p = cc.PhysicsSprite.prototype;
    _p.body;
    cc.defineGetterSetter(_p, "body", _p.getBody, _p.setBody);
    _p.dirty;
    cc.defineGetterSetter(_p, "dirty", _p.isDirty, _p.setDirty);
    cc.PhysicsSprite.create = function (fileName, rect) {
        return new cc.PhysicsSprite(fileName, rect)
    }
})();
cc.__convertVerts = function (verts) {
    var ret = [];
    for (var i = 0; i < verts.length / 2; i++)ret[i] = {x: verts[i * 2], y: verts[i * 2 + 1]};
    return ret
};
cc.ColorForBody = function (body) {
    if (body.isRogue() || body.isSleeping())return cc.color(128, 128, 128, 128); else if (body.nodeIdleTime > body.space.sleepTimeThreshold)return cc.color(84, 84, 84, 128); else return cc.color(255, 0, 0, 128)
};
cc.DrawShape = function (shape, renderer) {
    var body = shape.body;
    var color = cc.ColorForBody(body);
    switch (shape.collisionCode) {
        case cp.CircleShape.prototype.collisionCode:
            this.drawDot(shape.tc, Math.max(shape.r, 1), color);
            this.drawSegment(shape.tc, cp.v.add(shape.tc, cp.v.mult(body.rot, shape.r)), 1, color);
            break;
        case cp.SegmentShape.prototype.collisionCode:
            this.drawSegment(shape.ta, shape.tb, Math.max(shape.r, 2), color);
            break;
        case cp.PolyShape.prototype.collisionCode:
            var line = cc.color(color.r, color.g, color.b, cc.lerp(color.a,
                255, 0.5));
            this.drawPoly(cc.__convertVerts(shape.tVerts), color, 1, line);
            break;
        default:
            cc.log("cc.DrawShape(): Bad assertion in DrawShape()");
            break
    }
};
cc.DrawConstraint = function (constraint, renderer) {
    var body_a = constraint.a;
    var body_b = constraint.b;
    var a, b;
    if (constraint instanceof cp.PinJoint) {
        a = body_a.local2World(constraint.anchr1);
        b = body_b.local2World(constraint.anchr2);
        this.drawDot(a, 3, cc.CONSTRAINT_COLOR);
        this.drawDot(b, 3, cc.CONSTRAINT_COLOR);
        this.drawSegment(a, b, 1, cc.CONSTRAINT_COLOR)
    } else if (constraint instanceof cp.SlideJoint) {
        a = body_a.local2World(constraint.anchr1);
        b = body_b.local2World(constraint.anchr2);
        this.drawDot(a, 3, cc.CONSTRAINT_COLOR);
        this.drawDot(b, 3, cc.CONSTRAINT_COLOR);
        this.drawSegment(a, b, 1, cc.CONSTRAINT_COLOR)
    } else if (constraint instanceof cp.PivotJoint) {
        a = body_a.local2World(constraint.anchr1);
        b = body_b.local2World(constraint.anchr2);
        this.drawDot(a, 3, cc.CONSTRAINT_COLOR);
        this.drawDot(b, 3, cc.CONSTRAINT_COLOR)
    } else if (constraint instanceof cp.GrooveJoint) {
        a = body_a.local2World(constraint.grv_a);
        b = body_a.local2World(constraint.grv_b);
        var c = body_b.local2World(constraint.anchr2);
        this.drawDot(c, 3, cc.CONSTRAINT_COLOR);
        this.drawSegment(a,
            b, 1, cc.CONSTRAINT_COLOR)
    } else if (constraint instanceof cp.DampedSpring); else;
};
cc.CONSTRAINT_COLOR = cc.color(0, 255, 0, 128);
cc.PhysicsDebugNode = cc.DrawNode.extend({space: null, _spaceObj: null, _className: "PhysicsDebugNode", getSpace: function () {
    return this.space
}, setSpace: function (space) {
    this.space = space
}, draw: function (context) {
    if (!this.space)return;
    this.space.eachShape(cc.DrawShape.bind(this));
    this.space.eachConstraint(cc.DrawConstraint.bind(this));
    cc.DrawNode.prototype.draw.call(this);
    this.clear()
}});
cc.PhysicsDebugNode.debugNodeForChipmunkSpace = function (space) {
    var node = new cc.PhysicsDebugNode;
    if (node.init()) {
        node._spaceObj = space;
        node.space = space.space;
        return node
    }
    return null
};
cc.PhysicsDebugNode.debugNodeForCPSpace = function (space) {
    var node = new cc.PhysicsDebugNode;
    if (node.init()) {
        node.space = space;
        return node
    }
    return null
};
cc.PhysicsDebugNode.create = cc.PhysicsDebugNode.debugNodeForCPSpace;var io = "undefined" == typeof module ? {} : module.exports;
(function () {
    (function (a, b) {
        var c = a;
        c.version = "0.9.16", c.protocol = 1, c.transports = [], c.j = [], c.sockets = {}, c.connect = function (a, d) {
            var e = c.util.parseUri(a), f, g;
            b && b.location && (e.protocol = e.protocol || b.location.protocol.slice(0, -1), e.host = e.host || (b.document ? b.document.domain : b.location.hostname), e.port = e.port || b.location.port), f = c.util.uniqueUri(e);
            var h = {host: e.host, secure: "https" == e.protocol, port: e.port || ("https" == e.protocol ? 443 : 80), query: e.query || ""};
            c.util.merge(h, d);
            if (h["force new connection"] || !c.sockets[f])g = new c.Socket(h);
            return!h["force new connection"] && g && (c.sockets[f] = g), g = g || c.sockets[f], g.of(e.path.length > 1 ? e.path : "")
        }
    })("object" == typeof module ? module.exports : this.io = {}, this), function (a, b) {
        var c = a.util = {}, d = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, e = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative",
            "path", "directory", "file", "query", "anchor"];
        c.parseUri = function (a) {
            var b = d.exec(a || ""), c = {}, f = 14;
            while (f--)c[e[f]] = b[f] || "";
            return c
        }, c.uniqueUri = function (a) {
            var c = a.protocol, d = a.host, e = a.port;
            return"document"in b ? (d = d || document.domain, e = e || (c == "https" && document.location.protocol !== "https:" ? 443 : document.location.port)) : (d = d || "localhost", !e && c == "https" && (e = 443)), (c || "http") + "://" + d + ":" + (e || 80)
        }, c.query = function (a, b) {
            var d = c.chunkQuery(a || ""), e = [];
            c.merge(d, c.chunkQuery(b || ""));
            for (var f in d)d.hasOwnProperty(f) &&
            e.push(f + "\x3d" + d[f]);
            return e.length ? "?" + e.join("\x26") : ""
        }, c.chunkQuery = function (a) {
            var b = {}, c = a.split("\x26"), d = 0, e = c.length, f;
            for (; d < e; ++d)f = c[d].split("\x3d"), f[0] && (b[f[0]] = f[1]);
            return b
        };
        var f = !1;
        c.load = function (a) {
            if ("document"in b && document.readyState === "complete" || f)return a();
            c.on(b, "load", a, !1)
        }, c.on = function (a, b, c, d) {
            a.attachEvent ? a.attachEvent("on" + b, c) : a.addEventListener && a.addEventListener(b, c, d)
        }, c.request = function (a) {
            if (a && "undefined" != typeof XDomainRequest && !c.ua.hasCORS)return new XDomainRequest;
            if ("undefined" != typeof XMLHttpRequest && (!a || c.ua.hasCORS))return new XMLHttpRequest;
            if (!a)try {
                return new (window[["Active"].concat("Object").join("X")])("Microsoft.XMLHTTP")
            } catch (b) {
            }
            return null
        }, "undefined" != typeof window && c.load(function () {
            f = !0
        }), c.defer = function (a) {
            if (!c.ua.webkit || "undefined" != typeof importScripts)return a();
            c.load(function () {
                setTimeout(a, 100)
            })
        }, c.merge = function (b, d, e, f) {
            var g = f || [], h = typeof e == "undefined" ? 2 : e, i;
            for (i in d)d.hasOwnProperty(i) && c.indexOf(g, i) < 0 && (typeof b[i] !=
                "object" || !h ? (b[i] = d[i], g.push(d[i])) : c.merge(b[i], d[i], h - 1, g));
            return b
        }, c.mixin = function (a, b) {
            c.merge(a.prototype, b.prototype)
        }, c.inherit = function (a, b) {
            function c() {
            }

            c.prototype = b.prototype, a.prototype = new c
        }, c.isArray = Array.isArray || function (a) {
            return Object.prototype.toString.call(a) === "[object Array]"
        }, c.intersect = function (a, b) {
            var d = [], e = a.length > b.length ? a : b, f = a.length > b.length ? b : a;
            for (var g = 0, h = f.length; g < h; g++)~c.indexOf(e, f[g]) && d.push(f[g]);
            return d
        }, c.indexOf = function (a, b, c) {
            for (var d =
                a.length, c = c < 0 ? c + d < 0 ? 0 : c + d : c || 0; c < d && a[c] !== b; c++);
            return d <= c ? -1 : c
        }, c.toArray = function (a) {
            var b = [];
            for (var c = 0, d = a.length; c < d; c++)b.push(a[c]);
            return b
        }, c.ua = {}, c.ua.hasCORS = "undefined" != typeof XMLHttpRequest && function () {
            try {
                var a = new XMLHttpRequest
            } catch (b) {
                return!1
            }
            return a.withCredentials != undefined
        }(), c.ua.webkit = "undefined" != typeof navigator && /webkit/i.test(navigator.userAgent), c.ua.iDevice = "undefined" != typeof navigator && /iPad|iPhone|iPod/i.test(navigator.userAgent)
    }("undefined" != typeof io ?
        io : module.exports, this), function (a, b) {
        function c() {
        }

        a.EventEmitter = c, c.prototype.on = function (a, c) {
            return this.$events || (this.$events = {}), this.$events[a] ? b.util.isArray(this.$events[a]) ? this.$events[a].push(c) : this.$events[a] = [this.$events[a], c] : this.$events[a] = c, this
        }, c.prototype.addListener = c.prototype.on, c.prototype.once = function (a, b) {
            function d() {
                c.removeListener(a, d), b.apply(this, arguments)
            }

            var c = this;
            return d.listener = b, this.on(a, d), this
        }, c.prototype.removeListener = function (a, c) {
            if (this.$events &&
                this.$events[a]) {
                var d = this.$events[a];
                if (b.util.isArray(d)) {
                    var e = -1;
                    for (var f = 0, g = d.length; f < g; f++)if (d[f] === c || d[f].listener && d[f].listener === c) {
                        e = f;
                        break
                    }
                    if (e < 0)return this;
                    d.splice(e, 1), d.length || delete this.$events[a]
                } else(d === c || d.listener && d.listener === c) && delete this.$events[a]
            }
            return this
        }, c.prototype.removeAllListeners = function (a) {
            return a === undefined ? (this.$events = {}, this) : (this.$events && this.$events[a] && (this.$events[a] = null), this)
        }, c.prototype.listeners = function (a) {
            return this.$events ||
                (this.$events = {}), this.$events[a] || (this.$events[a] = []), b.util.isArray(this.$events[a]) || (this.$events[a] = [this.$events[a]]), this.$events[a]
        }, c.prototype.emit = function (a) {
            if (!this.$events)return!1;
            var c = this.$events[a];
            if (!c)return!1;
            var d = Array.prototype.slice.call(arguments, 1);
            if ("function" == typeof c)c.apply(this, d); else {
                if (!b.util.isArray(c))return!1;
                var e = c.slice();
                for (var f = 0, g = e.length; f < g; f++)e[f].apply(this, d)
            }
            return!0
        }
    }("undefined" != typeof io ? io : module.exports, "undefined" != typeof io ? io : module.parent.exports),
        function (exports, nativeJSON) {
            function f(a) {
                return a < 10 ? "0" + a : a
            }

            function date(a, b) {
                return isFinite(a.valueOf()) ? a.getUTCFullYear() + "-" + f(a.getUTCMonth() + 1) + "-" + f(a.getUTCDate()) + "T" + f(a.getUTCHours()) + ":" + f(a.getUTCMinutes()) + ":" + f(a.getUTCSeconds()) + "Z" : null
            }

            function quote(a) {
                return escapable.lastIndex = 0, escapable.test(a) ? '"' + a.replace(escapable, function (a) {
                    var b = meta[a];
                    return typeof b == "string" ? b : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4)
                }) + '"' : '"' + a + '"'
            }

            function str(a, b) {
                var c, d, e, f,
                    g = gap, h, i = b[a];
                i instanceof Date && (i = date(a)), typeof rep == "function" && (i = rep.call(b, a, i));
                switch (typeof i) {
                    case "string":
                        return quote(i);
                    case "number":
                        return isFinite(i) ? String(i) : "null";
                    case "boolean":
                    case "null":
                        return String(i);
                    case "object":
                        if (!i)return"null";
                        gap += indent, h = [];
                        if (Object.prototype.toString.apply(i) === "[object Array]") {
                            f = i.length;
                            for (c = 0; c < f; c += 1)h[c] = str(c, i) || "null";
                            return e = h.length === 0 ? "[]" : gap ? "[\n" + gap + h.join(",\n" + gap) + "\n" + g + "]" : "[" + h.join(",") + "]", gap = g, e
                        }
                        if (rep && typeof rep ==
                            "object") {
                            f = rep.length;
                            for (c = 0; c < f; c += 1)typeof rep[c] == "string" && (d = rep[c], e = str(d, i), e && h.push(quote(d) + (gap ? ": " : ":") + e))
                        } else for (d in i)Object.prototype.hasOwnProperty.call(i, d) && (e = str(d, i), e && h.push(quote(d) + (gap ? ": " : ":") + e));
                        return e = h.length === 0 ? "{}" : gap ? "{\n" + gap + h.join(",\n" + gap) + "\n" + g + "}" : "{" + h.join(",") + "}", gap = g, e
                }
            }

            "use strict";
            if (nativeJSON && nativeJSON.parse)return exports.JSON = {parse: nativeJSON.parse, stringify: nativeJSON.stringify};
            var JSON = exports.JSON = {}, cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
                escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {"\b": "\\b", "\t": "\\t", "\n": "\\n", "\f": "\\f", "\r": "\\r", '"': '\\"', "\\": "\\\\"}, rep;
            JSON.stringify = function (a, b, c) {
                var d;
                gap = "", indent = "";
                if (typeof c == "number")for (d = 0; d < c; d += 1)indent += " "; else typeof c == "string" && (indent = c);
                rep = b;
                if (!b || typeof b == "function" || typeof b == "object" && typeof b.length == "number")return str("", {"": a});
                throw new Error("JSON.stringify");
            }, JSON.parse = function (text, reviver) {
                function walk(a, b) {
                    var c, d, e = a[b];
                    if (e && typeof e == "object")for (c in e)Object.prototype.hasOwnProperty.call(e, c) && (d = walk(e, c), d !== undefined ? e[c] = d : delete e[c]);
                    return reviver.call(a, b, e)
                }

                var j;
                text = String(text), cx.lastIndex = 0, cx.test(text) && (text = text.replace(cx, function (a) {
                    return"\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4)
                }));
                if (/^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, "@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
                    "]").replace(/(?:^|:|,)(?:\s*\[)+/g, "")))return j = eval("(" + text + ")"), typeof reviver == "function" ? walk({"": j}, "") : j;
                throw new SyntaxError("JSON.parse");
            }
        }("undefined" != typeof io ? io : module.exports, typeof JSON != "undefined" ? JSON : undefined), function (a, b) {
        var c = a.parser = {}, d = c.packets = ["disconnect", "connect", "heartbeat", "message", "json", "event", "ack", "error", "noop"], e = c.reasons = ["transport not supported", "client not handshaken", "unauthorized"], f = c.advice = ["reconnect"], g = b.JSON, h = b.util.indexOf;
        c.encodePacket =
            function (a) {
                var b = h(d, a.type), c = a.id || "", i = a.endpoint || "", j = a.ack, k = null;
                switch (a.type) {
                    case "error":
                        var l = a.reason ? h(e, a.reason) : "", m = a.advice ? h(f, a.advice) : "";
                        if (l !== "" || m !== "")k = l + (m !== "" ? "+" + m : "");
                        break;
                    case "message":
                        a.data !== "" && (k = a.data);
                        break;
                    case "event":
                        var n = {name: a.name};
                        a.args && a.args.length && (n.args = a.args), k = g.stringify(n);
                        break;
                    case "json":
                        k = g.stringify(a.data);
                        break;
                    case "connect":
                        a.qs && (k = a.qs);
                        break;
                    case "ack":
                        k = a.ackId + (a.args && a.args.length ? "+" + g.stringify(a.args) : "")
                }
                var o =
                    [b, c + (j == "data" ? "+" : ""), i];
                return k !== null && k !== undefined && o.push(k), o.join(":")
            }, c.encodePayload = function (a) {
            var b = "";
            if (a.length == 1)return a[0];
            for (var c = 0, d = a.length; c < d; c++) {
                var e = a[c];
                b += "\ufffd" + e.length + "\ufffd" + a[c]
            }
            return b
        };
        var i = /([^:]+):([0-9]+)?(\+)?:([^:]+)?:?([\s\S]*)?/;
        c.decodePacket = function (a) {
            var b = a.match(i);
            if (!b)return{};
            var c = b[2] || "", a = b[5] || "", h = {type: d[b[1]], endpoint: b[4] || ""};
            c && (h.id = c, b[3] ? h.ack = "data" : h.ack = !0);
            switch (h.type) {
                case "error":
                    var b = a.split("+");
                    h.reason =
                        e[b[0]] || "", h.advice = f[b[1]] || "";
                    break;
                case "message":
                    h.data = a || "";
                    break;
                case "event":
                    try {
                        var j = g.parse(a);
                        h.name = j.name, h.args = j.args
                    } catch (k) {
                    }
                    h.args = h.args || [];
                    break;
                case "json":
                    try {
                        h.data = g.parse(a)
                    } catch (k) {
                    }
                    break;
                case "connect":
                    h.qs = a || "";
                    break;
                case "ack":
                    var b = a.match(/^([0-9]+)(\+)?(.*)/);
                    if (b) {
                        h.ackId = b[1], h.args = [];
                        if (b[3])try {
                            h.args = b[3] ? g.parse(b[3]) : []
                        } catch (k) {
                        }
                    }
                    break;
                case "disconnect":
                case "heartbeat":
            }
            return h
        }, c.decodePayload = function (a) {
            if (a.charAt(0) == "\ufffd") {
                var b = [];
                for (var d =
                    1, e = ""; d < a.length; d++)a.charAt(d) == "\ufffd" ? (b.push(c.decodePacket(a.substr(d + 1).substr(0, e))), d += Number(e) + 1, e = "") : e += a.charAt(d);
                return b
            }
            return[c.decodePacket(a)]
        }
    }("undefined" != typeof io ? io : module.exports, "undefined" != typeof io ? io : module.parent.exports), function (a, b) {
        function c(a, b) {
            this.socket = a, this.sessid = b
        }

        a.Transport = c, b.util.mixin(c, b.EventEmitter), c.prototype.heartbeats = function () {
            return!0
        }, c.prototype.onData = function (a) {
            this.clearCloseTimeout(), (this.socket.connected || this.socket.connecting ||
                this.socket.reconnecting) && this.setCloseTimeout();
            if (a !== "") {
                var c = b.parser.decodePayload(a);
                if (c && c.length)for (var d = 0, e = c.length; d < e; d++)this.onPacket(c[d])
            }
            return this
        }, c.prototype.onPacket = function (a) {
            return this.socket.setHeartbeatTimeout(), a.type == "heartbeat" ? this.onHeartbeat() : (a.type == "connect" && a.endpoint == "" && this.onConnect(), a.type == "error" && a.advice == "reconnect" && (this.isOpen = !1), this.socket.onPacket(a), this)
        }, c.prototype.setCloseTimeout = function () {
            if (!this.closeTimeout) {
                var a = this;
                this.closeTimeout =
                    setTimeout(function () {
                        a.onDisconnect()
                    }, this.socket.closeTimeout)
            }
        }, c.prototype.onDisconnect = function () {
            return this.isOpen && this.close(), this.clearTimeouts(), this.socket.onDisconnect(), this
        }, c.prototype.onConnect = function () {
            return this.socket.onConnect(), this
        }, c.prototype.clearCloseTimeout = function () {
            this.closeTimeout && (clearTimeout(this.closeTimeout), this.closeTimeout = null)
        }, c.prototype.clearTimeouts = function () {
            this.clearCloseTimeout(), this.reopenTimeout && clearTimeout(this.reopenTimeout)
        }, c.prototype.packet =
            function (a) {
                this.send(b.parser.encodePacket(a))
            }, c.prototype.onHeartbeat = function (a) {
            this.packet({type: "heartbeat"})
        }, c.prototype.onOpen = function () {
            this.isOpen = !0, this.clearCloseTimeout(), this.socket.onOpen()
        }, c.prototype.onClose = function () {
            var a = this;
            this.isOpen = !1, this.socket.onClose(), this.onDisconnect()
        }, c.prototype.prepareUrl = function () {
            var a = this.socket.options;
            return this.scheme() + "://" + a.host + ":" + a.port + "/" + a.resource + "/" + b.protocol + "/" + this.name + "/" + this.sessid
        }, c.prototype.ready = function (a, b) {
            b.call(this)
        }
    }("undefined" != typeof io ? io : module.exports, "undefined" != typeof io ? io : module.parent.exports), function (a, b, c) {
        function d(a) {
            this.options = {port: 80, secure: !1, document: "document"in c ? document : !1, resource: "socket.io", transports: b.transports, "connect timeout": 1E4, "try multiple transports": !0, reconnect: !0, "reconnection delay": 500, "reconnection limit": Infinity, "reopen delay": 3E3, "max reconnection attempts": 10, "sync disconnect on unload": !1, "auto connect": !0, "flash policy port": 10843, manualFlush: !1},
                b.util.merge(this.options, a), this.connected = !1, this.open = !1, this.connecting = !1, this.reconnecting = !1, this.namespaces = {}, this.buffer = [], this.doBuffer = !1;
            if (this.options["sync disconnect on unload"] && (!this.isXDomain() || b.util.ua.hasCORS)) {
                var d = this;
                b.util.on(c, "beforeunload", function () {
                    d.disconnectSync()
                }, !1)
            }
            this.options["auto connect"] && this.connect()
        }

        function e() {
        }

        a.Socket = d, b.util.mixin(d, b.EventEmitter), d.prototype.of = function (a) {
            return this.namespaces[a] || (this.namespaces[a] = new b.SocketNamespace(this,
                a), a !== "" && this.namespaces[a].packet({type: "connect"})), this.namespaces[a]
        }, d.prototype.publish = function () {
            this.emit.apply(this, arguments);
            var a;
            for (var b in this.namespaces)this.namespaces.hasOwnProperty(b) && (a = this.of(b), a.$emit.apply(a, arguments))
        }, d.prototype.handshake = function (a) {
            function f(b) {
                b instanceof Error ? (c.connecting = !1, c.onError(b.message)) : a.apply(null, b.split(":"))
            }

            var c = this, d = this.options, g = ["http" + (d.secure ? "s" : "") + ":/", d.host + ":" + d.port, d.resource, b.protocol, b.util.query(this.options.query,
                    "t\x3d" + +new Date)].join("/");
            if (this.isXDomain() && !b.util.ua.hasCORS) {
                var h = document.getElementsByTagName("script")[0], i = document.createElement("script");
                i.src = g + "\x26jsonp\x3d" + b.j.length, h.parentNode.insertBefore(i, h), b.j.push(function (a) {
                    f(a), i.parentNode.removeChild(i)
                })
            } else {
                var j = b.util.request();
                j.open("GET", g, !0), this.isXDomain() && (j.withCredentials = !0), j.onreadystatechange = function () {
                    j.readyState == 4 && (j.onreadystatechange = e, j.status == 200 ? f(j.responseText) : j.status == 403 ? c.onError(j.responseText) :
                        (c.connecting = !1, !c.reconnecting && c.onError(j.responseText)))
                }, j.send(null)
            }
        }, d.prototype.getTransport = function (a) {
            var c = a || this.transports, d;
            for (var e = 0, f; f = c[e]; e++)if (b.Transport[f] && b.Transport[f].check(this) && (!this.isXDomain() || b.Transport[f].xdomainCheck(this)))return new b.Transport[f](this, this.sessionid);
            return null
        }, d.prototype.connect = function (a) {
            if (this.connecting)return this;
            var c = this;
            return c.connecting = !0, this.handshake(function (d, e, f, g) {
                function h(a) {
                    c.transport && c.transport.clearTimeouts(),
                        c.transport = c.getTransport(a);
                    if (!c.transport)return c.publish("connect_failed");
                    c.transport.ready(c, function () {
                        c.connecting = !0, c.publish("connecting", c.transport.name), c.transport.open(), c.options["connect timeout"] && (c.connectTimeoutTimer = setTimeout(function () {
                            if (!c.connected) {
                                c.connecting = !1;
                                if (c.options["try multiple transports"]) {
                                    var a = c.transports;
                                    while (a.length > 0 && a.splice(0, 1)[0] != c.transport.name);
                                    a.length ? h(a) : c.publish("connect_failed")
                                }
                            }
                        }, c.options["connect timeout"]))
                    })
                }

                c.sessionid = d,
                    c.closeTimeout = f * 1E3, c.heartbeatTimeout = e * 1E3, c.transports || (c.transports = c.origTransports = g ? b.util.intersect(g.split(","), c.options.transports) : c.options.transports), c.setHeartbeatTimeout(), h(c.transports), c.once("connect", function () {
                    clearTimeout(c.connectTimeoutTimer), a && typeof a == "function" && a()
                })
            }), this
        }, d.prototype.setHeartbeatTimeout = function () {
            clearTimeout(this.heartbeatTimeoutTimer);
            if (this.transport && !this.transport.heartbeats())return;
            var a = this;
            this.heartbeatTimeoutTimer = setTimeout(function () {
                    a.transport.onClose()
                },
                this.heartbeatTimeout)
        }, d.prototype.packet = function (a) {
            return this.connected && !this.doBuffer ? this.transport.packet(a) : this.buffer.push(a), this
        }, d.prototype.setBuffer = function (a) {
            this.doBuffer = a, !a && this.connected && this.buffer.length && (this.options.manualFlush || this.flushBuffer())
        }, d.prototype.flushBuffer = function () {
            this.transport.payload(this.buffer), this.buffer = []
        }, d.prototype.disconnect = function () {
            if (this.connected || this.connecting)this.open && this.of("").packet({type: "disconnect"}), this.onDisconnect("booted");
            return this
        }, d.prototype.disconnectSync = function () {
            var a = b.util.request(), c = ["http" + (this.options.secure ? "s" : "") + ":/", this.options.host + ":" + this.options.port, this.options.resource, b.protocol, "", this.sessionid].join("/") + "/?disconnect\x3d1";
            a.open("GET", c, !1), a.send(null), this.onDisconnect("booted")
        }, d.prototype.isXDomain = function () {
            var a = c.location.port || ("https:" == c.location.protocol ? 443 : 80);
            return this.options.host !== c.location.hostname || this.options.port != a
        }, d.prototype.onConnect = function () {
            this.connected ||
            (this.connected = !0, this.connecting = !1, this.doBuffer || this.setBuffer(!1), this.emit("connect"))
        }, d.prototype.onOpen = function () {
            this.open = !0
        }, d.prototype.onClose = function () {
            this.open = !1, clearTimeout(this.heartbeatTimeoutTimer)
        }, d.prototype.onPacket = function (a) {
            this.of(a.endpoint).onPacket(a)
        }, d.prototype.onError = function (a) {
            a && a.advice && a.advice === "reconnect" && (this.connected || this.connecting) && (this.disconnect(), this.options.reconnect && this.reconnect()), this.publish("error", a && a.reason ? a.reason : a)
        },
            d.prototype.onDisconnect = function (a) {
                var b = this.connected, c = this.connecting;
                this.connected = !1, this.connecting = !1, this.open = !1;
                if (b || c)this.transport.close(), this.transport.clearTimeouts(), b && (this.publish("disconnect", a), "booted" != a && this.options.reconnect && !this.reconnecting && this.reconnect())
            }, d.prototype.reconnect = function () {
            function e() {
                if (a.connected) {
                    for (var b in a.namespaces)a.namespaces.hasOwnProperty(b) && "" !== b && a.namespaces[b].packet({type: "connect"});
                    a.publish("reconnect", a.transport.name,
                        a.reconnectionAttempts)
                }
                clearTimeout(a.reconnectionTimer), a.removeListener("connect_failed", f), a.removeListener("connect", f), a.reconnecting = !1, delete a.reconnectionAttempts, delete a.reconnectionDelay, delete a.reconnectionTimer, delete a.redoTransports, a.options["try multiple transports"] = c
            }

            function f() {
                if (!a.reconnecting)return;
                if (a.connected)return e();
                if (a.connecting && a.reconnecting)return a.reconnectionTimer = setTimeout(f, 1E3);
                a.reconnectionAttempts++ >= b ? a.redoTransports ? (a.publish("reconnect_failed"),
                    e()) : (a.on("connect_failed", f), a.options["try multiple transports"] = !0, a.transports = a.origTransports, a.transport = a.getTransport(), a.redoTransports = !0, a.connect()) : (a.reconnectionDelay < d && (a.reconnectionDelay *= 2), a.connect(), a.publish("reconnecting", a.reconnectionDelay, a.reconnectionAttempts), a.reconnectionTimer = setTimeout(f, a.reconnectionDelay))
            }

            this.reconnecting = !0, this.reconnectionAttempts = 0, this.reconnectionDelay = this.options["reconnection delay"];
            var a = this, b = this.options["max reconnection attempts"],
                c = this.options["try multiple transports"], d = this.options["reconnection limit"];
            this.options["try multiple transports"] = !1, this.reconnectionTimer = setTimeout(f, this.reconnectionDelay), this.on("connect", f)
        }
    }("undefined" != typeof io ? io : module.exports, "undefined" != typeof io ? io : module.parent.exports, this), function (a, b) {
        function c(a, b) {
            this.socket = a, this.name = b || "", this.flags = {}, this.json = new d(this, "json"), this.ackPackets = 0, this.acks = {}
        }

        function d(a, b) {
            this.namespace = a, this.name = b
        }

        a.SocketNamespace = c, b.util.mixin(c,
            b.EventEmitter), c.prototype.$emit = b.EventEmitter.prototype.emit, c.prototype.of = function () {
            return this.socket.of.apply(this.socket, arguments)
        }, c.prototype.packet = function (a) {
            return a.endpoint = this.name, this.socket.packet(a), this.flags = {}, this
        }, c.prototype.send = function (a, b) {
            var c = {type: this.flags.json ? "json" : "message", data: a};
            return"function" == typeof b && (c.id = ++this.ackPackets, c.ack = !0, this.acks[c.id] = b), this.packet(c)
        }, c.prototype.emit = function (a) {
            var b = Array.prototype.slice.call(arguments, 1), c = b[b.length -
                1], d = {type: "event", name: a};
            return"function" == typeof c && (d.id = ++this.ackPackets, d.ack = "data", this.acks[d.id] = c, b = b.slice(0, b.length - 1)), d.args = b, this.packet(d)
        }, c.prototype.disconnect = function () {
            return this.name === "" ? this.socket.disconnect() : (this.packet({type: "disconnect"}), this.$emit("disconnect")), this
        }, c.prototype.onPacket = function (a) {
            function d() {
                c.packet({type: "ack", args: b.util.toArray(arguments), ackId: a.id})
            }

            var c = this;
            switch (a.type) {
                case "connect":
                    this.$emit("connect");
                    break;
                case "disconnect":
                    this.name ===
                    "" ? this.socket.onDisconnect(a.reason || "booted") : this.$emit("disconnect", a.reason);
                    break;
                case "message":
                case "json":
                    var e = ["message", a.data];
                    a.ack == "data" ? e.push(d) : a.ack && this.packet({type: "ack", ackId: a.id}), this.$emit.apply(this, e);
                    break;
                case "event":
                    var e = [a.name].concat(a.args);
                    a.ack == "data" && e.push(d), this.$emit.apply(this, e);
                    break;
                case "ack":
                    this.acks[a.ackId] && (this.acks[a.ackId].apply(this, a.args), delete this.acks[a.ackId]);
                    break;
                case "error":
                    a.advice ? this.socket.onError(a) : a.reason == "unauthorized" ?
                        this.$emit("connect_failed", a.reason) : this.$emit("error", a.reason)
            }
        }, d.prototype.send = function () {
            this.namespace.flags[this.name] = !0, this.namespace.send.apply(this.namespace, arguments)
        }, d.prototype.emit = function () {
            this.namespace.flags[this.name] = !0, this.namespace.emit.apply(this.namespace, arguments)
        }
    }("undefined" != typeof io ? io : module.exports, "undefined" != typeof io ? io : module.parent.exports), function (a, b, c) {
        function d(a) {
            b.Transport.apply(this, arguments)
        }

        a.websocket = d, b.util.inherit(d, b.Transport), d.prototype.name =
            "websocket", d.prototype.open = function () {
            var a = b.util.query(this.socket.options.query), d = this, e;
            return e || (e = c.MozWebSocket || c.WebSocket), this.websocket = new e(this.prepareUrl() + a), this.websocket.onopen = function () {
                d.onOpen(), d.socket.setBuffer(!1)
            }, this.websocket.onmessage = function (a) {
                d.onData(a.data)
            }, this.websocket.onclose = function () {
                d.onClose(), d.socket.setBuffer(!0)
            }, this.websocket.onerror = function (a) {
                d.onError(a)
            }, this
        }, b.util.ua.iDevice ? d.prototype.send = function (a) {
            var b = this;
            return setTimeout(function () {
                    b.websocket.send(a)
                },
                0), this
        } : d.prototype.send = function (a) {
            return this.websocket.send(a), this
        }, d.prototype.payload = function (a) {
            for (var b = 0, c = a.length; b < c; b++)this.packet(a[b]);
            return this
        }, d.prototype.close = function () {
            return this.websocket.close(), this
        }, d.prototype.onError = function (a) {
            this.socket.onError(a)
        }, d.prototype.scheme = function () {
            return this.socket.options.secure ? "wss" : "ws"
        }, d.check = function () {
            return"WebSocket"in c && !("__addTask"in WebSocket) || "MozWebSocket"in c
        }, d.xdomainCheck = function () {
            return!0
        }, b.transports.push("websocket")
    }("undefined" != typeof io ? io.Transport : module.exports, "undefined" != typeof io ? io : module.parent.exports, this), function (a, b) {
        function c() {
            b.Transport.websocket.apply(this, arguments)
        }

        a.flashsocket = c, b.util.inherit(c, b.Transport.websocket), c.prototype.name = "flashsocket", c.prototype.open = function () {
            var a = this, c = arguments;
            return WebSocket.__addTask(function () {
                b.Transport.websocket.prototype.open.apply(a, c)
            }), this
        }, c.prototype.send = function () {
            var a = this, c = arguments;
            return WebSocket.__addTask(function () {
                b.Transport.websocket.prototype.send.apply(a,
                    c)
            }), this
        }, c.prototype.close = function () {
            return WebSocket.__tasks.length = 0, b.Transport.websocket.prototype.close.call(this), this
        }, c.prototype.ready = function (a, d) {
            function e() {
                var b = a.options, e = b["flash policy port"], g = ["http" + (b.secure ? "s" : "") + ":/", b.host + ":" + b.port, b.resource, "static/flashsocket", "WebSocketMain" + (a.isXDomain() ? "Insecure" : "") + ".swf"];
                c.loaded || (typeof WEB_SOCKET_SWF_LOCATION == "undefined" && (WEB_SOCKET_SWF_LOCATION = g.join("/")), e !== 843 && WebSocket.loadFlashPolicyFile("xmlsocket://" + b.host +
                    ":" + e), WebSocket.__initialize(), c.loaded = !0), d.call(f)
            }

            var f = this;
            if (document.body)return e();
            b.util.load(e)
        }, c.check = function () {
            return typeof WebSocket != "undefined" && "__initialize"in WebSocket && !!swfobject ? swfobject.getFlashPlayerVersion().major >= 10 : !1
        }, c.xdomainCheck = function () {
            return!0
        }, typeof window != "undefined" && (WEB_SOCKET_DISABLE_AUTO_INITIALIZATION = !0), b.transports.push("flashsocket")
    }("undefined" != typeof io ? io.Transport : module.exports, "undefined" != typeof io ? io : module.parent.exports);
    if ("undefined" != typeof window)var swfobject = function () {
        function A() {
            if (t)return;
            try {
                var a = i.getElementsByTagName("body")[0].appendChild(Q("span"));
                a.parentNode.removeChild(a)
            } catch (b) {
                return
            }
            t = !0;
            var c = l.length;
            for (var d = 0; d < c; d++)l[d]()
        }

        function B(a) {
            t ? a() : l[l.length] = a
        }

        function C(b) {
            if (typeof h.addEventListener != a)h.addEventListener("load", b, !1); else if (typeof i.addEventListener != a)i.addEventListener("load", b, !1); else if (typeof h.attachEvent != a)R(h, "onload", b); else if (typeof h.onload == "function") {
                var c = h.onload;
                h.onload = function () {
                    c(), b()
                }
            } else h.onload = b
        }

        function D() {
            k ? E() : F()
        }

        function E() {
            var c = i.getElementsByTagName("body")[0], d = Q(b);
            d.setAttribute("type", e);
            var f = c.appendChild(d);
            if (f) {
                var g = 0;
                (function () {
                    if (typeof f.GetVariable != a) {
                        var b = f.GetVariable("$version");
                        b && (b = b.split(" ")[1].split(","), y.pv = [parseInt(b[0], 10), parseInt(b[1], 10), parseInt(b[2], 10)])
                    } else if (g < 10) {
                        g++, setTimeout(arguments.callee, 10);
                        return
                    }
                    c.removeChild(d), f = null, F()
                })()
            } else F()
        }

        function F() {
            var b = m.length;
            if (b > 0)for (var c = 0; c <
                b; c++) {
                var d = m[c].id, e = m[c].callbackFn, f = {success: !1, id: d};
                if (y.pv[0] > 0) {
                    var g = P(d);
                    if (g)if (S(m[c].swfVersion) && !(y.wk && y.wk < 312))U(d, !0), e && (f.success = !0, f.ref = G(d), e(f)); else if (m[c].expressInstall && H()) {
                        var h = {};
                        h.data = m[c].expressInstall, h.width = g.getAttribute("width") || "0", h.height = g.getAttribute("height") || "0", g.getAttribute("class") && (h.styleclass = g.getAttribute("class")), g.getAttribute("align") && (h.align = g.getAttribute("align"));
                        var i = {}, j = g.getElementsByTagName("param"), k = j.length;
                        for (var l =
                            0; l < k; l++)j[l].getAttribute("name").toLowerCase() != "movie" && (i[j[l].getAttribute("name")] = j[l].getAttribute("value"));
                        I(h, i, d, e)
                    } else J(g), e && e(f)
                } else {
                    U(d, !0);
                    if (e) {
                        var n = G(d);
                        n && typeof n.SetVariable != a && (f.success = !0, f.ref = n), e(f)
                    }
                }
            }
        }

        function G(c) {
            var d = null, e = P(c);
            if (e && e.nodeName == "OBJECT")if (typeof e.SetVariable != a)d = e; else {
                var f = e.getElementsByTagName(b)[0];
                f && (d = f)
            }
            return d
        }

        function H() {
            return!u && S("6.0.65") && (y.win || y.mac) && !(y.wk && y.wk < 312)
        }

        function I(b, c, d, e) {
            u = !0, r = e || null, s = {success: !1,
                id: d};
            var g = P(d);
            if (g) {
                g.nodeName == "OBJECT" ? (p = K(g), q = null) : (p = g, q = d), b.id = f;
                if (typeof b.width == a || !/%$/.test(b.width) && parseInt(b.width, 10) < 310)b.width = "310";
                if (typeof b.height == a || !/%$/.test(b.height) && parseInt(b.height, 10) < 137)b.height = "137";
                i.title = i.title.slice(0, 47) + " - Flash Player Installation";
                var j = y.ie && y.win ? ["Active"].concat("").join("X") : "PlugIn", k = "MMredirectURL\x3d" + h.location.toString().replace(/&/g, "%26") + "\x26MMplayerType\x3d" + j + "\x26MMdoctitle\x3d" + i.title;
                typeof c.flashvars !=
                a ? c.flashvars += "\x26" + k : c.flashvars = k;
                if (y.ie && y.win && g.readyState != 4) {
                    var l = Q("div");
                    d += "SWFObjectNew", l.setAttribute("id", d), g.parentNode.insertBefore(l, g), g.style.display = "none", function () {
                        g.readyState == 4 ? g.parentNode.removeChild(g) : setTimeout(arguments.callee, 10)
                    }()
                }
                L(b, c, d)
            }
        }

        function J(a) {
            if (y.ie && y.win && a.readyState != 4) {
                var b = Q("div");
                a.parentNode.insertBefore(b, a), b.parentNode.replaceChild(K(a), b), a.style.display = "none", function () {
                    a.readyState == 4 ? a.parentNode.removeChild(a) : setTimeout(arguments.callee,
                        10)
                }()
            } else a.parentNode.replaceChild(K(a), a)
        }

        function K(a) {
            var c = Q("div");
            if (y.win && y.ie)c.innerHTML = a.innerHTML; else {
                var d = a.getElementsByTagName(b)[0];
                if (d) {
                    var e = d.childNodes;
                    if (e) {
                        var f = e.length;
                        for (var g = 0; g < f; g++)(e[g].nodeType != 1 || e[g].nodeName != "PARAM") && e[g].nodeType != 8 && c.appendChild(e[g].cloneNode(!0))
                    }
                }
            }
            return c
        }

        function L(c, d, f) {
            var g, h = P(f);
            if (y.wk && y.wk < 312)return g;
            if (h) {
                typeof c.id == a && (c.id = f);
                if (y.ie && y.win) {
                    var i = "";
                    for (var j in c)c[j] != Object.prototype[j] && (j.toLowerCase() ==
                        "data" ? d.movie = c[j] : j.toLowerCase() == "styleclass" ? i += ' class\x3d"' + c[j] + '"' : j.toLowerCase() != "classid" && (i += " " + j + '\x3d"' + c[j] + '"'));
                    var k = "";
                    for (var l in d)d[l] != Object.prototype[l] && (k += '\x3cparam name\x3d"' + l + '" value\x3d"' + d[l] + '" /\x3e');
                    h.outerHTML = '\x3cobject classid\x3d"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"' + i + "\x3e" + k + "\x3c/object\x3e", n[n.length] = c.id, g = P(c.id)
                } else {
                    var m = Q(b);
                    m.setAttribute("type", e);
                    for (var o in c)c[o] != Object.prototype[o] && (o.toLowerCase() == "styleclass" ? m.setAttribute("class",
                        c[o]) : o.toLowerCase() != "classid" && m.setAttribute(o, c[o]));
                    for (var p in d)d[p] != Object.prototype[p] && p.toLowerCase() != "movie" && M(m, p, d[p]);
                    h.parentNode.replaceChild(m, h), g = m
                }
            }
            return g
        }

        function M(a, b, c) {
            var d = Q("param");
            d.setAttribute("name", b), d.setAttribute("value", c), a.appendChild(d)
        }

        function N(a) {
            var b = P(a);
            b && b.nodeName == "OBJECT" && (y.ie && y.win ? (b.style.display = "none", function () {
                b.readyState == 4 ? O(a) : setTimeout(arguments.callee, 10)
            }()) : b.parentNode.removeChild(b))
        }

        function O(a) {
            var b = P(a);
            if (b) {
                for (var c in b)typeof b[c] ==
                "function" && (b[c] = null);
                b.parentNode.removeChild(b)
            }
        }

        function P(a) {
            var b = null;
            try {
                b = i.getElementById(a)
            } catch (c) {
            }
            return b
        }

        function Q(a) {
            return i.createElement(a)
        }

        function R(a, b, c) {
            a.attachEvent(b, c), o[o.length] = [a, b, c]
        }

        function S(a) {
            var b = y.pv, c = a.split(".");
            return c[0] = parseInt(c[0], 10), c[1] = parseInt(c[1], 10) || 0, c[2] = parseInt(c[2], 10) || 0, b[0] > c[0] || b[0] == c[0] && b[1] > c[1] || b[0] == c[0] && b[1] == c[1] && b[2] >= c[2] ? !0 : !1
        }

        function T(c, d, e, f) {
            if (y.ie && y.mac)return;
            var g = i.getElementsByTagName("head")[0];
            if (!g)return;
            var h = e && typeof e == "string" ? e : "screen";
            f && (v = null, w = null);
            if (!v || w != h) {
                var j = Q("style");
                j.setAttribute("type", "text/css"), j.setAttribute("media", h), v = g.appendChild(j), y.ie && y.win && typeof i.styleSheets != a && i.styleSheets.length > 0 && (v = i.styleSheets[i.styleSheets.length - 1]), w = h
            }
            y.ie && y.win ? v && typeof v.addRule == b && v.addRule(c, d) : v && typeof i.createTextNode != a && v.appendChild(i.createTextNode(c + " {" + d + "}"))
        }

        function U(a, b) {
            if (!x)return;
            var c = b ? "visible" : "hidden";
            t && P(a) ? P(a).style.visibility = c : T("#" + a, "visibility:" +
                c)
        }

        function V(b) {
            var c = /[\\\"<>\.;]/, d = c.exec(b) != null;
            return d && typeof encodeURIComponent != a ? encodeURIComponent(b) : b
        }

        var a = "undefined", b = "object", c = "Shockwave Flash", d = "ShockwaveFlash.ShockwaveFlash", e = "application/x-shockwave-flash", f = "SWFObjectExprInst", g = "onreadystatechange", h = window, i = document, j = navigator, k = !1, l = [D], m = [], n = [], o = [], p, q, r, s, t = !1, u = !1, v, w, x = !0, y = function () {
            var f = typeof i.getElementById != a && typeof i.getElementsByTagName != a && typeof i.createElement != a, g = j.userAgent.toLowerCase(), l =
                j.platform.toLowerCase(), m = l ? /win/.test(l) : /win/.test(g), n = l ? /mac/.test(l) : /mac/.test(g), o = /webkit/.test(g) ? parseFloat(g.replace(/^.*webkit\/(\d+(\.\d+)?).*$/, "$1")) : !1, p = !1, q = [0, 0, 0], r = null;
            if (typeof j.plugins != a && typeof j.plugins[c] == b)r = j.plugins[c].description, r && (typeof j.mimeTypes == a || !j.mimeTypes[e] || !!j.mimeTypes[e].enabledPlugin) && (k = !0, p = !1, r = r.replace(/^.*\s+(\S+\s+\S+$)/, "$1"), q[0] = parseInt(r.replace(/^(.*)\..*$/, "$1"), 10), q[1] = parseInt(r.replace(/^.*\.(.*)\s.*$/, "$1"), 10), q[2] = /[a-zA-Z]/.test(r) ?
                parseInt(r.replace(/^.*[a-zA-Z]+(.*)$/, "$1"), 10) : 0); else if (typeof h[["Active"].concat("Object").join("X")] != a)try {
                var s = new (window[["Active"].concat("Object").join("X")])(d);
                s && (r = s.GetVariable("$version"), r && (p = !0, r = r.split(" ")[1].split(","), q = [parseInt(r[0], 10), parseInt(r[1], 10), parseInt(r[2], 10)]))
            } catch (t) {
            }
            return{w3: f, pv: q, wk: o, ie: p, win: m, mac: n}
        }(), z = function () {
            if (!y.w3)return;
            (typeof i.readyState != a && i.readyState == "complete" || typeof i.readyState == a && (i.getElementsByTagName("body")[0] || i.body)) &&
            A(), t || (typeof i.addEventListener != a && i.addEventListener("DOMContentLoaded", A, !1), y.ie && y.win && (i.attachEvent(g, function () {
                i.readyState == "complete" && (i.detachEvent(g, arguments.callee), A())
            }), h == top && function () {
                if (t)return;
                try {
                    i.documentElement.doScroll("left")
                } catch (a) {
                    setTimeout(arguments.callee, 0);
                    return
                }
                A()
            }()), y.wk && function () {
                if (t)return;
                if (!/loaded|complete/.test(i.readyState)) {
                    setTimeout(arguments.callee, 0);
                    return
                }
                A()
            }(), C(A))
        }(), W = function () {
            y.ie && y.win && window.attachEvent("onunload", function () {
                var a =
                    o.length;
                for (var b = 0; b < a; b++)o[b][0].detachEvent(o[b][1], o[b][2]);
                var c = n.length;
                for (var d = 0; d < c; d++)N(n[d]);
                for (var e in y)y[e] = null;
                y = null;
                for (var f in swfobject)swfobject[f] = null;
                swfobject = null
            })
        }();
        return{registerObject: function (a, b, c, d) {
            if (y.w3 && a && b) {
                var e = {};
                e.id = a, e.swfVersion = b, e.expressInstall = c, e.callbackFn = d, m[m.length] = e, U(a, !1)
            } else d && d({success: !1, id: a})
        }, getObjectById: function (a) {
            if (y.w3)return G(a)
        }, embedSWF: function (c, d, e, f, g, h, i, j, k, l) {
            var m = {success: !1, id: d};
            y.w3 && !(y.wk && y.wk <
                312) && c && d && e && f && g ? (U(d, !1), B(function () {
                e += "", f += "";
                var n = {};
                if (k && typeof k === b)for (var o in k)n[o] = k[o];
                n.data = c, n.width = e, n.height = f;
                var p = {};
                if (j && typeof j === b)for (var q in j)p[q] = j[q];
                if (i && typeof i === b)for (var r in i)typeof p.flashvars != a ? p.flashvars += "\x26" + r + "\x3d" + i[r] : p.flashvars = r + "\x3d" + i[r];
                if (S(g)) {
                    var s = L(n, p, d);
                    n.id == d && U(d, !0), m.success = !0, m.ref = s
                } else {
                    if (h && H()) {
                        n.data = h, I(n, p, d, l);
                        return
                    }
                    U(d, !0)
                }
                l && l(m)
            })) : l && l(m)
        }, switchOffAutoHideShow: function () {
            x = !1
        }, ua: y, getFlashPlayerVersion: function () {
            return{major: y.pv[0],
                minor: y.pv[1], release: y.pv[2]}
        }, hasFlashPlayerVersion: S, createSWF: function (a, b, c) {
            return y.w3 ? L(a, b, c) : undefined
        }, showExpressInstall: function (a, b, c, d) {
            y.w3 && H() && I(a, b, c, d)
        }, removeSWF: function (a) {
            y.w3 && N(a)
        }, createCSS: function (a, b, c, d) {
            y.w3 && T(a, b, c, d)
        }, addDomLoadEvent: B, addLoadEvent: C, getQueryParamValue: function (a) {
            var b = i.location.search || i.location.hash;
            if (b) {
                /\?/.test(b) && (b = b.split("?")[1]);
                if (a == null)return V(b);
                var c = b.split("\x26");
                for (var d = 0; d < c.length; d++)if (c[d].substring(0, c[d].indexOf("\x3d")) ==
                    a)return V(c[d].substring(c[d].indexOf("\x3d") + 1))
            }
            return""
        }, expressInstallCallback: function () {
            if (u) {
                var a = P(f);
                a && p && (a.parentNode.replaceChild(p, a), q && (U(q, !0), y.ie && y.win && (p.style.display = "block")), r && r(s)), u = !1
            }
        }}
    }();
    (function () {
        if ("undefined" == typeof window || window.WebSocket)return;
        var a = window.console;
        if (!a || !a.log || !a.error)a = {log: function () {
        }, error: function () {
        }};
        if (!swfobject.hasFlashPlayerVersion("10.0.0")) {
            a.error("Flash Player \x3e\x3d 10.0.0 is required.");
            return
        }
        location.protocol == "file:" &&
        a.error("WARNING: web-socket-js doesn't work in file:///... URL unless you set Flash Security Settings properly. Open the page via Web server i.e. http://..."), WebSocket = function (a, b, c, d, e) {
            var f = this;
            f.__id = WebSocket.__nextId++, WebSocket.__instances[f.__id] = f, f.readyState = WebSocket.CONNECTING, f.bufferedAmount = 0, f.__events = {}, b ? typeof b == "string" && (b = [b]) : b = [], setTimeout(function () {
                WebSocket.__addTask(function () {
                    WebSocket.__flash.create(f.__id, a, b, c || null, d || 0, e || null)
                })
            }, 0)
        }, WebSocket.prototype.send =
            function (a) {
                if (this.readyState == WebSocket.CONNECTING)throw"INVALID_STATE_ERR: Web Socket connection has not been established";
                var b = WebSocket.__flash.send(this.__id, encodeURIComponent(a));
                return b < 0 ? !0 : (this.bufferedAmount += b, !1)
            }, WebSocket.prototype.close = function () {
            if (this.readyState == WebSocket.CLOSED || this.readyState == WebSocket.CLOSING)return;
            this.readyState = WebSocket.CLOSING, WebSocket.__flash.close(this.__id)
        }, WebSocket.prototype.addEventListener = function (a, b, c) {
            a in this.__events || (this.__events[a] =
                []), this.__events[a].push(b)
        }, WebSocket.prototype.removeEventListener = function (a, b, c) {
            if (!(a in this.__events))return;
            var d = this.__events[a];
            for (var e = d.length - 1; e >= 0; --e)if (d[e] === b) {
                d.splice(e, 1);
                break
            }
        }, WebSocket.prototype.dispatchEvent = function (a) {
            var b = this.__events[a.type] || [];
            for (var c = 0; c < b.length; ++c)b[c](a);
            var d = this["on" + a.type];
            d && d(a)
        }, WebSocket.prototype.__handleEvent = function (a) {
            "readyState"in a && (this.readyState = a.readyState), "protocol"in a && (this.protocol = a.protocol);
            var b;
            if (a.type ==
                "open" || a.type == "error")b = this.__createSimpleEvent(a.type); else if (a.type == "close")b = this.__createSimpleEvent("close"); else {
                if (a.type != "message")throw"unknown event type: " + a.type;
                var c = decodeURIComponent(a.message);
                b = this.__createMessageEvent("message", c)
            }
            this.dispatchEvent(b)
        }, WebSocket.prototype.__createSimpleEvent = function (a) {
            if (document.createEvent && window.Event) {
                var b = document.createEvent("Event");
                return b.initEvent(a, !1, !1), b
            }
            return{type: a, bubbles: !1, cancelable: !1}
        }, WebSocket.prototype.__createMessageEvent =
            function (a, b) {
                if (document.createEvent && window.MessageEvent && !window.opera) {
                    var c = document.createEvent("MessageEvent");
                    return c.initMessageEvent("message", !1, !1, b, null, null, window, null), c
                }
                return{type: a, data: b, bubbles: !1, cancelable: !1}
            }, WebSocket.CONNECTING = 0, WebSocket.OPEN = 1, WebSocket.CLOSING = 2, WebSocket.CLOSED = 3, WebSocket.__flash = null, WebSocket.__instances = {}, WebSocket.__tasks = [], WebSocket.__nextId = 0, WebSocket.loadFlashPolicyFile = function (a) {
            WebSocket.__addTask(function () {
                WebSocket.__flash.loadManualPolicyFile(a)
            })
        },
            WebSocket.__initialize = function () {
                if (WebSocket.__flash)return;
                WebSocket.__swfLocation && (window.WEB_SOCKET_SWF_LOCATION = WebSocket.__swfLocation);
                if (!window.WEB_SOCKET_SWF_LOCATION) {
                    a.error("[WebSocket] set WEB_SOCKET_SWF_LOCATION to location of WebSocketMain.swf");
                    return
                }
                var b = document.createElement("div");
                b.id = "webSocketContainer", b.style.position = "absolute", WebSocket.__isFlashLite() ? (b.style.left = "0px", b.style.top = "0px") : (b.style.left = "-100px", b.style.top = "-100px");
                var c = document.createElement("div");
                c.id = "webSocketFlash", b.appendChild(c), document.body.appendChild(b), swfobject.embedSWF(WEB_SOCKET_SWF_LOCATION, "webSocketFlash", "1", "1", "10.0.0", null, null, {hasPriority: !0, swliveconnect: !0, allowScriptAccess: "always"}, null, function (b) {
                    b.success || a.error("[WebSocket] swfobject.embedSWF failed")
                })
            }, WebSocket.__onFlashInitialized = function () {
            setTimeout(function () {
                WebSocket.__flash = document.getElementById("webSocketFlash"), WebSocket.__flash.setCallerUrl(location.href), WebSocket.__flash.setDebug(!!window.WEB_SOCKET_DEBUG);
                for (var a = 0; a < WebSocket.__tasks.length; ++a)WebSocket.__tasks[a]();
                WebSocket.__tasks = []
            }, 0)
        }, WebSocket.__onFlashEvent = function () {
            return setTimeout(function () {
                try {
                    var b = WebSocket.__flash.receiveEvents();
                    for (var c = 0; c < b.length; ++c)WebSocket.__instances[b[c].webSocketId].__handleEvent(b[c])
                } catch (d) {
                    a.error(d)
                }
            }, 0), !0
        }, WebSocket.__log = function (b) {
            a.log(decodeURIComponent(b))
        }, WebSocket.__error = function (b) {
            a.error(decodeURIComponent(b))
        }, WebSocket.__addTask = function (a) {
            WebSocket.__flash ? a() : WebSocket.__tasks.push(a)
        },
            WebSocket.__isFlashLite = function () {
                if (!window.navigator || !window.navigator.mimeTypes)return!1;
                var a = window.navigator.mimeTypes["application/x-shockwave-flash"];
                return!a || !a.enabledPlugin || !a.enabledPlugin.filename ? !1 : a.enabledPlugin.filename.match(/flashlite/i) ? !0 : !1
            }, window.WEB_SOCKET_DISABLE_AUTO_INITIALIZATION || (window.addEventListener ? window.addEventListener("load", function () {
            WebSocket.__initialize()
        }, !1) : window.attachEvent("onload", function () {
            WebSocket.__initialize()
        }))
    })(), function (a, b, c) {
        function d(a) {
            if (!a)return;
            b.Transport.apply(this, arguments), this.sendBuffer = []
        }

        function e() {
        }

        a.XHR = d, b.util.inherit(d, b.Transport), d.prototype.open = function () {
            return this.socket.setBuffer(!1), this.onOpen(), this.get(), this.setCloseTimeout(), this
        }, d.prototype.payload = function (a) {
            var c = [];
            for (var d = 0, e = a.length; d < e; d++)c.push(b.parser.encodePacket(a[d]));
            this.send(b.parser.encodePayload(c))
        }, d.prototype.send = function (a) {
            return this.post(a), this
        }, d.prototype.post = function (a) {
            function d() {
                this.readyState == 4 && (this.onreadystatechange =
                    e, b.posting = !1, this.status == 200 ? b.socket.setBuffer(!1) : b.onClose())
            }

            function f() {
                this.onload = e, b.socket.setBuffer(!1)
            }

            var b = this;
            this.socket.setBuffer(!0), this.sendXHR = this.request("POST"), c.XDomainRequest && this.sendXHR instanceof XDomainRequest ? this.sendXHR.onload = this.sendXHR.onerror = f : this.sendXHR.onreadystatechange = d, this.sendXHR.send(a)
        }, d.prototype.close = function () {
            return this.onClose(), this
        }, d.prototype.request = function (a) {
            var c = b.util.request(this.socket.isXDomain()), d = b.util.query(this.socket.options.query,
                    "t\x3d" + +new Date);
            c.open(a || "GET", this.prepareUrl() + d, !0);
            if (a == "POST")try {
                c.setRequestHeader ? c.setRequestHeader("Content-type", "text/plain;charset\x3dUTF-8") : c.contentType = "text/plain"
            } catch (e) {
            }
            return c
        }, d.prototype.scheme = function () {
            return this.socket.options.secure ? "https" : "http"
        }, d.check = function (a, d) {
            try {
                var e = b.util.request(d), f = c.XDomainRequest && e instanceof XDomainRequest, g = a && a.options && a.options.secure ? "https:" : "http:", h = c.location && g != c.location.protocol;
                if (e && (!f || !h))return!0
            } catch (i) {
            }
            return!1
        },
            d.xdomainCheck = function (a) {
                return d.check(a, !0)
            }
    }("undefined" != typeof io ? io.Transport : module.exports, "undefined" != typeof io ? io : module.parent.exports, this), function (a, b) {
        function c(a) {
            b.Transport.XHR.apply(this, arguments)
        }

        a.htmlfile = c, b.util.inherit(c, b.Transport.XHR), c.prototype.name = "htmlfile", c.prototype.get = function () {
            this.doc = new (window[["Active"].concat("Object").join("X")])("htmlfile"), this.doc.open(), this.doc.write("\x3chtml\x3e\x3c/html\x3e"), this.doc.close(), this.doc.parentWindow.s = this;
            var a = this.doc.createElement("div");
            a.className = "socketio", this.doc.body.appendChild(a), this.iframe = this.doc.createElement("iframe"), a.appendChild(this.iframe);
            var c = this, d = b.util.query(this.socket.options.query, "t\x3d" + +new Date);
            this.iframe.src = this.prepareUrl() + d, b.util.on(window, "unload", function () {
                c.destroy()
            })
        }, c.prototype._ = function (a, b) {
            a = a.replace(/\\\//g, "/"), this.onData(a);
            try {
                var c = b.getElementsByTagName("script")[0];
                c.parentNode.removeChild(c)
            } catch (d) {
            }
        }, c.prototype.destroy = function () {
            if (this.iframe) {
                try {
                    this.iframe.src =
                        "about:blank"
                } catch (a) {
                }
                this.doc = null, this.iframe.parentNode.removeChild(this.iframe), this.iframe = null, CollectGarbage()
            }
        }, c.prototype.close = function () {
            return this.destroy(), b.Transport.XHR.prototype.close.call(this)
        }, c.check = function (a) {
            if (typeof window != "undefined" && ["Active"].concat("Object").join("X")in window)try {
                var c = new (window[["Active"].concat("Object").join("X")])("htmlfile");
                return c && b.Transport.XHR.check(a)
            } catch (d) {
            }
            return!1
        }, c.xdomainCheck = function () {
            return!1
        }, b.transports.push("htmlfile")
    }("undefined" != typeof io ? io.Transport : module.exports, "undefined" != typeof io ? io : module.parent.exports), function (a, b, c) {
        function d() {
            b.Transport.XHR.apply(this, arguments)
        }

        function e() {
        }

        a["xhr-polling"] = d, b.util.inherit(d, b.Transport.XHR), b.util.merge(d, b.Transport.XHR), d.prototype.name = "xhr-polling", d.prototype.heartbeats = function () {
            return!1
        }, d.prototype.open = function () {
            var a = this;
            return b.Transport.XHR.prototype.open.call(a), !1
        }, d.prototype.get = function () {
            function b() {
                this.readyState == 4 && (this.onreadystatechange =
                    e, this.status == 200 ? (a.onData(this.responseText), a.get()) : a.onClose())
            }

            function d() {
                this.onload = e, this.onerror = e, a.retryCounter = 1, a.onData(this.responseText), a.get()
            }

            function f() {
                a.retryCounter++, !a.retryCounter || a.retryCounter > 3 ? a.onClose() : a.get()
            }

            if (!this.isOpen)return;
            var a = this;
            this.xhr = this.request(), c.XDomainRequest && this.xhr instanceof XDomainRequest ? (this.xhr.onload = d, this.xhr.onerror = f) : this.xhr.onreadystatechange = b, this.xhr.send(null)
        }, d.prototype.onClose = function () {
            b.Transport.XHR.prototype.onClose.call(this);
            if (this.xhr) {
                this.xhr.onreadystatechange = this.xhr.onload = this.xhr.onerror = e;
                try {
                    this.xhr.abort()
                } catch (a) {
                }
                this.xhr = null
            }
        }, d.prototype.ready = function (a, c) {
            var d = this;
            b.util.defer(function () {
                c.call(d)
            })
        }, b.transports.push("xhr-polling")
    }("undefined" != typeof io ? io.Transport : module.exports, "undefined" != typeof io ? io : module.parent.exports, this), function (a, b, c) {
        function e(a) {
            b.Transport["xhr-polling"].apply(this, arguments), this.index = b.j.length;
            var c = this;
            b.j.push(function (a) {
                c._(a)
            })
        }

        var d = c.document &&
            "MozAppearance"in c.document.documentElement.style;
        a["jsonp-polling"] = e, b.util.inherit(e, b.Transport["xhr-polling"]), e.prototype.name = "jsonp-polling", e.prototype.post = function (a) {
            function i() {
                j(), c.socket.setBuffer(!1)
            }

            function j() {
                c.iframe && c.form.removeChild(c.iframe);
                try {
                    h = document.createElement('\x3ciframe name\x3d"' + c.iframeId + '"\x3e')
                } catch (a) {
                    h = document.createElement("iframe"), h.name = c.iframeId
                }
                h.id = c.iframeId, c.form.appendChild(h), c.iframe = h
            }

            var c = this, d = b.util.query(this.socket.options.query,
                    "t\x3d" + +new Date + "\x26i\x3d" + this.index);
            if (!this.form) {
                var e = document.createElement("form"), f = document.createElement("textarea"), g = this.iframeId = "socketio_iframe_" + this.index, h;
                e.className = "socketio", e.style.position = "absolute", e.style.top = "0px", e.style.left = "0px", e.style.display = "none", e.target = g, e.method = "POST", e.setAttribute("accept-charset", "utf-8"), f.name = "d", e.appendChild(f), document.body.appendChild(e), this.form = e, this.area = f
            }
            this.form.action = this.prepareUrl() + d, j(), this.area.value = b.JSON.stringify(a);
            try {
                this.form.submit()
            } catch (k) {
            }
            this.iframe.attachEvent ? h.onreadystatechange = function () {
                c.iframe.readyState == "complete" && i()
            } : this.iframe.onload = i, this.socket.setBuffer(!0)
        }, e.prototype.get = function () {
            var a = this, c = document.createElement("script"), e = b.util.query(this.socket.options.query, "t\x3d" + +new Date + "\x26i\x3d" + this.index);
            this.script && (this.script.parentNode.removeChild(this.script), this.script = null), c.async = !0, c.src = this.prepareUrl() + e, c.onerror = function () {
                a.onClose()
            };
            var f = document.getElementsByTagName("script")[0];
            f.parentNode.insertBefore(c, f), this.script = c, d && setTimeout(function () {
                var a = document.createElement("iframe");
                document.body.appendChild(a), document.body.removeChild(a)
            }, 100)
        }, e.prototype._ = function (a) {
            return this.onData(a), this.isOpen && this.get(), this
        }, e.prototype.ready = function (a, c) {
            var e = this;
            if (!d)return c.call(this);
            b.util.load(function () {
                c.call(e)
            })
        }, e.check = function () {
            return"document"in c
        }, e.xdomainCheck = function () {
            return!0
        }, b.transports.push("jsonp-polling")
    }("undefined" != typeof io ? io.Transport :
        module.exports, "undefined" != typeof io ? io : module.parent.exports, this), typeof define == "function" && define.amd && define([], function () {
        return io
    })
})();(function () {
    Object.create = Object.create || function (o) {
        function F() {
        }

        F.prototype = o;
        return new F
    };
    var cp;
    if (typeof exports === "undefined") {
        cp = {};
        if (typeof window === "object")window["cp"] = cp
    } else cp = exports;
    var assert = function (value, message) {
        if (!value)throw new Error("Assertion failed: " + message);
    };
    var assertSoft = function (value, message) {
        if (!value && console && console.warn) {
            console.warn("ASSERTION FAILED: " + message);
            if (console.trace)console.trace()
        }
    };
    var mymin = function (a, b) {
        return a < b ? a : b
    };
    var mymax = function (a, b) {
        return a > b ? a : b
    };
    var min, max;
    if (typeof window === "object" && window.navigator.userAgent.indexOf("Firefox") > -1) {
        min = Math.min;
        max = Math.max
    } else {
        min = mymin;
        max = mymax
    }
    var hashPair = function (a, b) {
        return a < b ? a + " " + b : b + " " + a
    };
    var deleteObjFromList = function (arr, obj) {
        for (var i = 0; i < arr.length; i++)if (arr[i] === obj) {
            arr[i] = arr[arr.length - 1];
            arr.length--;
            return
        }
    };
    var momentForCircle = cp.momentForCircle = function (m, r1, r2, offset) {
        return m * (0.5 * (r1 * r1 + r2 * r2) + vlengthsq(offset))
    };
    var areaForCircle = cp.areaForCircle = function (r1, r2) {
        return Math.PI * Math.abs(r1 * r1 - r2 * r2)
    };
    var momentForSegment = cp.momentForSegment = function (m, a, b) {
        var length = vlength(vsub(b, a));
        var offset = vmult(vadd(a, b), 1 / 2);
        return m * (length * length / 12 + vlengthsq(offset))
    };
    var areaForSegment = cp.areaForSegment = function (a, b, r) {
        return r * (Math.PI * r + 2 * vdist(a, b))
    };
    var momentForPoly = cp.momentForPoly = function (m, verts, offset) {
        var sum1 = 0;
        var sum2 = 0;
        var len = verts.length;
        for (var i = 0; i < len; i += 2) {
            var v1x = verts[i] + offset.x;
            var v1y = verts[i + 1] + offset.y;
            var v2x = verts[(i + 2) % len] +
                offset.x;
            var v2y = verts[(i + 3) % len] + offset.y;
            var a = vcross2(v2x, v2y, v1x, v1y);
            var b = vdot2(v1x, v1y, v1x, v1y) + vdot2(v1x, v1y, v2x, v2y) + vdot2(v2x, v2y, v2x, v2y);
            sum1 += a * b;
            sum2 += a
        }
        return m * sum1 / (6 * sum2)
    };
    var areaForPoly = cp.areaForPoly = function (verts) {
        var area = 0;
        for (var i = 0, len = verts.length; i < len; i += 2)area += vcross(new Vect(verts[i], verts[i + 1]), new Vect(verts[(i + 2) % len], verts[(i + 3) % len]));
        return-area / 2
    };
    var centroidForPoly = cp.centroidForPoly = function (verts) {
        var sum = 0;
        var vsum = new Vect(0, 0);
        for (var i = 0, len = verts.length; i <
            len; i += 2) {
            var v1 = new Vect(verts[i], verts[i + 1]);
            var v2 = new Vect(verts[(i + 2) % len], verts[(i + 3) % len]);
            var cross = vcross(v1, v2);
            sum += cross;
            vsum = vadd(vsum, vmult(vadd(v1, v2), cross))
        }
        return vmult(vsum, 1 / (3 * sum))
    };
    var recenterPoly = cp.recenterPoly = function (verts) {
        var centroid = centroidForPoly(verts);
        for (var i = 0; i < verts.length; i += 2) {
            verts[i] -= centroid.x;
            verts[i + 1] -= centroid.y
        }
    };
    var momentForBox = cp.momentForBox = function (m, width, height) {
        return m * (width * width + height * height) / 12
    };
    var momentForBox2 = cp.momentForBox2 =
        function (m, box) {
            width = box.r - box.l;
            height = box.t - box.b;
            offset = vmult([box.l + box.r, box.b + box.t], 0.5);
            return momentForBox(m, width, height) + m * vlengthsq(offset)
        };
    var clamp = function (f, minv, maxv) {
        return min(max(f, minv), maxv)
    };
    var clamp01 = cp.clamp01 = function (f) {
        return max(0, min(f, 1))
    };
    var lerp = function (f1, f2, t) {
        return f1 * (1 - t) + f2 * t
    };
    var lerpconst = function (f1, f2, d) {
        return f1 + clamp(f2 - f1, -d, d)
    };
    var numVects = 0;
    var traces = {};
    var Vect = cp.Vect = function (x, y) {
        this.x = x;
        this.y = y;
        numVects++
    };
    cp.v = function (x, y) {
        return new Vect(x,
            y)
    };
    var vzero = cp.vzero = new Vect(0, 0);
    var vdot = cp.v.dot = function (v1, v2) {
        return v1.x * v2.x + v1.y * v2.y
    };
    var vdot2 = function (x1, y1, x2, y2) {
        return x1 * x2 + y1 * y2
    };
    var vlength = cp.v.len = function (v) {
        return Math.sqrt(vdot(v, v))
    };
    var veql = cp.v.eql = function (v1, v2) {
        return v1.x === v2.x && v1.y === v2.y
    };
    var vadd = cp.v.add = function (v1, v2) {
        return new Vect(v1.x + v2.x, v1.y + v2.y)
    };
    Vect.prototype.add = function (v2) {
        this.x += v2.x;
        this.y += v2.y;
        return this
    };
    var vsub = cp.v.sub = function (v1, v2) {
        return new Vect(v1.x - v2.x, v1.y - v2.y)
    };
    Vect.prototype.sub =
        function (v2) {
            this.x -= v2.x;
            this.y -= v2.y;
            return this
        };
    var vneg = cp.v.neg = function (v) {
        return new Vect(-v.x, -v.y)
    };
    Vect.prototype.neg = function () {
        this.x = -this.x;
        this.y = -this.y;
        return this
    };
    var vmult = cp.v.mult = function (v, s) {
        return new Vect(v.x * s, v.y * s)
    };
    Vect.prototype.mult = function (s) {
        this.x *= s;
        this.y *= s;
        return this
    };
    var vcross = cp.v.cross = function (v1, v2) {
        return v1.x * v2.y - v1.y * v2.x
    };
    var vcross2 = function (x1, y1, x2, y2) {
        return x1 * y2 - y1 * x2
    };
    var vperp = cp.v.perp = function (v) {
        return new Vect(-v.y, v.x)
    };
    var vpvrperp =
        cp.v.pvrperp = function (v) {
            return new Vect(v.y, -v.x)
        };
    var vproject = cp.v.project = function (v1, v2) {
        return vmult(v2, vdot(v1, v2) / vlengthsq(v2))
    };
    Vect.prototype.project = function (v2) {
        this.mult(vdot(this, v2) / vlengthsq(v2));
        return this
    };
    var vrotate = cp.v.rotate = function (v1, v2) {
        return new Vect(v1.x * v2.x - v1.y * v2.y, v1.x * v2.y + v1.y * v2.x)
    };
    Vect.prototype.rotate = function (v2) {
        this.x = this.x * v2.x - this.y * v2.y;
        this.y = this.x * v2.y + this.y * v2.x;
        return this
    };
    var vunrotate = cp.v.unrotate = function (v1, v2) {
        return new Vect(v1.x * v2.x +
            v1.y * v2.y, v1.y * v2.x - v1.x * v2.y)
    };
    var vlengthsq = cp.v.lengthsq = function (v) {
        return vdot(v, v)
    };
    var vlerp = cp.v.lerp = function (v1, v2, t) {
        return vadd(vmult(v1, 1 - t), vmult(v2, t))
    };
    var vnormalize = cp.v.normalize = function (v) {
        return vmult(v, 1 / vlength(v))
    };
    var vnormalize_safe = cp.v.normalize_safe = function (v) {
        return v.x === 0 && v.y === 0 ? vzero : vnormalize(v)
    };
    var vclamp = cp.v.clamp = function (v, len) {
        return vdot(v, v) > len * len ? vmult(vnormalize(v), len) : v
    };
    var vlerpconst = cp.v.lerpconst = function (v1, v2, d) {
        return vadd(v1, vclamp(vsub(v2,
            v1), d))
    };
    var vdist = cp.v.dist = function (v1, v2) {
        return vlength(vsub(v1, v2))
    };
    var vdistsq = cp.v.distsq = function (v1, v2) {
        return vlengthsq(vsub(v1, v2))
    };
    var vnear = cp.v.near = function (v1, v2, dist) {
        return vdistsq(v1, v2) < dist * dist
    };
    var vslerp = cp.v.slerp = function (v1, v2, t) {
        var omega = Math.acos(vdot(v1, v2));
        if (omega) {
            var denom = 1 / Math.sin(omega);
            return vadd(vmult(v1, Math.sin((1 - t) * omega) * denom), vmult(v2, Math.sin(t * omega) * denom))
        } else return v1
    };
    var vslerpconst = cp.v.slerpconst = function (v1, v2, a) {
        var angle = Math.acos(vdot(v1,
            v2));
        return vslerp(v1, v2, min(a, angle) / angle)
    };
    var vforangle = cp.v.forangle = function (a) {
        return new Vect(Math.cos(a), Math.sin(a))
    };
    var vtoangle = cp.v.toangle = function (v) {
        return Math.atan2(v.y, v.x)
    };
    var vstr = cp.v.str = function (v) {
        return"(" + v.x.toFixed(3) + ", " + v.y.toFixed(3) + ")"
    };
    var numBB = 0;
    var BB = cp.BB = function (l, b, r, t) {
        this.l = l;
        this.b = b;
        this.r = r;
        this.t = t;
        numBB++
    };
    cp.bb = function (l, b, r, t) {
        return new BB(l, b, r, t)
    };
    var bbNewForCircle = function (p, r) {
        return new BB(p.x - r, p.y - r, p.x + r, p.y + r)
    };
    var bbIntersects = function (a, b) {
        return a.l <= b.r && b.l <= a.r && a.b <= b.t && b.b <= a.t
    };
    var bbIntersects2 = function (bb, l, b, r, t) {
        return bb.l <= r && l <= bb.r && bb.b <= t && b <= bb.t
    };
    var bbContainsBB = function (bb, other) {
        return bb.l <= other.l && bb.r >= other.r && bb.b <= other.b && bb.t >= other.t
    };
    var bbContainsVect = function (bb, v) {
        return bb.l <= v.x && bb.r >= v.x && bb.b <= v.y && bb.t >= v.y
    };
    var bbContainsVect2 = function (l, b, r, t, v) {
        return l <= v.x && r >= v.x && b <= v.y && t >= v.y
    };
    var bbMerge = function (a, b) {
        return new BB(min(a.l, b.l), min(a.b, b.b), max(a.r, b.r), max(a.t, b.t))
    };
    var bbExpand =
        function (bb, v) {
            return new BB(min(bb.l, v.x), min(bb.b, v.y), max(bb.r, v.x), max(bb.t, v.y))
        };
    var bbArea = function (bb) {
        return(bb.r - bb.l) * (bb.t - bb.b)
    };
    var bbMergedArea = function (a, b) {
        return(max(a.r, b.r) - min(a.l, b.l)) * (max(a.t, b.t) - min(a.b, b.b))
    };
    var bbMergedArea2 = function (bb, l, b, r, t) {
        return(max(bb.r, r) - min(bb.l, l)) * (max(bb.t, t) - min(bb.b, b))
    };
    var bbIntersectsSegment = function (bb, a, b) {
        return bbSegmentQuery(bb, a, b) != Infinity
    };
    var bbClampVect = function (bb, v) {
        var x = min(max(bb.l, v.x), bb.r);
        var y = min(max(bb.b, v.y),
            bb.t);
        return new Vect(x, y)
    };
    var bbWrapVect = function (bb, v) {
        var ix = Math.abs(bb.r - bb.l);
        var modx = (v.x - bb.l) % ix;
        var x = modx > 0 ? modx : modx + ix;
        var iy = Math.abs(bb.t - bb.b);
        var mody = (v.y - bb.b) % iy;
        var y = mody > 0 ? mody : mody + iy;
        return new Vect(x + bb.l, y + bb.b)
    };
    var shapeIDCounter = 0;
    var CP_NO_GROUP = cp.NO_GROUP = 0;
    var CP_ALL_LAYERS = cp.ALL_LAYERS = ~0;
    cp.resetShapeIdCounter = function () {
        shapeIDCounter = 0
    };
    var Shape = cp.Shape = function (body) {
        this.body = body;
        this.bb_l = this.bb_b = this.bb_r = this.bb_t = 0;
        this.hashid = shapeIDCounter++;
        this.sensor =
            false;
        this.e = 0;
        this.u = 0;
        this.surface_v = vzero;
        this.collision_type = 0;
        this.group = 0;
        this.layers = CP_ALL_LAYERS;
        this.space = null;
        this.collisionCode = this.collisionCode
    };
    Shape.prototype.setElasticity = function (e) {
        this.e = e
    };
    Shape.prototype.setFriction = function (u) {
        this.body.activate();
        this.u = u
    };
    Shape.prototype.setLayers = function (layers) {
        this.body.activate();
        this.layers = layers
    };
    Shape.prototype.setSensor = function (sensor) {
        this.body.activate();
        this.sensor = sensor
    };
    Shape.prototype.setCollisionType = function (collision_type) {
        this.body.activate();
        this.collision_type = collision_type
    };
    Shape.prototype.getBody = function () {
        return this.body
    };
    Shape.prototype.active = function () {
        return this.body && this.body.shapeList.indexOf(this) !== -1
    };
    Shape.prototype.setBody = function (body) {
        assert(!this.active(), "You cannot change the body on an active shape. You must remove the shape, then ");
        this.body = body
    };
    Shape.prototype.cacheBB = function () {
        return this.update(this.body.p, this.body.rot)
    };
    Shape.prototype.update = function (pos, rot) {
        assert(!isNaN(rot.x), "Rotation is NaN");
        assert(!isNaN(pos.x), "Position is NaN");
        this.cacheData(pos, rot)
    };
    Shape.prototype.getBB = function () {
        return new BB(this.bb_l, this.bb_b, this.bb_r, this.bb_t)
    };
    var PointQueryExtendedInfo = function (shape) {
        this.shape = shape;
        this.d = Infinity;
        this.n = vzero
    };
    var SegmentQueryInfo = function (shape, t, n) {
        this.shape = shape;
        this.t = t;
        this.n = n
    };
    SegmentQueryInfo.prototype.hitPoint = function (start, end) {
        return vlerp(start, end, this.t)
    };
    SegmentQueryInfo.prototype.hitDist = function (start, end) {
        return vdist(start, end) * this.t
    };
    var CircleShape =
        cp.CircleShape = function (body, radius, offset) {
            this.c = this.tc = offset;
            this.r = radius;
            this.type = "circle";
            Shape.call(this, body)
        };
    CircleShape.prototype = Object.create(Shape.prototype);
    CircleShape.prototype.cacheData = function (p, rot) {
        var c = this.tc = vrotate(this.c, rot).add(p);
        var r = this.r;
        this.bb_l = c.x - r;
        this.bb_b = c.y - r;
        this.bb_r = c.x + r;
        this.bb_t = c.y + r
    };
    CircleShape.prototype.pointQuery = function (p) {
        var delta = vsub(p, this.tc);
        var distsq = vlengthsq(delta);
        var r = this.r;
        if (distsq < r * r) {
            var info = new PointQueryExtendedInfo(this);
            var dist = Math.sqrt(distsq);
            info.d = r - dist;
            info.n = vmult(delta, 1 / dist);
            return info
        }
    };
    var circleSegmentQuery = function (shape, center, r, a, b, info) {
        a = vsub(a, center);
        b = vsub(b, center);
        var qa = vdot(a, a) - 2 * vdot(a, b) + vdot(b, b);
        var qb = -2 * vdot(a, a) + 2 * vdot(a, b);
        var qc = vdot(a, a) - r * r;
        var det = qb * qb - 4 * qa * qc;
        if (det >= 0) {
            var t = (-qb - Math.sqrt(det)) / (2 * qa);
            if (0 <= t && t <= 1)return new SegmentQueryInfo(shape, t, vnormalize(vlerp(a, b, t)))
        }
    };
    CircleShape.prototype.segmentQuery = function (a, b) {
        return circleSegmentQuery(this, this.tc, this.r,
            a, b)
    };
    var SegmentShape = cp.SegmentShape = function (body, a, b, r) {
        this.a = a;
        this.b = b;
        this.n = vperp(vnormalize(vsub(b, a)));
        this.ta = this.tb = this.tn = null;
        this.r = r;
        this.a_tangent = vzero;
        this.b_tangent = vzero;
        this.type = "segment";
        Shape.call(this, body)
    };
    SegmentShape.prototype = Object.create(Shape.prototype);
    SegmentShape.prototype.cacheData = function (p, rot) {
        this.ta = vadd(p, vrotate(this.a, rot));
        this.tb = vadd(p, vrotate(this.b, rot));
        this.tn = vrotate(this.n, rot);
        var l, r, b, t;
        if (this.ta.x < this.tb.x) {
            l = this.ta.x;
            r = this.tb.x
        } else {
            l =
                this.tb.x;
            r = this.ta.x
        }
        if (this.ta.y < this.tb.y) {
            b = this.ta.y;
            t = this.tb.y
        } else {
            b = this.tb.y;
            t = this.ta.y
        }
        var rad = this.r;
        this.bb_l = l - rad;
        this.bb_b = b - rad;
        this.bb_r = r + rad;
        this.bb_t = t + rad
    };
    SegmentShape.prototype.pointQuery = function (p) {
        if (!bbContainsVect2(this.bb_l, this.bb_b, this.bb_r, this.bb_t, p))return;
        var a = this.ta;
        var b = this.tb;
        var seg_delta = vsub(b, a);
        var closest_t = clamp01(vdot(seg_delta, vsub(p, a)) / vlengthsq(seg_delta));
        var closest = vadd(a, vmult(seg_delta, closest_t));
        var delta = vsub(p, closest);
        var distsq =
            vlengthsq(delta);
        var r = this.r;
        if (distsq < r * r) {
            var info = new PointQueryExtendedInfo(this);
            var dist = Math.sqrt(distsq);
            info.d = r - dist;
            info.n = vmult(delta, 1 / dist);
            return info
        }
    };
    SegmentShape.prototype.segmentQuery = function (a, b) {
        var n = this.tn;
        var d = vdot(vsub(this.ta, a), n);
        var r = this.r;
        var flipped_n = d > 0 ? vneg(n) : n;
        var n_offset = vsub(vmult(flipped_n, r), a);
        var seg_a = vadd(this.ta, n_offset);
        var seg_b = vadd(this.tb, n_offset);
        var delta = vsub(b, a);
        if (vcross(delta, seg_a) * vcross(delta, seg_b) <= 0) {
            var d_offset = d + (d > 0 ? -r : r);
            var ad = -d_offset;
            var bd = vdot(delta, n) - d_offset;
            if (ad * bd < 0)return new SegmentQueryInfo(this, ad / (ad - bd), flipped_n)
        } else if (r !== 0) {
            var info1 = circleSegmentQuery(this, this.ta, this.r, a, b);
            var info2 = circleSegmentQuery(this, this.tb, this.r, a, b);
            if (info1)return info2 && info2.t < info1.t ? info2 : info1; else return info2
        }
    };
    SegmentShape.prototype.setNeighbors = function (prev, next) {
        this.a_tangent = vsub(prev, this.a);
        this.b_tangent = vsub(next, this.b)
    };
    SegmentShape.prototype.setEndpoints = function (a, b) {
        this.a = a;
        this.b = b;
        this.n =
            vperp(vnormalize(vsub(b, a)))
    };
    var polyValidate = function (verts) {
        var len = verts.length;
        for (var i = 0; i < len; i += 2) {
            var ax = verts[i];
            var ay = verts[i + 1];
            var bx = verts[(i + 2) % len];
            var by = verts[(i + 3) % len];
            var cx = verts[(i + 4) % len];
            var cy = verts[(i + 5) % len];
            if (vcross2(bx - ax, by - ay, cx - bx, cy - by) > 0)return false
        }
        return true
    };
    var PolyShape = cp.PolyShape = function (body, verts, offset) {
        assert(verts.length >= 4, "Polygons require some verts");
        assert(typeof verts[0] === "number", "Polygon verticies should be specified in a flattened list");
        assert(polyValidate(verts), "Polygon is concave or has a reversed winding.");
        this.setVerts(verts, offset);
        this.type = "poly";
        Shape.call(this, body)
    };
    PolyShape.prototype = Object.create(Shape.prototype);
    var Axis = function (n, d) {
        this.n = n;
        this.d = d
    };
    PolyShape.prototype.setVerts = function (verts, offset) {
        var len = verts.length;
        var numVerts = len >> 1;
        this.verts = new Array(len);
        this.tVerts = new Array(len);
        this.axes = new Array(numVerts);
        this.tAxes = new Array(numVerts);
        for (var i = 0; i < len; i += 2) {
            var ax = verts[i] + offset.x;
            var ay = verts[i +
                1] + offset.y;
            var bx = verts[(i + 2) % len] + offset.x;
            var by = verts[(i + 3) % len] + offset.y;
            var n = vnormalize(vperp(new Vect(bx - ax, by - ay)));
            this.verts[i] = ax;
            this.verts[i + 1] = ay;
            this.axes[i >> 1] = new Axis(n, vdot2(n.x, n.y, ax, ay));
            this.tAxes[i >> 1] = new Axis(new Vect(0, 0), 0)
        }
    };
    var BoxShape = cp.BoxShape = function (body, width, height) {
        var hw = width / 2;
        var hh = height / 2;
        return BoxShape2(body, new BB(-hw, -hh, hw, hh))
    };
    var BoxShape2 = cp.BoxShape2 = function (body, box) {
        var verts = [box.l, box.b, box.l, box.t, box.r, box.t, box.r, box.b];
        return new PolyShape(body,
            verts, vzero)
    };
    PolyShape.prototype.transformVerts = function (p, rot) {
        var src = this.verts;
        var dst = this.tVerts;
        var l = Infinity, r = -Infinity;
        var b = Infinity, t = -Infinity;
        for (var i = 0; i < src.length; i += 2) {
            var x = src[i];
            var y = src[i + 1];
            var vx = p.x + x * rot.x - y * rot.y;
            var vy = p.y + x * rot.y + y * rot.x;
            dst[i] = vx;
            dst[i + 1] = vy;
            l = min(l, vx);
            r = max(r, vx);
            b = min(b, vy);
            t = max(t, vy)
        }
        this.bb_l = l;
        this.bb_b = b;
        this.bb_r = r;
        this.bb_t = t
    };
    PolyShape.prototype.transformAxes = function (p, rot) {
        var src = this.axes;
        var dst = this.tAxes;
        for (var i = 0; i < src.length; i++) {
            var n =
                vrotate(src[i].n, rot);
            dst[i].n = n;
            dst[i].d = vdot(p, n) + src[i].d
        }
    };
    PolyShape.prototype.cacheData = function (p, rot) {
        this.transformAxes(p, rot);
        this.transformVerts(p, rot)
    };
    PolyShape.prototype.pointQuery = function (p) {
        if (!bbContainsVect2(this.bb_l, this.bb_b, this.bb_r, this.bb_t, p))return;
        var info = new PointQueryExtendedInfo(this);
        var axes = this.tAxes;
        for (var i = 0; i < axes.length; i++) {
            var n = axes[i].n;
            var dist = axes[i].d - vdot(n, p);
            if (dist < 0)return; else if (dist < info.d) {
                info.d = dist;
                info.n = n
            }
        }
        return info
    };
    PolyShape.prototype.segmentQuery =
        function (a, b) {
            var axes = this.tAxes;
            var verts = this.tVerts;
            var numVerts = axes.length;
            var len = numVerts * 2;
            for (var i = 0; i < numVerts; i++) {
                var n = axes[i].n;
                var an = vdot(a, n);
                if (axes[i].d > an)continue;
                var bn = vdot(b, n);
                var t = (axes[i].d - an) / (bn - an);
                if (t < 0 || 1 < t)continue;
                var point = vlerp(a, b, t);
                var dt = -vcross(n, point);
                var dtMin = -vcross2(n.x, n.y, verts[i * 2], verts[i * 2 + 1]);
                var dtMax = -vcross2(n.x, n.y, verts[(i * 2 + 2) % len], verts[(i * 2 + 3) % len]);
                if (dtMin <= dt && dt <= dtMax)return new SegmentQueryInfo(this, t, n)
            }
        };
    PolyShape.prototype.getNumVerts =
        function () {
            return this.verts.length / 2
        };
    PolyShape.prototype.getVert = function (idx) {
        return new Vect(this.verts[idx * 2], this.verts[idx * 2 + 1])
    };
    PolyShape.prototype.valueOnAxis = function (n, d) {
        var verts = this.tVerts;
        var m = vdot2(n.x, n.y, verts[0], verts[1]);
        for (var i = 2; i < verts.length; i += 2)m = min(m, vdot2(n.x, n.y, verts[i], verts[i + 1]));
        return m - d
    };
    PolyShape.prototype.containsVert = function (vx, vy) {
        var axes = this.tAxes;
        for (var i = 0; i < axes.length; i++) {
            var n = axes[i].n;
            var dist = vdot2(n.x, n.y, vx, vy) - axes[i].d;
            if (dist > 0)return false
        }
        return true
    };
    PolyShape.prototype.containsVertPartial = function (vx, vy, n) {
        var axes = this.tAxes;
        for (var i = 0; i < axes.length; i++) {
            var n = axes[i].n;
            if (vdot(n, n) < 0)continue;
            var dist = vdot2(n.x, n.y, vx, vy) - axes[i].d;
            if (dist > 0)return false
        }
        return true
    };
    PolyShape.prototype.getNumVerts = function () {
        return this.verts.length / 2
    };
    PolyShape.prototype.getVert = function (i) {
        return new Vect(this.verts[i * 2], this.verts[i * 2 + 1])
    };
    var Body = cp.Body = function (m, i) {
        this.p = new Vect(0, 0);
        this.vx = this.vy = 0;
        this.f = new Vect(0, 0);
        this.w = 0;
        this.t = 0;
        this.v_limit =
            Infinity;
        this.w_limit = Infinity;
        this.v_biasx = this.v_biasy = 0;
        this.w_bias = 0;
        this.space = null;
        this.shapeList = [];
        this.arbiterList = null;
        this.constraintList = null;
        this.nodeRoot = null;
        this.nodeNext = null;
        this.nodeIdleTime = 0;
        this.setMass(m);
        this.setMoment(i);
        this.rot = new Vect(0, 0);
        this.setAngle(0)
    };
    var createStaticBody = function () {
        body = new Body(Infinity, Infinity);
        body.nodeIdleTime = Infinity;
        return body
    };
    cp.StaticBody = createStaticBody;
    if (typeof DEBUG !== "undefined" && DEBUG) {
        var v_assert_nan = function (v, message) {
            assert(v.x ==
                v.x && v.y == v.y, message)
        };
        var v_assert_infinite = function (v, message) {
            assert(Math.abs(v.x) !== Infinity && Math.abs(v.y) !== Infinity, message)
        };
        var v_assert_sane = function (v, message) {
            v_assert_nan(v, message);
            v_assert_infinite(v, message)
        };
        Body.prototype.sanityCheck = function () {
            assert(this.m === this.m && this.m_inv === this.m_inv, "Body's mass is invalid.");
            assert(this.i === this.i && this.i_inv === this.i_inv, "Body's moment is invalid.");
            v_assert_sane(this.p, "Body's position is invalid.");
            v_assert_sane(this.f, "Body's force is invalid.");
            assert(this.vx === this.vx && Math.abs(this.vx) !== Infinity, "Body's velocity is invalid.");
            assert(this.vy === this.vy && Math.abs(this.vy) !== Infinity, "Body's velocity is invalid.");
            assert(this.a === this.a && Math.abs(this.a) !== Infinity, "Body's angle is invalid.");
            assert(this.w === this.w && Math.abs(this.w) !== Infinity, "Body's angular velocity is invalid.");
            assert(this.t === this.t && Math.abs(this.t) !== Infinity, "Body's torque is invalid.");
            v_assert_sane(this.rot, "Internal error: Body's rotation vector is invalid.");
            assert(this.v_limit === this.v_limit, "Body's velocity limit is invalid.");
            assert(this.w_limit === this.w_limit, "Body's angular velocity limit is invalid.")
        }
    } else Body.prototype.sanityCheck = function () {
    };
    Body.prototype.getPos = function () {
        return this.p
    };
    Body.prototype.getVel = function () {
        return new Vect(this.vx, this.vy)
    };
    Body.prototype.getAngVel = function () {
        return this.w
    };
    Body.prototype.isSleeping = function () {
        return this.nodeRoot !== null
    };
    Body.prototype.isStatic = function () {
        return this.nodeIdleTime === Infinity
    };
    Body.prototype.isRogue = function () {
        return this.space === null
    };
    Body.prototype.setMass = function (mass) {
        assert(mass > 0, "Mass must be positive and non-zero.");
        this.activate();
        this.m = mass;
        this.m_inv = 1 / mass
    };
    Body.prototype.setMoment = function (moment) {
        assert(moment > 0, "Moment of Inertia must be positive and non-zero.");
        this.activate();
        this.i = moment;
        this.i_inv = 1 / moment
    };
    Body.prototype.addShape = function (shape) {
        this.shapeList.push(shape)
    };
    Body.prototype.removeShape = function (shape) {
        deleteObjFromList(this.shapeList,
            shape)
    };
    var filterConstraints = function (node, body, filter) {
        if (node === filter)return node.next(body); else if (node.a === body)node.next_a = filterConstraints(node.next_a, body, filter); else node.next_b = filterConstraints(node.next_b, body, filter);
        return node
    };
    Body.prototype.removeConstraint = function (constraint) {
        this.constraintList = filterConstraints(this.constraintList, this, constraint)
    };
    Body.prototype.setPos = function (pos) {
        this.activate();
        this.sanityCheck();
        this.p = pos
    };
    Body.prototype.setVel = function (velocity) {
        this.activate();
        this.vx = velocity.x;
        this.vy = velocity.y
    };
    Body.prototype.setAngVel = function (w) {
        this.activate();
        this.w = w
    };
    Body.prototype.setAngleInternal = function (angle) {
        assert(!isNaN(angle), "Internal Error: Attempting to set body's angle to NaN");
        this.a = angle;
        this.rot.x = Math.cos(angle);
        this.rot.y = Math.sin(angle)
    };
    Body.prototype.setAngle = function (angle) {
        this.activate();
        this.sanityCheck();
        this.setAngleInternal(angle)
    };
    Body.prototype.velocity_func = function (gravity, damping, dt) {
        var vx = this.vx * damping + (gravity.x + this.f.x *
            this.m_inv) * dt;
        var vy = this.vy * damping + (gravity.y + this.f.y * this.m_inv) * dt;
        var v_limit = this.v_limit;
        var lensq = vx * vx + vy * vy;
        var scale = lensq > v_limit * v_limit ? v_limit / Math.sqrt(lensq) : 1;
        this.vx = vx * scale;
        this.vy = vy * scale;
        var w_limit = this.w_limit;
        this.w = clamp(this.w * damping + this.t * this.i_inv * dt, -w_limit, w_limit);
        this.sanityCheck()
    };
    Body.prototype.position_func = function (dt) {
        this.p.x += (this.vx + this.v_biasx) * dt;
        this.p.y += (this.vy + this.v_biasy) * dt;
        this.setAngleInternal(this.a + (this.w + this.w_bias) * dt);
        this.v_biasx =
            this.v_biasy = 0;
        this.w_bias = 0;
        this.sanityCheck()
    };
    Body.prototype.resetForces = function () {
        this.activate();
        this.f = new Vect(0, 0);
        this.t = 0
    };
    Body.prototype.applyForce = function (force, r) {
        this.activate();
        this.f = vadd(this.f, force);
        this.t += vcross(r, force)
    };
    Body.prototype.applyImpulse = function (j, r) {
        this.activate();
        apply_impulse(this, j.x, j.y, r)
    };
    Body.prototype.getVelAtPoint = function (r) {
        return vadd(new Vect(this.vx, this.vy), vmult(vperp(r), this.w))
    };
    Body.prototype.getVelAtWorldPoint = function (point) {
        return this.getVelAtPoint(vsub(point,
            this.p))
    };
    Body.prototype.getVelAtLocalPoint = function (point) {
        return this.getVelAtPoint(vrotate(point, this.rot))
    };
    Body.prototype.eachShape = function (func) {
        for (var i = 0, len = this.shapeList.length; i < len; i++)func(this.shapeList[i])
    };
    Body.prototype.eachConstraint = function (func) {
        var constraint = this.constraintList;
        while (constraint) {
            var next = constraint.next(this);
            func(constraint);
            constraint = next
        }
    };
    Body.prototype.eachArbiter = function (func) {
        var arb = this.arbiterList;
        while (arb) {
            var next = arb.next(this);
            arb.swappedColl =
                this === arb.body_b;
            func(arb);
            arb = next
        }
    };
    Body.prototype.local2World = function (v) {
        return vadd(this.p, vrotate(v, this.rot))
    };
    Body.prototype.world2Local = function (v) {
        return vunrotate(vsub(v, this.p), this.rot)
    };
    Body.prototype.kineticEnergy = function () {
        var vsq = this.vx * this.vx + this.vy * this.vy;
        var wsq = this.w * this.w;
        return(vsq ? vsq * this.m : 0) + (wsq ? wsq * this.i : 0)
    };
    var SpatialIndex = cp.SpatialIndex = function (staticIndex) {
        this.staticIndex = staticIndex;
        if (staticIndex) {
            assert(!staticIndex.dynamicIndex, "This static index is already associated with a dynamic index.");
            staticIndex.dynamicIndex = this
        }
    };
    SpatialIndex.prototype.collideStatic = function (staticIndex, func) {
        if (staticIndex.count > 0) {
            var query = staticIndex.query;
            this.each(function (obj) {
                query(obj, new BB(obj.bb_l, obj.bb_b, obj.bb_r, obj.bb_t), func)
            })
        }
    };
    var BBTree = cp.BBTree = function (staticIndex) {
        SpatialIndex.call(this, staticIndex);
        this.velocityFunc = null;
        this.leaves = {};
        this.count = 0;
        this.root = null;
        this.stamp = 0
    };
    BBTree.prototype = Object.create(SpatialIndex.prototype);
    var numNodes = 0;
    var Node = function (tree, a, b) {
        this.obj =
            null;
        this.bb_l = min(a.bb_l, b.bb_l);
        this.bb_b = min(a.bb_b, b.bb_b);
        this.bb_r = max(a.bb_r, b.bb_r);
        this.bb_t = max(a.bb_t, b.bb_t);
        this.parent = null;
        this.setA(a);
        this.setB(b);
        numNodes++
    };
    var numLeaves = 0;
    var Leaf = function (tree, obj) {
        this.obj = obj;
        tree.getBB(obj, this);
        this.parent = null;
        this.stamp = 1;
        this.pairs = null;
        numLeaves++
    };
    BBTree.prototype.getBB = function (obj, dest) {
        var velocityFunc = this.velocityFunc;
        if (velocityFunc) {
            var coef = 0.1;
            var x = (obj.bb_r - obj.bb_l) * coef;
            var y = (obj.bb_t - obj.bb_b) * coef;
            var v = vmult(velocityFunc(obj),
                0.1);
            dest.bb_l = obj.bb_l + min(-x, v.x);
            dest.bb_b = obj.bb_b + min(-y, v.y);
            dest.bb_r = obj.bb_r + max(x, v.x);
            dest.bb_t = obj.bb_t + max(y, v.y)
        } else {
            dest.bb_l = obj.bb_l;
            dest.bb_b = obj.bb_b;
            dest.bb_r = obj.bb_r;
            dest.bb_t = obj.bb_t
        }
    };
    BBTree.prototype.getStamp = function () {
        var dynamic = this.dynamicIndex;
        return dynamic && dynamic.stamp ? dynamic.stamp : this.stamp
    };
    BBTree.prototype.incrementStamp = function () {
        if (this.dynamicIndex && this.dynamicIndex.stamp)this.dynamicIndex.stamp++; else this.stamp++
    };
    var Pair = function (a, b) {
        this.a = a;
        this.b =
            b
    };
    var Thread = function (leaf, next) {
        this.prev = null;
        this.next = next;
        this.leaf = leaf
    };
    Thread.prototype.unlink = function () {
        var next = this.next;
        var prev = this.prev;
        if (next)if (next.a.leaf == this.leaf)next.a.prev = prev; else next.b.prev = prev;
        if (prev)if (prev.a.leaf == this.leaf)prev.a.next = next; else prev.b.next = next; else this.leaf.pairs = next
    };
    Leaf.prototype.clearPairs = function (tree) {
        var pair = this.pairs, next;
        this.pairs = null;
        while (pair)if (pair.a.leaf == this) {
            next = pair.a.next;
            pair.b.unlink();
            pair = next
        } else {
            next = pair.b.next;
            pair.a.unlink();
            pair = next
        }
    };
    var pairInsert = function (a, b, tree) {
        var nextA = a.pairs, nextB = b.pairs;
        var pair = new Pair(new Thread(a, nextA), new Thread(b, nextB));
        a.pairs = b.pairs = pair;
        if (nextA)if (nextA.a.leaf == a)nextA.a.prev = pair; else nextA.b.prev = pair;
        if (nextB)if (nextB.a.leaf == b)nextB.a.prev = pair; else nextB.b.prev = pair
    };
    Node.prototype.setA = function (value) {
        this.A = value;
        value.parent = this
    };
    Node.prototype.setB = function (value) {
        this.B = value;
        value.parent = this
    };
    Leaf.prototype.isLeaf = true;
    Node.prototype.isLeaf = false;
    Node.prototype.otherChild = function (child) {
        return this.A == child ? this.B : this.A
    };
    Node.prototype.replaceChild = function (child, value, tree) {
        assertSoft(child == this.A || child == this.B, "Node is not a child of parent.");
        if (this.A == child)this.setA(value); else this.setB(value);
        for (var node = this; node; node = node.parent) {
            var a = node.A;
            var b = node.B;
            node.bb_l = min(a.bb_l, b.bb_l);
            node.bb_b = min(a.bb_b, b.bb_b);
            node.bb_r = max(a.bb_r, b.bb_r);
            node.bb_t = max(a.bb_t, b.bb_t)
        }
    };
    Node.prototype.bbArea = Leaf.prototype.bbArea = function () {
        return(this.bb_r -
            this.bb_l) * (this.bb_t - this.bb_b)
    };
    var bbTreeMergedArea = function (a, b) {
        return(max(a.bb_r, b.bb_r) - min(a.bb_l, b.bb_l)) * (max(a.bb_t, b.bb_t) - min(a.bb_b, b.bb_b))
    };
    var bbProximity = function (a, b) {
        return Math.abs(a.bb_l + a.bb_r - b.bb_l - b.bb_r) + Math.abs(a.bb_b + b.bb_t - b.bb_b - b.bb_t)
    };
    var subtreeInsert = function (subtree, leaf, tree) {
        if (subtree == null)return leaf; else if (subtree.isLeaf)return new Node(tree, leaf, subtree); else {
            var cost_a = subtree.B.bbArea() + bbTreeMergedArea(subtree.A, leaf);
            var cost_b = subtree.A.bbArea() +
                bbTreeMergedArea(subtree.B, leaf);
            if (cost_a === cost_b) {
                cost_a = bbProximity(subtree.A, leaf);
                cost_b = bbProximity(subtree.B, leaf)
            }
            if (cost_b < cost_a)subtree.setB(subtreeInsert(subtree.B, leaf, tree)); else subtree.setA(subtreeInsert(subtree.A, leaf, tree));
            subtree.bb_l = min(subtree.bb_l, leaf.bb_l);
            subtree.bb_b = min(subtree.bb_b, leaf.bb_b);
            subtree.bb_r = max(subtree.bb_r, leaf.bb_r);
            subtree.bb_t = max(subtree.bb_t, leaf.bb_t);
            return subtree
        }
    };
    Node.prototype.intersectsBB = Leaf.prototype.intersectsBB = function (bb) {
        return this.bb_l <=
            bb.r && bb.l <= this.bb_r && this.bb_b <= bb.t && bb.b <= this.bb_t
    };
    var subtreeQuery = function (subtree, bb, func) {
        if (subtree.intersectsBB(bb))if (subtree.isLeaf)func(subtree.obj); else {
            subtreeQuery(subtree.A, bb, func);
            subtreeQuery(subtree.B, bb, func)
        }
    };
    var nodeSegmentQuery = function (node, a, b) {
        var idx = 1 / (b.x - a.x);
        var tx1 = node.bb_l == a.x ? -Infinity : (node.bb_l - a.x) * idx;
        var tx2 = node.bb_r == a.x ? Infinity : (node.bb_r - a.x) * idx;
        var txmin = min(tx1, tx2);
        var txmax = max(tx1, tx2);
        var idy = 1 / (b.y - a.y);
        var ty1 = node.bb_b == a.y ? -Infinity : (node.bb_b -
            a.y) * idy;
        var ty2 = node.bb_t == a.y ? Infinity : (node.bb_t - a.y) * idy;
        var tymin = min(ty1, ty2);
        var tymax = max(ty1, ty2);
        if (tymin <= txmax && txmin <= tymax) {
            var min_ = max(txmin, tymin);
            var max_ = min(txmax, tymax);
            if (0 <= max_ && min_ <= 1)return max(min_, 0)
        }
        return Infinity
    };
    var subtreeSegmentQuery = function (subtree, a, b, t_exit, func) {
        if (subtree.isLeaf)return func(subtree.obj); else {
            var t_a = nodeSegmentQuery(subtree.A, a, b);
            var t_b = nodeSegmentQuery(subtree.B, a, b);
            if (t_a < t_b) {
                if (t_a < t_exit)t_exit = min(t_exit, subtreeSegmentQuery(subtree.A,
                    a, b, t_exit, func));
                if (t_b < t_exit)t_exit = min(t_exit, subtreeSegmentQuery(subtree.B, a, b, t_exit, func))
            } else {
                if (t_b < t_exit)t_exit = min(t_exit, subtreeSegmentQuery(subtree.B, a, b, t_exit, func));
                if (t_a < t_exit)t_exit = min(t_exit, subtreeSegmentQuery(subtree.A, a, b, t_exit, func))
            }
            return t_exit
        }
    };
    var subtreeRemove = function (subtree, leaf, tree) {
        if (leaf == subtree)return null; else {
            var parent = leaf.parent;
            if (parent == subtree) {
                var other = subtree.otherChild(leaf);
                other.parent = subtree.parent;
                return other
            } else {
                parent.parent.replaceChild(parent,
                    parent.otherChild(leaf), tree);
                return subtree
            }
        }
    };
    var bbTreeIntersectsNode = function (a, b) {
        return a.bb_l <= b.bb_r && b.bb_l <= a.bb_r && a.bb_b <= b.bb_t && b.bb_b <= a.bb_t
    };
    var markLeafQuery = function (subtree, leaf, left, tree, func) {
        if (bbTreeIntersectsNode(leaf, subtree))if (subtree.isLeaf)if (left)pairInsert(leaf, subtree, tree); else {
            if (subtree.stamp < leaf.stamp)pairInsert(subtree, leaf, tree);
            if (func)func(leaf.obj, subtree.obj)
        } else {
            markLeafQuery(subtree.A, leaf, left, tree, func);
            markLeafQuery(subtree.B, leaf, left, tree, func)
        }
    };
    var markLeaf = function (leaf, tree, staticRoot, func) {
        if (leaf.stamp == tree.getStamp()) {
            if (staticRoot)markLeafQuery(staticRoot, leaf, false, tree, func);
            for (var node = leaf; node.parent; node = node.parent)if (node == node.parent.A)markLeafQuery(node.parent.B, leaf, true, tree, func); else markLeafQuery(node.parent.A, leaf, false, tree, func)
        } else {
            var pair = leaf.pairs;
            while (pair)if (leaf == pair.b.leaf) {
                if (func)func(pair.a.leaf.obj, leaf.obj);
                pair = pair.b.next
            } else pair = pair.a.next
        }
    };
    var markSubtree = function (subtree, tree, staticRoot, func) {
        if (subtree.isLeaf)markLeaf(subtree, tree, staticRoot, func); else {
            markSubtree(subtree.A, tree, staticRoot, func);
            markSubtree(subtree.B, tree, staticRoot, func)
        }
    };
    Leaf.prototype.containsObj = function (obj) {
        return this.bb_l <= obj.bb_l && this.bb_r >= obj.bb_r && this.bb_b <= obj.bb_b && this.bb_t >= obj.bb_t
    };
    Leaf.prototype.update = function (tree) {
        var root = tree.root;
        var obj = this.obj;
        if (!this.containsObj(obj)) {
            tree.getBB(this.obj, this);
            root = subtreeRemove(root, this, tree);
            tree.root = subtreeInsert(root, this, tree);
            this.clearPairs(tree);
            this.stamp = tree.getStamp();
            return true
        }
        return false
    };
    Leaf.prototype.addPairs = function (tree) {
        var dynamicIndex = tree.dynamicIndex;
        if (dynamicIndex) {
            var dynamicRoot = dynamicIndex.root;
            if (dynamicRoot)markLeafQuery(dynamicRoot, this, true, dynamicIndex, null)
        } else {
            var staticRoot = tree.staticIndex.root;
            markLeaf(this, tree, staticRoot, null)
        }
    };
    BBTree.prototype.insert = function (obj, hashid) {
        var leaf = new Leaf(this, obj);
        this.leaves[hashid] = leaf;
        this.root = subtreeInsert(this.root, leaf, this);
        this.count++;
        leaf.stamp = this.getStamp();
        leaf.addPairs(this);
        this.incrementStamp()
    };
    BBTree.prototype.remove = function (obj, hashid) {
        var leaf = this.leaves[hashid];
        delete this.leaves[hashid];
        this.root = subtreeRemove(this.root, leaf, this);
        this.count--;
        leaf.clearPairs(this)
    };
    BBTree.prototype.contains = function (obj, hashid) {
        return this.leaves[hashid] != null
    };
    var voidQueryFunc = function (obj1, obj2) {
    };
    BBTree.prototype.reindexQuery = function (func) {
        if (!this.root)return;
        var hashid, leaves = this.leaves;
        for (hashid in leaves)leaves[hashid].update(this);
        var staticIndex =
            this.staticIndex;
        var staticRoot = staticIndex && staticIndex.root;
        markSubtree(this.root, this, staticRoot, func);
        if (staticIndex && !staticRoot)this.collideStatic(this, staticIndex, func);
        this.incrementStamp()
    };
    BBTree.prototype.reindex = function () {
        this.reindexQuery(voidQueryFunc)
    };
    BBTree.prototype.reindexObject = function (obj, hashid) {
        var leaf = this.leaves[hashid];
        if (leaf) {
            if (leaf.update(this))leaf.addPairs(this);
            this.incrementStamp()
        }
    };
    BBTree.prototype.pointQuery = function (point, func) {
        if (this.root)subtreeQuery(this.root,
            new BB(point.x, point.y, point.x, point.y), func)
    };
    BBTree.prototype.segmentQuery = function (a, b, t_exit, func) {
        if (this.root)subtreeSegmentQuery(this.root, a, b, t_exit, func)
    };
    BBTree.prototype.query = function (bb, func) {
        if (this.root)subtreeQuery(this.root, bb, func)
    };
    BBTree.prototype.count = function () {
        return this.count
    };
    BBTree.prototype.each = function (func) {
        var hashid;
        for (hashid in this.leaves)func(this.leaves[hashid].obj)
    };
    var bbTreeMergedArea2 = function (node, l, b, r, t) {
        return(max(node.bb_r, r) - min(node.bb_l, l)) * (max(node.bb_t,
            t) - min(node.bb_b, b))
    };
    var partitionNodes = function (tree, nodes, offset, count) {
        if (count == 1)return nodes[offset]; else if (count == 2)return new Node(tree, nodes[offset], nodes[offset + 1]);
        var node = nodes[offset];
        var bb_l = node.bb_l, bb_b = node.bb_b, bb_r = node.bb_r, bb_t = node.bb_t;
        var end = offset + count;
        for (var i = offset + 1; i < end; i++) {
            node = nodes[i];
            bb_l = min(bb_l, node.bb_l);
            bb_b = min(bb_b, node.bb_b);
            bb_r = max(bb_r, node.bb_r);
            bb_t = max(bb_t, node.bb_t)
        }
        var splitWidth = bb_r - bb_l > bb_t - bb_b;
        var bounds = new Array(count * 2);
        if (splitWidth)for (var i =
            offset; i < end; i++) {
            bounds[2 * i + 0] = nodes[i].bb_l;
            bounds[2 * i + 1] = nodes[i].bb_r
        } else for (var i = offset; i < end; i++) {
            bounds[2 * i + 0] = nodes[i].bb_b;
            bounds[2 * i + 1] = nodes[i].bb_t
        }
        bounds.sort(function (a, b) {
            return a - b
        });
        var split = (bounds[count - 1] + bounds[count]) * 0.5;
        var a_l = bb_l, a_b = bb_b, a_r = bb_r, a_t = bb_t;
        var b_l = bb_l, b_b = bb_b, b_r = bb_r, b_t = bb_t;
        if (splitWidth)a_r = b_l = split; else a_t = b_b = split;
        var right = end;
        for (var left = offset; left < right;) {
            var node = nodes[left];
            if (bbTreeMergedArea2(node, b_l, b_b, b_r, b_t) < bbTreeMergedArea2(node,
                a_l, a_b, a_r, a_t)) {
                right--;
                nodes[left] = nodes[right];
                nodes[right] = node
            } else left++
        }
        if (right == count) {
            var node = null;
            for (var i = offset; i < end; i++)node = subtreeInsert(node, nodes[i], tree);
            return node
        }
        return NodeNew(tree, partitionNodes(tree, nodes, offset, right - offset), partitionNodes(tree, nodes, right, end - right))
    };
    BBTree.prototype.optimize = function () {
        var nodes = new Array(this.count);
        var i = 0;
        for (var hashid in this.leaves)nodes[i++] = this.nodes[hashid];
        this.root = partitionNodes(tree, nodes, nodes.length)
    };
    var nodeRender =
        function (node, depth) {
            if (!node.isLeaf && depth <= 10) {
                nodeRender(node.a, depth + 1);
                nodeRender(node.b, depth + 1)
            }
            var str = "";
            for (var i = 0; i < depth; i++)str += " "
        };
    BBTree.prototype.log = function () {
        if (this.root)nodeRender(this.root, 0)
    };
    var CollisionHandler = cp.CollisionHandler = function () {
        this.a = this.b = 0
    };
    CollisionHandler.prototype.begin = function (arb, space) {
        return true
    };
    CollisionHandler.prototype.preSolve = function (arb, space) {
        return true
    };
    CollisionHandler.prototype.postSolve = function (arb, space) {
    };
    CollisionHandler.prototype.separate =
        function (arb, space) {
        };
    var CP_MAX_CONTACTS_PER_ARBITER = 4;
    var Arbiter = function (a, b) {
        this.e = 0;
        this.u = 0;
        this.surface_vr = vzero;
        this.a = a;
        this.body_a = a.body;
        this.b = b;
        this.body_b = b.body;
        this.thread_a_next = this.thread_a_prev = null;
        this.thread_b_next = this.thread_b_prev = null;
        this.contacts = null;
        this.stamp = 0;
        this.handler = null;
        this.swappedColl = false;
        this.state = "first coll"
    };
    Arbiter.prototype.getShapes = function () {
        if (this.swappedColl)return[this.b, this.a]; else return[this.a, this.b]
    };
    Arbiter.prototype.totalImpulse =
        function () {
            var contacts = this.contacts;
            var sum = new Vect(0, 0);
            for (var i = 0, count = contacts.length; i < count; i++) {
                var con = contacts[i];
                sum.add(vmult(con.n, con.jnAcc))
            }
            return this.swappedColl ? sum : sum.neg()
        };
    Arbiter.prototype.totalImpulseWithFriction = function () {
        var contacts = this.contacts;
        var sum = new Vect(0, 0);
        for (var i = 0, count = contacts.length; i < count; i++) {
            var con = contacts[i];
            sum.add((new Vect(con.jnAcc, con.jtAcc)).rotate(con.n))
        }
        return this.swappedColl ? sum : sum.neg()
    };
    Arbiter.prototype.totalKE = function () {
        var eCoef =
            (1 - this.e) / (1 + this.e);
        var sum = 0;
        var contacts = this.contacts;
        for (var i = 0, count = contacts.length; i < count; i++) {
            var con = contacts[i];
            var jnAcc = con.jnAcc;
            var jtAcc = con.jtAcc;
            sum += eCoef * jnAcc * jnAcc / con.nMass + jtAcc * jtAcc / con.tMass
        }
        return sum
    };
    Arbiter.prototype.ignore = function () {
        this.state = "ignore"
    };
    Arbiter.prototype.getA = function () {
        return this.swappedColl ? this.b : this.a
    };
    Arbiter.prototype.getB = function () {
        return this.swappedColl ? this.a : this.b
    };
    Arbiter.prototype.isFirstContact = function () {
        return this.state === "first coll"
    };
    var ContactPoint = function (point, normal, dist) {
        this.point = point;
        this.normal = normal;
        this.dist = dist
    };
    Arbiter.prototype.getContactPointSet = function () {
        var set = new Array(this.contacts.length);
        var i;
        for (i = 0; i < set.length; i++)set[i] = new ContactPoint(this.contacts[i].p, this.contacts[i].n, this.contacts[i].dist);
        return set
    };
    Arbiter.prototype.getNormal = function (i) {
        var n = this.contacts[i].n;
        return this.swappedColl ? vneg(n) : n
    };
    Arbiter.prototype.getPoint = function (i) {
        return this.contacts[i].p
    };
    Arbiter.prototype.getDepth =
        function (i) {
            return this.contacts[i].dist
        };
    var unthreadHelper = function (arb, body, prev, next) {
        if (prev)if (prev.body_a === body)prev.thread_a_next = next; else prev.thread_b_next = next; else body.arbiterList = next;
        if (next)if (next.body_a === body)next.thread_a_prev = prev; else next.thread_b_prev = prev
    };
    Arbiter.prototype.unthread = function () {
        unthreadHelper(this, this.body_a, this.thread_a_prev, this.thread_a_next);
        unthreadHelper(this, this.body_b, this.thread_b_prev, this.thread_b_next);
        this.thread_a_prev = this.thread_a_next =
            null;
        this.thread_b_prev = this.thread_b_next = null
    };
    Arbiter.prototype.update = function (contacts, handler, a, b) {
        if (this.contacts)for (var i = 0; i < this.contacts.length; i++) {
            var old = this.contacts[i];
            for (var j = 0; j < contacts.length; j++) {
                var new_contact = contacts[j];
                if (new_contact.hash === old.hash) {
                    new_contact.jnAcc = old.jnAcc;
                    new_contact.jtAcc = old.jtAcc
                }
            }
        }
        this.contacts = contacts;
        this.handler = handler;
        this.swappedColl = a.collision_type !== handler.a;
        this.e = a.e * b.e;
        this.u = a.u * b.u;
        this.surface_vr = vsub(a.surface_v, b.surface_v);
        this.a = a;
        this.body_a = a.body;
        this.b = b;
        this.body_b = b.body;
        if (this.state == "cached")this.state = "first coll"
    };
    Arbiter.prototype.preStep = function (dt, slop, bias) {
        var a = this.body_a;
        var b = this.body_b;
        for (var i = 0; i < this.contacts.length; i++) {
            var con = this.contacts[i];
            con.r1 = vsub(con.p, a.p);
            con.r2 = vsub(con.p, b.p);
            con.nMass = 1 / k_scalar(a, b, con.r1, con.r2, con.n);
            con.tMass = 1 / k_scalar(a, b, con.r1, con.r2, vperp(con.n));
            con.bias = -bias * min(0, con.dist + slop) / dt;
            con.jBias = 0;
            con.bounce = normal_relative_velocity(a, b, con.r1, con.r2,
                con.n) * this.e
        }
    };
    Arbiter.prototype.applyCachedImpulse = function (dt_coef) {
        if (this.isFirstContact())return;
        var a = this.body_a;
        var b = this.body_b;
        for (var i = 0; i < this.contacts.length; i++) {
            var con = this.contacts[i];
            var nx = con.n.x;
            var ny = con.n.y;
            var jx = nx * con.jnAcc - ny * con.jtAcc;
            var jy = nx * con.jtAcc + ny * con.jnAcc;
            apply_impulses(a, b, con.r1, con.r2, jx * dt_coef, jy * dt_coef)
        }
    };
    var numApplyImpulse = 0;
    var numApplyContact = 0;
    Arbiter.prototype.applyImpulse = function () {
        numApplyImpulse++;
        var a = this.body_a;
        var b = this.body_b;
        var surface_vr =
            this.surface_vr;
        var friction = this.u;
        for (var i = 0; i < this.contacts.length; i++) {
            numApplyContact++;
            var con = this.contacts[i];
            var nMass = con.nMass;
            var n = con.n;
            var r1 = con.r1;
            var r2 = con.r2;
            var vrx = b.vx - r2.y * b.w - (a.vx - r1.y * a.w);
            var vry = b.vy + r2.x * b.w - (a.vy + r1.x * a.w);
            var vbn = n.x * (b.v_biasx - r2.y * b.w_bias - a.v_biasx + r1.y * a.w_bias) + n.y * (r2.x * b.w_bias + b.v_biasy - r1.x * a.w_bias - a.v_biasy);
            var vrn = vdot2(vrx, vry, n.x, n.y);
            var vrt = vdot2(vrx + surface_vr.x, vry + surface_vr.y, -n.y, n.x);
            var jbn = (con.bias - vbn) * nMass;
            var jbnOld = con.jBias;
            con.jBias = max(jbnOld + jbn, 0);
            var jn = -(con.bounce + vrn) * nMass;
            var jnOld = con.jnAcc;
            con.jnAcc = max(jnOld + jn, 0);
            var jtMax = friction * con.jnAcc;
            var jt = -vrt * con.tMass;
            var jtOld = con.jtAcc;
            con.jtAcc = clamp(jtOld + jt, -jtMax, jtMax);
            var bias_x = n.x * (con.jBias - jbnOld);
            var bias_y = n.y * (con.jBias - jbnOld);
            apply_bias_impulse(a, -bias_x, -bias_y, r1);
            apply_bias_impulse(b, bias_x, bias_y, r2);
            var rot_x = con.jnAcc - jnOld;
            var rot_y = con.jtAcc - jtOld;
            apply_impulses(a, b, r1, r2, n.x * rot_x - n.y * rot_y, n.x * rot_y + n.y * rot_x)
        }
    };
    Arbiter.prototype.callSeparate =
        function (space) {
            var handler = space.lookupHandler(this.a.collision_type, this.b.collision_type);
            handler.separate(this, space)
        };
    Arbiter.prototype.next = function (body) {
        return this.body_a == body ? this.thread_a_next : this.thread_b_next
    };
    var numContacts = 0;
    var Contact = function (p, n, dist, hash) {
        this.p = p;
        this.n = n;
        this.dist = dist;
        this.r1 = this.r2 = vzero;
        this.nMass = this.tMass = this.bounce = this.bias = 0;
        this.jnAcc = this.jtAcc = this.jBias = 0;
        this.hash = hash;
        numContacts++
    };
    var NONE = [];
    var circle2circleQuery = function (p1, p2, r1, r2) {
        var mindist =
            r1 + r2;
        var delta = vsub(p2, p1);
        var distsq = vlengthsq(delta);
        if (distsq >= mindist * mindist)return;
        var dist = Math.sqrt(distsq);
        return new Contact(vadd(p1, vmult(delta, 0.5 + (r1 - 0.5 * mindist) / (dist ? dist : Infinity))), dist ? vmult(delta, 1 / dist) : new Vect(1, 0), dist - mindist, 0)
    };
    var circle2circle = function (circ1, circ2) {
        var contact = circle2circleQuery(circ1.tc, circ2.tc, circ1.r, circ2.r);
        return contact ? [contact] : NONE
    };
    var circle2segment = function (circleShape, segmentShape) {
        var seg_a = segmentShape.ta;
        var seg_b = segmentShape.tb;
        var center =
            circleShape.tc;
        var seg_delta = vsub(seg_b, seg_a);
        var closest_t = clamp01(vdot(seg_delta, vsub(center, seg_a)) / vlengthsq(seg_delta));
        var closest = vadd(seg_a, vmult(seg_delta, closest_t));
        var contact = circle2circleQuery(center, closest, circleShape.r, segmentShape.r);
        if (contact) {
            var n = contact.n;
            return closest_t === 0 && vdot(n, segmentShape.a_tangent) < 0 || closest_t === 1 && vdot(n, segmentShape.b_tangent) < 0 ? NONE : [contact]
        } else return NONE
    };
    var last_MSA_min = 0;
    var findMSA = function (poly, axes) {
        var min_index = 0;
        var min = poly.valueOnAxis(axes[0].n,
            axes[0].d);
        if (min > 0)return-1;
        for (var i = 1; i < axes.length; i++) {
            var dist = poly.valueOnAxis(axes[i].n, axes[i].d);
            if (dist > 0)return-1; else if (dist > min) {
                min = dist;
                min_index = i
            }
        }
        last_MSA_min = min;
        return min_index
    };
    var findVertsFallback = function (poly1, poly2, n, dist) {
        var arr = [];
        var verts1 = poly1.tVerts;
        for (var i = 0; i < verts1.length; i += 2) {
            var vx = verts1[i];
            var vy = verts1[i + 1];
            if (poly2.containsVertPartial(vx, vy, vneg(n)))arr.push(new Contact(new Vect(vx, vy), n, dist, hashPair(poly1.hashid, i)))
        }
        var verts2 = poly2.tVerts;
        for (var i =
            0; i < verts2.length; i += 2) {
            var vx = verts2[i];
            var vy = verts2[i + 1];
            if (poly1.containsVertPartial(vx, vy, n))arr.push(new Contact(new Vect(vx, vy), n, dist, hashPair(poly2.hashid, i)))
        }
        return arr
    };
    var findVerts = function (poly1, poly2, n, dist) {
        var arr = [];
        var verts1 = poly1.tVerts;
        for (var i = 0; i < verts1.length; i += 2) {
            var vx = verts1[i];
            var vy = verts1[i + 1];
            if (poly2.containsVert(vx, vy))arr.push(new Contact(new Vect(vx, vy), n, dist, hashPair(poly1.hashid, i >> 1)))
        }
        var verts2 = poly2.tVerts;
        for (var i = 0; i < verts2.length; i += 2) {
            var vx = verts2[i];
            var vy = verts2[i + 1];
            if (poly1.containsVert(vx, vy))arr.push(new Contact(new Vect(vx, vy), n, dist, hashPair(poly2.hashid, i >> 1)))
        }
        return arr.length ? arr : findVertsFallback(poly1, poly2, n, dist)
    };
    var poly2poly = function (poly1, poly2) {
        var mini1 = findMSA(poly2, poly1.tAxes);
        if (mini1 == -1)return NONE;
        var min1 = last_MSA_min;
        var mini2 = findMSA(poly1, poly2.tAxes);
        if (mini2 == -1)return NONE;
        var min2 = last_MSA_min;
        if (min1 > min2)return findVerts(poly1, poly2, poly1.tAxes[mini1].n, min1); else return findVerts(poly1, poly2, vneg(poly2.tAxes[mini2].n),
            min2)
    };
    var segValueOnAxis = function (seg, n, d) {
        var a = vdot(n, seg.ta) - seg.r;
        var b = vdot(n, seg.tb) - seg.r;
        return min(a, b) - d
    };
    var findPointsBehindSeg = function (arr, seg, poly, pDist, coef) {
        var dta = vcross(seg.tn, seg.ta);
        var dtb = vcross(seg.tn, seg.tb);
        var n = vmult(seg.tn, coef);
        var verts = poly.tVerts;
        for (var i = 0; i < verts.length; i += 2) {
            var vx = verts[i];
            var vy = verts[i + 1];
            if (vdot2(vx, vy, n.x, n.y) < vdot(seg.tn, seg.ta) * coef + seg.r) {
                var dt = vcross2(seg.tn.x, seg.tn.y, vx, vy);
                if (dta >= dt && dt >= dtb)arr.push(new Contact(new Vect(vx, vy),
                    n, pDist, hashPair(poly.hashid, i)))
            }
        }
    };
    var seg2poly = function (seg, poly) {
        var arr = [];
        var axes = poly.tAxes;
        var numVerts = axes.length;
        var segD = vdot(seg.tn, seg.ta);
        var minNorm = poly.valueOnAxis(seg.tn, segD) - seg.r;
        var minNeg = poly.valueOnAxis(vneg(seg.tn), -segD) - seg.r;
        if (minNeg > 0 || minNorm > 0)return NONE;
        var mini = 0;
        var poly_min = segValueOnAxis(seg, axes[0].n, axes[0].d);
        if (poly_min > 0)return NONE;
        for (var i = 0; i < numVerts; i++) {
            var dist = segValueOnAxis(seg, axes[i].n, axes[i].d);
            if (dist > 0)return NONE; else if (dist > poly_min) {
                poly_min =
                    dist;
                mini = i
            }
        }
        var poly_n = vneg(axes[mini].n);
        var va = vadd(seg.ta, vmult(poly_n, seg.r));
        var vb = vadd(seg.tb, vmult(poly_n, seg.r));
        if (poly.containsVert(va.x, va.y))arr.push(new Contact(va, poly_n, poly_min, hashPair(seg.hashid, 0)));
        if (poly.containsVert(vb.x, vb.y))arr.push(new Contact(vb, poly_n, poly_min, hashPair(seg.hashid, 1)));
        if (minNorm >= poly_min || minNeg >= poly_min)if (minNorm > minNeg)findPointsBehindSeg(arr, seg, poly, minNorm, 1); else findPointsBehindSeg(arr, seg, poly, minNeg, -1);
        if (arr.length === 0) {
            var mini2 = mini *
                2;
            var verts = poly.tVerts;
            var poly_a = new Vect(verts[mini2], verts[mini2 + 1]);
            var con;
            if (con = circle2circleQuery(seg.ta, poly_a, seg.r, 0, arr))return[con];
            if (con = circle2circleQuery(seg.tb, poly_a, seg.r, 0, arr))return[con];
            var len = numVerts * 2;
            var poly_b = new Vect(verts[(mini2 + 2) % len], verts[(mini2 + 3) % len]);
            if (con = circle2circleQuery(seg.ta, poly_b, seg.r, 0, arr))return[con];
            if (con = circle2circleQuery(seg.tb, poly_b, seg.r, 0, arr))return[con]
        }
        return arr
    };
    var circle2poly = function (circ, poly) {
        var axes = poly.tAxes;
        var mini = 0;
        var min = vdot(axes[0].n, circ.tc) - axes[0].d - circ.r;
        for (var i = 0; i < axes.length; i++) {
            var dist = vdot(axes[i].n, circ.tc) - axes[i].d - circ.r;
            if (dist > 0)return NONE; else if (dist > min) {
                min = dist;
                mini = i
            }
        }
        var n = axes[mini].n;
        var verts = poly.tVerts;
        var len = verts.length;
        var mini2 = mini << 1;
        var ax = verts[mini2];
        var ay = verts[mini2 + 1];
        var bx = verts[(mini2 + 2) % len];
        var by = verts[(mini2 + 3) % len];
        var dta = vcross2(n.x, n.y, ax, ay);
        var dtb = vcross2(n.x, n.y, bx, by);
        var dt = vcross(n, circ.tc);
        if (dt < dtb) {
            var con = circle2circleQuery(circ.tc, new Vect(bx,
                by), circ.r, 0, con);
            return con ? [con] : NONE
        } else if (dt < dta)return[new Contact(vsub(circ.tc, vmult(n, circ.r + min / 2)), vneg(n), min, 0)]; else {
            var con = circle2circleQuery(circ.tc, new Vect(ax, ay), circ.r, 0, con);
            return con ? [con] : NONE
        }
    };
    CircleShape.prototype.collisionCode = 0;
    SegmentShape.prototype.collisionCode = 1;
    PolyShape.prototype.collisionCode = 2;
    CircleShape.prototype.collisionTable = [circle2circle, circle2segment, circle2poly];
    SegmentShape.prototype.collisionTable = [null, function (seg, seg2) {
        return NONE
    }, seg2poly];
    PolyShape.prototype.collisionTable =
        [null, null, poly2poly];
    var collideShapes = cp.collideShapes = function (a, b) {
        assert(a.collisionCode <= b.collisionCode, "Collided shapes must be sorted by type");
        return a.collisionTable[b.collisionCode](a, b)
    };
    var defaultCollisionHandler = new CollisionHandler;
    var Space = cp.Space = function () {
        this.stamp = 0;
        this.curr_dt = 0;
        this.bodies = [];
        this.rousedBodies = [];
        this.sleepingComponents = [];
        this.staticShapes = new BBTree(null);
        this.activeShapes = new BBTree(this.staticShapes);
        this.arbiters = [];
        this.contactBuffersHead = null;
        this.cachedArbiters =
        {};
        this.constraints = [];
        this.locked = 0;
        this.collisionHandlers = {};
        this.defaultHandler = defaultCollisionHandler;
        this.postStepCallbacks = [];
        this.iterations = 10;
        this.gravity = vzero;
        this.damping = 1;
        this.idleSpeedThreshold = 0;
        this.sleepTimeThreshold = Infinity;
        this.collisionSlop = 0.1;
        this.collisionBias = Math.pow(1 - 0.1, 60);
        this.collisionPersistence = 3;
        this.enableContactGraph = false;
        this.staticBody = new Body(Infinity, Infinity);
        this.staticBody.nodeIdleTime = Infinity;
        this.collideShapes = this.makeCollideShapes()
    };
    Space.prototype.getCurrentTimeStep =
        function () {
            return this.curr_dt
        };
    Space.prototype.isLocked = function () {
        return this.locked
    };
    var assertSpaceUnlocked = function (space) {
        assert(!space.locked, "This addition/removal cannot be done safely during a call to cpSpaceStep()  or during a query. Put these calls into a post-step callback.")
    };
    Space.prototype.addCollisionHandler = function (a, b, begin, preSolve, postSolve, separate) {
        assertSpaceUnlocked(this);
        this.removeCollisionHandler(a, b);
        var handler = new CollisionHandler;
        handler.a = a;
        handler.b = b;
        if (begin)handler.begin =
            begin;
        if (preSolve)handler.preSolve = preSolve;
        if (postSolve)handler.postSolve = postSolve;
        if (separate)handler.separate = separate;
        this.collisionHandlers[hashPair(a, b)] = handler
    };
    Space.prototype.removeCollisionHandler = function (a, b) {
        assertSpaceUnlocked(this);
        delete this.collisionHandlers[hashPair(a, b)]
    };
    Space.prototype.setDefaultCollisionHandler = function (begin, preSolve, postSolve, separate) {
        assertSpaceUnlocked(this);
        var handler = new CollisionHandler;
        if (begin)handler.begin = begin;
        if (preSolve)handler.preSolve = preSolve;
        if (postSolve)handler.postSolve = postSolve;
        if (separate)handler.separate = separate;
        this.defaultHandler = handler
    };
    Space.prototype.lookupHandler = function (a, b) {
        return this.collisionHandlers[hashPair(a, b)] || this.defaultHandler
    };
    Space.prototype.addShape = function (shape) {
        var body = shape.body;
        if (body.isStatic())return this.addStaticShape(shape);
        assert(!shape.space, "This shape is already added to a space and cannot be added to another.");
        assertSpaceUnlocked(this);
        body.activate();
        body.addShape(shape);
        shape.update(body.p,
            body.rot);
        this.activeShapes.insert(shape, shape.hashid);
        shape.space = this;
        return shape
    };
    Space.prototype.addStaticShape = function (shape) {
        assert(!shape.space, "This shape is already added to a space and cannot be added to another.");
        assertSpaceUnlocked(this);
        var body = shape.body;
        body.addShape(shape);
        shape.update(body.p, body.rot);
        this.staticShapes.insert(shape, shape.hashid);
        shape.space = this;
        return shape
    };
    Space.prototype.addBody = function (body) {
        assert(!body.isStatic(), "Static bodies cannot be added to a space as they are not meant to be simulated.");
        assert(!body.space, "This body is already added to a space and cannot be added to another.");
        assertSpaceUnlocked(this);
        this.bodies.push(body);
        body.space = this;
        return body
    };
    Space.prototype.addConstraint = function (constraint) {
        assert(!constraint.space, "This shape is already added to a space and cannot be added to another.");
        assertSpaceUnlocked(this);
        var a = constraint.a, b = constraint.b;
        a.activate();
        b.activate();
        this.constraints.push(constraint);
        constraint.next_a = a.constraintList;
        a.constraintList = constraint;
        constraint.next_b = b.constraintList;
        b.constraintList = constraint;
        constraint.space = this;
        return constraint
    };
    Space.prototype.filterArbiters = function (body, filter) {
        for (var hash in this.cachedArbiters) {
            var arb = this.cachedArbiters[hash];
            if (body === arb.body_a && (filter === arb.a || filter === null) || body === arb.body_b && (filter === arb.b || filter === null)) {
                if (filter && arb.state !== "cached")arb.callSeparate(this);
                arb.unthread();
                deleteObjFromList(this.arbiters, arb);
                delete this.cachedArbiters[hash]
            }
        }
    };
    Space.prototype.removeShape =
        function (shape) {
            var body = shape.body;
            if (body.isStatic())this.removeStaticShape(shape); else {
                assert(this.containsShape(shape), "Cannot remove a shape that was not added to the space. (Removed twice maybe?)");
                assertSpaceUnlocked(this);
                body.activate();
                body.removeShape(shape);
                this.filterArbiters(body, shape);
                this.activeShapes.remove(shape, shape.hashid);
                shape.space = null
            }
        };
    Space.prototype.removeStaticShape = function (shape) {
        assert(this.containsShape(shape), "Cannot remove a static or sleeping shape that was not added to the space. (Removed twice maybe?)");
        assertSpaceUnlocked(this);
        var body = shape.body;
        if (body.isStatic())body.activateStatic(shape);
        body.removeShape(shape);
        this.filterArbiters(body, shape);
        this.staticShapes.remove(shape, shape.hashid);
        shape.space = null
    };
    Space.prototype.removeBody = function (body) {
        assert(this.containsBody(body), "Cannot remove a body that was not added to the space. (Removed twice maybe?)");
        assertSpaceUnlocked(this);
        body.activate();
        deleteObjFromList(this.bodies, body);
        body.space = null
    };
    Space.prototype.removeConstraint = function (constraint) {
        assert(this.containsConstraint(constraint),
            "Cannot remove a constraint that was not added to the space. (Removed twice maybe?)");
        assertSpaceUnlocked(this);
        constraint.a.activate();
        constraint.b.activate();
        deleteObjFromList(this.constraints, constraint);
        constraint.a.removeConstraint(constraint);
        constraint.b.removeConstraint(constraint);
        constraint.space = null
    };
    Space.prototype.containsShape = function (shape) {
        return shape.space === this
    };
    Space.prototype.containsBody = function (body) {
        return body.space == this
    };
    Space.prototype.containsConstraint = function (constraint) {
        return constraint.space ==
            this
    };
    Space.prototype.uncacheArbiter = function (arb) {
        delete this.cachedArbiters[hashPair(arb.a.hashid, arb.b.hashid)];
        deleteObjFromList(this.arbiters, arb)
    };
    Space.prototype.eachBody = function (func) {
        this.lock();
        var bodies = this.bodies;
        for (var i = 0; i < bodies.length; i++)func(bodies[i]);
        var components = this.sleepingComponents;
        for (var i = 0; i < components.length; i++) {
            var root = components[i];
            var body = root;
            while (body) {
                var next = body.nodeNext;
                func(body);
                body = next
            }
        }
        this.unlock(true)
    };
    Space.prototype.eachShape = function (func) {
        this.lock();
        this.activeShapes.each(func);
        this.staticShapes.each(func);
        this.unlock(true)
    };
    Space.prototype.eachConstraint = function (func) {
        this.lock();
        var constraints = this.constraints;
        for (var i = 0; i < constraints.length; i++)func(constraints[i]);
        this.unlock(true)
    };
    Space.prototype.reindexStatic = function () {
        assert(!this.locked, "You cannot manually reindex objects while the space is locked. Wait until the current query or step is complete.");
        this.staticShapes.each(function (shape) {
            var body = shape.body;
            shape.update(body.p,
                body.rot)
        });
        this.staticShapes.reindex()
    };
    Space.prototype.reindexShape = function (shape) {
        assert(!this.locked, "You cannot manually reindex objects while the space is locked. Wait until the current query or step is complete.");
        var body = shape.body;
        shape.update(body.p, body.rot);
        this.activeShapes.reindexObject(shape, shape.hashid);
        this.staticShapes.reindexObject(shape, shape.hashid)
    };
    Space.prototype.reindexShapesForBody = function (body) {
        for (var shape = body.shapeList; shape; shape = shape.next)this.reindexShape(shape)
    };
    Space.prototype.useSpatialHash = function (dim, count) {
        throw new Error("Spatial Hash not yet implemented!");
        var staticShapes = new SpaceHash(dim, count, null);
        var activeShapes = new SpaceHash(dim, count, staticShapes);
        this.staticShapes.each(function (shape) {
            staticShapes.insert(shape, shape.hashid)
        });
        this.activeShapes.each(function (shape) {
            activeShapes.insert(shape, shape.hashid)
        });
        this.staticShapes = staticShapes;
        this.activeShapes = activeShapes
    };
    Space.prototype.activateBody = function (body) {
        assert(!body.isRogue(), "Internal error: Attempting to activate a rogue body.");
        if (this.locked) {
            if (this.rousedBodies.indexOf(body) === -1)this.rousedBodies.push(body)
        } else {
            this.bodies.push(body);
            for (var i = 0; i < body.shapeList.length; i++) {
                var shape = body.shapeList[i];
                this.staticShapes.remove(shape, shape.hashid);
                this.activeShapes.insert(shape, shape.hashid)
            }
            for (var arb = body.arbiterList; arb; arb = arb.next(body)) {
                var bodyA = arb.body_a;
                if (body === bodyA || bodyA.isStatic()) {
                    var a = arb.a, b = arb.b;
                    this.cachedArbiters[hashPair(a.hashid, b.hashid)] = arb;
                    arb.stamp = this.stamp;
                    arb.handler = this.lookupHandler(a.collision_type,
                        b.collision_type);
                    this.arbiters.push(arb)
                }
            }
            for (var constraint = body.constraintList; constraint; constraint = constraint.nodeNext) {
                var bodyA = constraint.a;
                if (body === bodyA || bodyA.isStatic())this.constraints.push(constraint)
            }
        }
    };
    Space.prototype.deactivateBody = function (body) {
        assert(!body.isRogue(), "Internal error: Attempting to deactivate a rogue body.");
        deleteObjFromList(this.bodies, body);
        for (var i = 0; i < body.shapeList.length; i++) {
            var shape = body.shapeList[i];
            this.activeShapes.remove(shape, shape.hashid);
            this.staticShapes.insert(shape,
                shape.hashid)
        }
        for (var arb = body.arbiterList; arb; arb = arb.next(body)) {
            var bodyA = arb.body_a;
            if (body === bodyA || bodyA.isStatic())this.uncacheArbiter(arb)
        }
        for (var constraint = body.constraintList; constraint; constraint = constraint.nodeNext) {
            var bodyA = constraint.a;
            if (body === bodyA || bodyA.isStatic())deleteObjFromList(this.constraints, constraint)
        }
    };
    var componentRoot = function (body) {
        return body ? body.nodeRoot : null
    };
    var componentActivate = function (root) {
        if (!root || !root.isSleeping(root))return;
        assert(!root.isRogue(), "Internal Error: componentActivate() called on a rogue body.");
        var space = root.space;
        var body = root;
        while (body) {
            var next = body.nodeNext;
            body.nodeIdleTime = 0;
            body.nodeRoot = null;
            body.nodeNext = null;
            space.activateBody(body);
            body = next
        }
        deleteObjFromList(space.sleepingComponents, root)
    };
    Body.prototype.activate = function () {
        if (!this.isRogue()) {
            this.nodeIdleTime = 0;
            componentActivate(componentRoot(this))
        }
    };
    Body.prototype.activateStatic = function (filter) {
        assert(this.isStatic(), "Body.activateStatic() called on a non-static body.");
        for (var arb = this.arbiterList; arb; arb = arb.next(this))if (!filter ||
            filter == arb.a || filter == arb.b)(arb.body_a == this ? arb.body_b : arb.body_a).activate()
    };
    Body.prototype.pushArbiter = function (arb) {
        assertSoft((arb.body_a === this ? arb.thread_a_next : arb.thread_b_next) === null, "Internal Error: Dangling contact graph pointers detected. (A)");
        assertSoft((arb.body_a === this ? arb.thread_a_prev : arb.thread_b_prev) === null, "Internal Error: Dangling contact graph pointers detected. (B)");
        var next = this.arbiterList;
        assertSoft(next === null || (next.body_a === this ? next.thread_a_prev : next.thread_b_prev) ===
            null, "Internal Error: Dangling contact graph pointers detected. (C)");
        if (arb.body_a === this)arb.thread_a_next = next; else arb.thread_b_next = next;
        if (next)if (next.body_a === this)next.thread_a_prev = arb; else next.thread_b_prev = arb;
        this.arbiterList = arb
    };
    var componentAdd = function (root, body) {
        body.nodeRoot = root;
        if (body !== root) {
            body.nodeNext = root.nodeNext;
            root.nodeNext = body
        }
    };
    var floodFillComponent = function (root, body) {
        if (!body.isRogue()) {
            var other_root = componentRoot(body);
            if (other_root == null) {
                componentAdd(root,
                    body);
                for (var arb = body.arbiterList; arb; arb = arb.next(body))floodFillComponent(root, body == arb.body_a ? arb.body_b : arb.body_a);
                for (var constraint = body.constraintList; constraint; constraint = constraint.next(body))floodFillComponent(root, body == constraint.a ? constraint.b : constraint.a)
            } else assertSoft(other_root === root, "Internal Error: Inconsistency detected in the contact graph.")
        }
    };
    var componentActive = function (root, threshold) {
        for (var body = root; body; body = body.nodeNext)if (body.nodeIdleTime < threshold)return true;
        return false
    };
    Space.prototype.processComponents = function (dt) {
        var sleep = this.sleepTimeThreshold !== Infinity;
        var bodies = this.bodies;
        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i];
            assertSoft(body.nodeNext === null, "Internal Error: Dangling next pointer detected in contact graph.");
            assertSoft(body.nodeRoot === null, "Internal Error: Dangling root pointer detected in contact graph.")
        }
        if (sleep) {
            var dv = this.idleSpeedThreshold;
            var dvsq = dv ? dv * dv : vlengthsq(this.gravity) * dt * dt;
            for (var i = 0; i < bodies.length; i++) {
                var body =
                    bodies[i];
                var keThreshold = dvsq ? body.m * dvsq : 0;
                body.nodeIdleTime = body.kineticEnergy() > keThreshold ? 0 : body.nodeIdleTime + dt
            }
        }
        var arbiters = this.arbiters;
        for (var i = 0, count = arbiters.length; i < count; i++) {
            var arb = arbiters[i];
            var a = arb.body_a, b = arb.body_b;
            if (sleep) {
                if (b.isRogue() && !b.isStatic() || a.isSleeping())a.activate();
                if (a.isRogue() && !a.isStatic() || b.isSleeping())b.activate()
            }
            a.pushArbiter(arb);
            b.pushArbiter(arb)
        }
        if (sleep) {
            var constraints = this.constraints;
            for (var i = 0; i < constraints.length; i++) {
                var constraint =
                    constraints[i];
                var a = constraint.a, b = constraint.b;
                if (b.isRogue() && !b.isStatic())a.activate();
                if (a.isRogue() && !a.isStatic())b.activate()
            }
            for (var i = 0; i < bodies.length;) {
                var body = bodies[i];
                if (componentRoot(body) === null) {
                    floodFillComponent(body, body);
                    if (!componentActive(body, this.sleepTimeThreshold)) {
                        this.sleepingComponents.push(body);
                        for (var other = body; other; other = other.nodeNext)this.deactivateBody(other);
                        continue
                    }
                }
                i++;
                body.nodeRoot = null;
                body.nodeNext = null
            }
        }
    };
    Body.prototype.sleep = function () {
        this.sleepWithGroup(null)
    };
    Body.prototype.sleepWithGroup = function (group) {
        assert(!this.isStatic() && !this.isRogue(), "Rogue and static bodies cannot be put to sleep.");
        var space = this.space;
        assert(space, "Cannot put a rogue body to sleep.");
        assert(!space.locked, "Bodies cannot be put to sleep during a query or a call to cpSpaceStep(). Put these calls into a post-step callback.");
        assert(group === null || group.isSleeping(), "Cannot use a non-sleeping body as a group identifier.");
        if (this.isSleeping()) {
            assert(componentRoot(this) === componentRoot(group),
                "The body is already sleeping and it's group cannot be reassigned.");
            return
        }
        for (var i = 0; i < body.shapeList.length; i++)body.shapeList.update(this.p, this.rot);
        space.deactivateBody(this);
        if (group) {
            var root = componentRoot(group);
            this.nodeRoot = root;
            this.nodeNext = root.nodeNext;
            this.nodeIdleTime = 0;
            root.nodeNext = this
        } else {
            this.nodeRoot = this;
            this.nodeNext = null;
            this.nodeIdleTime = 0;
            space.sleepingComponents.push(this)
        }
        deleteObjFromList(space.bodies, this)
    };
    Space.prototype.activateShapesTouchingShape = function (shape) {
        if (this.sleepTimeThreshold !==
            Infinity)this.shapeQuery(shape, function (shape, points) {
            shape.body.activate()
        })
    };
    Space.prototype.pointQuery = function (point, layers, group, func) {
        var helper = function (shape) {
            if (!(shape.group && group === shape.group) && layers & shape.layers && shape.pointQuery(point))func(shape)
        };
        this.lock();
        this.activeShapes.pointQuery(point, helper);
        this.staticShapes.pointQuery(point, helper);
        this.unlock(true)
    };
    Space.prototype.pointQueryFirst = function (point, layers, group) {
        var outShape = null;
        this.pointQuery(point, layers, group, function (shape) {
            if (!shape.sensor)outShape =
                shape
        });
        return outShape
    };
    Space.prototype.segmentQuery = function (start, end, layers, group, func) {
        var helper = function (shape) {
            var info;
            if (!(shape.group && group === shape.group) && layers & shape.layers && (info = shape.segmentQuery(start, end)))func(shape, info.t, info.n);
            return 1
        };
        this.lock();
        this.staticShapes.segmentQuery(start, end, 1, helper);
        this.activeShapes.segmentQuery(start, end, 1, helper);
        this.unlock(true)
    };
    Space.prototype.segmentQueryFirst = function (start, end, layers, group) {
        var out = null;
        var helper = function (shape) {
            var info;
            if (!(shape.group && group === shape.group) && layers & shape.layers && !shape.sensor && (info = shape.segmentQuery(start, end)) && (out === null || info.t < out.t))out = info;
            return out ? out.t : 1
        };
        this.staticShapes.segmentQuery(start, end, 1, helper);
        this.activeShapes.segmentQuery(start, end, out ? out.t : 1, helper);
        return out
    };
    Space.prototype.bbQuery = function (bb, layers, group, func) {
        var helper = function (shape) {
            if (!(shape.group && group === shape.group) && layers & shape.layers && bbIntersects2(bb, shape.bb_l, shape.bb_b, shape.bb_r, shape.bb_t))func(shape)
        };
        this.lock();
        this.activeShapes.query(bb, helper);
        this.staticShapes.query(bb, helper);
        this.unlock(true)
    };
    Space.prototype.shapeQuery = function (shape, func) {
        var body = shape.body;
        if (body)shape.update(body.p, body.rot);
        var bb = new BB(shape.bb_l, shape.bb_b, shape.bb_r, shape.bb_t);
        var anyCollision = false;
        var helper = function (b) {
            var a = shape;
            if (a.group && a.group === b.group || !(a.layers & b.layers) || a === b)return;
            var contacts;
            if (a.collisionCode <= b.collisionCode)contacts = cpCollideShapes(a, b); else {
                contacts = cpCollideShapes(b,
                    a);
                for (var i = 0; i < contacts.length; i++)contacts[i].n = vneg(contacts[i].n)
            }
            if (contacts.length) {
                anyCollision = !(a.sensor || b.sensor);
                if (func) {
                    var set = new Array(contacts.length);
                    for (var i = 0; i < contacts.length; i++)set[i] = new ContactPoint(contacts[i].p, contacts[i].n, contacts[i].dist);
                    func(b, set)
                }
            }
        };
        this.lock();
        this.activeShapes.query(bb, helper);
        this.staticShapes.query(bb, helper);
        this.unlock(true);
        return anyCollision
    };
    Space.prototype.addPostStepCallback = function (func) {
        assertSoft(this.locked, "Adding a post-step callback when the space is not locked is unnecessary. " +
            "Post-step callbacks will not called until the end of the next call to cpSpaceStep() or the next query.");
        this.postStepCallbacks.push(func)
    };
    Space.prototype.runPostStepCallbacks = function () {
        for (var i = 0; i < this.postStepCallbacks.length; i++)this.postStepCallbacks[i]();
        this.postStepCallbacks = []
    };
    Space.prototype.lock = function () {
        this.locked++
    };
    Space.prototype.unlock = function (runPostStep) {
        this.locked--;
        assert(this.locked >= 0, "Internal Error: Space lock underflow.");
        if (!this.locked && runPostStep) {
            var waking =
                this.rousedBodies;
            for (var i = 0; i < waking.length; i++)this.activateBody(waking[i]);
            waking.length = 0;
            this.runPostStepCallbacks()
        }
    };
    Space.prototype.makeCollideShapes = function () {
        var space_ = this;
        return function (a, b) {
            var space = space_;
            if (!(a.bb_l <= b.bb_r && b.bb_l <= a.bb_r && a.bb_b <= b.bb_t && b.bb_b <= a.bb_t) || a.body === b.body || a.group && a.group === b.group || !(a.layers & b.layers))return;
            var handler = space.lookupHandler(a.collision_type, b.collision_type);
            var sensor = a.sensor || b.sensor;
            if (sensor && handler === defaultCollisionHandler)return;
            if (a.collisionCode > b.collisionCode) {
                var temp = a;
                a = b;
                b = temp
            }
            var contacts = collideShapes(a, b);
            if (contacts.length === 0)return;
            var arbHash = hashPair(a.hashid, b.hashid);
            var arb = space.cachedArbiters[arbHash];
            if (!arb)arb = space.cachedArbiters[arbHash] = new Arbiter(a, b);
            arb.update(contacts, handler, a, b);
            if (arb.state == "first coll" && !handler.begin(arb, space))arb.ignore();
            if (arb.state !== "ignore" && handler.preSolve(arb, space) && !sensor)space.arbiters.push(arb); else {
                arb.contacts = null;
                if (arb.state !== "ignore")arb.state =
                    "normal"
            }
            arb.stamp = space.stamp
        }
    };
    Space.prototype.arbiterSetFilter = function (arb) {
        var ticks = this.stamp - arb.stamp;
        var a = arb.body_a, b = arb.body_b;
        if ((a.isStatic() || a.isSleeping()) && (b.isStatic() || b.isSleeping()))return true;
        if (ticks >= 1 && arb.state != "cached") {
            arb.callSeparate(this);
            arb.state = "cached"
        }
        if (ticks >= this.collisionPersistence) {
            arb.contacts = null;
            return false
        }
        return true
    };
    var updateFunc = function (shape) {
        var body = shape.body;
        shape.update(body.p, body.rot)
    };
    Space.prototype.step = function (dt) {
        if (dt === 0)return;
        assert(vzero.x === 0 && vzero.y === 0, "vzero is invalid");
        this.stamp++;
        var prev_dt = this.curr_dt;
        this.curr_dt = dt;
        var bodies = this.bodies;
        var constraints = this.constraints;
        var arbiters = this.arbiters;
        for (var i = 0; i < arbiters.length; i++) {
            var arb = arbiters[i];
            arb.state = "normal";
            if (!arb.body_a.isSleeping() && !arb.body_b.isSleeping())arb.unthread()
        }
        arbiters.length = 0;
        this.lock();
        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i];
            body.position_func(dt)
        }
        this.activeShapes.each(updateFunc);
        this.activeShapes.reindexQuery(this.collideShapes);
        this.unlock(false);
        this.processComponents(dt);
        this.lock();
        for (var hash in this.cachedArbiters)if (!this.arbiterSetFilter(this.cachedArbiters[hash]))delete this.cachedArbiters[hash];
        var slop = this.collisionSlop;
        var biasCoef = 1 - Math.pow(this.collisionBias, dt);
        for (var i = 0; i < arbiters.length; i++)arbiters[i].preStep(dt, slop, biasCoef);
        for (var i = 0; i < constraints.length; i++) {
            var constraint = constraints[i];
            constraint.preSolve(this);
            constraint.preStep(dt)
        }
        var damping = Math.pow(this.damping, dt);
        var gravity = this.gravity;
        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i];
            body.velocity_func(gravity, damping, dt)
        }
        var dt_coef = prev_dt === 0 ? 0 : dt / prev_dt;
        for (var i = 0; i < arbiters.length; i++)arbiters[i].applyCachedImpulse(dt_coef);
        for (var i = 0; i < constraints.length; i++) {
            var constraint = constraints[i];
            constraint.applyCachedImpulse(dt_coef)
        }
        for (var i = 0; i < this.iterations; i++) {
            for (var j = 0; j < arbiters.length; j++)arbiters[j].applyImpulse();
            for (var j = 0; j < constraints.length; j++)constraints[j].applyImpulse()
        }
        for (var i = 0; i < constraints.length; i++)constraints[i].postSolve(this);
        for (var i = 0; i < arbiters.length; i++) {
            var arb = arbiters[i];
            arb.handler.postSolve(arb, this)
        }
        this.unlock(true)
    };
    var relative_velocity = function (a, b, r1, r2) {
        var v1_sumx = a.vx + -r1.y * a.w;
        var v1_sumy = a.vy + r1.x * a.w;
        var v2_sumx = b.vx + -r2.y * b.w;
        var v2_sumy = b.vy + r2.x * b.w;
        return new Vect(v2_sumx - v1_sumx, v2_sumy - v1_sumy)
    };
    var normal_relative_velocity = function (a, b, r1, r2, n) {
        var v1_sumx = a.vx + -r1.y * a.w;
        var v1_sumy = a.vy + r1.x * a.w;
        var v2_sumx = b.vx + -r2.y * b.w;
        var v2_sumy = b.vy + r2.x * b.w;
        return vdot2(v2_sumx - v1_sumx, v2_sumy - v1_sumy,
            n.x, n.y)
    };
    var apply_impulse = function (body, jx, jy, r) {
        body.vx += jx * body.m_inv;
        body.vy += jy * body.m_inv;
        body.w += body.i_inv * (r.x * jy - r.y * jx)
    };
    var apply_impulses = function (a, b, r1, r2, jx, jy) {
        apply_impulse(a, -jx, -jy, r1);
        apply_impulse(b, jx, jy, r2)
    };
    var apply_bias_impulse = function (body, jx, jy, r) {
        body.v_biasx += jx * body.m_inv;
        body.v_biasy += jy * body.m_inv;
        body.w_bias += body.i_inv * vcross2(r.x, r.y, jx, jy)
    };
    var k_scalar_body = function (body, r, n) {
        var rcn = vcross(r, n);
        return body.m_inv + body.i_inv * rcn * rcn
    };
    var k_scalar = function (a, b, r1, r2, n) {
        var value = k_scalar_body(a, r1, n) + k_scalar_body(b, r2, n);
        assertSoft(value !== 0, "Unsolvable collision or constraint.");
        return value
    };
    var k_tensor = function (a, b, r1, r2, k1, k2) {
        var k11, k12, k21, k22;
        var m_sum = a.m_inv + b.m_inv;
        k11 = m_sum;
        k12 = 0;
        k21 = 0;
        k22 = m_sum;
        var a_i_inv = a.i_inv;
        var r1xsq = r1.x * r1.x * a_i_inv;
        var r1ysq = r1.y * r1.y * a_i_inv;
        var r1nxy = -r1.x * r1.y * a_i_inv;
        k11 += r1ysq;
        k12 += r1nxy;
        k21 += r1nxy;
        k22 += r1xsq;
        var b_i_inv = b.i_inv;
        var r2xsq = r2.x * r2.x * b_i_inv;
        var r2ysq = r2.y * r2.y * b_i_inv;
        var r2nxy = -r2.x * r2.y *
            b_i_inv;
        k11 += r2ysq;
        k12 += r2nxy;
        k21 += r2nxy;
        k22 += r2xsq;
        var determinant = k11 * k22 - k12 * k21;
        assertSoft(determinant !== 0, "Unsolvable constraint.");
        var det_inv = 1 / determinant;
        k1.x = k22 * det_inv;
        k1.y = -k12 * det_inv;
        k2.x = -k21 * det_inv;
        k2.y = k11 * det_inv
    };
    var mult_k = function (vr, k1, k2) {
        return new Vect(vdot(vr, k1), vdot(vr, k2))
    };
    var bias_coef = function (errorBias, dt) {
        return 1 - Math.pow(errorBias, dt)
    };
    var Constraint = cp.Constraint = function (a, b) {
        this.a = a;
        this.b = b;
        this.space = null;
        this.next_a = null;
        this.next_b = null;
        this.maxForce =
            Infinity;
        this.errorBias = Math.pow(1 - 0.1, 60);
        this.maxBias = Infinity
    };
    Constraint.prototype.activateBodies = function () {
        if (this.a)this.a.activate();
        if (this.b)this.b.activate()
    };
    Constraint.prototype.preStep = function (dt) {
    };
    Constraint.prototype.applyCachedImpulse = function (dt_coef) {
    };
    Constraint.prototype.applyImpulse = function () {
    };
    Constraint.prototype.getImpulse = function () {
        return 0
    };
    Constraint.prototype.preSolve = function (space) {
    };
    Constraint.prototype.postSolve = function (space) {
    };
    Constraint.prototype.next = function (body) {
        return this.a ===
            body ? this.next_a : this.next_b
    };
    var PinJoint = cp.PinJoint = function (a, b, anchr1, anchr2) {
        Constraint.call(this, a, b);
        this.anchr1 = anchr1;
        this.anchr2 = anchr2;
        var p1 = a ? vadd(a.p, vrotate(anchr1, a.rot)) : anchr1;
        var p2 = b ? vadd(b.p, vrotate(anchr2, b.rot)) : anchr2;
        this.dist = vlength(vsub(p2, p1));
        assertSoft(this.dist > 0, "You created a 0 length pin joint. A pivot joint will be much more stable.");
        this.r1 = this.r2 = null;
        this.n = null;
        this.nMass = 0;
        this.jnAcc = this.jnMax = 0;
        this.bias = 0
    };
    PinJoint.prototype = Object.create(Constraint.prototype);
    PinJoint.prototype.preStep = function (dt) {
        var a = this.a;
        var b = this.b;
        this.r1 = vrotate(this.anchr1, a.rot);
        this.r2 = vrotate(this.anchr2, b.rot);
        var delta = vsub(vadd(b.p, this.r2), vadd(a.p, this.r1));
        var dist = vlength(delta);
        this.n = vmult(delta, 1 / (dist ? dist : Infinity));
        this.nMass = 1 / k_scalar(a, b, this.r1, this.r2, this.n);
        var maxBias = this.maxBias;
        this.bias = clamp(-bias_coef(this.errorBias, dt) * (dist - this.dist) / dt, -maxBias, maxBias);
        this.jnMax = this.maxForce * dt
    };
    PinJoint.prototype.applyCachedImpulse = function (dt_coef) {
        var j =
            vmult(this.n, this.jnAcc * dt_coef);
        apply_impulses(this.a, this.b, this.r1, this.r2, j.x, j.y)
    };
    PinJoint.prototype.applyImpulse = function () {
        var a = this.a;
        var b = this.b;
        var n = this.n;
        var vrn = normal_relative_velocity(a, b, this.r1, this.r2, n);
        var jn = (this.bias - vrn) * this.nMass;
        var jnOld = this.jnAcc;
        this.jnAcc = clamp(jnOld + jn, -this.jnMax, this.jnMax);
        jn = this.jnAcc - jnOld;
        apply_impulses(a, b, this.r1, this.r2, n.x * jn, n.y * jn)
    };
    PinJoint.prototype.getImpulse = function () {
        return Math.abs(this.jnAcc)
    };
    var SlideJoint = cp.SlideJoint =
        function (a, b, anchr1, anchr2, min, max) {
            Constraint.call(this, a, b);
            this.anchr1 = anchr1;
            this.anchr2 = anchr2;
            this.min = min;
            this.max = max;
            this.r1 = this.r2 = this.n = null;
            this.nMass = 0;
            this.jnAcc = this.jnMax = 0;
            this.bias = 0
        };
    SlideJoint.prototype = Object.create(Constraint.prototype);
    SlideJoint.prototype.preStep = function (dt) {
        var a = this.a;
        var b = this.b;
        this.r1 = vrotate(this.anchr1, a.rot);
        this.r2 = vrotate(this.anchr2, b.rot);
        var delta = vsub(vadd(b.p, this.r2), vadd(a.p, this.r1));
        var dist = vlength(delta);
        var pdist = 0;
        if (dist > this.max) {
            pdist =
                dist - this.max;
            this.n = vnormalize_safe(delta)
        } else if (dist < this.min) {
            pdist = this.min - dist;
            this.n = vneg(vnormalize_safe(delta))
        } else {
            this.n = vzero;
            this.jnAcc = 0
        }
        this.nMass = 1 / k_scalar(a, b, this.r1, this.r2, this.n);
        var maxBias = this.maxBias;
        this.bias = clamp(-bias_coef(this.errorBias, dt) * pdist / dt, -maxBias, maxBias);
        this.jnMax = this.maxForce * dt
    };
    SlideJoint.prototype.applyCachedImpulse = function (dt_coef) {
        var jn = this.jnAcc * dt_coef;
        apply_impulses(this.a, this.b, this.r1, this.r2, this.n.x * jn, this.n.y * jn)
    };
    SlideJoint.prototype.applyImpulse =
        function () {
            if (this.n.x === 0 && this.n.y === 0)return;
            var a = this.a;
            var b = this.b;
            var n = this.n;
            var r1 = this.r1;
            var r2 = this.r2;
            var vr = relative_velocity(a, b, r1, r2);
            var vrn = vdot(vr, n);
            var jn = (this.bias - vrn) * this.nMass;
            var jnOld = this.jnAcc;
            this.jnAcc = clamp(jnOld + jn, -this.jnMax, 0);
            jn = this.jnAcc - jnOld;
            apply_impulses(a, b, this.r1, this.r2, n.x * jn, n.y * jn)
        };
    SlideJoint.prototype.getImpulse = function () {
        return Math.abs(this.jnAcc)
    };
    var PivotJoint = cp.PivotJoint = function (a, b, anchr1, anchr2) {
        Constraint.call(this, a, b);
        if (typeof anchr2 ===
            "undefined") {
            var pivot = anchr1;
            anchr1 = a ? a.world2Local(pivot) : pivot;
            anchr2 = b ? b.world2Local(pivot) : pivot
        }
        this.anchr1 = anchr1;
        this.anchr2 = anchr2;
        this.r1 = this.r2 = vzero;
        this.k1 = new Vect(0, 0);
        this.k2 = new Vect(0, 0);
        this.jAcc = vzero;
        this.jMaxLen = 0;
        this.bias = vzero
    };
    PivotJoint.prototype = Object.create(Constraint.prototype);
    PivotJoint.prototype.preStep = function (dt) {
        var a = this.a;
        var b = this.b;
        this.r1 = vrotate(this.anchr1, a.rot);
        this.r2 = vrotate(this.anchr2, b.rot);
        k_tensor(a, b, this.r1, this.r2, this.k1, this.k2);
        this.jMaxLen =
            this.maxForce * dt;
        var delta = vsub(vadd(b.p, this.r2), vadd(a.p, this.r1));
        this.bias = vclamp(vmult(delta, -bias_coef(this.errorBias, dt) / dt), this.maxBias)
    };
    PivotJoint.prototype.applyCachedImpulse = function (dt_coef) {
        apply_impulses(this.a, this.b, this.r1, this.r2, this.jAcc.x * dt_coef, this.jAcc.y * dt_coef)
    };
    PivotJoint.prototype.applyImpulse = function () {
        var a = this.a;
        var b = this.b;
        var r1 = this.r1;
        var r2 = this.r2;
        var vr = relative_velocity(a, b, r1, r2);
        var j = mult_k(vsub(this.bias, vr), this.k1, this.k2);
        var jOld = this.jAcc;
        this.jAcc =
            vclamp(vadd(this.jAcc, j), this.jMaxLen);
        apply_impulses(a, b, this.r1, this.r2, this.jAcc.x - jOld.x, this.jAcc.y - jOld.y)
    };
    PivotJoint.prototype.getImpulse = function () {
        return vlength(this.jAcc)
    };
    var GrooveJoint = cp.GrooveJoint = function (a, b, groove_a, groove_b, anchr2) {
        Constraint.call(this, a, b);
        this.grv_a = groove_a;
        this.grv_b = groove_b;
        this.grv_n = vperp(vnormalize(vsub(groove_b, groove_a)));
        this.anchr2 = anchr2;
        this.grv_tn = null;
        this.clamp = 0;
        this.r1 = this.r2 = null;
        this.k1 = new Vect(0, 0);
        this.k2 = new Vect(0, 0);
        this.jAcc = vzero;
        this.jMaxLen = 0;
        this.bias = null
    };
    GrooveJoint.prototype = Object.create(Constraint.prototype);
    GrooveJoint.prototype.preStep = function (dt) {
        var a = this.a;
        var b = this.b;
        var ta = a.local2World(this.grv_a);
        var tb = a.local2World(this.grv_b);
        var n = vrotate(this.grv_n, a.rot);
        var d = vdot(ta, n);
        this.grv_tn = n;
        this.r2 = vrotate(this.anchr2, b.rot);
        var td = vcross(vadd(b.p, this.r2), n);
        if (td <= vcross(ta, n)) {
            this.clamp = 1;
            this.r1 = vsub(ta, a.p)
        } else if (td >= vcross(tb, n)) {
            this.clamp = -1;
            this.r1 = vsub(tb, a.p)
        } else {
            this.clamp = 0;
            this.r1 = vsub(vadd(vmult(vperp(n),
                -td), vmult(n, d)), a.p)
        }
        k_tensor(a, b, this.r1, this.r2, this.k1, this.k2);
        this.jMaxLen = this.maxForce * dt;
        var delta = vsub(vadd(b.p, this.r2), vadd(a.p, this.r1));
        this.bias = vclamp(vmult(delta, -bias_coef(this.errorBias, dt) / dt), this.maxBias)
    };
    GrooveJoint.prototype.applyCachedImpulse = function (dt_coef) {
        apply_impulses(this.a, this.b, this.r1, this.r2, this.jAcc.x * dt_coef, this.jAcc.y * dt_coef)
    };
    GrooveJoint.prototype.grooveConstrain = function (j) {
        var n = this.grv_tn;
        var jClamp = this.clamp * vcross(j, n) > 0 ? j : vproject(j, n);
        return vclamp(jClamp,
            this.jMaxLen)
    };
    GrooveJoint.prototype.applyImpulse = function () {
        var a = this.a;
        var b = this.b;
        var r1 = this.r1;
        var r2 = this.r2;
        var vr = relative_velocity(a, b, r1, r2);
        var j = mult_k(vsub(this.bias, vr), this.k1, this.k2);
        var jOld = this.jAcc;
        this.jAcc = this.grooveConstrain(vadd(jOld, j));
        apply_impulses(a, b, this.r1, this.r2, this.jAcc.x - jOld.x, this.jAcc.y - jOld.y)
    };
    GrooveJoint.prototype.getImpulse = function () {
        return vlength(this.jAcc)
    };
    GrooveJoint.prototype.setGrooveA = function (value) {
        this.grv_a = value;
        this.grv_n = vperp(vnormalize(vsub(this.grv_b,
            value)));
        this.activateBodies()
    };
    GrooveJoint.prototype.setGrooveB = function (value) {
        this.grv_b = value;
        this.grv_n = vperp(vnormalize(vsub(value, this.grv_a)));
        this.activateBodies()
    };
    var defaultSpringForce = function (spring, dist) {
        return(spring.restLength - dist) * spring.stiffness
    };
    var DampedSpring = cp.DampedSpring = function (a, b, anchr1, anchr2, restLength, stiffness, damping) {
        Constraint.call(this, a, b);
        this.anchr1 = anchr1;
        this.anchr2 = anchr2;
        this.restLength = restLength;
        this.stiffness = stiffness;
        this.damping = damping;
        this.springForceFunc =
            defaultSpringForce;
        this.target_vrn = this.v_coef = 0;
        this.r1 = this.r2 = null;
        this.nMass = 0;
        this.n = null
    };
    DampedSpring.prototype = Object.create(Constraint.prototype);
    DampedSpring.prototype.preStep = function (dt) {
        var a = this.a;
        var b = this.b;
        this.r1 = vrotate(this.anchr1, a.rot);
        this.r2 = vrotate(this.anchr2, b.rot);
        var delta = vsub(vadd(b.p, this.r2), vadd(a.p, this.r1));
        var dist = vlength(delta);
        this.n = vmult(delta, 1 / (dist ? dist : Infinity));
        var k = k_scalar(a, b, this.r1, this.r2, this.n);
        assertSoft(k !== 0, "Unsolvable this.");
        this.nMass =
            1 / k;
        this.target_vrn = 0;
        this.v_coef = 1 - Math.exp(-this.damping * dt * k);
        var f_spring = this.springForceFunc(this, dist);
        apply_impulses(a, b, this.r1, this.r2, this.n.x * f_spring * dt, this.n.y * f_spring * dt)
    };
    DampedSpring.prototype.applyCachedImpulse = function (dt_coef) {
    };
    DampedSpring.prototype.applyImpulse = function () {
        var a = this.a;
        var b = this.b;
        var n = this.n;
        var r1 = this.r1;
        var r2 = this.r2;
        var vrn = normal_relative_velocity(a, b, r1, r2, n);
        var v_damp = (this.target_vrn - vrn) * this.v_coef;
        this.target_vrn = vrn + v_damp;
        v_damp *= this.nMass;
        apply_impulses(a, b, this.r1, this.r2, this.n.x * v_damp, this.n.y * v_damp)
    };
    DampedSpring.prototype.getImpulse = function () {
        return 0
    };
    var defaultSpringTorque = function (spring, relativeAngle) {
        return(relativeAngle - spring.restAngle) * spring.stiffness
    };
    var DampedRotarySpring = cp.DampedRotarySpring = function (a, b, restAngle, stiffness, damping) {
        Constraint.call(this, a, b);
        this.restAngle = restAngle;
        this.stiffness = stiffness;
        this.damping = damping;
        this.springTorqueFunc = defaultSpringTorque;
        this.target_wrn = 0;
        this.w_coef = 0;
        this.iSum =
            0
    };
    DampedRotarySpring.prototype = Object.create(Constraint.prototype);
    DampedRotarySpring.prototype.preStep = function (dt) {
        var a = this.a;
        var b = this.b;
        var moment = a.i_inv + b.i_inv;
        assertSoft(moment !== 0, "Unsolvable spring.");
        this.iSum = 1 / moment;
        this.w_coef = 1 - Math.exp(-this.damping * dt * moment);
        this.target_wrn = 0;
        var j_spring = this.springTorqueFunc(this, a.a - b.a) * dt;
        a.w -= j_spring * a.i_inv;
        b.w += j_spring * b.i_inv
    };
    DampedRotarySpring.prototype.applyImpulse = function () {
        var a = this.a;
        var b = this.b;
        var wrn = a.w - b.w;
        var w_damp =
            (this.target_wrn - wrn) * this.w_coef;
        this.target_wrn = wrn + w_damp;
        var j_damp = w_damp * this.iSum;
        a.w += j_damp * a.i_inv;
        b.w -= j_damp * b.i_inv
    };
    var RotaryLimitJoint = cp.RotaryLimitJoint = function (a, b, min, max) {
        Constraint.call(this, a, b);
        this.min = min;
        this.max = max;
        this.jAcc = 0;
        this.iSum = this.bias = this.jMax = 0
    };
    RotaryLimitJoint.prototype = Object.create(Constraint.prototype);
    RotaryLimitJoint.prototype.preStep = function (dt) {
        var a = this.a;
        var b = this.b;
        var dist = b.a - a.a;
        var pdist = 0;
        if (dist > this.max)pdist = this.max - dist; else if (dist <
            this.min)pdist = this.min - dist;
        this.iSum = 1 / (1 / a.i + 1 / b.i);
        var maxBias = this.maxBias;
        this.bias = clamp(-bias_coef(this.errorBias, dt) * pdist / dt, -maxBias, maxBias);
        this.jMax = this.maxForce * dt;
        if (!this.bias)this.jAcc = 0
    };
    RotaryLimitJoint.prototype.applyCachedImpulse = function (dt_coef) {
        var a = this.a;
        var b = this.b;
        var j = this.jAcc * dt_coef;
        a.w -= j * a.i_inv;
        b.w += j * b.i_inv
    };
    RotaryLimitJoint.prototype.applyImpulse = function () {
        if (!this.bias)return;
        var a = this.a;
        var b = this.b;
        var wr = b.w - a.w;
        var j = -(this.bias + wr) * this.iSum;
        var jOld =
            this.jAcc;
        if (this.bias < 0)this.jAcc = clamp(jOld + j, 0, this.jMax); else this.jAcc = clamp(jOld + j, -this.jMax, 0);
        j = this.jAcc - jOld;
        a.w -= j * a.i_inv;
        b.w += j * b.i_inv
    };
    RotaryLimitJoint.prototype.getImpulse = function () {
        return Math.abs(joint.jAcc)
    };
    var RatchetJoint = cp.RatchetJoint = function (a, b, phase, ratchet) {
        Constraint.call(this, a, b);
        this.angle = 0;
        this.phase = phase;
        this.ratchet = ratchet;
        this.angle = (b ? b.a : 0) - (a ? a.a : 0);
        this.iSum = this.bias = this.jAcc = this.jMax = 0
    };
    RatchetJoint.prototype = Object.create(Constraint.prototype);
    RatchetJoint.prototype.preStep =
        function (dt) {
            var a = this.a;
            var b = this.b;
            var angle = this.angle;
            var phase = this.phase;
            var ratchet = this.ratchet;
            var delta = b.a - a.a;
            var diff = angle - delta;
            var pdist = 0;
            if (diff * ratchet > 0)pdist = diff; else this.angle = Math.floor((delta - phase) / ratchet) * ratchet + phase;
            this.iSum = 1 / (a.i_inv + b.i_inv);
            var maxBias = this.maxBias;
            this.bias = clamp(-bias_coef(this.errorBias, dt) * pdist / dt, -maxBias, maxBias);
            this.jMax = this.maxForce * dt;
            if (!this.bias)this.jAcc = 0
        };
    RatchetJoint.prototype.applyCachedImpulse = function (dt_coef) {
        var a = this.a;
        var b = this.b;
        var j = this.jAcc * dt_coef;
        a.w -= j * a.i_inv;
        b.w += j * b.i_inv
    };
    RatchetJoint.prototype.applyImpulse = function () {
        if (!this.bias)return;
        var a = this.a;
        var b = this.b;
        var wr = b.w - a.w;
        var ratchet = this.ratchet;
        var j = -(this.bias + wr) * this.iSum;
        var jOld = this.jAcc;
        this.jAcc = clamp((jOld + j) * ratchet, 0, this.jMax * Math.abs(ratchet)) / ratchet;
        j = this.jAcc - jOld;
        a.w -= j * a.i_inv;
        b.w += j * b.i_inv
    };
    RatchetJoint.prototype.getImpulse = function (joint) {
        return Math.abs(joint.jAcc)
    };
    var GearJoint = cp.GearJoint = function (a, b, phase, ratio) {
        Constraint.call(this,
            a, b);
        this.phase = phase;
        this.ratio = ratio;
        this.ratio_inv = 1 / ratio;
        this.jAcc = 0;
        this.iSum = this.bias = this.jMax = 0
    };
    GearJoint.prototype = Object.create(Constraint.prototype);
    GearJoint.prototype.preStep = function (dt) {
        var a = this.a;
        var b = this.b;
        this.iSum = 1 / (a.i_inv * this.ratio_inv + this.ratio * b.i_inv);
        var maxBias = this.maxBias;
        this.bias = clamp(-bias_coef(this.errorBias, dt) * (b.a * this.ratio - a.a - this.phase) / dt, -maxBias, maxBias);
        this.jMax = this.maxForce * dt
    };
    GearJoint.prototype.applyCachedImpulse = function (dt_coef) {
        var a =
            this.a;
        var b = this.b;
        var j = this.jAcc * dt_coef;
        a.w -= j * a.i_inv * this.ratio_inv;
        b.w += j * b.i_inv
    };
    GearJoint.prototype.applyImpulse = function () {
        var a = this.a;
        var b = this.b;
        var wr = b.w * this.ratio - a.w;
        var j = (this.bias - wr) * this.iSum;
        var jOld = this.jAcc;
        this.jAcc = clamp(jOld + j, -this.jMax, this.jMax);
        j = this.jAcc - jOld;
        a.w -= j * a.i_inv * this.ratio_inv;
        b.w += j * b.i_inv
    };
    GearJoint.prototype.getImpulse = function () {
        return Math.abs(this.jAcc)
    };
    GearJoint.prototype.setRatio = function (value) {
        this.ratio = value;
        this.ratio_inv = 1 / value;
        this.activateBodies()
    };
    var SimpleMotor = cp.SimpleMotor = function (a, b, rate) {
        Constraint.call(this, a, b);
        this.rate = rate;
        this.jAcc = 0;
        this.iSum = this.jMax = 0
    };
    SimpleMotor.prototype = Object.create(Constraint.prototype);
    SimpleMotor.prototype.preStep = function (dt) {
        this.iSum = 1 / (this.a.i_inv + this.b.i_inv);
        this.jMax = this.maxForce * dt
    };
    SimpleMotor.prototype.applyCachedImpulse = function (dt_coef) {
        var a = this.a;
        var b = this.b;
        var j = this.jAcc * dt_coef;
        a.w -= j * a.i_inv;
        b.w += j * b.i_inv
    };
    SimpleMotor.prototype.applyImpulse = function () {
        var a = this.a;
        var b = this.b;
        var wr = b.w - a.w + this.rate;
        var j = -wr * this.iSum;
        var jOld = this.jAcc;
        this.jAcc = clamp(jOld + j, -this.jMax, this.jMax);
        j = this.jAcc - jOld;
        a.w -= j * a.i_inv;
        b.w += j * b.i_inv
    };
    SimpleMotor.prototype.getImpulse = function () {
        return Math.abs(this.jAcc)
    }
})();var sp = sp || {};
sp.VERTEX_INDEX = {X1: 0, Y1: 1, X2: 2, Y2: 3, X3: 4, Y3: 5, X4: 6, Y4: 7};
sp.ATTACHMENT_TYPE = {REGION: 0, REGION_SEQUENCE: 1, BOUNDING_BOX: 2};
sp.Skeleton = cc.NodeRGBA.extend({_skeleton: null, _rootBone: null, _timeScale: 1, _debugSlots: false, _debugBones: false, _premultipliedAlpha: false, _ownsSkeletonData: null, _atlas: null, _blendFunc: null, ctor: function () {
    cc.NodeRGBA.prototype.ctor.call(this);
    this._blendFunc = {src: cc.BLEND_SRC, dst: cc.BLEND_DST}
}, init: function () {
    cc.Node.prototype.init.call(this);
    this.setOpacityModifyRGB(true);
    this._blendFunc.src = cc.ONE;
    this._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA;
    if (cc._renderType === cc._RENDER_TYPE_WEBGL)this.setShaderProgram(cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR));
    this.scheduleUpdate()
}, setDebugSolots: function (v) {
    this._debugSlots = v
}, setDebugBones: function (v) {
    this._debugBones = v
}, setTimeScale: function (v) {
    this._timeScale = v
}, initWithArgs: function () {
    var argSkeletonFile = arguments[0], argAtlasFile = arguments[1], skeletonData, atlas, scale, ownsSkeletonData;
    if (typeof argSkeletonFile == "string") {
        if (typeof argAtlasFile == "string") {
            var data = cc.loader.getRes(argAtlasFile);
            sp._atlasLoader.setAtlasFile(argAtlasFile);
            atlas = new spine.Atlas(data, sp._atlasLoader)
        } else atlas = arguments[1];
        scale = arguments[2] || 1 / cc.director.getContentScaleFactor();
        var attachmentLoader = new spine.AtlasAttachmentLoader(atlas);
        var skeletonJsonReader = new spine.SkeletonJson(attachmentLoader);
        skeletonJsonReader.scale = scale;
        var skeletonJson = cc.loader.getRes(argSkeletonFile);
        skeletonData = skeletonJsonReader.readSkeletonData(skeletonJson);
        atlas.dispose(skeletonJsonReader);
        ownsSkeletonData = true
    } else {
        skeletonData = arguments[0];
        ownsSkeletonData = arguments[1]
    }
    this.setSkeletonData(skeletonData, ownsSkeletonData);
    this.init()
},
    boundingBox: function () {
        var minX = cc.FLT_MAX, minY = cc.FLT_MAX, maxX = cc.FLT_MIN, maxY = cc.FLT_MIN;
        var scaleX = this.getScaleX(), scaleY = this.getScaleY(), vertices = [], slots = this._skeleton.slots, VERTEX = sp.VERTEX_INDEX;
        for (var i = 0, slotCount = slots.length; i < slotCount; ++i) {
            var slot = slots[i];
            if (!slot.attachment || slot.attachment.type != sp.ATTACHMENT_TYPE.REGION)continue;
            var attachment = slot.attachment;
            sp.regionAttachment_computeWorldVertices(attachment, slot.skeleton.x, slot.skeleton.y, slot.bone, vertices);
            minX = Math.min(minX,
                    vertices[VERTEX.X1] * scaleX, vertices[VERTEX.X4] * scaleX, vertices[VERTEX.X2] * scaleX, vertices[VERTEX.X3] * scaleX);
            minY = Math.min(minY, vertices[VERTEX.Y1] * scaleY, vertices[VERTEX.Y4] * scaleY, vertices[VERTEX.Y2] * scaleY, vertices[VERTEX.Y3] * scaleY);
            maxX = Math.max(maxX, vertices[VERTEX.X1] * scaleX, vertices[VERTEX.X4] * scaleX, vertices[VERTEX.X2] * scaleX, vertices[VERTEX.X3] * scaleX);
            maxY = Math.max(maxY, vertices[VERTEX.Y1] * scaleY, vertices[VERTEX.Y4] * scaleY, vertices[VERTEX.Y2] * scaleY, vertices[VERTEX.Y3] * scaleY)
        }
        var position =
            this.getPosition();
        return cc.rect(position.x + minX, position.y + minY, maxX - minX, maxY - minY)
    }, updateWorldTransform: function () {
        this._skeleton.updateWorldTransform()
    }, setToSetupPose: function () {
        this._skeleton.setToSetupPose()
    }, setBonesToSetupPose: function () {
        this._skeleton.setBonesToSetupPose()
    }, setSlotsToSetupPose: function () {
        this._skeleton.setSlotsToSetupPose()
    }, findBone: function (boneName) {
        return this._skeleton.findBone(boneName)
    }, findSlot: function (slotName) {
        return this._skeleton.findSlot(slotName)
    }, setSkin: function (skinName) {
        return this._skeleton.setSkinByName(skinName)
    },
    getAttachment: function (slotName, attachmentName) {
        return this._skeleton.getAttachmentBySlotName(slotName, attachmentName)
    }, setAttachment: function (slotName, attachmentName) {
        return this._skeleton.setAttachment(slotName, attachmentName)
    }, setOpacityModifyRGB: function (v) {
        this._premultipliedAlpha = v
    }, isOpacityModifyRGB: function () {
        return this._premultipliedAlpha
    }, setSkeletonData: function (skeletonData, ownsSkeletonData) {
        this._skeleton = new spine.Skeleton(skeletonData);
        this._rootBone = this._skeleton.getRootBone();
        this._ownsSkeletonData = ownsSkeletonData;
        if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
            var locSkeleton = this._skeleton, rendererObject, rect;
            for (var i = 0, n = locSkeleton.drawOrder.length; i < n; i++) {
                var slot = locSkeleton.drawOrder[i];
                var attachment = slot.attachment;
                if (!(attachment instanceof spine.RegionAttachment))continue;
                rendererObject = attachment.rendererObject;
                rect = cc.rect(rendererObject.x, rendererObject.y, rendererObject.width, rendererObject.height);
                var sprite = cc.Sprite.create(rendererObject.page._texture,
                    rect, rendererObject.rotate);
                this.addChild(sprite, -1);
                slot.currentSprite = sprite
            }
        }
    }, getTextureAtlas: function (regionAttachment) {
        return regionAttachment.rendererObject.page.rendererObject
    }, getBlendFunc: function () {
        return this._blendFunc
    }, setBlendFunc: function (_blendFunc) {
        this._blendFunc = _blendFunc
    }, update: function (dt) {
        this._skeleton.update(dt);
        if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
            var color = this.getColor(), locSkeleton = this._skeleton;
            locSkeleton.updateWorldTransform();
            var drawOrder = this._skeleton.drawOrder;
            for (var i = 0, n = drawOrder.length; i < n; i++) {
                var slot = drawOrder[i];
                var attachment = slot.attachment, selSprite = slot.currentSprite;
                if (!(attachment instanceof spine.RegionAttachment)) {
                    if (selSprite)selSprite.setVisible(false);
                    continue
                }
                if (!selSprite) {
                    var rendererObject = attachment.rendererObject;
                    var rect = cc.rect(rendererObject.x, rendererObject.y, rendererObject.width, rendererObject.height);
                    var sprite = cc.Sprite.create(rendererObject.page._texture, rect, rendererObject.rotate);
                    this.addChild(sprite, -1);
                    slot.currentSprite =
                        sprite
                }
                selSprite.setVisible(true);
                selSprite.setBlendFunc(cc.BLEND_SRC, slot.data.additiveBlending ? cc.ONE : cc.BLEND_DST);
                var bone = slot.bone;
                selSprite.setPosition(bone.worldX + attachment.x * bone.m00 + attachment.y * bone.m01, bone.worldY + attachment.x * bone.m10 + attachment.y * bone.m11);
                selSprite.setScale(bone.worldScaleX, bone.worldScaleY);
                selSprite.setRotation(-(slot.bone.worldRotation + attachment.rotation))
            }
        }
    }, draw: null, _drawForWebGL: function () {
        cc.nodeDrawSetup(this);
        var color = this.getColor(), locSkeleton = this._skeleton;
        locSkeleton.r = color.r / 255;
        locSkeleton.g = color.g / 255;
        locSkeleton.b = color.b / 255;
        locSkeleton.a = this.getOpacity() / 255;
        if (this._premultipliedAlpha) {
            locSkeleton.r *= locSkeleton.a;
            locSkeleton.g *= locSkeleton.a;
            locSkeleton.b *= locSkeleton.a
        }
        var additive, textureAtlas, attachment, slot, i, n, quad = new cc.V3F_C4B_T2F_Quad;
        var locBlendFunc = this._blendFunc;
        for (i = 0, n = locSkeleton.slots.length; i < n; i++) {
            slot = locSkeleton.drawOrder[i];
            if (!slot.attachment || slot.attachment.type != sp.ATTACHMENT_TYPE.REGION)continue;
            attachment =
                slot.attachment;
            var regionTextureAtlas = this.getTextureAtlas(attachment);
            if (slot.data.additiveBlending != additive) {
                if (textureAtlas) {
                    textureAtlas.drawQuads();
                    textureAtlas.removeAllQuads()
                }
                additive = !additive;
                cc.glBlendFunc(locBlendFunc.src, additive ? cc.ONE : locBlendFunc.dst)
            } else if (regionTextureAtlas != textureAtlas && textureAtlas) {
                textureAtlas.drawQuads();
                textureAtlas.removeAllQuads()
            }
            textureAtlas = regionTextureAtlas;
            var quadCount = textureAtlas.getTotalQuads();
            if (textureAtlas.getCapacity() == quadCount) {
                textureAtlas.drawQuads();
                textureAtlas.removeAllQuads();
                if (!textureAtlas.resizeCapacity(textureAtlas.getCapacity() * 2))return
            }
            sp._regionAttachment_updateQuad(attachment, slot, quad, this._premultipliedAlpha);
            textureAtlas.updateQuad(quad, quadCount)
        }
        if (textureAtlas) {
            textureAtlas.drawQuads();
            textureAtlas.removeAllQuads()
        }
        var drawingUtil = cc._drawingUtil;
        if (this._debugSlots) {
            drawingUtil.setDrawColor(0, 0, 255, 255);
            drawingUtil.setLineWidth(1);
            for (i = 0, n = locSkeleton.slots.length; i < n; i++) {
                slot = locSkeleton.drawOrder[i];
                if (!slot.attachment ||
                    slot.attachment.type != sp.ATTACHMENT_TYPE.REGION)continue;
                attachment = slot.attachment;
                quad = new cc.V3F_C4B_T2F_Quad;
                sp._regionAttachment_updateQuad(attachment, slot, quad);
                var points = [];
                points.push(cc.p(quad.bl.vertices.x, quad.bl.vertices.y));
                points.push(cc.p(quad.br.vertices.x, quad.br.vertices.y));
                points.push(cc.p(quad.tr.vertices.x, quad.tr.vertices.y));
                points.push(cc.p(quad.tl.vertices.x, quad.tl.vertices.y));
                drawingUtil.drawPoly(points, 4, true)
            }
        }
        if (this._debugBones) {
            var bone;
            drawingUtil.setLineWidth(2);
            drawingUtil.setDrawColor(255, 0, 0, 255);
            for (i = 0, n = locSkeleton.bones.length; i < n; i++) {
                bone = locSkeleton.bones[i];
                var x = bone.data.length * bone.m00 + bone.worldX;
                var y = bone.data.length * bone.m10 + bone.worldY;
                drawingUtil.drawLine(cc.p(bone.worldX, bone.worldY), cc.p(x, y))
            }
            drawingUtil.setPointSize(4);
            drawingUtil.setDrawColor(0, 0, 255, 255);
            for (i = 0, n = locSkeleton.bones.length; i < n; i++) {
                bone = locSkeleton.bones[i];
                drawingUtil.drawPoint(cc.p(bone.worldX, bone.worldY));
                if (i == 0)drawingUtil.setDrawColor(0, 255, 0, 255)
            }
        }
    }, _drawForCanvas: function () {
        if (!this._debugSlots && !this._debugBones)return;
        var locSkeleton = this._skeleton;
        var attachment, slot, i, n, drawingUtil = cc._drawingUtil;
        if (this._debugSlots) {
            drawingUtil.setDrawColor(0, 0, 255, 255);
            drawingUtil.setLineWidth(1);
            var points = [];
            for (i = 0, n = locSkeleton.slots.length; i < n; i++) {
                slot = locSkeleton.drawOrder[i];
                if (!slot.attachment || slot.attachment.type != sp.ATTACHMENT_TYPE.REGION)continue;
                attachment = slot.attachment;
                sp._regionAttachment_updateSlotForCanvas(attachment, slot, points);
                drawingUtil.drawPoly(points, 4, true)
            }
        }
        if (this._debugBones) {
            var bone;
            drawingUtil.setLineWidth(2);
            drawingUtil.setDrawColor(255, 0, 0, 255);
            for (i = 0, n = locSkeleton.bones.length; i < n; i++) {
                bone = locSkeleton.bones[i];
                var x = bone.data.length * bone.m00 + bone.worldX;
                var y = bone.data.length * bone.m10 + bone.worldY;
                drawingUtil.drawLine(cc.p(bone.worldX, bone.worldY), cc.p(x, y))
            }
            drawingUtil.setPointSize(4);
            drawingUtil.setDrawColor(0, 0, 255, 255);
            for (i = 0, n = locSkeleton.bones.length; i < n; i++) {
                bone = locSkeleton.bones[i];
                drawingUtil.drawPoint(cc.p(bone.worldX, bone.worldY));
                if (i === 0)drawingUtil.setDrawColor(0,
                    255, 0, 255)
            }
        }
    }});
if (cc._renderType === cc._RENDER_TYPE_WEBGL)sp.Skeleton.prototype.draw = sp.Skeleton.prototype._drawForWebGL; else sp.Skeleton.prototype.draw = sp.Skeleton.prototype._drawForCanvas;
sp.Skeleton.createWithData = function (skeletonData, ownsSkeletonData) {
    var c = new sp.Skeleton;
    c.initWithArgs.apply(c, arguments);
    return c
};
sp.Skeleton.create = function (skeletonDataFile, atlasFile, scale) {
    var c = new sp.Skeleton;
    c.initWithArgs.apply(c, arguments);
    return c
};
var spine = spine || {};
spine.BoneData = function (name, parent) {
    this.name = name;
    this.parent = parent
};
spine.BoneData.prototype = {length: 0, x: 0, y: 0, rotation: 0, scaleX: 1, scaleY: 1, inheritScale: true, inheritRotation: true};
spine.SlotData = function (name, boneData) {
    this.name = name;
    this.boneData = boneData
};
spine.SlotData.prototype = {r: 1, g: 1, b: 1, a: 1, attachmentName: null, additiveBlending: false};
spine.Bone = function (boneData, parent) {
    this.data = boneData;
    this.parent = parent;
    this.setToSetupPose()
};
spine.Bone.yDown = false;
spine.Bone.prototype = {x: 0, y: 0, rotation: 0, scaleX: 1, scaleY: 1, m00: 0, m01: 0, worldX: 0, m10: 0, m11: 0, worldY: 0, worldRotation: 0, worldScaleX: 1, worldScaleY: 1, updateWorldTransform: function (flipX, flipY) {
    var parent = this.parent;
    if (parent != null) {
        this.worldX = this.x * parent.m00 + this.y * parent.m01 + parent.worldX;
        this.worldY = this.x * parent.m10 + this.y * parent.m11 + parent.worldY;
        if (this.data.inheritScale) {
            this.worldScaleX = parent.worldScaleX * this.scaleX;
            this.worldScaleY = parent.worldScaleY * this.scaleY
        } else {
            this.worldScaleX = this.scaleX;
            this.worldScaleY = this.scaleY
        }
        this.worldRotation = this.data.inheritRotation ? parent.worldRotation + this.rotation : this.rotation
    } else {
        this.worldX = flipX ? -this.x : this.x;
        this.worldY = flipY != spine.Bone.yDown ? -this.y : this.y;
        this.worldScaleX = this.scaleX;
        this.worldScaleY = this.scaleY;
        this.worldRotation = this.rotation
    }
    var radians = this.worldRotation * Math.PI / 180;
    var cos = Math.cos(radians);
    var sin = Math.sin(radians);
    this.m00 = cos * this.worldScaleX;
    this.m10 = sin * this.worldScaleX;
    this.m01 = -sin * this.worldScaleY;
    this.m11 = cos *
        this.worldScaleY;
    if (flipX) {
        this.m00 = -this.m00;
        this.m01 = -this.m01
    }
    if (flipY != spine.Bone.yDown) {
        this.m10 = -this.m10;
        this.m11 = -this.m11
    }
}, setToSetupPose: function () {
    var data = this.data;
    this.x = data.x;
    this.y = data.y;
    this.rotation = data.rotation;
    this.scaleX = data.scaleX;
    this.scaleY = data.scaleY
}};
spine.Slot = function (slotData, skeleton, bone) {
    this.data = slotData;
    this.skeleton = skeleton;
    this.bone = bone;
    this.setToSetupPose()
};
spine.Slot.prototype = {r: 1, g: 1, b: 1, a: 1, _attachmentTime: 0, attachment: null, setAttachment: function (attachment) {
    this.attachment = attachment;
    this._attachmentTime = this.skeleton.time
}, setAttachmentTime: function (time) {
    this._attachmentTime = this.skeleton.time - time
}, getAttachmentTime: function () {
    return this.skeleton.time - this._attachmentTime
}, setToSetupPose: function () {
    var data = this.data;
    this.r = data.r;
    this.g = data.g;
    this.b = data.b;
    this.a = data.a;
    var slotDatas = this.skeleton.data.slots;
    for (var i = 0, n = slotDatas.length; i <
        n; i++)if (slotDatas[i] == data) {
        this.setAttachment(!data.attachmentName ? null : this.skeleton.getAttachmentBySlotIndex(i, data.attachmentName));
        break
    }
}};
spine.Skin = function (name) {
    this.name = name;
    this.attachments = {}
};
spine.Skin.prototype = {addAttachment: function (slotIndex, name, attachment) {
    this.attachments[slotIndex + ":" + name] = attachment
}, getAttachment: function (slotIndex, name) {
    return this.attachments[slotIndex + ":" + name]
}, _attachAll: function (skeleton, oldSkin) {
    console.log(oldSkin.attachments);
    for (var key in oldSkin.attachments) {
        var colon = key.indexOf(":");
        var slotIndex = parseInt(key.substring(0, colon));
        var name = key.substring(colon + 1);
        var slot = skeleton.slots[slotIndex];
        if (slot.attachment && slot.attachment.name == name) {
            var attachment =
                this.getAttachment(slotIndex, name);
            if (attachment)slot.setAttachment(attachment)
        }
    }
}};
spine.Animation = function (name, timelines, duration) {
    this.name = name;
    this.timelines = timelines;
    this.duration = duration
};
spine.Animation.prototype = {apply: function (skeleton, lastTime, time, loop, events) {
    if (loop && this.duration != 0) {
        time %= this.duration;
        lastTime %= this.duration
    }
    var timelines = this.timelines;
    for (var i = 0, n = timelines.length; i < n; i++)timelines[i].apply(skeleton, lastTime, time, events, 1)
}, mix: function (skeleton, lastTime, time, loop, events, alpha) {
    if (loop && this.duration != 0) {
        time %= this.duration;
        lastTime %= this.duration
    }
    var timelines = this.timelines;
    for (var i = 0, n = timelines.length; i < n; i++)timelines[i].apply(skeleton, lastTime,
        time, events, alpha)
}};
spine.binarySearch = function (values, target, step) {
    var low = 0;
    var high = Math.floor(values.length / step) - 2;
    if (high == 0)return step;
    var current = high >>> 1;
    while (true) {
        if (values[(current + 1) * step] <= target)low = current + 1; else high = current;
        if (low == high)return(low + 1) * step;
        current = low + high >>> 1
    }
};
spine.linearSearch = function (values, target, step) {
    for (var i = 0, last = values.length - step; i <= last; i += step)if (values[i] > target)return i;
    return-1
};
spine.Curves = function (frameCount) {
    this.curves = [];
    this.curves.length = (frameCount - 1) * 6
};
spine.Curves.prototype = {setLinear: function (frameIndex) {
    this.curves[frameIndex * 6] = 0
}, setStepped: function (frameIndex) {
    this.curves[frameIndex * 6] = -1
}, setCurve: function (frameIndex, cx1, cy1, cx2, cy2) {
    var subdiv_step = 1 / 10;
    var subdiv_step2 = subdiv_step * subdiv_step;
    var subdiv_step3 = subdiv_step2 * subdiv_step;
    var pre1 = 3 * subdiv_step;
    var pre2 = 3 * subdiv_step2;
    var pre4 = 6 * subdiv_step2;
    var pre5 = 6 * subdiv_step3;
    var tmp1x = -cx1 * 2 + cx2;
    var tmp1y = -cy1 * 2 + cy2;
    var tmp2x = (cx1 - cx2) * 3 + 1;
    var tmp2y = (cy1 - cy2) * 3 + 1;
    var i = frameIndex * 6;
    var curves =
        this.curves;
    curves[i] = cx1 * pre1 + tmp1x * pre2 + tmp2x * subdiv_step3;
    curves[i + 1] = cy1 * pre1 + tmp1y * pre2 + tmp2y * subdiv_step3;
    curves[i + 2] = tmp1x * pre4 + tmp2x * pre5;
    curves[i + 3] = tmp1y * pre4 + tmp2y * pre5;
    curves[i + 4] = tmp2x * pre5;
    curves[i + 5] = tmp2y * pre5
}, getCurvePercent: function (frameIndex, percent) {
    percent = percent < 0 ? 0 : percent > 1 ? 1 : percent;
    var curveIndex = frameIndex * 6;
    var curves = this.curves;
    var dfx = curves[curveIndex];
    if (!dfx)return percent;
    if (dfx == -1)return 0;
    var dfy = curves[curveIndex + 1];
    var ddfx = curves[curveIndex + 2];
    var ddfy =
        curves[curveIndex + 3];
    var dddfx = curves[curveIndex + 4];
    var dddfy = curves[curveIndex + 5];
    var x = dfx, y = dfy;
    var i = 10 - 2;
    while (true) {
        if (x >= percent) {
            var lastX = x - dfx;
            var lastY = y - dfy;
            return lastY + (y - lastY) * (percent - lastX) / (x - lastX)
        }
        if (i == 0)break;
        i--;
        dfx += ddfx;
        dfy += ddfy;
        ddfx += dddfx;
        ddfy += dddfy;
        x += dfx;
        y += dfy
    }
    return y + (1 - y) * (percent - x) / (1 - x)
}};
spine.RotateTimeline = function (frameCount) {
    this.curves = new spine.Curves(frameCount);
    this.frames = [];
    this.frames.length = frameCount * 2
};
spine.RotateTimeline.prototype = {boneIndex: 0, getFrameCount: function () {
    return this.frames.length / 2
}, setFrame: function (frameIndex, time, angle) {
    frameIndex *= 2;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + 1] = angle
}, apply: function (skeleton, lastTime, time, firedEvents, alpha) {
    var frames = this.frames;
    if (time < frames[0])return;
    var bone = skeleton.bones[this.boneIndex];
    if (time >= frames[frames.length - 2]) {
        var amount = bone.data.rotation + frames[frames.length - 1] - bone.rotation;
        while (amount > 180)amount -= 360;
        while (amount < -180)amount += 360;
        bone.rotation += amount * alpha;
        return
    }
    var frameIndex = spine.binarySearch(frames, time, 2);
    var lastFrameValue = frames[frameIndex - 1];
    var frameTime = frames[frameIndex];
    var percent = 1 - (time - frameTime) / (frames[frameIndex - 2] - frameTime);
    percent = this.curves.getCurvePercent(frameIndex / 2 - 1, percent);
    var amount = frames[frameIndex + 1] - lastFrameValue;
    while (amount > 180)amount -= 360;
    while (amount < -180)amount += 360;
    amount = bone.data.rotation + (lastFrameValue + amount * percent) - bone.rotation;
    while (amount > 180)amount -=
        360;
    while (amount < -180)amount += 360;
    bone.rotation += amount * alpha
}};
spine.TranslateTimeline = function (frameCount) {
    this.curves = new spine.Curves(frameCount);
    this.frames = [];
    this.frames.length = frameCount * 3
};
spine.TranslateTimeline.prototype = {boneIndex: 0, getFrameCount: function () {
    return this.frames.length / 3
}, setFrame: function (frameIndex, time, x, y) {
    frameIndex *= 3;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + 1] = x;
    this.frames[frameIndex + 2] = y
}, apply: function (skeleton, lastTime, time, firedEvents, alpha) {
    var frames = this.frames;
    if (time < frames[0])return;
    var bone = skeleton.bones[this.boneIndex];
    if (time >= frames[frames.length - 3]) {
        bone.x += (bone.data.x + frames[frames.length - 2] - bone.x) * alpha;
        bone.y += (bone.data.y + frames[frames.length -
            1] - bone.y) * alpha;
        return
    }
    var frameIndex = spine.binarySearch(frames, time, 3);
    var lastFrameX = frames[frameIndex - 2];
    var lastFrameY = frames[frameIndex - 1];
    var frameTime = frames[frameIndex];
    var percent = 1 - (time - frameTime) / (frames[frameIndex + -3] - frameTime);
    percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);
    bone.x += (bone.data.x + lastFrameX + (frames[frameIndex + 1] - lastFrameX) * percent - bone.x) * alpha;
    bone.y += (bone.data.y + lastFrameY + (frames[frameIndex + 2] - lastFrameY) * percent - bone.y) * alpha
}};
spine.ScaleTimeline = function (frameCount) {
    this.curves = new spine.Curves(frameCount);
    this.frames = [];
    this.frames.length = frameCount * 3
};
spine.ScaleTimeline.prototype = {boneIndex: 0, getFrameCount: function () {
    return this.frames.length / 3
}, setFrame: function (frameIndex, time, x, y) {
    frameIndex *= 3;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + 1] = x;
    this.frames[frameIndex + 2] = y
}, apply: function (skeleton, lastTime, time, firedEvents, alpha) {
    var frames = this.frames;
    if (time < frames[0])return;
    var bone = skeleton.bones[this.boneIndex];
    if (time >= frames[frames.length - 3]) {
        bone.scaleX += (bone.data.scaleX - 1 + frames[frames.length - 2] - bone.scaleX) * alpha;
        bone.scaleY +=
            (bone.data.scaleY - 1 + frames[frames.length - 1] - bone.scaleY) * alpha;
        return
    }
    var frameIndex = spine.binarySearch(frames, time, 3);
    var lastFrameX = frames[frameIndex - 2];
    var lastFrameY = frames[frameIndex - 1];
    var frameTime = frames[frameIndex];
    var percent = 1 - (time - frameTime) / (frames[frameIndex + -3] - frameTime);
    percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);
    bone.scaleX += (bone.data.scaleX - 1 + lastFrameX + (frames[frameIndex + 1] - lastFrameX) * percent - bone.scaleX) * alpha;
    bone.scaleY += (bone.data.scaleY - 1 + lastFrameY + (frames[frameIndex +
        2] - lastFrameY) * percent - bone.scaleY) * alpha
}};
spine.ColorTimeline = function (frameCount) {
    this.curves = new spine.Curves(frameCount);
    this.frames = [];
    this.frames.length = frameCount * 5
};
spine.ColorTimeline.prototype = {slotIndex: 0, getFrameCount: function () {
    return this.frames.length / 5
}, setFrame: function (frameIndex, time, r, g, b, a) {
    frameIndex *= 5;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + 1] = r;
    this.frames[frameIndex + 2] = g;
    this.frames[frameIndex + 3] = b;
    this.frames[frameIndex + 4] = a
}, apply: function (skeleton, lastTime, time, firedEvents, alpha) {
    var frames = this.frames;
    if (time < frames[0])return;
    var slot = skeleton.slots[this.slotIndex];
    if (time >= frames[frames.length - 5]) {
        var i = frames.length - 1;
        slot.r =
            frames[i - 3];
        slot.g = frames[i - 2];
        slot.b = frames[i - 1];
        slot.a = frames[i];
        return
    }
    var frameIndex = spine.binarySearch(frames, time, 5);
    var lastFrameR = frames[frameIndex - 4];
    var lastFrameG = frames[frameIndex - 3];
    var lastFrameB = frames[frameIndex - 2];
    var lastFrameA = frames[frameIndex - 1];
    var frameTime = frames[frameIndex];
    var percent = 1 - (time - frameTime) / (frames[frameIndex - 5] - frameTime);
    percent = this.curves.getCurvePercent(frameIndex / 5 - 1, percent);
    var r = lastFrameR + (frames[frameIndex + 1] - lastFrameR) * percent;
    var g = lastFrameG + (frames[frameIndex +
        2] - lastFrameG) * percent;
    var b = lastFrameB + (frames[frameIndex + 3] - lastFrameB) * percent;
    var a = lastFrameA + (frames[frameIndex + 4] - lastFrameA) * percent;
    if (alpha < 1) {
        slot.r += (r - slot.r) * alpha;
        slot.g += (g - slot.g) * alpha;
        slot.b += (b - slot.b) * alpha;
        slot.a += (a - slot.a) * alpha
    } else {
        slot.r = r;
        slot.g = g;
        slot.b = b;
        slot.a = a
    }
}};
spine.AttachmentTimeline = function (frameCount) {
    this.curves = new spine.Curves(frameCount);
    this.frames = [];
    this.frames.length = frameCount;
    this.attachmentNames = [];
    this.attachmentNames.length = frameCount
};
spine.AttachmentTimeline.prototype = {slotIndex: 0, getFrameCount: function () {
    return this.frames.length
}, setFrame: function (frameIndex, time, attachmentName) {
    this.frames[frameIndex] = time;
    this.attachmentNames[frameIndex] = attachmentName
}, apply: function (skeleton, lastTime, time, firedEvents, alpha) {
    var frames = this.frames;
    if (time < frames[0])return;
    var frameIndex;
    if (time >= frames[frames.length - 1])frameIndex = frames.length - 1; else frameIndex = spine.binarySearch(frames, time, 1) - 1;
    var attachmentName = this.attachmentNames[frameIndex];
    skeleton.slots[this.slotIndex].setAttachment(!attachmentName ? null : skeleton.getAttachmentBySlotIndex(this.slotIndex, attachmentName))
}};
spine.EventTimeline = function (frameCount) {
    this.frames = [];
    this.frames.length = frameCount;
    this.events = [];
    this.events.length = frameCount
};
spine.EventTimeline.prototype = {getFrameCount: function () {
    return this.frames.length
}, setFrame: function (frameIndex, time, event) {
    this.frames[frameIndex] = time;
    this.events[frameIndex] = event
}, apply: function (skeleton, lastTime, time, firedEvents, alpha) {
    if (!firedEvents)return;
    var frames = this.frames;
    var frameCount = frames.length;
    if (lastTime > time) {
        this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha);
        lastTime = -1
    } else if (lastTime >= frames[frameCount - 1])return;
    if (time < frames[0])return;
    var frameIndex;
    if (lastTime <
        frames[0])frameIndex = 0; else {
        frameIndex = spine.binarySearch(frames, lastTime, 1);
        var frame = frames[frameIndex];
        while (frameIndex > 0) {
            if (frames[frameIndex - 1] != frame)break;
            frameIndex--
        }
    }
    var events = this.events;
    for (; frameIndex < frameCount && time >= frames[frameIndex]; frameIndex++)firedEvents.push(events[frameIndex])
}};
spine.DrawOrderTimeline = function (frameCount) {
    this.frames = [];
    this.frames.length = frameCount;
    this.drawOrders = [];
    this.drawOrders.length = frameCount
};
spine.DrawOrderTimeline.prototype = {getFrameCount: function () {
    return this.frames.length
}, setFrame: function (frameIndex, time, drawOrder) {
    this.frames[frameIndex] = time;
    this.drawOrders[frameIndex] = drawOrder
}, apply: function (skeleton, lastTime, time, firedEvents, alpha) {
    var frames = this.frames;
    if (time < frames[0])return;
    var frameIndex;
    if (time >= frames[frames.length - 1])frameIndex = frames.length - 1; else frameIndex = spine.binarySearch(frames, time, 1) - 1;
    var drawOrder = skeleton.drawOrder;
    var slots = skeleton.slots;
    var drawOrderToSetupIndex =
        this.drawOrders[frameIndex];
    if (!drawOrderToSetupIndex)for (var i = 0, n = slots.length; i < n; i++)drawOrder[i] = slots[i]; else for (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++)drawOrder[i] = skeleton.slots[drawOrderToSetupIndex[i]]
}};
spine.SkeletonData = function () {
    this.bones = [];
    this.slots = [];
    this.skins = [];
    this.events = [];
    this.animations = []
};
spine.SkeletonData.prototype = {defaultSkin: null, findBone: function (boneName) {
    var bones = this.bones;
    for (var i = 0, n = bones.length; i < n; i++)if (bones[i].name == boneName)return bones[i];
    return null
}, findBoneIndex: function (boneName) {
    var bones = this.bones;
    for (var i = 0, n = bones.length; i < n; i++)if (bones[i].name == boneName)return i;
    return-1
}, findSlot: function (slotName) {
    var slots = this.slots;
    for (var i = 0, n = slots.length; i < n; i++)if (slots[i].name == slotName)return slots[i];
    return null
}, findSlotIndex: function (slotName) {
    var slots =
        this.slots;
    for (var i = 0, n = slots.length; i < n; i++)if (slots[i].name == slotName)return i;
    return-1
}, findSkin: function (skinName) {
    var skins = this.skins;
    for (var i = 0, n = skins.length; i < n; i++)if (skins[i].name == skinName)return skins[i];
    return null
}, findEvent: function (eventName) {
    var events = this.events;
    for (var i = 0, n = events.length; i < n; i++)if (events[i].name == eventName)return events[i];
    return null
}, findAnimation: function (animationName) {
    var animations = this.animations;
    for (var i = 0, n = animations.length; i < n; i++)if (animations[i].name ==
        animationName)return animations[i];
    return null
}};
spine.Skeleton = function (skeletonData) {
    this.data = skeletonData;
    this.bones = [];
    for (var i = 0, n = skeletonData.bones.length; i < n; i++) {
        var boneData = skeletonData.bones[i];
        var parent = !boneData.parent ? null : this.bones[skeletonData.bones.indexOf(boneData.parent)];
        this.bones.push(new spine.Bone(boneData, parent))
    }
    this.slots = [];
    this.drawOrder = [];
    for (var i = 0, n = skeletonData.slots.length; i < n; i++) {
        var slotData = skeletonData.slots[i];
        var bone = this.bones[skeletonData.bones.indexOf(slotData.boneData)];
        var slot = new spine.Slot(slotData,
            this, bone);
        this.slots.push(slot);
        this.drawOrder.push(slot)
    }
};
spine.Skeleton.prototype = {x: 0, y: 0, skin: null, r: 1, g: 1, b: 1, a: 1, time: 0, flipX: false, flipY: false, updateWorldTransform: function () {
    var flipX = this.flipX;
    var flipY = this.flipY;
    var bones = this.bones;
    for (var i = 0, n = bones.length; i < n; i++)bones[i].updateWorldTransform(flipX, flipY)
}, setToSetupPose: function () {
    this.setBonesToSetupPose();
    this.setSlotsToSetupPose()
}, setBonesToSetupPose: function () {
    var bones = this.bones;
    for (var i = 0, n = bones.length; i < n; i++)bones[i].setToSetupPose()
}, setSlotsToSetupPose: function () {
    var slots =
        this.slots;
    for (var i = 0, n = slots.length; i < n; i++)slots[i].setToSetupPose(i)
}, getRootBone: function () {
    return this.bones.length == 0 ? null : this.bones[0]
}, findBone: function (boneName) {
    var bones = this.bones;
    for (var i = 0, n = bones.length; i < n; i++)if (bones[i].data.name == boneName)return bones[i];
    return null
}, findBoneIndex: function (boneName) {
    var bones = this.bones;
    for (var i = 0, n = bones.length; i < n; i++)if (bones[i].data.name == boneName)return i;
    return-1
}, findSlot: function (slotName) {
    var slots = this.slots;
    for (var i = 0, n = slots.length; i <
        n; i++)if (slots[i].data.name == slotName)return slots[i];
    return null
}, findSlotIndex: function (slotName) {
    var slots = this.slots;
    for (var i = 0, n = slots.length; i < n; i++)if (slots[i].data.name == slotName)return i;
    return-1
}, setSkinByName: function (skinName) {
    var skin = this.data.findSkin(skinName);
    if (!skin)throw"Skin not found: " + skinName;
    this.setSkin(skin)
}, setSkin: function (newSkin) {
    if (this.skin && newSkin)newSkin._attachAll(this, this.skin);
    this.skin = newSkin
}, getAttachmentBySlotName: function (slotName, attachmentName) {
    return this.getAttachmentBySlotIndex(this.data.findSlotIndex(slotName),
        attachmentName)
}, getAttachmentBySlotIndex: function (slotIndex, attachmentName) {
    if (this.skin) {
        var attachment = this.skin.getAttachment(slotIndex, attachmentName);
        if (attachment)return attachment
    }
    if (this.data.defaultSkin)return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);
    return null
}, setAttachment: function (slotName, attachmentName) {
    var slots = this.slots;
    for (var i = 0, n = slots.length; i < n; i++) {
        var slot = slots[i];
        if (slot.data.name == slotName) {
            var attachment = null;
            if (attachmentName) {
                attachment = this.getAttachment(i,
                    attachmentName);
                if (!attachment)throw"Attachment not found: " + attachmentName + ", for slot: " + slotName;
            }
            slot.setAttachment(attachment);
            return
        }
    }
    throw"Slot not found: " + slotName;
}, update: function (delta) {
    this.time += delta
}};
spine.EventData = function (name) {
    this.name = name
};
spine.EventData.prototype = {intValue: 0, floatValue: 0, stringValue: null};
spine.Event = function (data) {
    this.data = data
};
spine.Event.prototype = {intValue: 0, floatValue: 0, stringValue: null};
spine.AttachmentType = {region: 0, boundingbox: 1};
spine.RegionAttachment = function (name) {
    this.name = name;
    this.offset = [];
    this.offset.length = 8;
    this.uvs = [];
    this.uvs.length = 8
};
spine.RegionAttachment.prototype = {type: spine.AttachmentType.region, x: 0, y: 0, rotation: 0, scaleX: 1, scaleY: 1, width: 0, height: 0, rendererObject: null, regionOffsetX: 0, regionOffsetY: 0, regionWidth: 0, regionHeight: 0, regionOriginalWidth: 0, regionOriginalHeight: 0, setUVs: function (u, v, u2, v2, rotate) {
    var uvs = this.uvs;
    if (rotate) {
        uvs[2] = u;
        uvs[3] = v2;
        uvs[4] = u;
        uvs[5] = v;
        uvs[6] = u2;
        uvs[7] = v;
        uvs[0] = u2;
        uvs[1] = v2
    } else {
        uvs[0] = u;
        uvs[1] = v2;
        uvs[2] = u;
        uvs[3] = v;
        uvs[4] = u2;
        uvs[5] = v;
        uvs[6] = u2;
        uvs[7] = v2
    }
}, updateOffset: function () {
    var regionScaleX =
        this.width / this.regionOriginalWidth * this.scaleX;
    var regionScaleY = this.height / this.regionOriginalHeight * this.scaleY;
    var localX = -this.width / 2 * this.scaleX + this.regionOffsetX * regionScaleX;
    var localY = -this.height / 2 * this.scaleY + this.regionOffsetY * regionScaleY;
    var localX2 = localX + this.regionWidth * regionScaleX;
    var localY2 = localY + this.regionHeight * regionScaleY;
    var radians = this.rotation * Math.PI / 180;
    var cos = Math.cos(radians);
    var sin = Math.sin(radians);
    var localXCos = localX * cos + this.x;
    var localXSin = localX * sin;
    var localYCos =
        localY * cos + this.y;
    var localYSin = localY * sin;
    var localX2Cos = localX2 * cos + this.x;
    var localX2Sin = localX2 * sin;
    var localY2Cos = localY2 * cos + this.y;
    var localY2Sin = localY2 * sin;
    var offset = this.offset;
    offset[0] = localXCos - localYSin;
    offset[1] = localYCos + localXSin;
    offset[2] = localXCos - localY2Sin;
    offset[3] = localY2Cos + localXSin;
    offset[4] = localX2Cos - localY2Sin;
    offset[5] = localY2Cos + localX2Sin;
    offset[6] = localX2Cos - localYSin;
    offset[7] = localYCos + localX2Sin
}, computeVertices: function (x, y, bone, vertices) {
    x += bone.worldX;
    y += bone.worldY;
    var m00 = bone.m00;
    var m01 = bone.m01;
    var m10 = bone.m10;
    var m11 = bone.m11;
    var offset = this.offset;
    vertices[0] = offset[0] * m00 + offset[1] * m01 + x;
    vertices[1] = offset[0] * m10 + offset[1] * m11 + y;
    vertices[2] = offset[2] * m00 + offset[3] * m01 + x;
    vertices[3] = offset[2] * m10 + offset[3] * m11 + y;
    vertices[4] = offset[4] * m00 + offset[5] * m01 + x;
    vertices[5] = offset[4] * m10 + offset[5] * m11 + y;
    vertices[6] = offset[6] * m00 + offset[7] * m01 + x;
    vertices[7] = offset[6] * m10 + offset[7] * m11 + y
}};
spine.BoundingBoxAttachment = function (name) {
    this.name = name;
    this.vertices = []
};
spine.BoundingBoxAttachment.prototype = {type: spine.AttachmentType.boundingBox, computeWorldVertices: function (x, y, bone, worldVertices) {
    x += bone.worldX;
    y += bone.worldY;
    var m00 = bone.m00;
    var m01 = bone.m01;
    var m10 = bone.m10;
    var m11 = bone.m11;
    var vertices = this.vertices;
    for (var i = 0, n = vertices.length; i < n; i += 2) {
        var px = vertices[i];
        var py = vertices[i + 1];
        worldVertices[i] = px * m00 + py * m01 + x;
        worldVertices[i + 1] = px * m10 + py * m11 + y
    }
}};
spine.AnimationStateData = function (skeletonData) {
    this.skeletonData = skeletonData;
    this.animationToMixTime = {}
};
spine.AnimationStateData.prototype = {defaultMix: 0, setMixByName: function (fromName, toName, duration) {
    var from = this.skeletonData.findAnimation(fromName);
    if (!from)throw"Animation not found: " + fromName;
    var to = this.skeletonData.findAnimation(toName);
    if (!to)throw"Animation not found: " + toName;
    this.setMix(from, to, duration)
}, setMix: function (from, to, duration) {
    this.animationToMixTime[from.name + ":" + to.name] = duration
}, getMix: function (from, to) {
    var time = this.animationToMixTime[from.name + ":" + to.name];
    return time ? time :
        this.defaultMix
}};
spine.TrackEntry = function () {
};
spine.TrackEntry.prototype = {next: null, previous: null, animation: null, loop: false, delay: 0, time: 0, lastTime: -1, endTime: 0, timeScale: 1, mixTime: 0, mixDuration: 0, onStart: null, onEnd: null, onComplete: null, onEvent: null};
spine.AnimationState = function (stateData) {
    this.data = stateData;
    this.tracks = [];
    this.events = []
};
spine.AnimationState.prototype = {onStart: null, onEnd: null, onComplete: null, onEvent: null, timeScale: 1, update: function (delta) {
    delta *= this.timeScale;
    for (var i = 0; i < this.tracks.length; i++) {
        var current = this.tracks[i];
        if (!current)continue;
        var trackDelta = delta * current.timeScale;
        current.time += trackDelta;
        if (current.previous) {
            current.previous.time += trackDelta;
            current.mixTime += trackDelta
        }
        var next = current.next;
        if (next) {
            if (current.lastTime >= next.delay)this.setCurrent(i, next)
        } else if (!current.loop && current.lastTime >=
            current.endTime)this.clearTrack(i)
    }
}, apply: function (skeleton) {
    for (var i = 0; i < this.tracks.length; i++) {
        var current = this.tracks[i];
        if (!current)continue;
        this.events.length = 0;
        var time = current.time;
        var lastTime = current.lastTime;
        var endTime = current.endTime;
        var loop = current.loop;
        if (!loop && time > endTime)time = endTime;
        var previous = current.previous;
        if (!previous)current.animation.apply(skeleton, current.lastTime, time, loop, this.events); else {
            var previousTime = previous.time;
            if (!previous.loop && previousTime > previous.endTime)previousTime =
                previous.endTime;
            previous.animation.apply(skeleton, previousTime, previousTime, previous.loop, null);
            var alpha = current.mixTime / current.mixDuration;
            if (alpha >= 1) {
                alpha = 1;
                current.previous = null
            }
            current.animation.mix(skeleton, current.lastTime, time, loop, this.events, alpha)
        }
        for (var ii = 0, nn = this.events.length; ii < nn; ii++) {
            var event = this.events[ii];
            if (current.onEvent != null)current.onEvent(i, event);
            if (this.onEvent != null)this.onEvent(i, event)
        }
        if (loop ? lastTime % endTime > time % endTime : lastTime < endTime && time >= endTime) {
            var count =
                Math.floor(time / endTime);
            if (current.onComplete)current.onComplete(i, count);
            if (this.onComplete)this.onComplete(i, count)
        }
        current.lastTime = current.time
    }
}, clearTracks: function () {
    for (var i = 0, n = this.tracks.length; i < n; i++)this.clearTrack(i);
    this.tracks.length = 0
}, clearTrack: function (trackIndex) {
    if (trackIndex >= this.tracks.length)return;
    var current = this.tracks[trackIndex];
    if (!current)return;
    if (current.onEnd != null)current.onEnd(trackIndex);
    if (this.onEnd != null)this.onEnd(trackIndex);
    this.tracks[trackIndex] = null
},
    _expandToIndex: function (index) {
        if (index < this.tracks.length)return this.tracks[index];
        while (index >= this.tracks.length)this.tracks.push(null);
        return null
    }, setCurrent: function (index, entry) {
        var current = this._expandToIndex(index);
        if (current) {
            var previous = current.previous;
            current.previous = null;
            if (current.onEnd != null)current.onEnd(index);
            if (this.onEnd != null)this.onEnd(index);
            entry.mixDuration = this.data.getMix(current.animation, entry.animation);
            if (entry.mixDuration > 0) {
                entry.mixTime = 0;
                if (previous && current.mixTime /
                    current.mixDuration < 0.5)entry.previous = previous; else entry.previous = current
            }
        }
        this.tracks[index] = entry;
        if (entry.onStart != null)entry.onStart(index);
        if (this.onStart != null)this.onStart(index)
    }, setAnimationByName: function (trackIndex, animationName, loop) {
        var animation = this.data.skeletonData.findAnimation(animationName);
        if (!animation)throw"Animation not found: " + animationName;
        return this.setAnimation(trackIndex, animation, loop)
    }, setAnimation: function (trackIndex, animation, loop) {
        var entry = new spine.TrackEntry;
        entry.animation = animation;
        entry.loop = loop;
        entry.endTime = animation.duration;
        this.setCurrent(trackIndex, entry);
        return entry
    }, addAnimationByName: function (trackIndex, animationName, loop, delay) {
        var animation = this.data.skeletonData.findAnimation(animationName);
        if (!animation)throw"Animation not found: " + animationName;
        return this.addAnimation(trackIndex, animation, loop, delay)
    }, addAnimation: function (trackIndex, animation, loop, delay) {
        var entry = new spine.TrackEntry;
        entry.animation = animation;
        entry.loop = loop;
        entry.endTime =
            animation.duration;
        var last = this._expandToIndex(trackIndex);
        if (last) {
            while (last.next)last = last.next;
            last.next = entry
        } else this.tracks[trackIndex] = entry;
        if (delay <= 0)if (last)delay += last.endTime - this.data.getMix(last.animation, animation); else delay = 0;
        entry.delay = delay;
        return entry
    }, getCurrent: function (trackIndex) {
        if (trackIndex >= this.tracks.length)return null;
        return this.tracks[trackIndex]
    }};
spine.SkeletonJson = function (attachmentLoader) {
    this.attachmentLoader = attachmentLoader
};
spine.SkeletonJson.prototype = {scale: 1, readSkeletonData: function (root) {
    var skeletonData = new spine.SkeletonData;
    var bones = root["bones"];
    for (var i = 0, n = bones.length; i < n; i++) {
        var boneMap = bones[i];
        var parent = null;
        if (boneMap["parent"]) {
            parent = skeletonData.findBone(boneMap["parent"]);
            if (!parent)throw"Parent bone not found: " + boneMap["parent"];
        }
        var boneData = new spine.BoneData(boneMap["name"], parent);
        boneData.length = (boneMap["length"] || 0) * this.scale;
        boneData.x = (boneMap["x"] || 0) * this.scale;
        boneData.y = (boneMap["y"] ||
            0) * this.scale;
        boneData.rotation = boneMap["rotation"] || 0;
        boneData.scaleX = boneMap["scaleX"] || 1;
        boneData.scaleY = boneMap["scaleY"] || 1;
        boneData.inheritScale = !boneMap["inheritScale"] || boneMap["inheritScale"] == "true";
        boneData.inheritRotation = !boneMap["inheritRotation"] || boneMap["inheritRotation"] == "true";
        skeletonData.bones.push(boneData)
    }
    var slots = root["slots"];
    for (var i = 0, n = slots.length; i < n; i++) {
        var slotMap = slots[i];
        var boneData = skeletonData.findBone(slotMap["bone"]);
        if (!boneData)throw"Slot bone not found: " +
            slotMap["bone"];
        var slotData = new spine.SlotData(slotMap["name"], boneData);
        var color = slotMap["color"];
        if (color) {
            slotData.r = spine.SkeletonJson.toColor(color, 0);
            slotData.g = spine.SkeletonJson.toColor(color, 1);
            slotData.b = spine.SkeletonJson.toColor(color, 2);
            slotData.a = spine.SkeletonJson.toColor(color, 3)
        }
        slotData.attachmentName = slotMap["attachment"];
        slotData.additiveBlending = slotMap["additive"] && slotMap["additive"] == "true";
        skeletonData.slots.push(slotData)
    }
    var skins = root["skins"];
    for (var skinName in skins) {
        if (!skins.hasOwnProperty(skinName))continue;
        var skinMap = skins[skinName];
        var skin = new spine.Skin(skinName);
        for (var slotName in skinMap) {
            if (!skinMap.hasOwnProperty(slotName))continue;
            var slotIndex = skeletonData.findSlotIndex(slotName);
            var slotEntry = skinMap[slotName];
            for (var attachmentName in slotEntry) {
                if (!slotEntry.hasOwnProperty(attachmentName))continue;
                var attachment = this.readAttachment(skin, attachmentName, slotEntry[attachmentName]);
                if (attachment != null)skin.addAttachment(slotIndex, attachmentName, attachment)
            }
        }
        skeletonData.skins.push(skin);
        if (skin.name ==
            "default")skeletonData.defaultSkin = skin
    }
    var events = root["events"];
    for (var eventName in events) {
        if (!events.hasOwnProperty(eventName))continue;
        var eventMap = events[eventName];
        var eventData = new spine.EventData(eventName);
        eventData.intValue = eventMap["int"] || 0;
        eventData.floatValue = eventMap["float"] || 0;
        eventData.stringValue = eventMap["string"] || null;
        skeletonData.events.push(eventData)
    }
    var animations = root["animations"];
    for (var animationName in animations) {
        if (!animations.hasOwnProperty(animationName))continue;
        this.readAnimation(animationName, animations[animationName], skeletonData)
    }
    return skeletonData
}, readAttachment: function (skin, name, map) {
    name = map["name"] || name;
    var type = spine.AttachmentType[map["type"] || "region"];
    var attachment = this.attachmentLoader.newAttachment(skin, type, name);
    if (type == spine.AttachmentType.region) {
        attachment.x = (map["x"] || 0) * this.scale;
        attachment.y = (map["y"] || 0) * this.scale;
        attachment.scaleX = map["scaleX"] || 1;
        attachment.scaleY = map["scaleY"] || 1;
        attachment.rotation = map["rotation"] || 0;
        attachment.width =
            (map["width"] || 32) * this.scale;
        attachment.height = (map["height"] || 32) * this.scale;
        attachment.updateOffset()
    } else if (type == spine.AttachmentType.boundingBox) {
        var vertices = map["vertices"];
        for (var i = 0, n = vertices.length; i < n; i++)attachment.vertices.push(vertices[i] * this.scale)
    }
    return attachment
}, readAnimation: function (name, map, skeletonData) {
    var timelines = [];
    var duration = 0;
    var bones = map["bones"];
    for (var boneName in bones) {
        if (!bones.hasOwnProperty(boneName))continue;
        var boneIndex = skeletonData.findBoneIndex(boneName);
        if (boneIndex == -1)throw"Bone not found: " + boneName;
        var boneMap = bones[boneName];
        for (var timelineName in boneMap) {
            if (!boneMap.hasOwnProperty(timelineName))continue;
            var values = boneMap[timelineName];
            if (timelineName == "rotate") {
                var timeline = new spine.RotateTimeline(values.length);
                timeline.boneIndex = boneIndex;
                var frameIndex = 0;
                for (var i = 0, n = values.length; i < n; i++) {
                    var valueMap = values[i];
                    timeline.setFrame(frameIndex, valueMap["time"], valueMap["angle"]);
                    spine.SkeletonJson.readCurve(timeline, frameIndex, valueMap);
                    frameIndex++
                }
                timelines.push(timeline);
                duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 2 - 2])
            } else if (timelineName == "translate" || timelineName == "scale") {
                var timeline;
                var timelineScale = 1;
                if (timelineName == "scale")timeline = new spine.ScaleTimeline(values.length); else {
                    timeline = new spine.TranslateTimeline(values.length);
                    timelineScale = this.scale
                }
                timeline.boneIndex = boneIndex;
                var frameIndex = 0;
                for (var i = 0, n = values.length; i < n; i++) {
                    var valueMap = values[i];
                    var x = (valueMap["x"] || 0) * timelineScale;
                    var y = (valueMap["y"] || 0) * timelineScale;
                    timeline.setFrame(frameIndex, valueMap["time"], x, y);
                    spine.SkeletonJson.readCurve(timeline, frameIndex, valueMap);
                    frameIndex++
                }
                timelines.push(timeline);
                duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 3 - 3])
            } else throw"Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")";
        }
    }
    var slots = map["slots"];
    for (var slotName in slots) {
        if (!slots.hasOwnProperty(slotName))continue;
        var slotMap = slots[slotName];
        var slotIndex = skeletonData.findSlotIndex(slotName);
        for (var timelineName in slotMap) {
            if (!slotMap.hasOwnProperty(timelineName))continue;
            var values = slotMap[timelineName];
            if (timelineName == "color") {
                var timeline = new spine.ColorTimeline(values.length);
                timeline.slotIndex = slotIndex;
                var frameIndex = 0;
                for (var i = 0, n = values.length; i < n; i++) {
                    var valueMap = values[i];
                    var color = valueMap["color"];
                    var r = spine.SkeletonJson.toColor(color, 0);
                    var g = spine.SkeletonJson.toColor(color, 1);
                    var b = spine.SkeletonJson.toColor(color, 2);
                    var a = spine.SkeletonJson.toColor(color, 3);
                    timeline.setFrame(frameIndex,
                        valueMap["time"], r, g, b, a);
                    spine.SkeletonJson.readCurve(timeline, frameIndex, valueMap);
                    frameIndex++
                }
                timelines.push(timeline);
                duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 5 - 5])
            } else if (timelineName == "attachment") {
                var timeline = new spine.AttachmentTimeline(values.length);
                timeline.slotIndex = slotIndex;
                var frameIndex = 0;
                for (var i = 0, n = values.length; i < n; i++) {
                    var valueMap = values[i];
                    timeline.setFrame(frameIndex++, valueMap["time"], valueMap["name"])
                }
                timelines.push(timeline);
                duration = Math.max(duration,
                    timeline.frames[timeline.getFrameCount() - 1])
            } else throw"Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")";
        }
    }
    var events = map["events"];
    if (events) {
        var timeline = new spine.EventTimeline(events.length);
        var frameIndex = 0;
        for (var i = 0, n = events.length; i < n; i++) {
            var eventMap = events[i];
            var eventData = skeletonData.findEvent(eventMap["name"]);
            if (!eventData)throw"Event not found: " + eventMap["name"];
            var event = new spine.Event(eventData);
            event.intValue = eventMap.hasOwnProperty("int") ? eventMap["int"] : eventData.intValue;
            event.floatValue = eventMap.hasOwnProperty("float") ? eventMap["float"] : eventData.floatValue;
            event.stringValue = eventMap.hasOwnProperty("string") ? eventMap["string"] : eventData.stringValue;
            timeline.setFrame(frameIndex++, eventMap["time"], event)
        }
        timelines.push(timeline);
        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1])
    }
    var drawOrderValues = map["draworder"];
    if (drawOrderValues) {
        var timeline = new spine.DrawOrderTimeline(drawOrderValues.length);
        var slotCount = skeletonData.slots.length;
        var frameIndex =
            0;
        for (var i = 0, n = drawOrderValues.length; i < n; i++) {
            var drawOrderMap = drawOrderValues[i];
            var drawOrder = null;
            if (drawOrderMap["offsets"]) {
                drawOrder = [];
                drawOrder.length = slotCount;
                for (var ii = slotCount - 1; ii >= 0; ii--)drawOrder[ii] = -1;
                var offsets = drawOrderMap["offsets"];
                var unchanged = [];
                unchanged.length = slotCount - offsets.length;
                var originalIndex = 0, unchangedIndex = 0;
                for (var ii = 0, nn = offsets.length; ii < nn; ii++) {
                    var offsetMap = offsets[ii];
                    var slotIndex = skeletonData.findSlotIndex(offsetMap["slot"]);
                    if (slotIndex == -1)throw"Slot not found: " +
                        offsetMap["slot"];
                    while (originalIndex != slotIndex)unchanged[unchangedIndex++] = originalIndex++;
                    drawOrder[originalIndex + offsetMap["offset"]] = originalIndex++
                }
                while (originalIndex < slotCount)unchanged[unchangedIndex++] = originalIndex++;
                for (var ii = slotCount - 1; ii >= 0; ii--)if (drawOrder[ii] == -1)drawOrder[ii] = unchanged[--unchangedIndex]
            }
            timeline.setFrame(frameIndex++, drawOrderMap["time"], drawOrder)
        }
        timelines.push(timeline);
        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1])
    }
    skeletonData.animations.push(new spine.Animation(name,
        timelines, duration))
}};
spine.SkeletonJson.readCurve = function (timeline, frameIndex, valueMap) {
    var curve = valueMap["curve"];
    if (!curve)return;
    if (curve == "stepped")timeline.curves.setStepped(frameIndex); else if (curve instanceof Array)timeline.curves.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3])
};
spine.SkeletonJson.toColor = function (hexString, colorIndex) {
    if (hexString.length != 8)throw"Color hexidecimal length must be 8, recieved: " + hexString;
    return parseInt(hexString.substring(colorIndex * 2, colorIndex * 2 + 2), 16) / 255
};
spine.Atlas = function (atlasText, textureLoader) {
    this.textureLoader = textureLoader;
    this.pages = [];
    this.regions = [];
    var reader = new spine.AtlasReader(atlasText);
    var tuple = [];
    tuple.length = 4;
    var page = null;
    while (true) {
        var line = reader.readLine();
        if (line == null)break;
        line = reader.trim(line);
        if (line.length == 0)page = null; else if (!page) {
            page = new spine.AtlasPage;
            page.name = line;
            page.format = spine.Atlas.Format[reader.readValue()];
            reader.readTuple(tuple);
            page.minFilter = spine.Atlas.TextureFilter[tuple[0]];
            page.magFilter =
                spine.Atlas.TextureFilter[tuple[1]];
            var direction = reader.readValue();
            page.uWrap = spine.Atlas.TextureWrap.clampToEdge;
            page.vWrap = spine.Atlas.TextureWrap.clampToEdge;
            if (direction == "x")page.uWrap = spine.Atlas.TextureWrap.repeat; else if (direction == "y")page.vWrap = spine.Atlas.TextureWrap.repeat; else if (direction == "xy")page.uWrap = page.vWrap = spine.Atlas.TextureWrap.repeat;
            textureLoader.load(page, line, this);
            this.pages.push(page)
        } else {
            var region = new spine.AtlasRegion;
            region.name = line;
            region.page = page;
            region.rotate =
                reader.readValue() == "true";
            reader.readTuple(tuple);
            var x = parseInt(tuple[0]);
            var y = parseInt(tuple[1]);
            reader.readTuple(tuple);
            var width = parseInt(tuple[0]);
            var height = parseInt(tuple[1]);
            region.u = x / page.width;
            region.v = y / page.height;
            if (region.rotate) {
                region.u2 = (x + height) / page.width;
                region.v2 = (y + width) / page.height
            } else {
                region.u2 = (x + width) / page.width;
                region.v2 = (y + height) / page.height
            }
            region.x = x;
            region.y = y;
            region.width = Math.abs(width);
            region.height = Math.abs(height);
            if (reader.readTuple(tuple) == 4) {
                region.splits =
                    [parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3])];
                if (reader.readTuple(tuple) == 4) {
                    region.pads = [parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3])];
                    reader.readTuple(tuple)
                }
            }
            region.originalWidth = parseInt(tuple[0]);
            region.originalHeight = parseInt(tuple[1]);
            reader.readTuple(tuple);
            region.offsetX = parseInt(tuple[0]);
            region.offsetY = parseInt(tuple[1]);
            region.index = parseInt(reader.readValue());
            this.regions.push(region)
        }
    }
};
spine.Atlas.prototype = {findRegion: function (name) {
    var regions = this.regions;
    for (var i = 0, n = regions.length; i < n; i++)if (regions[i].name == name)return regions[i];
    return null
}, dispose: function () {
    var pages = this.pages;
    for (var i = 0, n = pages.length; i < n; i++)this.textureLoader.unload(pages[i].rendererObject)
}, updateUVs: function (page) {
    var regions = this.regions;
    for (var i = 0, n = regions.length; i < n; i++) {
        var region = regions[i];
        if (region.page != page)continue;
        region.u = region.x / page.width;
        region.v = region.y / page.height;
        if (region.rotate) {
            region.u2 =
                (region.x + region.height) / page.width;
            region.v2 = (region.y + region.width) / page.height
        } else {
            region.u2 = (region.x + region.width) / page.width;
            region.v2 = (region.y + region.height) / page.height
        }
    }
}};
spine.Atlas.Format = {Alpha: 0, Intensity: 1, LuminanceAlpha: 2, RGB565: 3, RGBA4444: 4, RGB888: 5, RGBA8888: 6};
spine.Atlas.TextureFilter = {Nearest: 0, Linear: 1, MipMap: 2, MipMapNearestNearest: 3, MipMapLinearNearest: 4, MipMapNearestLinear: 5, MipMapLinearLinear: 6};
spine.Atlas.TextureWrap = {mirroredRepeat: 0, clampToEdge: 1, repeat: 2};
spine.AtlasPage = function () {
};
spine.AtlasPage.prototype = {name: null, format: null, minFilter: null, magFilter: null, uWrap: null, vWrap: null, rendererObject: null, width: 0, height: 0};
spine.AtlasRegion = function () {
};
spine.AtlasRegion.prototype = {page: null, name: null, x: 0, y: 0, width: 0, height: 0, u: 0, v: 0, u2: 0, v2: 0, offsetX: 0, offsetY: 0, originalWidth: 0, originalHeight: 0, index: 0, rotate: false, splits: null, pads: null};
spine.AtlasReader = function (text) {
    this.lines = text.split(/\r\n|\r|\n/)
};
spine.AtlasReader.prototype = {index: 0, trim: function (value) {
    return value.replace(/^\s+|\s+$/g, "")
}, readLine: function () {
    if (this.index >= this.lines.length)return null;
    return this.lines[this.index++]
}, readValue: function () {
    var line = this.readLine();
    var colon = line.indexOf(":");
    if (colon == -1)throw"Invalid line: " + line;
    return this.trim(line.substring(colon + 1))
}, readTuple: function (tuple) {
    var line = this.readLine();
    var colon = line.indexOf(":");
    if (colon == -1)throw"Invalid line: " + line;
    var i = 0, lastMatch = colon + 1;
    for (; i <
               3; i++) {
        var comma = line.indexOf(",", lastMatch);
        if (comma == -1) {
            if (i == 0)throw"Invalid line: " + line;
            break
        }
        tuple[i] = this.trim(line.substr(lastMatch, comma - lastMatch));
        lastMatch = comma + 1
    }
    tuple[i] = this.trim(line.substring(lastMatch));
    return i + 1
}};
spine.AtlasAttachmentLoader = function (atlas) {
    this.atlas = atlas
};
spine.AtlasAttachmentLoader.prototype = {newAttachment: function (skin, type, name) {
    switch (type) {
        case spine.AttachmentType.boundingbox:
            return new spine.BoundingBoxAttachment(name);
        case spine.AttachmentType.region:
            var region = this.atlas.findRegion(name);
            if (!region)throw"Region not found in atlas: " + name + " (" + type + ")";
            var attachment = new spine.RegionAttachment(name);
            attachment.rendererObject = region;
            attachment.setUVs(region.u, region.v, region.u2, region.v2, region.rotate);
            attachment.regionOffsetX = region.offsetX;
            attachment.regionOffsetY = region.offsetY;
            attachment.regionWidth = region.width;
            attachment.regionHeight = region.height;
            attachment.regionOriginalWidth = region.originalWidth;
            attachment.regionOriginalHeight = region.originalHeight;
            return attachment
    }
    throw"Unknown attachment type: " + type;
}};
spine.SkeletonBounds = function () {
    this.polygonPool = [];
    this.polygons = [];
    this.boundingBoxes = []
};
spine.SkeletonBounds.prototype = {minX: 0, minY: 0, maxX: 0, maxY: 0, update: function (skeleton, updateAabb) {
    var slots = skeleton.slots;
    var slotCount = slots.length;
    var x = skeleton.x, y = skeleton.y;
    var boundingBoxes = this.boundingBoxes;
    var polygonPool = this.polygonPool;
    var polygons = this.polygons;
    boundingBoxes.length = 0;
    for (var i = 0, n = polygons.length; i < n; i++)polygonPool.push(polygons[i]);
    polygons.length = 0;
    for (var i = 0; i < slotCount; i++) {
        var slot = slots[i];
        var boundingBox = slot.attachment;
        if (boundingBox.type != spine.AttachmentType.boundingBox)continue;
        boundingBoxes.push(boundingBox);
        var poolCount = polygonPool.length, polygon;
        if (poolCount > 0) {
            polygon = polygonPool[poolCount - 1];
            polygonPool.splice(poolCount - 1, 1)
        } else polygon = [];
        polygons.push(polygon);
        polygon.length = boundingBox.vertices.length;
        boundingBox.computeWorldVertices(x, y, slot.bone, polygon)
    }
    if (updateAabb)this.aabbCompute()
}, aabbCompute: function () {
    var polygons = this.polygons;
    var minX = Number.MAX_VALUE, minY = Number.MAX_VALUE, maxX = Number.MIN_VALUE, maxY = Number.MIN_VALUE;
    for (var i = 0, n = polygons.length; i <
        n; i++) {
        var vertices = polygons[i];
        for (var ii = 0, nn = vertices.length; ii < nn; ii += 2) {
            var x = vertices[ii];
            var y = vertices[ii + 1];
            minX = Math.min(minX, x);
            minY = Math.min(minY, y);
            maxX = Math.max(maxX, x);
            maxY = Math.max(maxY, y)
        }
    }
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY
}, aabbContainsPoint: function (x, y) {
    return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY
}, aabbIntersectsSegment: function (x1, y1, x2, y2) {
    var minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;
    if (x1 <= minX && x2 <= minX || y1 <= minY &&
        y2 <= minY || x1 >= maxX && x2 >= maxX || y1 >= maxY && y2 >= maxY)return false;
    var m = (y2 - y1) / (x2 - x1);
    var y = m * (minX - x1) + y1;
    if (y > minY && y < maxY)return true;
    y = m * (maxX - x1) + y1;
    if (y > minY && y < maxY)return true;
    var x = (minY - y1) / m + x1;
    if (x > minX && x < maxX)return true;
    x = (maxY - y1) / m + x1;
    if (x > minX && x < maxX)return true;
    return false
}, aabbIntersectsSkeleton: function (bounds) {
    return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY
}, containsPoint: function (x, y) {
    var polygons = this.polygons;
    for (var i = 0, n =
        polygons.length; i < n; i++)if (this.polygonContainsPoint(polygons[i], x, y))return this.boundingBoxes[i];
    return null
}, intersectsSegment: function (x1, y1, x2, y2) {
    var polygons = this.polygons;
    for (var i = 0, n = polygons.length; i < n; i++)if (polygons[i].intersectsSegment(x1, y1, x2, y2))return this.boundingBoxes[i];
    return null
}, polygonContainsPoint: function (polygon, x, y) {
    var nn = polygon.length;
    var prevIndex = nn - 2;
    var inside = false;
    for (var ii = 0; ii < nn; ii += 2) {
        var vertexY = polygon[ii + 1];
        var prevY = polygon[prevIndex + 1];
        if (vertexY < y &&
            prevY >= y || prevY < y && vertexY >= y) {
            var vertexX = polygon[ii];
            if (vertexX + (y - vertexY) / (prevY - vertexY) * (polygon[prevIndex] - vertexX) < x)inside = !inside
        }
        prevIndex = ii
    }
    return inside
}, intersectsSegment: function (polygon, x1, y1, x2, y2) {
    var nn = polygon.length;
    var width12 = x1 - x2, height12 = y1 - y2;
    var det1 = x1 * y2 - y1 * x2;
    var x3 = polygon[nn - 2], y3 = polygon[nn - 1];
    for (var ii = 0; ii < nn; ii += 2) {
        var x4 = polygon[ii], y4 = polygon[ii + 1];
        var det2 = x3 * y4 - y3 * x4;
        var width34 = x3 - x4, height34 = y3 - y4;
        var det3 = width12 * height34 - height12 * width34;
        var x = (det1 *
            width34 - width12 * det2) / det3;
        if ((x >= x3 && x <= x4 || x >= x4 && x <= x3) && (x >= x1 && x <= x2 || x >= x2 && x <= x1)) {
            var y = (det1 * height34 - height12 * det2) / det3;
            if ((y >= y3 && y <= y4 || y >= y4 && y <= y3) && (y >= y1 && y <= y2 || y >= y2 && y <= y1))return true
        }
        x3 = x4;
        y3 = y4
    }
    return false
}, getPolygon: function (attachment) {
    var index = this.boundingBoxes.indexOf(attachment);
    return index == -1 ? null : this.polygons[index]
}, getWidth: function () {
    return this.maxX - this.minX
}, getHeight: function () {
    return this.maxY - this.minY
}};
sp._atlasPage_createTexture_webGL = function (self, path) {
    var texture = cc.textureCache.addImage(path);
    self.rendererObject = cc.TextureAtlas.create(texture, 128);
    self.width = texture.getPixelsWide();
    self.height = texture.getPixelsHigh()
};
sp._atlasPage_createTexture_canvas = function (self, path) {
    self._texture = cc.textureCache.addImage(path)
};
sp._atlasPage_disposeTexture = function (self) {
    self.rendererObject.release()
};
sp._atlasLoader = {spAtlasFile: null, setAtlasFile: function (spAtlasFile) {
    this.spAtlasFile = spAtlasFile
}, load: function (page, line, spAtlas) {
    var texturePath = cc.path.join(cc.path.dirname(this.spAtlasFile), line);
    if (cc._renderType === cc._RENDER_TYPE_WEBGL)sp._atlasPage_createTexture_webGL(page, texturePath); else sp._atlasPage_createTexture_canvas(page, texturePath)
}, unload: function (obj) {
}};
sp.regionAttachment_computeWorldVertices = function (self, x, y, bone, vertices) {
    var offset = self.offset;
    x += bone.worldX;
    y += bone.worldY;
    var vertexIndex = sp.VERTEX_INDEX;
    vertices[vertexIndex.X1] = offset[vertexIndex.X1] * bone.m00 + offset[vertexIndex.Y1] * bone.m01 + x;
    vertices[vertexIndex.Y1] = offset[vertexIndex.X1] * bone.m10 + offset[vertexIndex.Y1] * bone.m11 + y;
    vertices[vertexIndex.X2] = offset[vertexIndex.X2] * bone.m00 + offset[vertexIndex.Y2] * bone.m01 + x;
    vertices[vertexIndex.Y2] = offset[vertexIndex.X2] * bone.m10 + offset[vertexIndex.Y2] *
        bone.m11 + y;
    vertices[vertexIndex.X3] = offset[vertexIndex.X3] * bone.m00 + offset[vertexIndex.Y3] * bone.m01 + x;
    vertices[vertexIndex.Y3] = offset[vertexIndex.X3] * bone.m10 + offset[vertexIndex.Y3] * bone.m11 + y;
    vertices[vertexIndex.X4] = offset[vertexIndex.X4] * bone.m00 + offset[vertexIndex.Y4] * bone.m01 + x;
    vertices[vertexIndex.Y4] = offset[vertexIndex.X4] * bone.m10 + offset[vertexIndex.Y4] * bone.m11 + y
};
sp._regionAttachment_updateQuad = function (self, slot, quad, premultipliedAlpha) {
    var vertices = {};
    self.computeVertices(slot.skeleton.x, slot.skeleton.y, slot.bone, vertices);
    var r = slot.skeleton.r * slot.r * 255;
    var g = slot.skeleton.g * slot.g * 255;
    var b = slot.skeleton.b * slot.b * 255;
    var normalizedAlpha = slot.skeleton.a * slot.a;
    if (premultipliedAlpha) {
        r *= normalizedAlpha;
        g *= normalizedAlpha;
        b *= normalizedAlpha
    }
    var a = normalizedAlpha * 255;
    quad.bl.colors.r = quad.tl.colors.r = quad.tr.colors.r = quad.br.colors.r = r;
    quad.bl.colors.g = quad.tl.colors.g =
        quad.tr.colors.g = quad.br.colors.g = g;
    quad.bl.colors.b = quad.tl.colors.b = quad.tr.colors.b = quad.br.colors.b = b;
    quad.bl.colors.a = quad.tl.colors.a = quad.tr.colors.a = quad.br.colors.a = a;
    var VERTEX = sp.VERTEX_INDEX;
    quad.bl.vertices.x = vertices[VERTEX.X1];
    quad.bl.vertices.y = vertices[VERTEX.Y1];
    quad.tl.vertices.x = vertices[VERTEX.X2];
    quad.tl.vertices.y = vertices[VERTEX.Y2];
    quad.tr.vertices.x = vertices[VERTEX.X3];
    quad.tr.vertices.y = vertices[VERTEX.Y3];
    quad.br.vertices.x = vertices[VERTEX.X4];
    quad.br.vertices.y = vertices[VERTEX.Y4];
    quad.bl.texCoords.u = self.uvs[VERTEX.X1];
    quad.bl.texCoords.v = self.uvs[VERTEX.Y1];
    quad.tl.texCoords.u = self.uvs[VERTEX.X2];
    quad.tl.texCoords.v = self.uvs[VERTEX.Y2];
    quad.tr.texCoords.u = self.uvs[VERTEX.X3];
    quad.tr.texCoords.v = self.uvs[VERTEX.Y3];
    quad.br.texCoords.u = self.uvs[VERTEX.X4];
    quad.br.texCoords.v = self.uvs[VERTEX.Y4]
};
sp._regionAttachment_updateSlotForCanvas = function (self, slot, points) {
    if (!points)return;
    var vertices = {};
    self.computeVertices(slot.skeleton.x, slot.skeleton.y, slot.bone, vertices);
    var VERTEX = sp.VERTEX_INDEX;
    points.length = 0;
    points.push(cc.p(vertices[VERTEX.X1], vertices[VERTEX.Y1]));
    points.push(cc.p(vertices[VERTEX.X4], vertices[VERTEX.Y4]));
    points.push(cc.p(vertices[VERTEX.X3], vertices[VERTEX.Y3]));
    points.push(cc.p(vertices[VERTEX.X2], vertices[VERTEX.Y2]))
};
sp.ANIMATION_EVENT_TYPE = {START: 0, END: 1, COMPLETE: 2, EVENT: 3};
sp.SkeletonAnimation = sp.Skeleton.extend({_state: null, _target: null, _callback: null, init: function () {
    this._super();
    this.setAnimationStateData(new spine.AnimationStateData(this._skeleton.data))
}, setAnimationStateData: function (stateData) {
    var state = new spine.AnimationState(stateData);
    state.onStart = this._onAnimationStateStart.bind(this);
    state.onComplete = this._onAnimationStateComplete.bind(this);
    state.onEnd = this._onAnimationStateEnd.bind(this);
    state.onEvent = this._onAnimationStateEvent.bind(this);
    this._state =
        state
}, setMix: function (fromAnimation, toAnimation, duration) {
    this._state.data.setMixByName(fromAnimation, toAnimation, duration)
}, setAnimationListener: function (target, callback) {
    this._target = target;
    this._callback = callback
}, setAnimation: function (trackIndex, name, loop) {
    var animation = this._skeleton.data.findAnimation(name);
    if (!animation) {
        cc.log("Spine: Animation not found: " + name);
        return 0
    }
    return this._state.setAnimation(trackIndex, animation, loop)
}, addAnimation: function (trackIndex, name, loop, delay) {
    var animation =
        this._skeleton.data.findAnimation(name);
    if (!animation) {
        cc.log("Spine: Animation not found:" + name);
        return 0
    }
    return this._state.addAnimation(trackIndex, animation, loop, delay)
}, getCurrent: function (trackIndex) {
    return this._state.getCurrent(trackIndex)
}, clearTracks: function () {
    this._state.clearTracks()
}, clearTrack: function (trackIndex) {
    this._state.clearTrack(trackIndex)
}, update: function (dt) {
    this._super(dt);
    dt *= this._timeScale;
    this._state.update(dt);
    this._state.apply(this._skeleton);
    this._skeleton.updateWorldTransform()
},
    _onAnimationStateStart: function (trackIndex) {
        this._animationStateCallback(trackIndex, sp.ANIMATION_EVENT_TYPE.START, null, 0)
    }, _onAnimationStateEnd: function (trackIndex) {
        this._animationStateCallback(trackIndex, sp.ANIMATION_EVENT_TYPE.END, null, 0)
    }, _onAnimationStateComplete: function (trackIndex, count) {
        this._animationStateCallback(trackIndex, sp.ANIMATION_EVENT_TYPE.COMPLETE, null, count)
    }, _onAnimationStateEvent: function (trackIndex, event) {
        this._animationStateCallback(trackIndex, sp.ANIMATION_EVENT_TYPE.EVENT,
            event, 0)
    }, _animationStateCallback: function (trackIndex, type, event, loopCount) {
        if (this._target && this._callback)this._callback.call(this._target, this, trackIndex, type, event, loopCount)
    }});
sp.SkeletonAnimation.createWithFile = function (skeletonData) {
    var c = new sp.SkeletonAnimation;
    c.initWithArgs.apply(c, arguments);
    return c
};
sp.SkeletonAnimation.create = function (skeletonDataFile, atlasFile, scale) {
    var c = new sp.SkeletonAnimation;
    c.initWithArgs.apply(c, arguments);
    return c
};